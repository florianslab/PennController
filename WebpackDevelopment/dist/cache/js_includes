/* This software is licensed under a BSD license; see the LICENSE file for details. */

define_ibex_controller({
name: "AcceptabilityJudgment",

jqueryWidget: {
    _init: function () {
        var opts = {
            options:     this.options,
            triggers:    [1],
            children:    [this.options._dashed ? "DashedSentence" : "FlashSentence",
                          this.options._dashed ? {
                                                     s: this.options.s,
                                                     mode: this.options.mode,
                                                     display: this.options.display,
                                                     blankText: this.options.blankText,
                                                     wordTime: this.options.wordTime,
                                                     wordPauseTime: this.options.wordPauseTime,
                                                     sentenceDescType: this.options.sentenceDescType,
                                                     showAhead: this.options.showAhead,
                                                     showBehind: this.options.showBehind
                                                 } :
                                                 {
                                                     s: this.options.s,
                                                     timeout: null, // Already present for 'Question'
                                                     audio: this.options.audio,
                                                     audioMessage: this.options.audioMessage,
                                                     audioTrigger: this.options.audioTrigger
                                                 },
                          this.options._dashed ? "!Question" : (this.options.s.audio ? "*Question" : "Question"),
                          { q:                   this.options.q,
                            as:                  this.options.as,
                            hasCorrect:          dget(this.options, "hasCorrect", false),
                            presentAsScale:      this.options.presentAsScale,
                            presentHorizontally: this.options.presentHorizontally,
                            autoFirstChar:       typeof(this.options.autoFirstChar) == "undefined" ? this.options.presentAsScale : this.options.autoFirstChar,
                            randomOrder:         this.options.randomOrder,
                            showNumbers:         this.options.showNumbers,
                            timeout:             this.options.timeout,
                            instructions:        this.options.instructions,
                            leftComment:         this.options.leftComment,
                            rightComment:        this.options.rightComment }]/*,
            manipulators: [
                [0, function(div) { div.css('font-size', "larger"); return div; }]
            ]*/
        };

        this.element.VBox(opts);
    }
},

properties: {
    obligatory: ["s", "as"],
    htmlDescription:
        function (opts) {
            var s = ibex_controller_get_property("FlashSentence", "htmlDescription")(opts);
            var q = ibex_controller_get_property("Question", "htmlDescription")(opts);
            var p =
                $("<p>")
                .append($("<p>").append("Q: ").append($(q)))
                .append("<br>").append($("<b>").text("S:"))
                .append($(s));
             return p;
        }
}
});


/* This software is licensed under a BSD license; see the LICENSE file for details. */

define_ibex_controller({
    name: "DashedAcceptabilityJudgment",
    jqueryWidget: {
        _init: function () {
            this.options._dashed = true;
            if (this.options.mode === undefined)
                this.options.mode = "speeded acceptability";
            $(this.element).AcceptabilityJudgment(this.options);
        }
    },
    properties: {
        obligatory: ["s", "as"],
        htmlDescription: function (opts) {
            var s = ibex_controller_get_property("DashedSentence", "htmlDescription")(opts);
            var q = ibex_controller_get_property("Question", "htmlDescription")(opts);
            var p =
                $("<p>")
                .append($("<p>").append("Q: ").append($(q)))
                .append("<br>").append($("<b>").text("S:"))
                .append($(s));
            return p;
        }
    }
});

/* This software is licensed under a BSD license; see the LICENSE file for details. */

function boolToInt(x) { if (x) return 1; else return 0; }

define_ibex_controller({
name: "DashedSentence",

jqueryWidget: {
    _init: function() {
        this.cssPrefix = this.options._cssPrefix;
        this.utils = this.options._utils;
        this.finishedCallback = this.options._finishedCallback;

        if (typeof(this.options.s) == "string") {
            // replace all linebreaks (and surrounding space) with 'space-return-space'
            var inputString = this.options.s.replace(/\s*[\r\n]\s*/g, " \r ");
            this.words = inputString.split(/[ \t]+/);
        } else {
            assert_is_arraylike(this.options.s, "Bad value for 's' option of DashedSentence.");
            this.words = this.options.s;
        }
        this.mode = dget(this.options, "mode", "self-paced reading");
        assert(this.mode == "self-paced reading" || this.mode == "speeded acceptability",
               "Value of 'mode' option for DashedSentence controller must be either " +
               "'self-paced reading' or 'speeded acceptability'.");
        this.display = dget(this.options, "display", "dashed");
        this.blankText = dget(this.options, "blankText", "\u2014\u2014"/*mdash*/);
        this.wordTime = dget(this.options, "wordTime", this.display == "in place" ? 400 : 300); // Only for speeded accpetability.
        this.wordPauseTime = dget(this.options, "wordPauseTime", this.display == "in place" ? 0 : 100); // Ditto.
        this.showAhead = dget(this.options, "showAhead", true);
        this.showBehind = dget(this.options, "showBehind", true);
        assert(this.display == "dashed" || this.display == "in place",
               "Value of 'display' option for DashedSentence controller must be either " +
               "'dashed' (default) or 'in place'.");

        this.currentWord = 0;

        // Is there a "stopping point" specified?
        this.stoppingPoint = this.words.length;
        for (var i = 0; i < this.words.length; ++i) {
            if (stringStartsWith("@", this.words[i])) {
                this.words[i] = this.words[i].substring(1);
                this.stoppingPoint = i + 1;
                break;
            }
        }

        this.hideUnderscores = dget(this.options, "hideUnderscores", true);
        if (this.hideUnderscores) {
            this.words = $.map(this.words, function(word) { return word.replace(/_/g, ' ') });
        }

        this.mainDiv = $("<div>");
        this.element.append(this.mainDiv);

        this.background = this.element.css('background-color') || "white";
        this.isIE7;
        /*@cc_on this.isIE = true; @*/
        if (this.isIE)
            this.background = "white";

        // Defaults.
        this.unshownBorderColor = dget(this.options, "unshownBorderColor", "#9ea4b1");
        this.shownBorderColor = dget(this.options, "shownBorderColor", "black");
        this.unshownWordColor = dget(this.options, "unshownWordColor", this.background);
        this.shownWordColor = dget(this.options, "shownWordColor", "black");

        // Precalculate MD5 of sentence.
        this.sentenceDescType = dget(this.options, "sentenceDescType", "literal");
        assert(this.sentenceDescType == "md5" || this.sentenceDescType == "literal", "Bad value for 'sentenceDescType' option of DashedSentence.");
        if (this.sentenceDescType == "md5") {
            var canonicalSentence = this.words.join(' ');
            this.sentenceDesc = hex_md5(canonicalSentence);
        }
        else {
	    if (typeof(this.options.s) == "string")
		this.sentenceDesc = csv_url_encode(this.options.s);
	    else
		this.sentenceDesc = csv_url_encode(this.options.s.join(' '));
        }

        this.mainDiv.addClass(this.cssPrefix + "sentence");

        this.resultsLines = [];
        if (this.mode == "self-paced reading") {
            // Don't want to be allocating arrays in time-critical code.
            this.sprResults = [];
            for (var i = 0; i < this.words.length; ++i)
                this.sprResults[i] = new Array(2);
        }
        this.previousTime = null;

        if (this.display == "in place") {
            this.wordSpan = $(document.createElement("span")).text(this.blankText);
            if (conf_centerItems) {
                this.mainDiv.css('text-align', 'center');
                this.wordSpan.css('text-align', 'center');
            }
            this.mainDiv.append(this.wordSpan);

            this.blankWord = this.blankWord_inplace;
            this.showWord = this.showWord_inplace;
        }
        else { // dashed
            this.blankWord = this.blankWord_dashed;
            this.showWord = this.showWord_dashed;

            this.wordISpans = []; // Inner spans.
            this.wordOSpans = []; // Outer spans.
            this.owsnjq = []; // 'outer word spans no jQuery'.
            this.iwsnjq = []; // 'inner word spans no jQuery'.
            for (var j = 0; j < this.words.length; ++j) {
                if ( this.words[j] == "\r" ) {
                    this.mainDiv.append('<br/>');

                    if (j <= this.stoppingPoint)
                        this.stoppingPoint--;
                    
                    continue;
                }

                var ispan;
                var ospan = $(document.createElement("span"))
                            .addClass(this.cssPrefix + 'ospan')
                            .append(ispan = $(document.createElement("span"))
                                            .addClass(this.cssPrefix + 'ispan')
                                            .text(this.words[j]));
                if (! this.showAhead)
                    ospan.css('border-color', this.background);
                this.mainDiv.append(ospan);
                if (j + 1 < this.words.length)
                    this.mainDiv.append("&nbsp; ");
                this.wordISpans.push(ispan);
                this.wordOSpans.push(ospan);
                this.iwsnjq.push(ispan[0]);
                this.owsnjq.push(ospan[0]);
            }
        }

        if (this.mode == "speeded acceptability") {
            this.showWord(0);
            var t = this;
            function wordTimeout() {
                t.blankWord(t.currentWord);
                ++(t.currentWord);
                if (t.currentWord >= t.stoppingPoint)
                    t.finishedCallback([[["Sentence (or sentence MD5)", t.sentenceDesc]]]);
                else
                    t.utils.setTimeout(wordPauseTimeout, t.wordPauseTime);
            }
            function wordPauseTimeout() {
                t.showWord(t.currentWord);
                t.utils.clearTimeout(wordPauseTimeout);
                t.utils.setTimeout(wordTimeout, t.wordTime);
            }
            this.utils.setTimeout(wordTimeout, this.wordTime);
        }
        else if (this.mode == "self-paced reading") {
            var t = this;
            // Inlining this to minimize function calls in code for updating screen after space is pressed.
/*            function goToNext(time) {
                t.recordSprResult(time, t.currentWord);

                if (t.currentWord - 1 >= 0)
                    t.blankWord(t.currentWord - 1);
                if (t.currentWord < t.stoppingPoint)
                    t.showWord(t.currentWord);
                ++(t.currentWord);
                if (t.currentWord > t.stoppingPoint) {
                    t.processSprResults();
                    t.finishedCallback(t.resultsLines);
                }

                return false;
            }*/

            this.safeBind($(document), 'keydown', function(e) {
                var time = new Date().getTime();
                var code = e.keyCode;

                if (code == 32) {
                    // *** goToNext() ***
//                    t.recordSprResult(time, t.currentWord);
                    var word = t.currentWord;
                    if (word > 0 && word <= t.stoppingPoint) {
                        var rs = t.sprResults[word-1];
                        rs[0] = time;
                        rs[1] = t.previousTime;
                    }
                    t.previousTime = time;

                    if (t.currentWord - 1 >= 0)
                        t.blankWord(t.currentWord - 1);
                    if (t.currentWord < t.stoppingPoint)
                        t.showWord(t.currentWord);
                    ++(t.currentWord);
                    if (t.currentWord > t.stoppingPoint) {
                        t.processSprResults();
                        t.finishedCallback(t.resultsLines);
                    }
                    return false;
                    // ***
                }
                else {
                    return true;
                }
            });

            // For iPhone/iPod touch -- add button for going to next word.
            if (isIPhone) {
                var btext = dget(this.options, "iPhoneNextButtonText", "next");
                var next = $("<div>")
                           .addClass(this.cssPrefix + "iphone-next")
                           .text(btext);
                this.element.append(next);
                next.click(function () {
                    var time = new Date().getTime();

                    // *** goToNext() ***
                    //t.recordSprResult(time, t.currentWord);
                    var word = t.currentWord;
                    if (word > 0 && word < t.stoppingPoint) {
                        var rs = t.sprResults[word-1];
                        rs[0] = time;
                        rs[1] = t.previousTime;
                    }
                    t.previousTime = time;

                    if (t.currentWord - 1 >= 0)
                        t.blankWord(t.currentWord - 1);
                    if (t.currentWord < t.stoppingPoint)
                        t.showWord(t.currentWord);
                    ++(t.currentWord);
                    if (t.currentWord > t.stoppingPoint) {
                        t.processSprResults();
                        t.finishedCallback(t.resultsLines);
                    }

                    return false;
                    // ***
                });
            }
        }
    },

    // Not using JQuery in these two methods just in case it slows things down too much.
    // NOTE: [0] subscript gets DOM object from JQuery selector.
    blankWord_dashed: function(w) {
        if (this.currentWord <= this.stoppingPoint) {
            this.owsnjq[w].style.borderColor = this.unshownBorderColor;
            this.iwsnjq[w].style.visibility = "hidden";
            if (! this.showBehind)
                this.owsnjq[w].style.borderColor = this.background;
        }
    },
    showWord_dashed: function(w) {
        if (this.currentWord < this.stoppingPoint) {
            if (this.showAhead || this.showBehind)
                this.owsnjq[w].style.borderColor = this.shownBorderColor;
            this.iwsnjq[w].style.visibility = "visible";
        }
    },

    blankWord_inplace: function (w) {
        if (this.wordPauseTime > 0 && this.currentWord <= this.stoppingPoint) {
            this.wordSpan.empty();
        }
    },
    showWord_inplace: function (w) {
        if (this.currentWord < this.stoppingPoint) {
            this.wordSpan.text(this.words[this.currentWord]);
        }
    },

    // Inlining this now.
    /*recordSprResult: function(time, word) {
        if (word > 0 && word < this.stoppingPoint) {
            var rs = this.sprResults[word-1];
            rs[0] = time;
            rs[1] = this.previousTime;
        }
        this.previousTime = time;
    },*/

    processSprResults: function () {
        var nonSpaceWords = [];
        for (var i = 0; i < this.words.length; ++i) {
        	if ( this.words[i] != "\r" )
	            nonSpaceWords.push(this.words[i]);
        }

        for (var i = 0; i < nonSpaceWords.length; ++i) {
            this.resultsLines.push([
                ["Word number", i+1],
                ["Word", csv_url_encode(nonSpaceWords[i])],
                ["Reading time", this.sprResults[i][0] - this.sprResults[i][1]],
                ["Newline?", (! this.display == "in place") &&
                             boolToInt(((i+1) < this.wordOSpans.length) &&
                             (this.wordOSpans[i].offset().top != this.wordOSpans[i+1].offset().top))],
                ["Sentence (or sentence MD5)", this.sentenceDesc]
            ]);
        }
    }
},

properties: {
    obligatory: ["s"],
    htmlDescription: function (opts) {
        return $(document.createElement("div")).text(opts.s);
    }
}
});


/* This software is licensed under a BSD license; see the LICENSE file for details. */

(function () {
var soundId = 0;

define_ibex_controller({
name: "FlashSentence",

init: function () {

},

jqueryWidget: {
    _init: function () {
        var self = this;
        self.cssPrefix = self.options._cssPrefix;

        var $loading;
        var doneLoading = false;
        if (typeof(self.options.s) != "string") {
            if (self.options.s.audio) {
                if (self.options.audioMessage) {
                    self.element.append($loading = $("<div>").addClass(self.cssPrefix + 'loading'));
                    setTimeout(function () {
                        if (! doneLoading)
                            $loading.text(conf_loadingMessage);
                    }, 250);
                }
                withSoundManager(completeInit);
            }
            else {
                self.sentenceDom = htmlCodeToDOM(self.options.s)
                completeInit();
            }
        }
        else {
            self.sentenceDom = $("<div>").text(self.options.s);
            completeInit();
        }
        this.sentenceDescType = dget(this.options, "sentenceDescType", "literal");
        assert(this.sentenceDescType == "literal", "Bad value for 'sentenceDescType' option of FlashSentence controller ('md5' no longer supported).");

        function completeInit(sm) {
            if (sm) {
                if (self.options.audioMessage) {
                    if (typeof(self.options.audioMessage) != "string") {
                        self.sentenceDom = $(htmlCodeToDOM(self.options.audioMessage));
                    }
                    else {
                        self.sentenceDom = $("<div>").text(self.options.audioMessage);
                    }
                }
                var names = null;
                if ($.isArray(self.options.s.audio))
                    names = self.options.s.audio;
                else
                    names = [self.options.s.audio];
                var urls = [ ];
                for (var i = 0; i < names.length; ++i) {
                    if (names[i].match(/^(?:https?)|(?:ftps?):\/\//))
                        urls.push(names[i]);
                    else
                        urls.push(__server_py_script_name__ + '?resource=' + escape(names[i]));
                }
                var sids = [ ];
                for (var i = 0; i < names.length; ++i)
                    sids.push(soundId++);
                for (var i = 0; i < names.length; ++i)
                    sm.createSound('sound' + sids[i], urls[i]);

                var nextSoundToPlayIndex = 0;

                function hideSD() { if (self.sentenceDom) self.sentenceDom.hide(); }
                if (self.options.audioTrigger == "click") {
                    self.sentenceDom.css('cursor', 'pointer');
                    self.sentenceDom.click(function () {
                        hideSD();
                        sm.play('sound' + sids[nextSoundToPlayIndex++], { onfinish: fin });
                    });
                }
                else { // Immediate
                    hideSD();
                    sm.play('sound' + sids[nextSoundToPlayIndex++], { onfinish: fin });
                }

                function fin() {
                    if (nextSoundToPlayIndex >= names.length)
                        setTimeout(function () { self.finishedCallback([[["Sentence (or sentence MD5)", self.sentenceMD5]]]); }, 200);
                    else
                        sm.play('sound' + sids[nextSoundToPlayIndex++], { onfinish: fin });
                }
            }

            self.finishedCallback = self.options._finishedCallback;
            self.utils = self.options._utils;

            self.timeout = dget(self.options, "timeout", 2000);

            self.sentenceMD5 = csv_url_encode(self.options.s.html ? self.options.s.html : (self.options.s.audio ? self.options.s.audio+'' : (self.options.s+'')));

            self.element.addClass(self.cssPrefix + "flashed-sentence");
            if (self.sentenceDom) {
                if ($loading) {
                    doneLoading = true;
                    $loading.replaceWith(self.sentenceDom)
                }
                else
                    self.element.append(self.sentenceDom);
            }

            if (self.timeout) {
                self.utils.setTimeout(function() {
                    self.finishedCallback([[["Sentence (or sentence MD5)", self.sentenceMD5]]]);
                }, self.timeout);
            }
            else if (! self.options.s.audio) {
                // Give results without actually finishing.
                if (self.utils.setResults)
                    self.utils.setResults([[["Sentence (or sentence MD5)", self.sentenceMD5]]]);
            }
        }
    }
},

properties: {
    obligatory: ["s"],
    htmlDescription: function (opts) {
        return $(document.createElement("div")).text(opts.s)[0];
    }
}
});

})();


/* This software is licensed under a BSD license; see the LICENSE file for details. */

define_ibex_controller({
name: "Form",

jqueryWidget: {
    _init: function () {
        this.cssPrefix = this.options._cssPrefix;
        this.finishedCallback = this.options._finishedCallback;
        this.utils = this.options._utils;

        this.html = dget(this.options, "html");
        this.continueOnReturn = dget(this.options, "continueOnReturn", false);
        this.continueMessage = dget(this.options, "continueMessage", "Click here to continue");
        this.checkedValue = dget(this.options, "checkedValue", "yes");
        this.uncheckedValue = dget(this.options, "uncheckedValue", "no");
        this.validators = dget(this.options, "validators", { });
        this.errorCSSClass = dget(this.options, "errorCSSClass", "error");
        this.saveReactionTime = dget(this.options, "saveReactionTime", false);
        this.obligatoryErrorGenerator =
            dget(this.options, "obligatoryErrorGenerator",
                 function (field) { return "The \u2018" + field + "\u2019 field is obligatory."; });
        this.obligatoryCheckboxErrorGenerator =
            dget(this.options, "obligatoryCheckboxErrorGenerator",
                 function (field) { return "You must check the " + field + " checkbox to continue."; });
        this.obligatoryRadioErrorGenerator =
            dget(this.options, "obligatoryRadioErrorGenerator",
                 function (field) { return "You must select an option for \u2018" + field + "\u2019."; });

        var t = this;

        function alertOrAddError(name, error) {
            var ae = $("label." + escape(t.errorCSSClass) + "[for=__ALL_FIELDS__]");
            if (ae.length > 0) {
                ae.addClass(t.cssPrefix + "error-text").text(error);
                return;
            }

            var e = $("label." + escape(t.errorCSSClass) + "[for=" + escape(name) + "]");
            if (e.length > 0)
                e.addClass(t.cssPrefix + "error-text").text(error);
            else 
                alert(error);
        }

        var HAS_LOADED = false;

        function handleClick(dom) {
            return function (e) {
                var answerTime = new Date().getTime();

                e.preventDefault();
                if (! HAS_LOADED) return;

                // Get rid of any previous errors.
                $("." + t.cssPrefix + "error-text").empty();

                var rlines = [];

                var inps = $(dom).find("input[type=text]");
                var tas = $(dom).find("textarea");
                for (var i = 0; i < tas.length; ++i) { inps.push(tas[i]); }

                for (var i = 0; i < inps.length; ++i) {
                    var inp = $(inps[i]);

                    if (inp.hasClass("obligatory") && ((! inp.attr('value')) || inp.attr('value').match(/^\s*$/))) {
                        alertOrAddError(inp.attr('name'), t.obligatoryErrorGenerator(inp.attr('name')));
                        return;
                    }

                    if (t.validators[inp.attr('name')]) {
                        var er = t.validators[inp.attr('name')](inp.attr('value'));
                        if (typeof(er) == "string") {
                            alertOrAddError(inp.attr('name'), er);
                            return;
                        }
                    }

                    rlines.push([["Field name", csv_url_encode(inp.attr('name'))],
                                 ["Field value", csv_url_encode(inp.attr('value'))]]);
                }

                var checks = $(dom).find("input[type=checkbox]");
                for (var i = 0; i < checks.length; ++i) {
                    var check = $(checks[i]);
 
                    // Checkboxes with the 'obligatory' class must be checked.
                    if (! check.attr('checked') && check.hasClass('obligatory')) {
                        alertOrAddError(check.attr('name'), t.obligatoryCheckboxErrorGenerator(check.attr('name')));
                        return;
                    }

                    rlines.push([["Field name", check.attr('name')],
                                 ["Field value", check.attr('checked') ? t.checkedValue : t.uncheckedValue]]);
                }

                var rads = $(dom).find("input[type=radio]");
                // Sort by name.
                var rgs = { };
                for (var i = 0; i < rads.length; ++i) {
                    var rad = $(rads[i]);
                    if (rad.attr('name')) {
                        if (! rgs[rad.attr('name')])
                            rgs[rad.attr('name')] = [];
                        rgs[rad.attr('name')].push(rad);
                    }
                }
                for (k in rgs) {
                    // Check if it's oblig.
                    var oblig = false;
                    var oneIsSelected = false;
                    var oneThatWasSelected;
                    var val;
                    for (var i = 0; i < rgs[k].length; ++i) {
                        if (rgs[k][i].hasClass('obligatory')) oblig = true;
                        if (rgs[k][i].attr('checked')) {
                            oneIsSelected = true;
                            oneThatWasSelected = i;
                            val = rgs[k][i].attr('value');
                        }
                    }
                    if (oblig && (! oneIsSelected)) {
                        alertOrAddError(rgs[k][0].attr('name'), t.obligatoryRadioErrorGenerator(rgs[k][0].attr('name')));
                        return;
                    }
                    if (oneIsSelected) {
                        rlines.push([["Field name", rgs[k][0].attr('name')],
                                     ["Field value", rgs[k][oneThatWasSelected].attr('value')]]);
                    }
                }

                if (t.saveReactionTime) {
                    rlines.push([["Field name", "_REACTION_TIME_"],
                                 ["Field value", answerTime - t.creationTime]]);
                }
                t.finishedCallback(rlines);
            }
        }

        var dom = htmlCodeToDOM(this.html, function (dom) {
            HAS_LOADED = true;

            if (t.continueOnReturn) {
                t.safeBind($(dom).find("input[type=text]"), 'keydown', function (e) { if (e.keyCode == 13) { console.log("H"); return handler(e);  } });
            }
        });
        var handler = handleClick(dom);

        this.element.append(dom);

        if (this.continueMessage) {
            this.element.append($("<p>").append($("<a>").attr('href', '').text("\u2192 " + this.continueMessage)
                                                .addClass(ibex_controller_name_to_css_prefix("Message") + "continue-link")
                                                .click(handler)));
        }

        this.creationTime = new Date().getTime();
    }
},

properties: {
    obligatory: ["html"],
    countsForProgressBar: false,
    htmlDescription: function (opts) {
        return htmlCodeToDOM(opts.html);
    }
}
});


/* This software is licensed under a BSD license; see the LICENSE file for details. */

define_ibex_controller({
name: "Message",

jqueryWidget: {
    _init: function () {
        this.cssPrefix = this.options._cssPrefix;
        this.utils = this.options._utils;
        this.finishedCallback = this.options._finishedCallback;

        this.html = this.options.html;
        this.element.addClass(this.cssPrefix + "message");
        this.element.append(htmlCodeToDOM(this.html));

        // Bit of copy/pasting from 'Separator' here.
        this.transfer = dget(this.options, "transfer", "click");
        assert((! this.transfer) || this.transfer == "click" || this.transfer == "keypress" || typeof(this.transfer) == "number",
               "Value of 'transfer' option of Message must either be the string 'click' or a number");

        if (this.transfer == "click") {
            this.continueMessage = dget(this.options, "continueMessage", "Click here to continue.");
            this.consentRequired = dget(this.options, "consentRequired", false);
            this.consentMessage = dget(this.options, "consentMessage", "I have read the above and agree to do the experiment.");
            this.consentErrorMessage = dget(this.options, "consentErrorMessage", "You must consent before continuing.");

            // Add the consent checkbox if necessary.
            var checkbox = null;
            if (this.consentRequired) {
                var names = { };
                var checkbox;
                var message;
                var dom =
                    $(document.createElement("form"))
                    .append($(document.createElement("table"))
                            .css('border', 'none').css('padding', 0).css('margin', 0)
                            .append($(document.createElement("tr"))
                                    .append($(document.createElement("td"))
                                            .css('border', 0).css('padding-left', 0).css('margin-left', 0)
                                            .append(checkbox = $(document.createElement("input"))
                                                    .attr('id', 'consent_checkbox')
                                                    .attr('type', 'checkbox')
                                                    .attr('checked', 0)))
                                    .append(message = $(document.createElement("td"))
                                            .css('border', 0).css('margin-left', 0).css('padding-left', 0)
                                            .append($("<label>")
                                                    .attr('for', 'consent_checkbox')
                                                    .text(this.consentMessage)))));

                this.element.append(dom);
                // Change cursor to pointer when hovering over the message (have to use JS because
                // IE doesn't support :hover for anything other than links).
                message.mouseover(function () {
                    message.css('cursor', "default");
                });
            }

            var t = this;
            // Get a proper lexical scope for the checkbox element so we can capture it in a closure.
            // ALEX: Looking at this again, I don't see why it's necessary to create a local scope here
            // but I am leaving it in as I may be missing something and it won't do any harm.
            (function (checkbox) {
                t.element.append(
                    $(document.createElement("p"))
                    .css('clear', 'left')
                        .append($(document.createElement("a"))
                            .attr('href', '')
                            .addClass(t.cssPrefix + 'continue-link')
                            .text("\u2192 " + t.continueMessage)
                            .click(function () {
                                if ((! checkbox) || checkbox.attr('checked'))
                                    t.finishedCallback();
                                else
                                    alert(t.consentErrorMessage);
                                return false;
                            }))
                );
            })(checkbox);
        }
        else if (this.transfer == "keypress") {
            var t = this;
            this.safeBind($(document), 'keydown', function () {
                t.finishedCallback(null);
                return false;
            });
        }
        else if (typeof(this.transfer) == "number") {
            assert(! this.consentRequired, "The 'consentRequired' option of the Message controller can only be set to true if the 'transfer' option is set to 'click'.");
            this.utils.setTimeout(this.finishedCallback, this.transfer);
        }
    }
},

properties: {
    obligatory: ["html"],
    countsForProgressBar: false,
    htmlDescription: function (opts) {
        return truncateHTML(htmlCodeToDOM(opts.html), 100);
    }
}
});

!function(e){var t={};function n(r){if(t[r])return t[r].exports;var i=t[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:r})},n.r=function(e){Object.defineProperty(e,"__esModule",{value:!0})},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=132)}([function(e,t,n){"use strict";n.r(t),n.d(t,"Abort",function(){return r}),n.d(t,"Ctrlr",function(){return i}),n.d(t,"changeRunningOrder",function(){return s}),n.d(t,"getChangeRunningOrder",function(){return a}),n.d(t,"PennController",function(){return u});var r=new Object;window.MutationObserver||window.WebKitMutationObserver||window.MozMutationObserver;var i={building:{},running:{},list:[]},o=[];function s(e){if(!(e instanceof Function))return console.log("ERROR: changeRunningOrder only takes functions as parameters");console.log("Pushed a function to modify running order"),o.push(e)}function a(e){return o}var u=function(){let e=i.list.length,t=arguments;return i.building.id=e,i.building.sequence=t,i.list.push(i.building),console.log("Just added controller:",i.building),i.building={},{instructions:t,id:e}};u.Configure=function(e){for(let t in e)t.indexOf.Configure<0&&(u[t]=e[t])},u.AddHost=function(){u.hasOwnProperty("hosts")||(u.hosts=[]);for(let e=0;e<arguments.length;e++)"string"==typeof arguments[e]&&arguments[e].match(/^https?:\/\//i)?u.hosts.push(arguments[e]):console.log("Warning: host #"+e+" is not a valid URL.",arguments[e])},u.RemovePrefix=function(){for(let e in u.instructions)window[e]=u.instructions[e]}},function(e,t,n){"use strict";var r=n(6),i=n(49),o=n(16),s=n(116),a=n(12);function u(e){return e}function l(e,t){for(var n=0;n<e.length;++n)t[n]=255&e.charCodeAt(n);return t}t.newBlob=function(e,n){t.checkSupport("blob");try{return new Blob([e],{type:n})}catch(t){try{var r=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);return r.append(e),r.getBlob(n)}catch(e){throw new Error("Bug : can't construct the Blob.")}}};var c={stringifyByChunk:function(e,t,n){var r=[],i=0,o=e.length;if(o<=n)return String.fromCharCode.apply(null,e);for(;i<o;)"array"===t||"nodebuffer"===t?r.push(String.fromCharCode.apply(null,e.slice(i,Math.min(i+n,o)))):r.push(String.fromCharCode.apply(null,e.subarray(i,Math.min(i+n,o)))),i+=n;return r.join("")},stringifyByChar:function(e){for(var t="",n=0;n<e.length;n++)t+=String.fromCharCode(e[n]);return t},applyCanBeUsed:{uint8array:function(){try{return r.uint8array&&1===String.fromCharCode.apply(null,new Uint8Array(1)).length}catch(e){return!1}}(),nodebuffer:function(){try{return r.nodebuffer&&1===String.fromCharCode.apply(null,o.allocBuffer(1)).length}catch(e){return!1}}()}};function h(e){var n=65536,r=t.getTypeOf(e),i=!0;if("uint8array"===r?i=c.applyCanBeUsed.uint8array:"nodebuffer"===r&&(i=c.applyCanBeUsed.nodebuffer),i)for(;n>1;)try{return c.stringifyByChunk(e,r,n)}catch(e){n=Math.floor(n/2)}return c.stringifyByChar(e)}function f(e,t){for(var n=0;n<e.length;n++)t[n]=e[n];return t}t.applyFromCharCode=h;var d={};d.string={string:u,array:function(e){return l(e,new Array(e.length))},arraybuffer:function(e){return d.string.uint8array(e).buffer},uint8array:function(e){return l(e,new Uint8Array(e.length))},nodebuffer:function(e){return l(e,o.allocBuffer(e.length))}},d.array={string:h,array:u,arraybuffer:function(e){return new Uint8Array(e).buffer},uint8array:function(e){return new Uint8Array(e)},nodebuffer:function(e){return o.newBufferFrom(e)}},d.arraybuffer={string:function(e){return h(new Uint8Array(e))},array:function(e){return f(new Uint8Array(e),new Array(e.byteLength))},arraybuffer:u,uint8array:function(e){return new Uint8Array(e)},nodebuffer:function(e){return o.newBufferFrom(new Uint8Array(e))}},d.uint8array={string:h,array:function(e){return f(e,new Array(e.length))},arraybuffer:function(e){return e.buffer},uint8array:u,nodebuffer:function(e){return o.newBufferFrom(e)}},d.nodebuffer={string:h,array:function(e){return f(e,new Array(e.length))},arraybuffer:function(e){return d.nodebuffer.uint8array(e).buffer},uint8array:function(e){return f(e,new Uint8Array(e.length))},nodebuffer:u},t.transformTo=function(e,n){if(n||(n=""),!e)return n;t.checkSupport(e);var r=t.getTypeOf(n);return d[r][e](n)},t.getTypeOf=function(e){return"string"==typeof e?"string":"[object Array]"===Object.prototype.toString.call(e)?"array":r.nodebuffer&&o.isBuffer(e)?"nodebuffer":r.uint8array&&e instanceof Uint8Array?"uint8array":r.arraybuffer&&e instanceof ArrayBuffer?"arraybuffer":void 0},t.checkSupport=function(e){if(!r[e.toLowerCase()])throw new Error(e+" is not supported by this platform")},t.MAX_VALUE_16BITS=65535,t.MAX_VALUE_32BITS=-1,t.pretty=function(e){var t,n,r="";for(n=0;n<(e||"").length;n++)r+="\\x"+((t=e.charCodeAt(n))<16?"0":"")+t.toString(16).toUpperCase();return r},t.delay=function(e,t,n){s(function(){e.apply(n||null,t||[])})},t.inherits=function(e,t){var n=function(){};n.prototype=t.prototype,e.prototype=new n},t.extend=function(){var e,t,n={};for(e=0;e<arguments.length;e++)for(t in arguments[e])arguments[e].hasOwnProperty(t)&&void 0===n[t]&&(n[t]=arguments[e][t]);return n},t.prepareContent=function(e,n,o,s,u){return a.Promise.resolve(n).then(function(e){return r.blob&&(e instanceof Blob||-1!==["[object File]","[object Blob]"].indexOf(Object.prototype.toString.call(e)))&&"undefined"!=typeof FileReader?new a.Promise(function(t,n){var r=new FileReader;r.onload=function(e){t(e.target.result)},r.onerror=function(e){n(e.target.error)},r.readAsArrayBuffer(e)}):e}).then(function(n){var c,h=t.getTypeOf(n);return h?("arraybuffer"===h?n=t.transformTo("uint8array",n):"string"===h&&(u?n=i.decode(n):o&&!0!==s&&(n=l(c=n,r.uint8array?new Uint8Array(c.length):new Array(c.length)))),n):a.Promise.reject(new Error("Can't read the data of '"+e+"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"))})}},function(e,t,n){"use strict";(function(e,r,i){n.d(t,"a",function(){return o}),n.d(t,"b",function(){return s}),n.d(t,"c",function(){return a}),n.d(t,"d",function(){return u}),n.d(t,"e",function(){return l}),n.d(t,"f",function(){return c}),n.d(t,"g",function(){return h});var o=!0,s=!0,a=!0,u=!0,l=[],c=12e4,h="Please wait while the resources are preloading. This process may take up to 2 minutes.";function f(t){let n=[],i=[];if(t.options.preload.hasOwnProperty(0))for(let e in t.options.preload){let n=t.options.preload[e];"number"!=typeof n&&("string"==typeof n&&(n=(n=>n==t.options.preload[e])),i.push(n))}else i=[anyType];let o=function(e){let t,n=[],r={};for(let t in e){let i=e[t];if(i[0]instanceof Array){if(i[0].length>1){let e=i[0][1];r.hasOwnProperty(e)||(r[e]=[]),r[e].push(i)}}else n.push(i)}t="undefined"!=typeof counterOverride?counterOverride:__counter_value_from_server__;for(let e=0;e<Object.keys(r).length;e++){let i=r[Object.keys(r)[e]],o=(t%i.length+e)%i.length;n.push(i[o])}return n}(items);for(let t in o){let r=o[t],s=r[0];s instanceof Array&&(s=r[0][0]);let a=!1;for(let e in i)if(i[e](s)){a=!0;break}if(!a)continue;let u=!1;for(let t in r){if(0==t)continue;let i=r[t];u&&(u=!1,i instanceof Object&&i.hasOwnProperty("id")&&(n=n.concat(e.list[i.id].preloadingInstructions))),t>0&&"PennController"==i&&(u=!0)}}let s=$("<div id='waitWhilePreloading'>").append(h);t.element.append(s);for(let e in n){let r=n[e];r&&l.indexOf(r)>=0&&(t.toPreload||(t.toPreload=[]),t.toPreload.indexOf(r)<0&&(t.toPreload.push(r),r._setResource=r.extend("_setResource",function(){let e=t.toPreload.indexOf(r);e>=0&&t.toPreload.splice(e,1),t.toPreload.length<=0&&jQuery.contains(document,s[0])&&(s.remove(),t.finishedCallback())})))}return(!t.toPreload||t.toPreload.length<=0)&&jQuery.contains(document,s[0])?(s.remove(),t.finishedCallback()):setTimeout(function(){if(!jQuery.contains(document,s[0]))return r;s.remove(),t.finishedCallback()},t.options.timeout),r}i.CheckPreload=function(){u=!1;let e=arguments[Object.keys(arguments).length-1];return("number"!=typeof e||e<=0)&&(e=c),{custom:f,preload:arguments,timeout:e,countsForProgressBar:!1}},i.AutoPreload=function(e){"images"==e?(a=!1,o=!1,s=!0):"audio"==e?(o=!0,s=!1,a=!1):"video"==parameters?(a=!0,o=!1,s=!1):"object"==typeof e?(e.hasOwnProperty("images")&&(s=e.images),e.hasOwnProperty("audio")&&(o=e.audio),e.hasOwnProperty("videos")&&(a=e.videos)):(o=!0,s=!0,a=!0)}}).call(this,n(0).Ctrlr,n(0).Abort,n(0).PennController)},function(e,t,n){"use strict";n.r(t),function(e,r,i){n.d(t,"Instruction",function(){return l});var o=n(2),s=n(7);const a=window.MutationObserver||window.WebKitMutationObserver||window.MozMutationObserver;var u=[{}];class l{constructor(t,n){this.type=n,this.content=t,this.hasBeenRun=!1,this.isDone=!1,this.parentElement=null,this.element=null,this.origin=this,this.itvlWhen=null,this.resource=null,this.j={},e.building.hasOwnProperty("instructions")||(e.building.instructions=[]),e.building.instructions.push(this),console.log("Created a new instruction, adding to controller:",e.building)}_addElement(t,n,i){if(null==t&&(t=e.running.element),null==n&&(n=this.element),!(n instanceof jQuery&&t instanceof jQuery))return r;if(t==e.running.element&&(n=$("<div>").append(n)),i instanceof Function&&a){let e=new a(t=>{0!==t[0].addedNodes.length&&-1!==Array.prototype.indexOf.call(t[0].addedNodes,n[0])&&(e.disconnect(),i())});e.observe(t[0],{childList:!0})}t.append(n)}setElement(e){this.element=e;let t=this;for(let e in this.origin.element)"function"==typeof t.origin.element[e]?t.j[e]=function(){return t.origin.element[e].apply(t.origin.element,arguments),t.newMeta(function(){this.done()})}:t.j[e]=function(){return t.origin.element[e]}}_addToPreload(){if(this.origin.resource)return r;o.e.indexOf(this.origin)<0&&o.e.push(this.origin),e.building.hasOwnProperty("preloadingInstructions")||(e.building.preloadingInstructions=[]),e.building.preloadingInstructions.indexOf(this.origin)<0&&e.building.preloadingInstructions.push(this.origin)}_setResource(e){if(this.origin.resource)return console.log("Warning: trying to replace resource for "+this.origin.content+"; several host copies of the same file? Ignoring new resource."),r;let t=o.e.indexOf(this.origin);t>=0&&o.e.splice(t,1),this.origin.resource=e}fetchResource(e,t){let n,o,a=this;if(this.origin.resource)return r;if(s.d&&s.a.length>0&&!e.match(/^http/i))return void s.c.push(function(){a.fetchResource(e,t)});let u="load";if(s.b.hasOwnProperty(e))t=s.b[e].type,o=URL.createObjectURL(s.b[e].blob),t.match(/audio/)&&(u="canplay");else if(e.match(/^http/i)){let n=e.match(/\.([^.]+)$/);if(!t&&!n)return console.log("Error: extension of resource "+file+" not recognized"),r;n=n[1],"audio"==t||n.match(/mp3|ogg|wav/i)?(t="audio/"+n.toLowerCase().replace("mp3","mpeg").toLowerCase(),o=e,u="canplaythrough"):"image"==t||n.match(/gif|png|jpe?g/i)?(t="image/"+n.replace(/jpg/i,"jpeg").toLowerCase(),o=e):"video"==t||n.match(/mp4|ogg|webm/i)}else if(i.hosts.length)for(let n in i.hosts)"string"==typeof i.hosts[n]&&i.hosts[n].match(/^http/i)&&a.fetchResource(i.hosts[n]+e,t);t.match(/audio/)?(n=$("<audio>").append($("<source>").attr({src:o,type:t})).css("display","none").attr({preload:"auto"})).get(0).readyState>4-("canplay"==u)?a._setResource(n):n.one(u,function(){a._setResource(n)}):t.match(/image/)&&(n=$("<img>").attr({src:o,type:t})).bind(u,function(){a.origin._setResource(n)}).bind("error",function(){console.log("Warning: could not find image "+e)})}done(){return this.isDone||!this.hasBeenRun?r:this.previousInstruction instanceof l&&!this.previousInstruction.isDone?r:(this.itvlWhen&&clearInterval(this.itvlWhen),void(this.isDone=!0))}run(){return this.hasBeenRun?r:this.previousInstruction instanceof l&&!this.previousInstruction.isDone?r:void(this.hasBeenRun=!0)}extend(e,t){let n=this,i=n[e];return function(){return i.apply(n,arguments)==r?r:t.apply(n,arguments)}}_whenToInsist(e){this.origin.clickable?this.origin.element.click(e):this.itvlWhen=setInterval(e,10)}when(t,n){return this.newMeta(function(){if(t())this.done();else{n instanceof l?(n.parentElement=e.running.element,n.run()):n instanceof Function&&n();let r=this;this._whenToInsist(function(){!r.isDone&&t()&&r.done()})}})}newMeta(e,t){let n=this,i=new this.origin.constructor(r);return i.sourceCallback=function(){let t=this;for(;t.source;){if(!t.source.isDone)return r;t=t.source}i.hasBeenRun=!0,"function"==typeof e&&e.apply(i,arguments)},i.before=function(){"function"==typeof t&&t.apply(i,arguments)},i.done=function(){if(l.prototype.done.apply(i)==r)return r;let e=this;for(;e.source;){if(!e.source.isDone)return r;e=e.source}},i.run=function(){if(l.prototype.run.apply(i)==r)return r;i.hasBeenRun=!1,i.before(),n.hasBeenRun?i.sourceCallback():(n.done=n.extend("done",function(){i.sourceCallback()}),n.run())},i.type="meta",i.source=n,i.setElement(n.element),i.origin=n.origin,i.toPreload=n.toPreload,i}remove(){return this.newMeta(function(){this.origin.element instanceof jQuery&&this.origin.element.detach(),this.done()})}move(e,t){return this.newMeta(function(){if(e instanceof l){let n=e.origin.element;for(;e instanceof ComplexInstr&&!n.is("table");)n=n.parent();"before"==t?n.before(this.origin.element):n.after(this.origin.element)}this.done()})}resize(e,t){return this.newMeta(function(){this.origin.element.css({width:e,height:t}),this.done()})}center(){return this.newMeta(function(){this.origin.element.parent().css("text-align","center"),this.origin.element.css("text-align","center"),this.origin.element.css("margin","auto"),this.done()})}shift(e,t){return this.newMeta(function(){this.origin.element.css("position").match(/static|relative/)?(this.origin.element.css("position","relative"),this.origin.element.css({left:e,top:t})):"absolute"==this.origin.element.css("position")&&this.origin.element.css({left:this.origin.element.css("left")+e,top:this.origin.element.css("top")+t}),this.done()})}css(){let e=arguments;return this.newMeta(function(){this.origin.element.css.apply(this.origin.element,e),this.done()})}hide(e){return void 0===e&&(e=!0),this.newMeta(function(){e?this.origin.element.css("visibility","hidden"):this.origin.element.css("visibility","visible"),this.done()})}click(t){return this.newMeta(function(){this.origin.clickable=!0,this.origin.element.addClass(e.running.cssPrefix+"clickable");let n=this;this.origin.element.click(function(){t instanceof l?(t.parentElement=e.running.element,t.run()):t instanceof Function&&t.apply(e.running.variables),n.done()})})}id(e){return u[u.length-1][e]=this.origin,this.origin._id=e,this.newMeta(function(){this.done()})}}i.instruction=function(t){return"string"!=typeof t?r:e.running&&u[e.running.id].hasOwnProperty(arg)?u[e.running.id][arg]:!e.running&&u[u.length-1].hasOwnProperty(arg)?u[u.length-1][arg]:void 0}}.call(this,n(0).Ctrlr,n(0).Abort,n(0).PennController)},function(e,t,n){"use strict";function r(e){this.name=e||"default",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null}r.prototype={push:function(e){this.emit("data",e)},end:function(){if(this.isFinished)return!1;this.flush();try{this.emit("end"),this.cleanUp(),this.isFinished=!0}catch(e){this.emit("error",e)}return!0},error:function(e){return!this.isFinished&&(this.isPaused?this.generatedError=e:(this.isFinished=!0,this.emit("error",e),this.previous&&this.previous.error(e),this.cleanUp()),!0)},on:function(e,t){return this._listeners[e].push(t),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[]},emit:function(e,t){if(this._listeners[e])for(var n=0;n<this._listeners[e].length;n++)this._listeners[e][n].call(this,t)},pipe:function(e){return e.registerPrevious(this)},registerPrevious:function(e){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.streamInfo=e.streamInfo,this.mergeStreamInfo(),this.previous=e;var t=this;return e.on("data",function(e){t.processChunk(e)}),e.on("end",function(){t.end()}),e.on("error",function(e){t.error(e)}),this},pause:function(){return!this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return!1;this.isPaused=!1;var e=!1;return this.generatedError&&(this.error(this.generatedError),e=!0),this.previous&&this.previous.resume(),!e},flush:function(){},processChunk:function(e){this.push(e)},withStreamInfo:function(e,t){return this.extraStreamInfo[e]=t,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var e in this.extraStreamInfo)this.extraStreamInfo.hasOwnProperty(e)&&(this.streamInfo[e]=this.extraStreamInfo[e])},lock:function(){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.isLocked=!0,this.previous&&this.previous.lock()},toString:function(){var e="Worker "+this.name;return this.previous?this.previous+" -> "+e:e}},e.exports=r},function(e,t,n){"use strict";var r="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;function i(e,t){return Object.prototype.hasOwnProperty.call(e,t)}t.assign=function(e){for(var t=Array.prototype.slice.call(arguments,1);t.length;){var n=t.shift();if(n){if("object"!=typeof n)throw new TypeError(n+"must be non-object");for(var r in n)i(n,r)&&(e[r]=n[r])}}return e},t.shrinkBuf=function(e,t){return e.length===t?e:e.subarray?e.subarray(0,t):(e.length=t,e)};var o={arraySet:function(e,t,n,r,i){if(t.subarray&&e.subarray)e.set(t.subarray(n,n+r),i);else for(var o=0;o<r;o++)e[i+o]=t[n+o]},flattenChunks:function(e){var t,n,r,i,o,s;for(r=0,t=0,n=e.length;t<n;t++)r+=e[t].length;for(s=new Uint8Array(r),i=0,t=0,n=e.length;t<n;t++)o=e[t],s.set(o,i),i+=o.length;return s}},s={arraySet:function(e,t,n,r,i){for(var o=0;o<r;o++)e[i+o]=t[n+o]},flattenChunks:function(e){return[].concat.apply([],e)}};t.setTyped=function(e){e?(t.Buf8=Uint8Array,t.Buf16=Uint16Array,t.Buf32=Int32Array,t.assign(t,o)):(t.Buf8=Array,t.Buf16=Array,t.Buf32=Array,t.assign(t,s))},t.setTyped(r)},function(e,t,n){"use strict";(function(e){if(t.base64=!0,t.array=!0,t.string=!0,t.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,t.nodebuffer=void 0!==e,t.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)t.blob=!1;else{var r=new ArrayBuffer(0);try{t.blob=0===new Blob([r],{type:"application/zip"}).size}catch(e){try{var i=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);i.append(r),t.blob=0===i.getBlob("application/zip").size}catch(e){t.blob=!1}}}try{t.nodestream=!!n(55).Readable}catch(e){t.nodestream=!1}}).call(this,n(14).Buffer)},function(e,t,n){"use strict";(function(e){n.d(t,"a",function(){return o}),n.d(t,"d",function(){return s}),n.d(t,"b",function(){return a}),n.d(t,"c",function(){return u});var r=n(20),i=n(58),o=[],s=!0,a={},u=[];e.PreloadZip=function(){for(let e in arguments)o.push(arguments[e])},$(document).ready(function(){!function(){if(o.length){var e=function(e){function t(){let t=o.indexOf(e);if(t>=0&&o.splice(t,1),o.length<=0){console.log(a);for(let e in u)u[e]instanceof Function&&u[e].call()}}var n=new r;Object(i.getBinaryContent)(e,function(r,i){if(r)throw t(),r;n.loadAsync(i).then(function(){console.log("Download of "+e+" complete");var r=0;n.forEach(function(e,i){i.async("arraybuffer").then(function(i){if(!e.match(/__MACOS.+\/\.[^\/]+$/)){let t=e.replace(/^.*?([^\/]+)$/,"$1"),n="";t.match(/\.(wav|mp3|ogg)$/i)?n="audio/"+t.replace(/^.+\.([^.]+)$/,"$1").replace(/mp3/i,"mpeg").toLowerCase():t.match(/\.(png|jpe?g|gif)$/i)&&(n="image/"+t.replace(/^.+\.([^.]+)$/,"$1").replace(/jpg/i,"jpeg").toLowerCase()),n.length>0&&(a[t]={blob:new Blob([i],{type:n}),type:n})}++r>=Object.keys(n.files).length&&t()})})})})};for(let t in o){let n=o[t],r=n.match(/^https?:\/\/.+\.(zip)$/i);"string"==typeof n&&r?"zip"==r[1].toLowerCase()&&e(n):console.log("Warning (Preload): entry #"+t+" is not a valid URL, ignoring it")}}}()})}).call(this,n(0).PennController)},function(e,t,n){"use strict";var r=n(18),i=Object.keys||function(e){var t=[];for(var n in e)t.push(n);return t};e.exports=h;var o=n(13);o.inherits=n(10);var s=n(54),a=n(26);o.inherits(h,s);for(var u=i(a.prototype),l=0;l<u.length;l++){var c=u[l];h.prototype[c]||(h.prototype[c]=a.prototype[c])}function h(e){if(!(this instanceof h))return new h(e);s.call(this,e),a.call(this,e),e&&!1===e.readable&&(this.readable=!1),e&&!1===e.writable&&(this.writable=!1),this.allowHalfOpen=!0,e&&!1===e.allowHalfOpen&&(this.allowHalfOpen=!1),this.once("end",f)}function f(){this.allowHalfOpen||this._writableState.ended||r.nextTick(d,this)}function d(e){e.end()}Object.defineProperty(h.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),Object.defineProperty(h.prototype,"destroyed",{get:function(){return void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed&&this._writableState.destroyed)},set:function(e){void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed=e,this._writableState.destroyed=e)}}),h.prototype._destroy=function(e,t){this.push(null),this.end(),r.nextTick(t,e)}},function(e,t){var n;n=function(){return this}();try{n=n||Function("return this")()||(0,eval)("this")}catch(e){"object"==typeof window&&(n=window)}e.exports=n},function(e,t){"function"==typeof Object.create?e.exports=function(e,t){e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}})}:e.exports=function(e,t){e.super_=t;var n=function(){};n.prototype=t.prototype,e.prototype=new n,e.prototype.constructor=e}},function(e,t,n){"use strict";for(var r=n(1),i=n(6),o=n(16),s=n(4),a=new Array(256),u=0;u<256;u++)a[u]=u>=252?6:u>=248?5:u>=240?4:u>=224?3:u>=192?2:1;a[254]=a[254]=1;function l(){s.call(this,"utf-8 decode"),this.leftOver=null}function c(){s.call(this,"utf-8 encode")}t.utf8encode=function(e){return i.nodebuffer?o.newBufferFrom(e,"utf-8"):function(e){var t,n,r,o,s,a=e.length,u=0;for(o=0;o<a;o++)55296==(64512&(n=e.charCodeAt(o)))&&o+1<a&&56320==(64512&(r=e.charCodeAt(o+1)))&&(n=65536+(n-55296<<10)+(r-56320),o++),u+=n<128?1:n<2048?2:n<65536?3:4;for(t=i.uint8array?new Uint8Array(u):new Array(u),s=0,o=0;s<u;o++)55296==(64512&(n=e.charCodeAt(o)))&&o+1<a&&56320==(64512&(r=e.charCodeAt(o+1)))&&(n=65536+(n-55296<<10)+(r-56320),o++),n<128?t[s++]=n:n<2048?(t[s++]=192|n>>>6,t[s++]=128|63&n):n<65536?(t[s++]=224|n>>>12,t[s++]=128|n>>>6&63,t[s++]=128|63&n):(t[s++]=240|n>>>18,t[s++]=128|n>>>12&63,t[s++]=128|n>>>6&63,t[s++]=128|63&n);return t}(e)},t.utf8decode=function(e){return i.nodebuffer?r.transformTo("nodebuffer",e).toString("utf-8"):function(e){var t,n,i,o,s=e.length,u=new Array(2*s);for(n=0,t=0;t<s;)if((i=e[t++])<128)u[n++]=i;else if((o=a[i])>4)u[n++]=65533,t+=o-1;else{for(i&=2===o?31:3===o?15:7;o>1&&t<s;)i=i<<6|63&e[t++],o--;o>1?u[n++]=65533:i<65536?u[n++]=i:(i-=65536,u[n++]=55296|i>>10&1023,u[n++]=56320|1023&i)}return u.length!==n&&(u.subarray?u=u.subarray(0,n):u.length=n),r.applyFromCharCode(u)}(e=r.transformTo(i.uint8array?"uint8array":"array",e))},r.inherits(l,s),l.prototype.processChunk=function(e){var n=r.transformTo(i.uint8array?"uint8array":"array",e.data);if(this.leftOver&&this.leftOver.length){if(i.uint8array){var o=n;(n=new Uint8Array(o.length+this.leftOver.length)).set(this.leftOver,0),n.set(o,this.leftOver.length)}else n=this.leftOver.concat(n);this.leftOver=null}var s=function(e,t){var n;for((t=t||e.length)>e.length&&(t=e.length),n=t-1;n>=0&&128==(192&e[n]);)n--;return n<0?t:0===n?t:n+a[e[n]]>t?n:t}(n),u=n;s!==n.length&&(i.uint8array?(u=n.subarray(0,s),this.leftOver=n.subarray(s,n.length)):(u=n.slice(0,s),this.leftOver=n.slice(s,n.length))),this.push({data:t.utf8decode(u),meta:e.meta})},l.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:t.utf8decode(this.leftOver),meta:{}}),this.leftOver=null)},t.Utf8DecodeWorker=l,r.inherits(c,s),c.prototype.processChunk=function(e){this.push({data:t.utf8encode(e.data),meta:e.meta})},t.Utf8EncodeWorker=c},function(e,t,n){"use strict";var r=null;r="undefined"!=typeof Promise?Promise:n(102),e.exports={Promise:r}},function(e,t,n){(function(e){function n(e){return Object.prototype.toString.call(e)}t.isArray=function(e){return Array.isArray?Array.isArray(e):"[object Array]"===n(e)},t.isBoolean=function(e){return"boolean"==typeof e},t.isNull=function(e){return null===e},t.isNullOrUndefined=function(e){return null==e},t.isNumber=function(e){return"number"==typeof e},t.isString=function(e){return"string"==typeof e},t.isSymbol=function(e){return"symbol"==typeof e},t.isUndefined=function(e){return void 0===e},t.isRegExp=function(e){return"[object RegExp]"===n(e)},t.isObject=function(e){return"object"==typeof e&&null!==e},t.isDate=function(e){return"[object Date]"===n(e)},t.isError=function(e){return"[object Error]"===n(e)||e instanceof Error},t.isFunction=function(e){return"function"==typeof e},t.isPrimitive=function(e){return null===e||"boolean"==typeof e||"number"==typeof e||"string"==typeof e||"symbol"==typeof e||void 0===e},t.isBuffer=e.isBuffer}).call(this,n(14).Buffer)},function(e,t,n){"use strict";(function(e){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
var r=n(130),i=n(129),o=n(56);function s(){return u.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function a(e,t){if(s()<t)throw new RangeError("Invalid typed array length");return u.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(t)).__proto__=u.prototype:(null===e&&(e=new u(t)),e.length=t),e}function u(e,t,n){if(!(u.TYPED_ARRAY_SUPPORT||this instanceof u))return new u(e,t,n);if("number"==typeof e){if("string"==typeof t)throw new Error("If encoding is specified then the first argument must be a string");return h(this,e)}return l(this,e,t,n)}function l(e,t,n,r){if("number"==typeof t)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer?function(e,t,n,r){if(t.byteLength,n<0||t.byteLength<n)throw new RangeError("'offset' is out of bounds");if(t.byteLength<n+(r||0))throw new RangeError("'length' is out of bounds");t=void 0===n&&void 0===r?new Uint8Array(t):void 0===r?new Uint8Array(t,n):new Uint8Array(t,n,r);u.TYPED_ARRAY_SUPPORT?(e=t).__proto__=u.prototype:e=f(e,t);return e}(e,t,n,r):"string"==typeof t?function(e,t,n){"string"==typeof n&&""!==n||(n="utf8");if(!u.isEncoding(n))throw new TypeError('"encoding" must be a valid string encoding');var r=0|p(t,n),i=(e=a(e,r)).write(t,n);i!==r&&(e=e.slice(0,i));return e}(e,t,n):function(e,t){if(u.isBuffer(t)){var n=0|d(t.length);return 0===(e=a(e,n)).length?e:(t.copy(e,0,0,n),e)}if(t){if("undefined"!=typeof ArrayBuffer&&t.buffer instanceof ArrayBuffer||"length"in t)return"number"!=typeof t.length||(r=t.length)!=r?a(e,0):f(e,t);if("Buffer"===t.type&&o(t.data))return f(e,t.data)}var r;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(e,t)}function c(e){if("number"!=typeof e)throw new TypeError('"size" argument must be a number');if(e<0)throw new RangeError('"size" argument must not be negative')}function h(e,t){if(c(t),e=a(e,t<0?0:0|d(t)),!u.TYPED_ARRAY_SUPPORT)for(var n=0;n<t;++n)e[n]=0;return e}function f(e,t){var n=t.length<0?0:0|d(t.length);e=a(e,n);for(var r=0;r<n;r+=1)e[r]=255&t[r];return e}function d(e){if(e>=s())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+s().toString(16)+" bytes");return 0|e}function p(e,t){if(u.isBuffer(e))return e.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;"string"!=typeof e&&(e=""+e);var n=e.length;if(0===n)return 0;for(var r=!1;;)switch(t){case"ascii":case"latin1":case"binary":return n;case"utf8":case"utf-8":case void 0:return F(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*n;case"hex":return n>>>1;case"base64":return j(e).length;default:if(r)return F(e).length;t=(""+t).toLowerCase(),r=!0}}function g(e,t,n){var r=e[t];e[t]=e[n],e[n]=r}function m(e,t,n,r,i){if(0===e.length)return-1;if("string"==typeof n?(r=n,n=0):n>2147483647?n=2147483647:n<-2147483648&&(n=-2147483648),n=+n,isNaN(n)&&(n=i?0:e.length-1),n<0&&(n=e.length+n),n>=e.length){if(i)return-1;n=e.length-1}else if(n<0){if(!i)return-1;n=0}if("string"==typeof t&&(t=u.from(t,r)),u.isBuffer(t))return 0===t.length?-1:y(e,t,n,r,i);if("number"==typeof t)return t&=255,u.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(e,t,n):Uint8Array.prototype.lastIndexOf.call(e,t,n):y(e,[t],n,r,i);throw new TypeError("val must be string, number or Buffer")}function y(e,t,n,r,i){var o,s=1,a=e.length,u=t.length;if(void 0!==r&&("ucs2"===(r=String(r).toLowerCase())||"ucs-2"===r||"utf16le"===r||"utf-16le"===r)){if(e.length<2||t.length<2)return-1;s=2,a/=2,u/=2,n/=2}function l(e,t){return 1===s?e[t]:e.readUInt16BE(t*s)}if(i){var c=-1;for(o=n;o<a;o++)if(l(e,o)===l(t,-1===c?0:o-c)){if(-1===c&&(c=o),o-c+1===u)return c*s}else-1!==c&&(o-=o-c),c=-1}else for(n+u>a&&(n=a-u),o=n;o>=0;o--){for(var h=!0,f=0;f<u;f++)if(l(e,o+f)!==l(t,f)){h=!1;break}if(h)return o}return-1}function v(e,t,n,r){n=Number(n)||0;var i=e.length-n;r?(r=Number(r))>i&&(r=i):r=i;var o=t.length;if(o%2!=0)throw new TypeError("Invalid hex string");r>o/2&&(r=o/2);for(var s=0;s<r;++s){var a=parseInt(t.substr(2*s,2),16);if(isNaN(a))return s;e[n+s]=a}return s}function b(e,t,n,r){return W(F(t,e.length-n),e,n,r)}function w(e,t,n,r){return W(function(e){for(var t=[],n=0;n<e.length;++n)t.push(255&e.charCodeAt(n));return t}(t),e,n,r)}function _(e,t,n,r){return w(e,t,n,r)}function k(e,t,n,r){return W(j(t),e,n,r)}function x(e,t,n,r){return W(function(e,t){for(var n,r,i,o=[],s=0;s<e.length&&!((t-=2)<0);++s)n=e.charCodeAt(s),r=n>>8,i=n%256,o.push(i),o.push(r);return o}(t,e.length-n),e,n,r)}function E(e,t,n){return 0===t&&n===e.length?r.fromByteArray(e):r.fromByteArray(e.slice(t,n))}function S(e,t,n){n=Math.min(e.length,n);for(var r=[],i=t;i<n;){var o,s,a,u,l=e[i],c=null,h=l>239?4:l>223?3:l>191?2:1;if(i+h<=n)switch(h){case 1:l<128&&(c=l);break;case 2:128==(192&(o=e[i+1]))&&(u=(31&l)<<6|63&o)>127&&(c=u);break;case 3:o=e[i+1],s=e[i+2],128==(192&o)&&128==(192&s)&&(u=(15&l)<<12|(63&o)<<6|63&s)>2047&&(u<55296||u>57343)&&(c=u);break;case 4:o=e[i+1],s=e[i+2],a=e[i+3],128==(192&o)&&128==(192&s)&&128==(192&a)&&(u=(15&l)<<18|(63&o)<<12|(63&s)<<6|63&a)>65535&&u<1114112&&(c=u)}null===c?(c=65533,h=1):c>65535&&(c-=65536,r.push(c>>>10&1023|55296),c=56320|1023&c),r.push(c),i+=h}return function(e){var t=e.length;if(t<=C)return String.fromCharCode.apply(String,e);var n="",r=0;for(;r<t;)n+=String.fromCharCode.apply(String,e.slice(r,r+=C));return n}(r)}t.Buffer=u,t.SlowBuffer=function(e){+e!=e&&(e=0);return u.alloc(+e)},t.INSPECT_MAX_BYTES=50,u.TYPED_ARRAY_SUPPORT=void 0!==e.TYPED_ARRAY_SUPPORT?e.TYPED_ARRAY_SUPPORT:function(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()&&"function"==typeof e.subarray&&0===e.subarray(1,1).byteLength}catch(e){return!1}}(),t.kMaxLength=s(),u.poolSize=8192,u._augment=function(e){return e.__proto__=u.prototype,e},u.from=function(e,t,n){return l(null,e,t,n)},u.TYPED_ARRAY_SUPPORT&&(u.prototype.__proto__=Uint8Array.prototype,u.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&u[Symbol.species]===u&&Object.defineProperty(u,Symbol.species,{value:null,configurable:!0})),u.alloc=function(e,t,n){return function(e,t,n,r){return c(t),t<=0?a(e,t):void 0!==n?"string"==typeof r?a(e,t).fill(n,r):a(e,t).fill(n):a(e,t)}(null,e,t,n)},u.allocUnsafe=function(e){return h(null,e)},u.allocUnsafeSlow=function(e){return h(null,e)},u.isBuffer=function(e){return!(null==e||!e._isBuffer)},u.compare=function(e,t){if(!u.isBuffer(e)||!u.isBuffer(t))throw new TypeError("Arguments must be Buffers");if(e===t)return 0;for(var n=e.length,r=t.length,i=0,o=Math.min(n,r);i<o;++i)if(e[i]!==t[i]){n=e[i],r=t[i];break}return n<r?-1:r<n?1:0},u.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},u.concat=function(e,t){if(!o(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return u.alloc(0);var n;if(void 0===t)for(t=0,n=0;n<e.length;++n)t+=e[n].length;var r=u.allocUnsafe(t),i=0;for(n=0;n<e.length;++n){var s=e[n];if(!u.isBuffer(s))throw new TypeError('"list" argument must be an Array of Buffers');s.copy(r,i),i+=s.length}return r},u.byteLength=p,u.prototype._isBuffer=!0,u.prototype.swap16=function(){var e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;t<e;t+=2)g(this,t,t+1);return this},u.prototype.swap32=function(){var e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;t<e;t+=4)g(this,t,t+3),g(this,t+1,t+2);return this},u.prototype.swap64=function(){var e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;t<e;t+=8)g(this,t,t+7),g(this,t+1,t+6),g(this,t+2,t+5),g(this,t+3,t+4);return this},u.prototype.toString=function(){var e=0|this.length;return 0===e?"":0===arguments.length?S(this,0,e):function(e,t,n){var r=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===n||n>this.length)&&(n=this.length),n<=0)return"";if((n>>>=0)<=(t>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return A(this,t,n);case"utf8":case"utf-8":return S(this,t,n);case"ascii":return P(this,t,n);case"latin1":case"binary":return R(this,t,n);case"base64":return E(this,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return T(this,t,n);default:if(r)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),r=!0}}.apply(this,arguments)},u.prototype.equals=function(e){if(!u.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===u.compare(this,e)},u.prototype.inspect=function(){var e="",n=t.INSPECT_MAX_BYTES;return this.length>0&&(e=this.toString("hex",0,n).match(/.{2}/g).join(" "),this.length>n&&(e+=" ... ")),"<Buffer "+e+">"},u.prototype.compare=function(e,t,n,r,i){if(!u.isBuffer(e))throw new TypeError("Argument must be a Buffer");if(void 0===t&&(t=0),void 0===n&&(n=e?e.length:0),void 0===r&&(r=0),void 0===i&&(i=this.length),t<0||n>e.length||r<0||i>this.length)throw new RangeError("out of range index");if(r>=i&&t>=n)return 0;if(r>=i)return-1;if(t>=n)return 1;if(t>>>=0,n>>>=0,r>>>=0,i>>>=0,this===e)return 0;for(var o=i-r,s=n-t,a=Math.min(o,s),l=this.slice(r,i),c=e.slice(t,n),h=0;h<a;++h)if(l[h]!==c[h]){o=l[h],s=c[h];break}return o<s?-1:s<o?1:0},u.prototype.includes=function(e,t,n){return-1!==this.indexOf(e,t,n)},u.prototype.indexOf=function(e,t,n){return m(this,e,t,n,!0)},u.prototype.lastIndexOf=function(e,t,n){return m(this,e,t,n,!1)},u.prototype.write=function(e,t,n,r){if(void 0===t)r="utf8",n=this.length,t=0;else if(void 0===n&&"string"==typeof t)r=t,n=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t|=0,isFinite(n)?(n|=0,void 0===r&&(r="utf8")):(r=n,n=void 0)}var i=this.length-t;if((void 0===n||n>i)&&(n=i),e.length>0&&(n<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");r||(r="utf8");for(var o=!1;;)switch(r){case"hex":return v(this,e,t,n);case"utf8":case"utf-8":return b(this,e,t,n);case"ascii":return w(this,e,t,n);case"latin1":case"binary":return _(this,e,t,n);case"base64":return k(this,e,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return x(this,e,t,n);default:if(o)throw new TypeError("Unknown encoding: "+r);r=(""+r).toLowerCase(),o=!0}},u.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var C=4096;function P(e,t,n){var r="";n=Math.min(e.length,n);for(var i=t;i<n;++i)r+=String.fromCharCode(127&e[i]);return r}function R(e,t,n){var r="";n=Math.min(e.length,n);for(var i=t;i<n;++i)r+=String.fromCharCode(e[i]);return r}function A(e,t,n){var r=e.length;(!t||t<0)&&(t=0),(!n||n<0||n>r)&&(n=r);for(var i="",o=t;o<n;++o)i+=U(e[o]);return i}function T(e,t,n){for(var r=e.slice(t,n),i="",o=0;o<r.length;o+=2)i+=String.fromCharCode(r[o]+256*r[o+1]);return i}function O(e,t,n){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>n)throw new RangeError("Trying to access beyond buffer length")}function I(e,t,n,r,i,o){if(!u.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>i||t<o)throw new RangeError('"value" argument is out of bounds');if(n+r>e.length)throw new RangeError("Index out of range")}function B(e,t,n,r){t<0&&(t=65535+t+1);for(var i=0,o=Math.min(e.length-n,2);i<o;++i)e[n+i]=(t&255<<8*(r?i:1-i))>>>8*(r?i:1-i)}function L(e,t,n,r){t<0&&(t=4294967295+t+1);for(var i=0,o=Math.min(e.length-n,4);i<o;++i)e[n+i]=t>>>8*(r?i:3-i)&255}function D(e,t,n,r,i,o){if(n+r>e.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("Index out of range")}function N(e,t,n,r,o){return o||D(e,0,n,4),i.write(e,t,n,r,23,4),n+4}function z(e,t,n,r,o){return o||D(e,0,n,8),i.write(e,t,n,r,52,8),n+8}u.prototype.slice=function(e,t){var n,r=this.length;if(e=~~e,t=void 0===t?r:~~t,e<0?(e+=r)<0&&(e=0):e>r&&(e=r),t<0?(t+=r)<0&&(t=0):t>r&&(t=r),t<e&&(t=e),u.TYPED_ARRAY_SUPPORT)(n=this.subarray(e,t)).__proto__=u.prototype;else{var i=t-e;n=new u(i,void 0);for(var o=0;o<i;++o)n[o]=this[o+e]}return n},u.prototype.readUIntLE=function(e,t,n){e|=0,t|=0,n||O(e,t,this.length);for(var r=this[e],i=1,o=0;++o<t&&(i*=256);)r+=this[e+o]*i;return r},u.prototype.readUIntBE=function(e,t,n){e|=0,t|=0,n||O(e,t,this.length);for(var r=this[e+--t],i=1;t>0&&(i*=256);)r+=this[e+--t]*i;return r},u.prototype.readUInt8=function(e,t){return t||O(e,1,this.length),this[e]},u.prototype.readUInt16LE=function(e,t){return t||O(e,2,this.length),this[e]|this[e+1]<<8},u.prototype.readUInt16BE=function(e,t){return t||O(e,2,this.length),this[e]<<8|this[e+1]},u.prototype.readUInt32LE=function(e,t){return t||O(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},u.prototype.readUInt32BE=function(e,t){return t||O(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},u.prototype.readIntLE=function(e,t,n){e|=0,t|=0,n||O(e,t,this.length);for(var r=this[e],i=1,o=0;++o<t&&(i*=256);)r+=this[e+o]*i;return r>=(i*=128)&&(r-=Math.pow(2,8*t)),r},u.prototype.readIntBE=function(e,t,n){e|=0,t|=0,n||O(e,t,this.length);for(var r=t,i=1,o=this[e+--r];r>0&&(i*=256);)o+=this[e+--r]*i;return o>=(i*=128)&&(o-=Math.pow(2,8*t)),o},u.prototype.readInt8=function(e,t){return t||O(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},u.prototype.readInt16LE=function(e,t){t||O(e,2,this.length);var n=this[e]|this[e+1]<<8;return 32768&n?4294901760|n:n},u.prototype.readInt16BE=function(e,t){t||O(e,2,this.length);var n=this[e+1]|this[e]<<8;return 32768&n?4294901760|n:n},u.prototype.readInt32LE=function(e,t){return t||O(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},u.prototype.readInt32BE=function(e,t){return t||O(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},u.prototype.readFloatLE=function(e,t){return t||O(e,4,this.length),i.read(this,e,!0,23,4)},u.prototype.readFloatBE=function(e,t){return t||O(e,4,this.length),i.read(this,e,!1,23,4)},u.prototype.readDoubleLE=function(e,t){return t||O(e,8,this.length),i.read(this,e,!0,52,8)},u.prototype.readDoubleBE=function(e,t){return t||O(e,8,this.length),i.read(this,e,!1,52,8)},u.prototype.writeUIntLE=function(e,t,n,r){(e=+e,t|=0,n|=0,r)||I(this,e,t,n,Math.pow(2,8*n)-1,0);var i=1,o=0;for(this[t]=255&e;++o<n&&(i*=256);)this[t+o]=e/i&255;return t+n},u.prototype.writeUIntBE=function(e,t,n,r){(e=+e,t|=0,n|=0,r)||I(this,e,t,n,Math.pow(2,8*n)-1,0);var i=n-1,o=1;for(this[t+i]=255&e;--i>=0&&(o*=256);)this[t+i]=e/o&255;return t+n},u.prototype.writeUInt8=function(e,t,n){return e=+e,t|=0,n||I(this,e,t,1,255,0),u.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[t]=255&e,t+1},u.prototype.writeUInt16LE=function(e,t,n){return e=+e,t|=0,n||I(this,e,t,2,65535,0),u.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):B(this,e,t,!0),t+2},u.prototype.writeUInt16BE=function(e,t,n){return e=+e,t|=0,n||I(this,e,t,2,65535,0),u.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):B(this,e,t,!1),t+2},u.prototype.writeUInt32LE=function(e,t,n){return e=+e,t|=0,n||I(this,e,t,4,4294967295,0),u.TYPED_ARRAY_SUPPORT?(this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e):L(this,e,t,!0),t+4},u.prototype.writeUInt32BE=function(e,t,n){return e=+e,t|=0,n||I(this,e,t,4,4294967295,0),u.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):L(this,e,t,!1),t+4},u.prototype.writeIntLE=function(e,t,n,r){if(e=+e,t|=0,!r){var i=Math.pow(2,8*n-1);I(this,e,t,n,i-1,-i)}var o=0,s=1,a=0;for(this[t]=255&e;++o<n&&(s*=256);)e<0&&0===a&&0!==this[t+o-1]&&(a=1),this[t+o]=(e/s>>0)-a&255;return t+n},u.prototype.writeIntBE=function(e,t,n,r){if(e=+e,t|=0,!r){var i=Math.pow(2,8*n-1);I(this,e,t,n,i-1,-i)}var o=n-1,s=1,a=0;for(this[t+o]=255&e;--o>=0&&(s*=256);)e<0&&0===a&&0!==this[t+o+1]&&(a=1),this[t+o]=(e/s>>0)-a&255;return t+n},u.prototype.writeInt8=function(e,t,n){return e=+e,t|=0,n||I(this,e,t,1,127,-128),u.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),e<0&&(e=255+e+1),this[t]=255&e,t+1},u.prototype.writeInt16LE=function(e,t,n){return e=+e,t|=0,n||I(this,e,t,2,32767,-32768),u.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):B(this,e,t,!0),t+2},u.prototype.writeInt16BE=function(e,t,n){return e=+e,t|=0,n||I(this,e,t,2,32767,-32768),u.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):B(this,e,t,!1),t+2},u.prototype.writeInt32LE=function(e,t,n){return e=+e,t|=0,n||I(this,e,t,4,2147483647,-2147483648),u.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24):L(this,e,t,!0),t+4},u.prototype.writeInt32BE=function(e,t,n){return e=+e,t|=0,n||I(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),u.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):L(this,e,t,!1),t+4},u.prototype.writeFloatLE=function(e,t,n){return N(this,e,t,!0,n)},u.prototype.writeFloatBE=function(e,t,n){return N(this,e,t,!1,n)},u.prototype.writeDoubleLE=function(e,t,n){return z(this,e,t,!0,n)},u.prototype.writeDoubleBE=function(e,t,n){return z(this,e,t,!1,n)},u.prototype.copy=function(e,t,n,r){if(n||(n=0),r||0===r||(r=this.length),t>=e.length&&(t=e.length),t||(t=0),r>0&&r<n&&(r=n),r===n)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(n<0||n>=this.length)throw new RangeError("sourceStart out of bounds");if(r<0)throw new RangeError("sourceEnd out of bounds");r>this.length&&(r=this.length),e.length-t<r-n&&(r=e.length-t+n);var i,o=r-n;if(this===e&&n<t&&t<r)for(i=o-1;i>=0;--i)e[i+t]=this[i+n];else if(o<1e3||!u.TYPED_ARRAY_SUPPORT)for(i=0;i<o;++i)e[i+t]=this[i+n];else Uint8Array.prototype.set.call(e,this.subarray(n,n+o),t);return o},u.prototype.fill=function(e,t,n,r){if("string"==typeof e){if("string"==typeof t?(r=t,t=0,n=this.length):"string"==typeof n&&(r=n,n=this.length),1===e.length){var i=e.charCodeAt(0);i<256&&(e=i)}if(void 0!==r&&"string"!=typeof r)throw new TypeError("encoding must be a string");if("string"==typeof r&&!u.isEncoding(r))throw new TypeError("Unknown encoding: "+r)}else"number"==typeof e&&(e&=255);if(t<0||this.length<t||this.length<n)throw new RangeError("Out of range index");if(n<=t)return this;var o;if(t>>>=0,n=void 0===n?this.length:n>>>0,e||(e=0),"number"==typeof e)for(o=t;o<n;++o)this[o]=e;else{var s=u.isBuffer(e)?e:F(new u(e,r).toString()),a=s.length;for(o=0;o<n-t;++o)this[o+t]=s[o%a]}return this};var M=/[^+\/0-9A-Za-z-_]/g;function U(e){return e<16?"0"+e.toString(16):e.toString(16)}function F(e,t){var n;t=t||1/0;for(var r=e.length,i=null,o=[],s=0;s<r;++s){if((n=e.charCodeAt(s))>55295&&n<57344){if(!i){if(n>56319){(t-=3)>-1&&o.push(239,191,189);continue}if(s+1===r){(t-=3)>-1&&o.push(239,191,189);continue}i=n;continue}if(n<56320){(t-=3)>-1&&o.push(239,191,189),i=n;continue}n=65536+(i-55296<<10|n-56320)}else i&&(t-=3)>-1&&o.push(239,191,189);if(i=null,n<128){if((t-=1)<0)break;o.push(n)}else if(n<2048){if((t-=2)<0)break;o.push(n>>6|192,63&n|128)}else if(n<65536){if((t-=3)<0)break;o.push(n>>12|224,n>>6&63|128,63&n|128)}else{if(!(n<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;o.push(n>>18|240,n>>12&63|128,n>>6&63|128,63&n|128)}}return o}function j(e){return r.toByteArray(function(e){if((e=function(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}(e).replace(M,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function W(e,t,n,r){for(var i=0;i<r&&!(i+n>=t.length||i>=e.length);++i)t[i+n]=e[i];return i}}).call(this,n(9))},function(e,t){var n=e.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=n)},function(e,t,n){"use strict";(function(t){e.exports={isNode:void 0!==t,newBufferFrom:function(e,n){return new t(e,n)},allocBuffer:function(e){return t.alloc?t.alloc(e):new t(e)},isBuffer:function(e){return t.isBuffer(e)},isStream:function(e){return e&&"function"==typeof e.on&&"function"==typeof e.pause&&"function"==typeof e.resume}}}).call(this,n(14).Buffer)},function(e,t,n){var r=n(14),i=r.Buffer;function o(e,t){for(var n in e)t[n]=e[n]}function s(e,t,n){return i(e,t,n)}i.from&&i.alloc&&i.allocUnsafe&&i.allocUnsafeSlow?e.exports=r:(o(r,t),t.Buffer=s),o(i,s),s.from=function(e,t,n){if("number"==typeof e)throw new TypeError("Argument must not be a number");return i(e,t,n)},s.alloc=function(e,t,n){if("number"!=typeof e)throw new TypeError("Argument must be a number");var r=i(e);return void 0!==t?"string"==typeof n?r.fill(t,n):r.fill(t):r.fill(0),r},s.allocUnsafe=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return i(e)},s.allocUnsafeSlow=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return r.SlowBuffer(e)}},function(e,t,n){"use strict";(function(t){!t.version||0===t.version.indexOf("v0.")||0===t.version.indexOf("v1.")&&0!==t.version.indexOf("v1.8.")?e.exports={nextTick:function(e,n,r,i){if("function"!=typeof e)throw new TypeError('"callback" argument must be a function');var o,s,a=arguments.length;switch(a){case 0:case 1:return t.nextTick(e);case 2:return t.nextTick(function(){e.call(null,n)});case 3:return t.nextTick(function(){e.call(null,n,r)});case 4:return t.nextTick(function(){e.call(null,n,r,i)});default:for(o=new Array(a-1),s=0;s<o.length;)o[s++]=arguments[s];return t.nextTick(function(){e.apply(null,o)})}}}:e.exports=t}).call(this,n(19))},function(e,t){var n,r,i=e.exports={};function o(){throw new Error("setTimeout has not been defined")}function s(){throw new Error("clearTimeout has not been defined")}function a(e){if(n===setTimeout)return setTimeout(e,0);if((n===o||!n)&&setTimeout)return n=setTimeout,setTimeout(e,0);try{return n(e,0)}catch(t){try{return n.call(null,e,0)}catch(t){return n.call(this,e,0)}}}!function(){try{n="function"==typeof setTimeout?setTimeout:o}catch(e){n=o}try{r="function"==typeof clearTimeout?clearTimeout:s}catch(e){r=s}}();var u,l=[],c=!1,h=-1;function f(){c&&u&&(c=!1,u.length?l=u.concat(l):h=-1,l.length&&d())}function d(){if(!c){var e=a(f);c=!0;for(var t=l.length;t;){for(u=l,l=[];++h<t;)u&&u[h].run();h=-1,t=l.length}u=null,c=!1,function(e){if(r===clearTimeout)return clearTimeout(e);if((r===s||!r)&&clearTimeout)return r=clearTimeout,clearTimeout(e);try{r(e)}catch(t){try{return r.call(null,e)}catch(t){return r.call(this,e)}}}(e)}}function p(e,t){this.fun=e,this.array=t}function g(){}i.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)t[n-1]=arguments[n];l.push(new p(e,t)),1!==l.length||c||a(d)},p.prototype.run=function(){this.fun.apply(null,this.array)},i.title="browser",i.browser=!0,i.env={},i.argv=[],i.version="",i.versions={},i.on=g,i.addListener=g,i.once=g,i.off=g,i.removeListener=g,i.removeAllListeners=g,i.emit=g,i.prependListener=g,i.prependOnceListener=g,i.listeners=function(e){return[]},i.binding=function(e){throw new Error("process.binding is not supported")},i.cwd=function(){return"/"},i.chdir=function(e){throw new Error("process.chdir is not supported")},i.umask=function(){return 0}},function(e,t,n){"use strict";function r(){if(!(this instanceof r))return new r;if(arguments.length)throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");this.files={},this.comment=null,this.root="",this.clone=function(){var e=new r;for(var t in this)"function"!=typeof this[t]&&(e[t]=this[t]);return e}}r.prototype=n(131),r.prototype.loadAsync=n(84),r.support=n(6),r.defaults=n(43),r.version="3.1.5",r.loadAsync=function(e,t){return(new r).loadAsync(e,t)},r.external=n(12),e.exports=r},function(e,t,n){"use strict";e.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},function(e,t,n){"use strict";var r=n(1);var i=function(){for(var e,t=[],n=0;n<256;n++){e=n;for(var r=0;r<8;r++)e=1&e?3988292384^e>>>1:e>>>1;t[n]=e}return t}();e.exports=function(e,t){return void 0!==e&&e.length?"string"!==r.getTypeOf(e)?function(e,t,n,r){var o=i,s=r+n;e^=-1;for(var a=r;a<s;a++)e=e>>>8^o[255&(e^t[a])];return-1^e}(0|t,e,e.length,0):function(e,t,n,r){var o=i,s=r+n;e^=-1;for(var a=r;a<s;a++)e=e>>>8^o[255&(e^t.charCodeAt(a))];return-1^e}(0|t,e,e.length,0):0}},function(e,t,n){"use strict";var r=n(12),i=n(42),o=n(41),s=n(40);o=n(41);function a(e,t,n,r,i){this.compressedSize=e,this.uncompressedSize=t,this.crc32=n,this.compression=r,this.compressedContent=i}a.prototype={getContentWorker:function(){var e=new i(r.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new o("data_length")),t=this;return e.on("end",function(){if(this.streamInfo.data_length!==t.uncompressedSize)throw new Error("Bug : uncompressed data size mismatch")}),e},getCompressedWorker:function(){return new i(r.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize",this.compressedSize).withStreamInfo("uncompressedSize",this.uncompressedSize).withStreamInfo("crc32",this.crc32).withStreamInfo("compression",this.compression)}},a.createWorkerFrom=function(e,t,n){return e.pipe(new s).pipe(new o("uncompressedSize")).pipe(t.compressWorker(n)).pipe(new o("compressedSize")).withStreamInfo("compression",t)},e.exports=a},function(e,t,n){e.exports=!n(46)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(e,t){e.exports=function(e){return"object"==typeof e?null!==e:"function"==typeof e}},function(e,t,n){"use strict";(function(t,r,i){var o=n(18);function s(e){var t=this;this.next=null,this.entry=null,this.finish=function(){!function(e,t,n){var r=e.entry;e.entry=null;for(;r;){var i=r.callback;t.pendingcb--,i(n),r=r.next}t.corkedRequestsFree?t.corkedRequestsFree.next=e:t.corkedRequestsFree=e}(t,e)}}e.exports=v;var a,u=!t.browser&&["v0.10","v0.9."].indexOf(t.version.slice(0,5))>-1?r:o.nextTick;v.WritableState=y;var l=n(13);l.inherits=n(10);var c={deprecate:n(122)},h=n(53),f=n(17).Buffer,d=i.Uint8Array||function(){};var p,g=n(52);function m(){}function y(e,t){a=a||n(8),e=e||{};var r=t instanceof a;this.objectMode=!!e.objectMode,r&&(this.objectMode=this.objectMode||!!e.writableObjectMode);var i=e.highWaterMark,l=e.writableHighWaterMark,c=this.objectMode?16:16384;this.highWaterMark=i||0===i?i:r&&(l||0===l)?l:c,this.highWaterMark=Math.floor(this.highWaterMark),this.finalCalled=!1,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1,this.destroyed=!1;var h=!1===e.decodeStrings;this.decodeStrings=!h,this.defaultEncoding=e.defaultEncoding||"utf8",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(e){!function(e,t){var n=e._writableState,r=n.sync,i=n.writecb;if(function(e){e.writing=!1,e.writecb=null,e.length-=e.writelen,e.writelen=0}(n),t)!function(e,t,n,r,i){--t.pendingcb,n?(o.nextTick(i,r),o.nextTick(E,e,t),e._writableState.errorEmitted=!0,e.emit("error",r)):(i(r),e._writableState.errorEmitted=!0,e.emit("error",r),E(e,t))}(e,n,r,t,i);else{var s=k(n);s||n.corked||n.bufferProcessing||!n.bufferedRequest||_(e,n),r?u(w,e,n,s,i):w(e,n,s,i)}}(t,e)},this.writecb=null,this.writelen=0,this.bufferedRequest=null,this.lastBufferedRequest=null,this.pendingcb=0,this.prefinished=!1,this.errorEmitted=!1,this.bufferedRequestCount=0,this.corkedRequestsFree=new s(this)}function v(e){if(a=a||n(8),!(p.call(v,this)||this instanceof a))return new v(e);this._writableState=new y(e,this),this.writable=!0,e&&("function"==typeof e.write&&(this._write=e.write),"function"==typeof e.writev&&(this._writev=e.writev),"function"==typeof e.destroy&&(this._destroy=e.destroy),"function"==typeof e.final&&(this._final=e.final)),h.call(this)}function b(e,t,n,r,i,o,s){t.writelen=r,t.writecb=s,t.writing=!0,t.sync=!0,n?e._writev(i,t.onwrite):e._write(i,o,t.onwrite),t.sync=!1}function w(e,t,n,r){n||function(e,t){0===t.length&&t.needDrain&&(t.needDrain=!1,e.emit("drain"))}(e,t),t.pendingcb--,r(),E(e,t)}function _(e,t){t.bufferProcessing=!0;var n=t.bufferedRequest;if(e._writev&&n&&n.next){var r=t.bufferedRequestCount,i=new Array(r),o=t.corkedRequestsFree;o.entry=n;for(var a=0,u=!0;n;)i[a]=n,n.isBuf||(u=!1),n=n.next,a+=1;i.allBuffers=u,b(e,t,!0,t.length,i,"",o.finish),t.pendingcb++,t.lastBufferedRequest=null,o.next?(t.corkedRequestsFree=o.next,o.next=null):t.corkedRequestsFree=new s(t),t.bufferedRequestCount=0}else{for(;n;){var l=n.chunk,c=n.encoding,h=n.callback;if(b(e,t,!1,t.objectMode?1:l.length,l,c,h),n=n.next,t.bufferedRequestCount--,t.writing)break}null===n&&(t.lastBufferedRequest=null)}t.bufferedRequest=n,t.bufferProcessing=!1}function k(e){return e.ending&&0===e.length&&null===e.bufferedRequest&&!e.finished&&!e.writing}function x(e,t){e._final(function(n){t.pendingcb--,n&&e.emit("error",n),t.prefinished=!0,e.emit("prefinish"),E(e,t)})}function E(e,t){var n=k(t);return n&&(!function(e,t){t.prefinished||t.finalCalled||("function"==typeof e._final?(t.pendingcb++,t.finalCalled=!0,o.nextTick(x,e,t)):(t.prefinished=!0,e.emit("prefinish")))}(e,t),0===t.pendingcb&&(t.finished=!0,e.emit("finish"))),n}l.inherits(v,h),y.prototype.getBuffer=function(){for(var e=this.bufferedRequest,t=[];e;)t.push(e),e=e.next;return t},function(){try{Object.defineProperty(y.prototype,"buffer",{get:c.deprecate(function(){return this.getBuffer()},"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.","DEP0003")})}catch(e){}}(),"function"==typeof Symbol&&Symbol.hasInstance&&"function"==typeof Function.prototype[Symbol.hasInstance]?(p=Function.prototype[Symbol.hasInstance],Object.defineProperty(v,Symbol.hasInstance,{value:function(e){return!!p.call(this,e)||this===v&&(e&&e._writableState instanceof y)}})):p=function(e){return e instanceof this},v.prototype.pipe=function(){this.emit("error",new Error("Cannot pipe, not readable"))},v.prototype.write=function(e,t,n){var r,i=this._writableState,s=!1,a=!i.objectMode&&(r=e,f.isBuffer(r)||r instanceof d);return a&&!f.isBuffer(e)&&(e=function(e){return f.from(e)}(e)),"function"==typeof t&&(n=t,t=null),a?t="buffer":t||(t=i.defaultEncoding),"function"!=typeof n&&(n=m),i.ended?function(e,t){var n=new Error("write after end");e.emit("error",n),o.nextTick(t,n)}(this,n):(a||function(e,t,n,r){var i=!0,s=!1;return null===n?s=new TypeError("May not write null values to stream"):"string"==typeof n||void 0===n||t.objectMode||(s=new TypeError("Invalid non-string/buffer chunk")),s&&(e.emit("error",s),o.nextTick(r,s),i=!1),i}(this,i,e,n))&&(i.pendingcb++,s=function(e,t,n,r,i,o){if(!n){var s=function(e,t,n){e.objectMode||!1===e.decodeStrings||"string"!=typeof t||(t=f.from(t,n));return t}(t,r,i);r!==s&&(n=!0,i="buffer",r=s)}var a=t.objectMode?1:r.length;t.length+=a;var u=t.length<t.highWaterMark;u||(t.needDrain=!0);if(t.writing||t.corked){var l=t.lastBufferedRequest;t.lastBufferedRequest={chunk:r,encoding:i,isBuf:n,callback:o,next:null},l?l.next=t.lastBufferedRequest:t.bufferedRequest=t.lastBufferedRequest,t.bufferedRequestCount+=1}else b(e,t,!1,a,r,i,o);return u}(this,i,a,e,t,n)),s},v.prototype.cork=function(){this._writableState.corked++},v.prototype.uncork=function(){var e=this._writableState;e.corked&&(e.corked--,e.writing||e.corked||e.finished||e.bufferProcessing||!e.bufferedRequest||_(this,e))},v.prototype.setDefaultEncoding=function(e){if("string"==typeof e&&(e=e.toLowerCase()),!(["hex","utf8","utf-8","ascii","binary","base64","ucs2","ucs-2","utf16le","utf-16le","raw"].indexOf((e+"").toLowerCase())>-1))throw new TypeError("Unknown encoding: "+e);return this._writableState.defaultEncoding=e,this},Object.defineProperty(v.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),v.prototype._write=function(e,t,n){n(new Error("_write() is not implemented"))},v.prototype._writev=null,v.prototype.end=function(e,t,n){var r=this._writableState;"function"==typeof e?(n=e,e=null,t=null):"function"==typeof t&&(n=t,t=null),null!==e&&void 0!==e&&this.write(e,t),r.corked&&(r.corked=1,this.uncork()),r.ending||r.finished||function(e,t,n){t.ending=!0,E(e,t),n&&(t.finished?o.nextTick(n):e.once("finish",n));t.ended=!0,e.writable=!1}(this,r,n)},Object.defineProperty(v.prototype,"destroyed",{get:function(){return void 0!==this._writableState&&this._writableState.destroyed},set:function(e){this._writableState&&(this._writableState.destroyed=e)}}),v.prototype.destroy=g.destroy,v.prototype._undestroy=g.undestroy,v.prototype._destroy=function(e,t){this.end(),t(e)}}).call(this,n(19),n(124).setImmediate,n(9))},function(e,t,n){(t=e.exports=n(54)).Stream=t,t.Readable=t,t.Writable=n(26),t.Duplex=n(8),t.Transform=n(50),t.PassThrough=n(121)},function(e,t){function n(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}function r(e){return"function"==typeof e}function i(e){return"object"==typeof e&&null!==e}function o(e){return void 0===e}e.exports=n,n.EventEmitter=n,n.prototype._events=void 0,n.prototype._maxListeners=void 0,n.defaultMaxListeners=10,n.prototype.setMaxListeners=function(e){if("number"!=typeof e||e<0||isNaN(e))throw TypeError("n must be a positive number");return this._maxListeners=e,this},n.prototype.emit=function(e){var t,n,s,a,u,l;if(this._events||(this._events={}),"error"===e&&(!this._events.error||i(this._events.error)&&!this._events.error.length)){if((t=arguments[1])instanceof Error)throw t;var c=new Error('Uncaught, unspecified "error" event. ('+t+")");throw c.context=t,c}if(o(n=this._events[e]))return!1;if(r(n))switch(arguments.length){case 1:n.call(this);break;case 2:n.call(this,arguments[1]);break;case 3:n.call(this,arguments[1],arguments[2]);break;default:a=Array.prototype.slice.call(arguments,1),n.apply(this,a)}else if(i(n))for(a=Array.prototype.slice.call(arguments,1),s=(l=n.slice()).length,u=0;u<s;u++)l[u].apply(this,a);return!0},n.prototype.addListener=function(e,t){var s;if(!r(t))throw TypeError("listener must be a function");return this._events||(this._events={}),this._events.newListener&&this.emit("newListener",e,r(t.listener)?t.listener:t),this._events[e]?i(this._events[e])?this._events[e].push(t):this._events[e]=[this._events[e],t]:this._events[e]=t,i(this._events[e])&&!this._events[e].warned&&(s=o(this._maxListeners)?n.defaultMaxListeners:this._maxListeners)&&s>0&&this._events[e].length>s&&(this._events[e].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[e].length),"function"==typeof console.trace&&console.trace()),this},n.prototype.on=n.prototype.addListener,n.prototype.once=function(e,t){if(!r(t))throw TypeError("listener must be a function");var n=!1;function i(){this.removeListener(e,i),n||(n=!0,t.apply(this,arguments))}return i.listener=t,this.on(e,i),this},n.prototype.removeListener=function(e,t){var n,o,s,a;if(!r(t))throw TypeError("listener must be a function");if(!this._events||!this._events[e])return this;if(s=(n=this._events[e]).length,o=-1,n===t||r(n.listener)&&n.listener===t)delete this._events[e],this._events.removeListener&&this.emit("removeListener",e,t);else if(i(n)){for(a=s;a-- >0;)if(n[a]===t||n[a].listener&&n[a].listener===t){o=a;break}if(o<0)return this;1===n.length?(n.length=0,delete this._events[e]):n.splice(o,1),this._events.removeListener&&this.emit("removeListener",e,t)}return this},n.prototype.removeAllListeners=function(e){var t,n;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[e]&&delete this._events[e],this;if(0===arguments.length){for(t in this._events)"removeListener"!==t&&this.removeAllListeners(t);return this.removeAllListeners("removeListener"),this._events={},this}if(r(n=this._events[e]))this.removeListener(e,n);else if(n)for(;n.length;)this.removeListener(e,n[n.length-1]);return delete this._events[e],this},n.prototype.listeners=function(e){return this._events&&this._events[e]?r(this._events[e])?[this._events[e]]:this._events[e].slice():[]},n.prototype.listenerCount=function(e){if(this._events){var t=this._events[e];if(r(t))return 1;if(t)return t.length}return 0},n.listenerCount=function(e,t){return e.listenerCount(t)}},function(e,t,n){"use strict";var r=n(31);function i(e){r.call(this,e)}n(1).inherits(i,r),i.prototype.readData=function(e){if(this.checkOffset(e),0===e)return new Uint8Array(0);var t=this.data.subarray(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},e.exports=i},function(e,t,n){"use strict";var r=n(1);function i(e){this.data=e,this.length=e.length,this.index=0,this.zero=0}i.prototype={checkOffset:function(e){this.checkIndex(this.index+e)},checkIndex:function(e){if(this.length<this.zero+e||e<0)throw new Error("End of data reached (data length = "+this.length+", asked index = "+e+"). Corrupted zip ?")},setIndex:function(e){this.checkIndex(e),this.index=e},skip:function(e){this.setIndex(this.index+e)},byteAt:function(e){},readInt:function(e){var t,n=0;for(this.checkOffset(e),t=this.index+e-1;t>=this.index;t--)n=(n<<8)+this.byteAt(t);return this.index+=e,n},readString:function(e){return r.transformTo("string",this.readData(e))},readData:function(e){},lastIndexOfSignature:function(e){},readAndCheckSignature:function(e){},readDate:function(){var e=this.readInt(4);return new Date(Date.UTC(1980+(e>>25&127),(e>>21&15)-1,e>>16&31,e>>11&31,e>>5&63,(31&e)<<1))}},e.exports=i},function(e,t,n){"use strict";var r=n(30);function i(e){r.call(this,e);for(var t=0;t<this.data.length;t++)e[t]=255&e[t]}n(1).inherits(i,r),i.prototype.byteAt=function(e){return this.data[this.zero+e]},i.prototype.lastIndexOfSignature=function(e){for(var t=e.charCodeAt(0),n=e.charCodeAt(1),r=e.charCodeAt(2),i=e.charCodeAt(3),o=this.length-4;o>=0;--o)if(this.data[o]===t&&this.data[o+1]===n&&this.data[o+2]===r&&this.data[o+3]===i)return o-this.zero;return-1},i.prototype.readAndCheckSignature=function(e){var t=e.charCodeAt(0),n=e.charCodeAt(1),r=e.charCodeAt(2),i=e.charCodeAt(3),o=this.readData(4);return t===o[0]&&n===o[1]&&r===o[2]&&i===o[3]},i.prototype.readData=function(e){if(this.checkOffset(e),0===e)return[];var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},e.exports=i},function(e,t,n){"use strict";var r=n(1),i=n(6),o=n(31),s=n(82),a=n(81),u=n(29);e.exports=function(e){var t=r.getTypeOf(e);return r.checkSupport(t),"string"!==t||i.uint8array?"nodebuffer"===t?new a(e):i.uint8array?new u(r.transformTo("uint8array",e)):new o(r.transformTo("array",e)):new s(e)}},function(e,t,n){"use strict";t.LOCAL_FILE_HEADER="PK",t.CENTRAL_FILE_HEADER="PK",t.CENTRAL_DIRECTORY_END="PK",t.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",t.ZIP64_CENTRAL_DIRECTORY_END="PK",t.DATA_DESCRIPTOR="PK\b"},function(e,t,n){"use strict";e.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},function(e,t,n){"use strict";e.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}},function(e,t,n){"use strict";var r=n(5),i=!0,o=!0;try{String.fromCharCode.apply(null,[0])}catch(e){i=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(e){o=!1}for(var s=new r.Buf8(256),a=0;a<256;a++)s[a]=a>=252?6:a>=248?5:a>=240?4:a>=224?3:a>=192?2:1;function u(e,t){if(t<65537&&(e.subarray&&o||!e.subarray&&i))return String.fromCharCode.apply(null,r.shrinkBuf(e,t));for(var n="",s=0;s<t;s++)n+=String.fromCharCode(e[s]);return n}s[254]=s[254]=1,t.string2buf=function(e){var t,n,i,o,s,a=e.length,u=0;for(o=0;o<a;o++)55296==(64512&(n=e.charCodeAt(o)))&&o+1<a&&56320==(64512&(i=e.charCodeAt(o+1)))&&(n=65536+(n-55296<<10)+(i-56320),o++),u+=n<128?1:n<2048?2:n<65536?3:4;for(t=new r.Buf8(u),s=0,o=0;s<u;o++)55296==(64512&(n=e.charCodeAt(o)))&&o+1<a&&56320==(64512&(i=e.charCodeAt(o+1)))&&(n=65536+(n-55296<<10)+(i-56320),o++),n<128?t[s++]=n:n<2048?(t[s++]=192|n>>>6,t[s++]=128|63&n):n<65536?(t[s++]=224|n>>>12,t[s++]=128|n>>>6&63,t[s++]=128|63&n):(t[s++]=240|n>>>18,t[s++]=128|n>>>12&63,t[s++]=128|n>>>6&63,t[s++]=128|63&n);return t},t.buf2binstring=function(e){return u(e,e.length)},t.binstring2buf=function(e){for(var t=new r.Buf8(e.length),n=0,i=t.length;n<i;n++)t[n]=e.charCodeAt(n);return t},t.buf2string=function(e,t){var n,r,i,o,a=t||e.length,l=new Array(2*a);for(r=0,n=0;n<a;)if((i=e[n++])<128)l[r++]=i;else if((o=s[i])>4)l[r++]=65533,n+=o-1;else{for(i&=2===o?31:3===o?15:7;o>1&&n<a;)i=i<<6|63&e[n++],o--;o>1?l[r++]=65533:i<65536?l[r++]=i:(i-=65536,l[r++]=55296|i>>10&1023,l[r++]=56320|1023&i)}return u(l,r)},t.utf8border=function(e,t){var n;for((t=t||e.length)>e.length&&(t=e.length),n=t-1;n>=0&&128==(192&e[n]);)n--;return n<0?t:0===n?t:n+s[e[n]]>t?n:t}},function(e,t,n){"use strict";var r=function(){for(var e,t=[],n=0;n<256;n++){e=n;for(var r=0;r<8;r++)e=1&e?3988292384^e>>>1:e>>>1;t[n]=e}return t}();e.exports=function(e,t,n,i){var o=r,s=i+n;e^=-1;for(var a=i;a<s;a++)e=e>>>8^o[255&(e^t[a])];return-1^e}},function(e,t,n){"use strict";e.exports=function(e,t,n,r){for(var i=65535&e|0,o=e>>>16&65535|0,s=0;0!==n;){n-=s=n>2e3?2e3:n;do{o=o+(i=i+t[r++]|0)|0}while(--s);i%=65521,o%=65521}return i|o<<16|0}},function(e,t,n){"use strict";var r=n(4);t.STORE={magic:"\0\0",compressWorker:function(e){return new r("STORE compression")},uncompressWorker:function(){return new r("STORE decompression")}},t.DEFLATE=n(96)},function(e,t,n){"use strict";var r=n(4),i=n(22);function o(){r.call(this,"Crc32Probe"),this.withStreamInfo("crc32",0)}n(1).inherits(o,r),o.prototype.processChunk=function(e){this.streamInfo.crc32=i(e.data,this.streamInfo.crc32||0),this.push(e)},e.exports=o},function(e,t,n){"use strict";var r=n(1),i=n(4);function o(e){i.call(this,"DataLengthProbe for "+e),this.propName=e,this.withStreamInfo(e,0)}r.inherits(o,i),o.prototype.processChunk=function(e){if(e){var t=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=t+e.data.length}i.prototype.processChunk.call(this,e)},e.exports=o},function(e,t,n){"use strict";var r=n(1),i=n(4);function o(e){i.call(this,"DataWorker");var t=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type="",this._tickScheduled=!1,e.then(function(e){t.dataIsReady=!0,t.data=e,t.max=e&&e.length||0,t.type=r.getTypeOf(e),t.isPaused||t._tickAndRepeat()},function(e){t.error(e)})}r.inherits(o,i),o.prototype.cleanUp=function(){i.prototype.cleanUp.call(this),this.data=null},o.prototype.resume=function(){return!!i.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,r.delay(this._tickAndRepeat,[],this)),!0)},o.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(r.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0))},o.prototype._tick=function(){if(this.isPaused||this.isFinished)return!1;var e=null,t=Math.min(this.max,this.index+16384);if(this.index>=this.max)return this.end();switch(this.type){case"string":e=this.data.substring(this.index,t);break;case"uint8array":e=this.data.subarray(this.index,t);break;case"array":case"nodebuffer":e=this.data.slice(this.index,t)}return this.index=t,this.push({data:e,meta:{percent:this.max?this.index/this.max*100:0}})},e.exports=o},function(e,t,n){"use strict";t.base64=!1,t.binary=!1,t.dir=!1,t.createFolders=!0,t.date=null,t.compression=null,t.compressionOptions=null,t.comment=null,t.unixPermissions=null,t.dosPermissions=null},function(e,t,n){"use strict";(function(t){var r=n(1),i=n(100),o=n(4),s=n(49),a=n(6),u=n(12),l=null;if(a.nodestream)try{l=n(99)}catch(e){}function c(e,n){return new u.Promise(function(i,o){var a=[],u=e._internalType,l=e._outputType,c=e._mimeType;e.on("data",function(e,t){a.push(e),n&&n(t)}).on("error",function(e){a=[],o(e)}).on("end",function(){try{var e=function(e,t,n){switch(e){case"blob":return r.newBlob(r.transformTo("arraybuffer",t),n);case"base64":return s.encode(t);default:return r.transformTo(e,t)}}(l,function(e,n){var r,i=0,o=null,s=0;for(r=0;r<n.length;r++)s+=n[r].length;switch(e){case"string":return n.join("");case"array":return Array.prototype.concat.apply([],n);case"uint8array":for(o=new Uint8Array(s),r=0;r<n.length;r++)o.set(n[r],i),i+=n[r].length;return o;case"nodebuffer":return t.concat(n);default:throw new Error("concat : unsupported type '"+e+"'")}}(u,a),c);i(e)}catch(e){o(e)}a=[]}).resume()})}function h(e,t,n){var s=t;switch(t){case"blob":case"arraybuffer":s="uint8array";break;case"base64":s="string"}try{this._internalType=s,this._outputType=t,this._mimeType=n,r.checkSupport(s),this._worker=e.pipe(new i(s)),e.lock()}catch(e){this._worker=new o("error"),this._worker.error(e)}}h.prototype={accumulate:function(e){return c(this,e)},on:function(e,t){var n=this;return"data"===e?this._worker.on(e,function(e){t.call(n,e.data,e.meta)}):this._worker.on(e,function(){r.delay(t,arguments,n)}),this},resume:function(){return r.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(e){if(r.checkSupport("nodestream"),"nodebuffer"!==this._outputType)throw new Error(this._outputType+" is not supported by this method");return new l(this,{objectMode:"nodebuffer"!==this._outputType},e)}},e.exports=h}).call(this,n(14).Buffer)},function(e,t,n){var r=n(25),i=n(15).document,o=r(i)&&r(i.createElement);e.exports=function(e){return o?i.createElement(e):{}}},function(e,t){e.exports=function(e){try{return!!e()}catch(e){return!0}}},function(e,t,n){var r=n(113);e.exports=function(e,t,n){if(r(e),void 0===t)return e;switch(n){case 1:return function(n){return e.call(t,n)};case 2:return function(n,r){return e.call(t,n,r)};case 3:return function(n,r,i){return e.call(t,n,r,i)}}return function(){return e.apply(t,arguments)}}},function(e,t){var n=e.exports={version:"2.3.0"};"number"==typeof __e&&(__e=n)},function(e,t,n){"use strict";var r=n(1),i=n(6),o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";t.encode=function(e){for(var t,n,i,s,a,u,l,c=[],h=0,f=e.length,d=f,p="string"!==r.getTypeOf(e);h<e.length;)d=f-h,p?(t=e[h++],n=h<f?e[h++]:0,i=h<f?e[h++]:0):(t=e.charCodeAt(h++),n=h<f?e.charCodeAt(h++):0,i=h<f?e.charCodeAt(h++):0),s=t>>2,a=(3&t)<<4|n>>4,u=d>1?(15&n)<<2|i>>6:64,l=d>2?63&i:64,c.push(o.charAt(s)+o.charAt(a)+o.charAt(u)+o.charAt(l));return c.join("")},t.decode=function(e){var t,n,r,s,a,u,l=0,c=0;if("data:"===e.substr(0,"data:".length))throw new Error("Invalid base64 input, it looks like a data url.");var h,f=3*(e=e.replace(/[^A-Za-z0-9\+\/\=]/g,"")).length/4;if(e.charAt(e.length-1)===o.charAt(64)&&f--,e.charAt(e.length-2)===o.charAt(64)&&f--,f%1!=0)throw new Error("Invalid base64 input, bad content length.");for(h=i.uint8array?new Uint8Array(0|f):new Array(0|f);l<e.length;)t=o.indexOf(e.charAt(l++))<<2|(s=o.indexOf(e.charAt(l++)))>>4,n=(15&s)<<4|(a=o.indexOf(e.charAt(l++)))>>2,r=(3&a)<<6|(u=o.indexOf(e.charAt(l++))),h[c++]=t,64!==a&&(h[c++]=n),64!==u&&(h[c++]=r);return h}},function(e,t,n){"use strict";e.exports=o;var r=n(8),i=n(13);function o(e){if(!(this instanceof o))return new o(e);r.call(this,e),this._transformState={afterTransform:function(e,t){var n=this._transformState;n.transforming=!1;var r=n.writecb;if(!r)return this.emit("error",new Error("write callback called multiple times"));n.writechunk=null,n.writecb=null,null!=t&&this.push(t),r(e);var i=this._readableState;i.reading=!1,(i.needReadable||i.length<i.highWaterMark)&&this._read(i.highWaterMark)}.bind(this),needTransform:!1,transforming:!1,writecb:null,writechunk:null,writeencoding:null},this._readableState.needReadable=!0,this._readableState.sync=!1,e&&("function"==typeof e.transform&&(this._transform=e.transform),"function"==typeof e.flush&&(this._flush=e.flush)),this.on("prefinish",s)}function s(){var e=this;"function"==typeof this._flush?this._flush(function(t,n){a(e,t,n)}):a(this,null,null)}function a(e,t,n){if(t)return e.emit("error",t);if(null!=n&&e.push(n),e._writableState.length)throw new Error("Calling transform done when ws.length != 0");if(e._transformState.transforming)throw new Error("Calling transform done when still transforming");return e.push(null)}i.inherits=n(10),i.inherits(o,r),o.prototype.push=function(e,t){return this._transformState.needTransform=!1,r.prototype.push.call(this,e,t)},o.prototype._transform=function(e,t,n){throw new Error("_transform() is not implemented")},o.prototype._write=function(e,t,n){var r=this._transformState;if(r.writecb=n,r.writechunk=e,r.writeencoding=t,!r.transforming){var i=this._readableState;(r.needTransform||i.needReadable||i.length<i.highWaterMark)&&this._read(i.highWaterMark)}},o.prototype._read=function(e){var t=this._transformState;null!==t.writechunk&&t.writecb&&!t.transforming?(t.transforming=!0,this._transform(t.writechunk,t.writeencoding,t.afterTransform)):t.needTransform=!0},o.prototype._destroy=function(e,t){var n=this;r.prototype._destroy.call(this,e,function(e){t(e),n.emit("close")})}},function(e,t,n){"use strict";var r=n(17).Buffer,i=r.isEncoding||function(e){switch((e=""+e)&&e.toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":case"raw":return!0;default:return!1}};function o(e){var t;switch(this.encoding=function(e){var t=function(e){if(!e)return"utf8";for(var t;;)switch(e){case"utf8":case"utf-8":return"utf8";case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return"utf16le";case"latin1":case"binary":return"latin1";case"base64":case"ascii":case"hex":return e;default:if(t)return;e=(""+e).toLowerCase(),t=!0}}(e);if("string"!=typeof t&&(r.isEncoding===i||!i(e)))throw new Error("Unknown encoding: "+e);return t||e}(e),this.encoding){case"utf16le":this.text=u,this.end=l,t=4;break;case"utf8":this.fillLast=a,t=4;break;case"base64":this.text=c,this.end=h,t=3;break;default:return this.write=f,void(this.end=d)}this.lastNeed=0,this.lastTotal=0,this.lastChar=r.allocUnsafe(t)}function s(e){return e<=127?0:e>>5==6?2:e>>4==14?3:e>>3==30?4:e>>6==2?-1:-2}function a(e){var t=this.lastTotal-this.lastNeed,n=function(e,t,n){if(128!=(192&t[0]))return e.lastNeed=0,"";if(e.lastNeed>1&&t.length>1){if(128!=(192&t[1]))return e.lastNeed=1,"";if(e.lastNeed>2&&t.length>2&&128!=(192&t[2]))return e.lastNeed=2,""}}(this,e);return void 0!==n?n:this.lastNeed<=e.length?(e.copy(this.lastChar,t,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal)):(e.copy(this.lastChar,t,0,e.length),void(this.lastNeed-=e.length))}function u(e,t){if((e.length-t)%2==0){var n=e.toString("utf16le",t);if(n){var r=n.charCodeAt(n.length-1);if(r>=55296&&r<=56319)return this.lastNeed=2,this.lastTotal=4,this.lastChar[0]=e[e.length-2],this.lastChar[1]=e[e.length-1],n.slice(0,-1)}return n}return this.lastNeed=1,this.lastTotal=2,this.lastChar[0]=e[e.length-1],e.toString("utf16le",t,e.length-1)}function l(e){var t=e&&e.length?this.write(e):"";if(this.lastNeed){var n=this.lastTotal-this.lastNeed;return t+this.lastChar.toString("utf16le",0,n)}return t}function c(e,t){var n=(e.length-t)%3;return 0===n?e.toString("base64",t):(this.lastNeed=3-n,this.lastTotal=3,1===n?this.lastChar[0]=e[e.length-1]:(this.lastChar[0]=e[e.length-2],this.lastChar[1]=e[e.length-1]),e.toString("base64",t,e.length-n))}function h(e){var t=e&&e.length?this.write(e):"";return this.lastNeed?t+this.lastChar.toString("base64",0,3-this.lastNeed):t}function f(e){return e.toString(this.encoding)}function d(e){return e&&e.length?this.write(e):""}t.StringDecoder=o,o.prototype.write=function(e){if(0===e.length)return"";var t,n;if(this.lastNeed){if(void 0===(t=this.fillLast(e)))return"";n=this.lastNeed,this.lastNeed=0}else n=0;return n<e.length?t?t+this.text(e,n):this.text(e,n):t||""},o.prototype.end=function(e){var t=e&&e.length?this.write(e):"";return this.lastNeed?t+"":t},o.prototype.text=function(e,t){var n=function(e,t,n){var r=t.length-1;if(r<n)return 0;var i=s(t[r]);if(i>=0)return i>0&&(e.lastNeed=i-1),i;if(--r<n||-2===i)return 0;if((i=s(t[r]))>=0)return i>0&&(e.lastNeed=i-2),i;if(--r<n||-2===i)return 0;if((i=s(t[r]))>=0)return i>0&&(2===i?i=0:e.lastNeed=i-3),i;return 0}(this,e,t);if(!this.lastNeed)return e.toString("utf8",t);this.lastTotal=n;var r=e.length-(n-this.lastNeed);return e.copy(this.lastChar,0,r),e.toString("utf8",t,r)},o.prototype.fillLast=function(e){if(this.lastNeed<=e.length)return e.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal);e.copy(this.lastChar,this.lastTotal-this.lastNeed,0,e.length),this.lastNeed-=e.length}},function(e,t,n){"use strict";var r=n(18);function i(e,t){e.emit("error",t)}e.exports={destroy:function(e,t){var n=this,o=this._readableState&&this._readableState.destroyed,s=this._writableState&&this._writableState.destroyed;return o||s?(t?t(e):!e||this._writableState&&this._writableState.errorEmitted||r.nextTick(i,this,e),this):(this._readableState&&(this._readableState.destroyed=!0),this._writableState&&(this._writableState.destroyed=!0),this._destroy(e||null,function(e){!t&&e?(r.nextTick(i,n,e),n._writableState&&(n._writableState.errorEmitted=!0)):t&&t(e)}),this)},undestroy:function(){this._readableState&&(this._readableState.destroyed=!1,this._readableState.reading=!1,this._readableState.ended=!1,this._readableState.endEmitted=!1),this._writableState&&(this._writableState.destroyed=!1,this._writableState.ended=!1,this._writableState.ending=!1,this._writableState.finished=!1,this._writableState.errorEmitted=!1)}}},function(e,t,n){e.exports=n(28).EventEmitter},function(e,t,n){"use strict";(function(t,r){var i=n(18);e.exports=b;var o,s=n(56);b.ReadableState=v;n(28).EventEmitter;var a=function(e,t){return e.listeners(t).length},u=n(53),l=n(17).Buffer,c=t.Uint8Array||function(){};var h=n(13);h.inherits=n(10);var f=n(127),d=void 0;d=f&&f.debuglog?f.debuglog("stream"):function(){};var p,g=n(126),m=n(52);h.inherits(b,u);var y=["error","close","destroy","pause","resume"];function v(e,t){o=o||n(8),e=e||{};var r=t instanceof o;this.objectMode=!!e.objectMode,r&&(this.objectMode=this.objectMode||!!e.readableObjectMode);var i=e.highWaterMark,s=e.readableHighWaterMark,a=this.objectMode?16:16384;this.highWaterMark=i||0===i?i:r&&(s||0===s)?s:a,this.highWaterMark=Math.floor(this.highWaterMark),this.buffer=new g,this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this.destroyed=!1,this.defaultEncoding=e.defaultEncoding||"utf8",this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,e.encoding&&(p||(p=n(51).StringDecoder),this.decoder=new p(e.encoding),this.encoding=e.encoding)}function b(e){if(o=o||n(8),!(this instanceof b))return new b(e);this._readableState=new v(e,this),this.readable=!0,e&&("function"==typeof e.read&&(this._read=e.read),"function"==typeof e.destroy&&(this._destroy=e.destroy)),u.call(this)}function w(e,t,n,r,i){var o,s=e._readableState;null===t?(s.reading=!1,function(e,t){if(t.ended)return;if(t.decoder){var n=t.decoder.end();n&&n.length&&(t.buffer.push(n),t.length+=t.objectMode?1:n.length)}t.ended=!0,E(e)}(e,s)):(i||(o=function(e,t){var n;r=t,l.isBuffer(r)||r instanceof c||"string"==typeof t||void 0===t||e.objectMode||(n=new TypeError("Invalid non-string/buffer chunk"));var r;return n}(s,t)),o?e.emit("error",o):s.objectMode||t&&t.length>0?("string"==typeof t||s.objectMode||Object.getPrototypeOf(t)===l.prototype||(t=function(e){return l.from(e)}(t)),r?s.endEmitted?e.emit("error",new Error("stream.unshift() after end event")):_(e,s,t,!0):s.ended?e.emit("error",new Error("stream.push() after EOF")):(s.reading=!1,s.decoder&&!n?(t=s.decoder.write(t),s.objectMode||0!==t.length?_(e,s,t,!1):C(e,s)):_(e,s,t,!1))):r||(s.reading=!1));return function(e){return!e.ended&&(e.needReadable||e.length<e.highWaterMark||0===e.length)}(s)}function _(e,t,n,r){t.flowing&&0===t.length&&!t.sync?(e.emit("data",n),e.read(0)):(t.length+=t.objectMode?1:n.length,r?t.buffer.unshift(n):t.buffer.push(n),t.needReadable&&E(e)),C(e,t)}Object.defineProperty(b.prototype,"destroyed",{get:function(){return void 0!==this._readableState&&this._readableState.destroyed},set:function(e){this._readableState&&(this._readableState.destroyed=e)}}),b.prototype.destroy=m.destroy,b.prototype._undestroy=m.undestroy,b.prototype._destroy=function(e,t){this.push(null),t(e)},b.prototype.push=function(e,t){var n,r=this._readableState;return r.objectMode?n=!0:"string"==typeof e&&((t=t||r.defaultEncoding)!==r.encoding&&(e=l.from(e,t),t=""),n=!0),w(this,e,t,!1,n)},b.prototype.unshift=function(e){return w(this,e,null,!0,!1)},b.prototype.isPaused=function(){return!1===this._readableState.flowing},b.prototype.setEncoding=function(e){return p||(p=n(51).StringDecoder),this._readableState.decoder=new p(e),this._readableState.encoding=e,this};var k=8388608;function x(e,t){return e<=0||0===t.length&&t.ended?0:t.objectMode?1:e!=e?t.flowing&&t.length?t.buffer.head.data.length:t.length:(e>t.highWaterMark&&(t.highWaterMark=function(e){return e>=k?e=k:(e--,e|=e>>>1,e|=e>>>2,e|=e>>>4,e|=e>>>8,e|=e>>>16,e++),e}(e)),e<=t.length?e:t.ended?t.length:(t.needReadable=!0,0))}function E(e){var t=e._readableState;t.needReadable=!1,t.emittedReadable||(d("emitReadable",t.flowing),t.emittedReadable=!0,t.sync?i.nextTick(S,e):S(e))}function S(e){d("emit readable"),e.emit("readable"),T(e)}function C(e,t){t.readingMore||(t.readingMore=!0,i.nextTick(P,e,t))}function P(e,t){for(var n=t.length;!t.reading&&!t.flowing&&!t.ended&&t.length<t.highWaterMark&&(d("maybeReadMore read 0"),e.read(0),n!==t.length);)n=t.length;t.readingMore=!1}function R(e){d("readable nexttick read 0"),e.read(0)}function A(e,t){t.reading||(d("resume read 0"),e.read(0)),t.resumeScheduled=!1,t.awaitDrain=0,e.emit("resume"),T(e),t.flowing&&!t.reading&&e.read(0)}function T(e){var t=e._readableState;for(d("flow",t.flowing);t.flowing&&null!==e.read(););}function O(e,t){return 0===t.length?null:(t.objectMode?n=t.buffer.shift():!e||e>=t.length?(n=t.decoder?t.buffer.join(""):1===t.buffer.length?t.buffer.head.data:t.buffer.concat(t.length),t.buffer.clear()):n=function(e,t,n){var r;e<t.head.data.length?(r=t.head.data.slice(0,e),t.head.data=t.head.data.slice(e)):r=e===t.head.data.length?t.shift():n?function(e,t){var n=t.head,r=1,i=n.data;e-=i.length;for(;n=n.next;){var o=n.data,s=e>o.length?o.length:e;if(s===o.length?i+=o:i+=o.slice(0,e),0===(e-=s)){s===o.length?(++r,n.next?t.head=n.next:t.head=t.tail=null):(t.head=n,n.data=o.slice(s));break}++r}return t.length-=r,i}(e,t):function(e,t){var n=l.allocUnsafe(e),r=t.head,i=1;r.data.copy(n),e-=r.data.length;for(;r=r.next;){var o=r.data,s=e>o.length?o.length:e;if(o.copy(n,n.length-e,0,s),0===(e-=s)){s===o.length?(++i,r.next?t.head=r.next:t.head=t.tail=null):(t.head=r,r.data=o.slice(s));break}++i}return t.length-=i,n}(e,t);return r}(e,t.buffer,t.decoder),n);var n}function I(e){var t=e._readableState;if(t.length>0)throw new Error('"endReadable()" called on non-empty stream');t.endEmitted||(t.ended=!0,i.nextTick(B,t,e))}function B(e,t){e.endEmitted||0!==e.length||(e.endEmitted=!0,t.readable=!1,t.emit("end"))}function L(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1}b.prototype.read=function(e){d("read",e),e=parseInt(e,10);var t=this._readableState,n=e;if(0!==e&&(t.emittedReadable=!1),0===e&&t.needReadable&&(t.length>=t.highWaterMark||t.ended))return d("read: emitReadable",t.length,t.ended),0===t.length&&t.ended?I(this):E(this),null;if(0===(e=x(e,t))&&t.ended)return 0===t.length&&I(this),null;var r,i=t.needReadable;return d("need readable",i),(0===t.length||t.length-e<t.highWaterMark)&&d("length less than watermark",i=!0),t.ended||t.reading?d("reading or ended",i=!1):i&&(d("do read"),t.reading=!0,t.sync=!0,0===t.length&&(t.needReadable=!0),this._read(t.highWaterMark),t.sync=!1,t.reading||(e=x(n,t))),null===(r=e>0?O(e,t):null)?(t.needReadable=!0,e=0):t.length-=e,0===t.length&&(t.ended||(t.needReadable=!0),n!==e&&t.ended&&I(this)),null!==r&&this.emit("data",r),r},b.prototype._read=function(e){this.emit("error",new Error("_read() is not implemented"))},b.prototype.pipe=function(e,t){var n=this,o=this._readableState;switch(o.pipesCount){case 0:o.pipes=e;break;case 1:o.pipes=[o.pipes,e];break;default:o.pipes.push(e)}o.pipesCount+=1,d("pipe count=%d opts=%j",o.pipesCount,t);var u=(!t||!1!==t.end)&&e!==r.stdout&&e!==r.stderr?c:b;function l(t,r){d("onunpipe"),t===n&&r&&!1===r.hasUnpiped&&(r.hasUnpiped=!0,d("cleanup"),e.removeListener("close",y),e.removeListener("finish",v),e.removeListener("drain",h),e.removeListener("error",m),e.removeListener("unpipe",l),n.removeListener("end",c),n.removeListener("end",b),n.removeListener("data",g),f=!0,!o.awaitDrain||e._writableState&&!e._writableState.needDrain||h())}function c(){d("onend"),e.end()}o.endEmitted?i.nextTick(u):n.once("end",u),e.on("unpipe",l);var h=function(e){return function(){var t=e._readableState;d("pipeOnDrain",t.awaitDrain),t.awaitDrain&&t.awaitDrain--,0===t.awaitDrain&&a(e,"data")&&(t.flowing=!0,T(e))}}(n);e.on("drain",h);var f=!1;var p=!1;function g(t){d("ondata"),p=!1,!1!==e.write(t)||p||((1===o.pipesCount&&o.pipes===e||o.pipesCount>1&&-1!==L(o.pipes,e))&&!f&&(d("false write response, pause",n._readableState.awaitDrain),n._readableState.awaitDrain++,p=!0),n.pause())}function m(t){d("onerror",t),b(),e.removeListener("error",m),0===a(e,"error")&&e.emit("error",t)}function y(){e.removeListener("finish",v),b()}function v(){d("onfinish"),e.removeListener("close",y),b()}function b(){d("unpipe"),n.unpipe(e)}return n.on("data",g),function(e,t,n){if("function"==typeof e.prependListener)return e.prependListener(t,n);e._events&&e._events[t]?s(e._events[t])?e._events[t].unshift(n):e._events[t]=[n,e._events[t]]:e.on(t,n)}(e,"error",m),e.once("close",y),e.once("finish",v),e.emit("pipe",n),o.flowing||(d("pipe resume"),n.resume()),e},b.prototype.unpipe=function(e){var t=this._readableState,n={hasUnpiped:!1};if(0===t.pipesCount)return this;if(1===t.pipesCount)return e&&e!==t.pipes?this:(e||(e=t.pipes),t.pipes=null,t.pipesCount=0,t.flowing=!1,e&&e.emit("unpipe",this,n),this);if(!e){var r=t.pipes,i=t.pipesCount;t.pipes=null,t.pipesCount=0,t.flowing=!1;for(var o=0;o<i;o++)r[o].emit("unpipe",this,n);return this}var s=L(t.pipes,e);return-1===s?this:(t.pipes.splice(s,1),t.pipesCount-=1,1===t.pipesCount&&(t.pipes=t.pipes[0]),e.emit("unpipe",this,n),this)},b.prototype.on=function(e,t){var n=u.prototype.on.call(this,e,t);if("data"===e)!1!==this._readableState.flowing&&this.resume();else if("readable"===e){var r=this._readableState;r.endEmitted||r.readableListening||(r.readableListening=r.needReadable=!0,r.emittedReadable=!1,r.reading?r.length&&E(this):i.nextTick(R,this))}return n},b.prototype.addListener=b.prototype.on,b.prototype.resume=function(){var e=this._readableState;return e.flowing||(d("resume"),e.flowing=!0,function(e,t){t.resumeScheduled||(t.resumeScheduled=!0,i.nextTick(A,e,t))}(this,e)),this},b.prototype.pause=function(){return d("call pause flowing=%j",this._readableState.flowing),!1!==this._readableState.flowing&&(d("pause"),this._readableState.flowing=!1,this.emit("pause")),this},b.prototype.wrap=function(e){var t=this,n=this._readableState,r=!1;for(var i in e.on("end",function(){if(d("wrapped end"),n.decoder&&!n.ended){var e=n.decoder.end();e&&e.length&&t.push(e)}t.push(null)}),e.on("data",function(i){(d("wrapped data"),n.decoder&&(i=n.decoder.write(i)),!n.objectMode||null!==i&&void 0!==i)&&((n.objectMode||i&&i.length)&&(t.push(i)||(r=!0,e.pause())))}),e)void 0===this[i]&&"function"==typeof e[i]&&(this[i]=function(t){return function(){return e[t].apply(e,arguments)}}(i));for(var o=0;o<y.length;o++)e.on(y[o],this.emit.bind(this,y[o]));return this._read=function(t){d("wrapped _read",t),r&&(r=!1,e.resume())},this},Object.defineProperty(b.prototype,"readableHighWaterMark",{enumerable:!1,get:function(){return this._readableState.highWaterMark}}),b._fromList=O}).call(this,n(9),n(19))},function(e,t,n){e.exports=n(128)},function(e,t){var n={}.toString;e.exports=Array.isArray||function(e){return"[object Array]"==n.call(e)}},function(e,t,n){var r,i=i||function(e){"use strict";if(!(void 0===e||"undefined"!=typeof navigator&&/MSIE [1-9]\./.test(navigator.userAgent))){var t=function(){return e.URL||e.webkitURL||e},n=e.document.createElementNS("http://www.w3.org/1999/xhtml","a"),r="download"in n,i=/constructor/i.test(e.HTMLElement)||e.safari,o=/CriOS\/[\d]+/.test(navigator.userAgent),s=function(t){(e.setImmediate||e.setTimeout)(function(){throw t},0)},a=function(e){setTimeout(function(){"string"==typeof e?t().revokeObjectURL(e):e.remove()},4e4)},u=function(e){return/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type)?new Blob([String.fromCharCode(65279),e],{type:e.type}):e},l=function(l,c,h){h||(l=u(l));var f,d=this,p="application/octet-stream"===l.type,g=function(){!function(e,t,n){for(var r=(t=[].concat(t)).length;r--;){var i=e["on"+t[r]];if("function"==typeof i)try{i.call(e,n||e)}catch(e){s(e)}}}(d,"writestart progress write writeend".split(" "))};if(d.readyState=d.INIT,r)return f=t().createObjectURL(l),void setTimeout(function(){var e,t;n.href=f,n.download=c,e=n,t=new MouseEvent("click"),e.dispatchEvent(t),g(),a(f),d.readyState=d.DONE});!function(){if((o||p&&i)&&e.FileReader){var n=new FileReader;return n.onloadend=function(){var t=o?n.result:n.result.replace(/^data:[^;]*;/,"data:attachment/file;");e.open(t,"_blank")||(e.location.href=t),t=void 0,d.readyState=d.DONE,g()},n.readAsDataURL(l),void(d.readyState=d.INIT)}f||(f=t().createObjectURL(l)),p?e.location.href=f:e.open(f,"_blank")||(e.location.href=f);d.readyState=d.DONE,g(),a(f)}()},c=l.prototype;return"undefined"!=typeof navigator&&navigator.msSaveOrOpenBlob?function(e,t,n){return t=t||e.name||"download",n||(e=u(e)),navigator.msSaveOrOpenBlob(e,t)}:(c.abort=function(){},c.readyState=c.INIT=0,c.WRITING=1,c.DONE=2,c.error=c.onwritestart=c.onprogress=c.onwrite=c.onabort=c.onerror=c.onwriteend=null,function(e,t,n){return new l(e,t||e.name||"download",n)})}}("undefined"!=typeof self&&self||"undefined"!=typeof window&&window||this.content);
/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */void 0!==e&&e.exports?e.exports.saveAs=i:null!==n(64)&&null!==n(63)&&(void 0===(r=function(){return i}.call(t,n,t,e))||(e.exports=r))},function(e,t,n){"use strict";var r={};function i(){try{return new window.XMLHttpRequest}catch(e){}}r._getBinaryFromXHR=function(e){return e.response||e.responseText};var o=window.ActiveXObject?function(){return i()||function(){try{return new window.ActiveXObject("Microsoft.XMLHTTP")}catch(e){}}()}:i;r.getBinaryContent=function(e,t){try{var n=o();n.open("GET",e,!0),"responseType"in n&&(n.responseType="arraybuffer"),n.overrideMimeType&&n.overrideMimeType("text/plain; charset=x-user-defined"),n.onreadystatechange=function(i){var o,s;if(4===n.readyState)if(200===n.status||0===n.status){o=null,s=null;try{o=r._getBinaryFromXHR(n)}catch(e){s=new Error(e)}t(s,o)}else t(new Error("Ajax error for "+e+" : "+this.status+" "+this.statusText),null)},n.send()}catch(e){t(new Error(e),null)}},e.exports=r},function(e,t,n){"use strict";(function(e,t,r){var i=n(2),o=n(0),s={};define_ibex_controller({name:"PennController",jqueryWidget:{_init:function(){var n=this;if(n.cssPrefix=n.options._cssPrefix,n.utils=n.options._utils,n.finishedCallback=n.options._finishedCallback,n.options.hasOwnProperty("custom")&&n.options.custom instanceof Function)return n.options.custom(n);if(n.instructions=n.options.instructions,n.id=n.options.id,n.toSave=[],n.toRunBeforeFinish=[],n.timers=[],n.save=function(e,t,r,i){n.toSave.push([["Parameter",e],["Value",t],["Time",r],["Comment",i||"NULL"]])},n.callbackBeforeFinish=function(e){n.toRunBeforeFinish.push(e)},n.end=function(){for(let e in n.toRunBeforeFinish)n.toRunBeforeFinish[e]();for(let e in s)s[e].parent().is("html")||(s[e].css("display","none"),s[e].appendTo($("html")));$("iframe").css("display","none"),$("audio").each(function(){this.pause(),this.currentTime=0});for(let e in this.timers)clearInterval(this.timers[e]),clearTimeout(this.timers[e]);n.save("Page","End",Date.now(),"NULL"),n.finishedCallback(n.toSave)},n.addToPreload=function(e){e&&i.e.indexOf(e)>=0&&(n.toPreload||(n.toPreload=[]),n.toPreload.indexOf(e)<0&&(n.toPreload.push(e),e._setResource=e.extend("_setResource",function(){let t=n.toPreload.indexOf(e);t>=0&&n.toPreload.splice(t,1),n.toPreload.length<=0&&($("#waitWhilePreloading").remove(),n.save("Preload","Complete",Date.now(),"NULL"),n.instructions[0].hasBeenRun||n.instructions[0].run())})))},!i.d&&e.list[this.id].hasOwnProperty("preloadingInstructions"))for(let t in e.list[this.id].preloadingInstructions)n.addToPreload(e.list[this.id].preloadingInstructions[t]);let o;for(let e in n.instructions){let r=n.instructions[e];r instanceof t&&(r.parentElement=n.element,o instanceof t&&(o.done=o.extend("done",function(){r.run()}),r.previousInstruction=o),o=r)}if(o.done=o.extend("done",function(){n.end()}),n.instructions[0].run=n.instructions[0].extend("run",function(){n.save("Page","RunFirstInstruction",Date.now(),"NULL")}),n.variables={},e.running=n,i.d&&i.e.length)for(let e in i.e)n.addToPreload(e);n.toPreload?(n.save("Preload","Start",Date.now(),"NULL"),n.element.append($("<div id='waitWhilePreloading'>").html(i.g)),setTimeout(function(){if(n.instructions[0].hasBeenRun)return r;$("#waitWhilePreloading").remove(),n.save("Preload","Timeout",Date.now(),"NULL"),n.instructions[0].hasBeenRun||n.instructions[0].run()},i.f)):n.instructions[0].run(),n.save("Page","Creation",Date.now(),"NULL")}},properties:{obligatory:[],countsForProgressBar:!0,htmlDescription:null}}),window.modifyRunningOrder=function(e){console.log("Running modifyRunningOrder");let t=Object(o.getChangeRunningOrder)();console.log("Now going through...");for(let n=0;n<t.length;n++)console.log("Modifying running order with a function"),e=t[n](e);return console.log("New running order:",e),e}}).call(this,n(0).Ctrlr,n(3).Instruction,n(0).Abort)},function(e,t){RegExp.escape=function(e){return e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")},function(){"use strict";var t;(t="undefined"!=typeof jQuery&&jQuery?jQuery:{}).csv={defaults:{separator:",",delimiter:'"',headers:!0},hooks:{castToScalar:function(e,t){if(isNaN(e))return e;if(/\./.test(e))return parseFloat(e);var n=parseInt(e);return isNaN(n)?null:n}},parsers:{parse:function(e,t){var n=t.separator,r=t.delimiter;t.state.rowNum||(t.state.rowNum=1),t.state.colNum||(t.state.colNum=1);var i=[],o=[],s=0,a="",u=!1;function l(){if(s=0,a="",t.start&&t.state.rowNum<t.start)return o=[],t.state.rowNum++,void(t.state.colNum=1);if(void 0===t.onParseEntry)i.push(o);else{var e=t.onParseEntry(o,t.state);!1!==e&&i.push(e)}o=[],t.end&&t.state.rowNum>=t.end&&(u=!0),t.state.rowNum++,t.state.colNum=1}function c(){if(void 0===t.onParseValue)o.push(a);else{var e=t.onParseValue(a,t.state);!1!==e&&o.push(e)}a="",s=0,t.state.colNum++}var h=RegExp.escape(n),f=RegExp.escape(r),d=/(D|S|\r\n|\n|\r|[^DS\r\n]+)/,p=d.source;return p=(p=p.replace(/S/g,h)).replace(/D/g,f),d=new RegExp(p,"gm"),e.replace(d,function(e){if(!u)switch(s){case 0:if(e===n){a+="",c();break}if(e===r){s=1;break}if(/^(\r\n|\n|\r)$/.test(e)){c(),l();break}a+=e,s=3;break;case 1:if(e===r){s=2;break}a+=e,s=1;break;case 2:if(e===r){a+=e,s=1;break}if(e===n){c();break}if(/^(\r\n|\n|\r)$/.test(e)){c(),l();break}throw new Error("CSVDataError: Illegal State [Row:"+t.state.rowNum+"][Col:"+t.state.colNum+"]");case 3:if(e===n){c();break}if(/^(\r\n|\n|\r)$/.test(e)){c(),l();break}if(e===r)throw new Error("CSVDataError: Illegal Quote [Row:"+t.state.rowNum+"][Col:"+t.state.colNum+"]");throw new Error("CSVDataError: Illegal Data [Row:"+t.state.rowNum+"][Col:"+t.state.colNum+"]");default:throw new Error("CSVDataError: Unknown State [Row:"+t.state.rowNum+"][Col:"+t.state.colNum+"]")}}),0!==o.length&&(c(),l()),i},splitLines:function(e,n){if(e){var r=(n=n||{}).separator||t.csv.defaults.separator,i=n.delimiter||t.csv.defaults.delimiter;n.state=n.state||{},n.state.rowNum||(n.state.rowNum=1);var o=[],s=0,a="",u=!1,l=RegExp.escape(r),c=RegExp.escape(i),h=/(D|S|\n|\r|[^DS\r\n]+)/,f=h.source;return f=(f=f.replace(/S/g,l)).replace(/D/g,c),h=new RegExp(f,"gm"),e.replace(h,function(e){if(!u)switch(s){case 0:if(e===r){a+=e,s=0;break}if(e===i){a+=e,s=1;break}if("\n"===e){d();break}if(/^\r$/.test(e))break;a+=e,s=3;break;case 1:if(e===i){a+=e,s=2;break}a+=e,s=1;break;case 2:var t=a.substr(a.length-1);if(e===i&&t===i){a+=e,s=1;break}if(e===r){a+=e,s=0;break}if("\n"===e){d();break}if("\r"===e)break;throw new Error("CSVDataError: Illegal state [Row:"+n.state.rowNum+"]");case 3:if(e===r){a+=e,s=0;break}if("\n"===e){d();break}if("\r"===e)break;if(e===i)throw new Error("CSVDataError: Illegal quote [Row:"+n.state.rowNum+"]");throw new Error("CSVDataError: Illegal state [Row:"+n.state.rowNum+"]");default:throw new Error("CSVDataError: Unknown state [Row:"+n.state.rowNum+"]")}}),""!==a&&d(),o}function d(){if(s=0,n.start&&n.state.rowNum<n.start)return a="",void n.state.rowNum++;if(void 0===n.onParseEntry)o.push(a);else{var e=n.onParseEntry(a,n.state);!1!==e&&o.push(e)}a="",n.end&&n.state.rowNum>=n.end&&(u=!0),n.state.rowNum++}},parseEntry:function(e,t){var n=t.separator,r=t.delimiter;t.state.rowNum||(t.state.rowNum=1),t.state.colNum||(t.state.colNum=1);var i=[],o=0,s="";function a(){if(void 0===t.onParseValue)i.push(s);else{var e=t.onParseValue(s,t.state);!1!==e&&i.push(e)}s="",o=0,t.state.colNum++}if(!t.match){var u=RegExp.escape(n),l=RegExp.escape(r),c=/(D|S|\n|\r|[^DS\r\n]+)/.source;c=(c=c.replace(/S/g,u)).replace(/D/g,l),t.match=new RegExp(c,"gm")}return e.replace(t.match,function(e){switch(o){case 0:if(e===n){s+="",a();break}if(e===r){o=1;break}if("\n"===e||"\r"===e)break;s+=e,o=3;break;case 1:if(e===r){o=2;break}s+=e,o=1;break;case 2:if(e===r){s+=e,o=1;break}if(e===n){a();break}if("\n"===e||"\r"===e)break;throw new Error("CSVDataError: Illegal State [Row:"+t.state.rowNum+"][Col:"+t.state.colNum+"]");case 3:if(e===n){a();break}if("\n"===e||"\r"===e)break;if(e===r)throw new Error("CSVDataError: Illegal Quote [Row:"+t.state.rowNum+"][Col:"+t.state.colNum+"]");throw new Error("CSVDataError: Illegal Data [Row:"+t.state.rowNum+"][Col:"+t.state.colNum+"]");default:throw new Error("CSVDataError: Unknown State [Row:"+t.state.rowNum+"][Col:"+t.state.colNum+"]")}}),a(),i}},helpers:{collectPropertyNames:function(e){var t=[],n=[],r=[];for(t in e)for(n in e[t])e[t].hasOwnProperty(n)&&r.indexOf(n)<0&&"function"!=typeof e[t][n]&&r.push(n);return r}},toArray:function(e,n,r){n=void 0!==n?n:{};var i={};i.callback=void 0!==r&&"function"==typeof r&&r,i.separator="separator"in n?n.separator:t.csv.defaults.separator,i.delimiter="delimiter"in n?n.delimiter:t.csv.defaults.delimiter;var o=void 0!==n.state?n.state:{};n={delimiter:i.delimiter,separator:i.separator,onParseEntry:n.onParseEntry,onParseValue:n.onParseValue,state:o};var s=t.csv.parsers.parseEntry(e,n);if(!i.callback)return s;i.callback("",s)},toArrays:function(e,n,r){n=void 0!==n?n:{};var i={};i.callback=void 0!==r&&"function"==typeof r&&r,i.separator="separator"in n?n.separator:t.csv.defaults.separator,i.delimiter="delimiter"in n?n.delimiter:t.csv.defaults.delimiter;var o;if(void 0!==(n={delimiter:i.delimiter,separator:i.separator,onPreParse:n.onPreParse,onParseEntry:n.onParseEntry,onParseValue:n.onParseValue,onPostParse:n.onPostParse,start:n.start,end:n.end,state:{rowNum:1,colNum:1}}).onPreParse&&n.onPreParse(e,n.state),o=t.csv.parsers.parse(e,n),void 0!==n.onPostParse&&n.onPostParse(o,n.state),!i.callback)return o;i.callback("",o)},toObjects:function(e,n,r){n=void 0!==n?n:{};var i={};i.callback=void 0!==r&&"function"==typeof r&&r,i.separator="separator"in n?n.separator:t.csv.defaults.separator,i.delimiter="delimiter"in n?n.delimiter:t.csv.defaults.delimiter,i.headers="headers"in n?n.headers:t.csv.defaults.headers,n.start="start"in n?n.start:1,i.headers&&n.start++,n.end&&i.headers&&n.end++;var o,s=[];n={delimiter:i.delimiter,separator:i.separator,onPreParse:n.onPreParse,onParseEntry:n.onParseEntry,onParseValue:n.onParseValue,onPostParse:n.onPostParse,start:n.start,end:n.end,state:{rowNum:1,colNum:1},match:!1,transform:n.transform};var a={delimiter:i.delimiter,separator:i.separator,start:1,end:1,state:{rowNum:1,colNum:1}};void 0!==n.onPreParse&&n.onPreParse(e,n.state);var u=t.csv.parsers.splitLines(e,a),l=t.csv.toArray(u[0],n);o=t.csv.parsers.splitLines(e,n),n.state.colNum=1,n.state.rowNum=l?2:1;for(var c=0,h=o.length;c<h;c++){for(var f=t.csv.toArray(o[c],n),d={},p=0;p<l.length;p++)d[l[p]]=f[p];void 0!==n.transform?s.push(n.transform.call(void 0,d)):s.push(d),n.state.rowNum++}if(void 0!==n.onPostParse&&n.onPostParse(s,n.state),!i.callback)return s;i.callback("",s)},fromArrays:function(e,n,r){n=void 0!==n?n:{};var i={};i.callback=void 0!==r&&"function"==typeof r&&r,i.separator="separator"in n?n.separator:t.csv.defaults.separator,i.delimiter="delimiter"in n?n.delimiter:t.csv.defaults.delimiter;var o,s,a,u,l="";for(a=0;a<e.length;a++){for(o=e[a],s=[],u=0;u<o.length;u++){var c=void 0===o[u]||null===o[u]?"":o[u].toString();c.indexOf(i.delimiter)>-1&&(c=c.replace(new RegExp(i.delimiter,"g"),i.delimiter+i.delimiter));var h="\n|\r|S|D";h=(h=h.replace("S",i.separator)).replace("D",i.delimiter),c.search(h)>-1&&(c=i.delimiter+c+i.delimiter),s.push(c)}l+=s.join(i.separator)+"\n"}if(!i.callback)return l;i.callback("",l)},fromObjects:function(e,n,r){n=void 0!==n?n:{};var i={};if(i.callback=void 0!==r&&"function"==typeof r&&r,i.separator="separator"in n?n.separator:t.csv.defaults.separator,i.delimiter="delimiter"in n?n.delimiter:t.csv.defaults.delimiter,i.headers="headers"in n?n.headers:t.csv.defaults.headers,i.sortOrder="sortOrder"in n?n.sortOrder:"declare",i.manualOrder="manualOrder"in n?n.manualOrder:[],i.transform=n.transform,"string"==typeof i.manualOrder&&(i.manualOrder=t.csv.toArray(i.manualOrder,i)),void 0!==i.transform){var o,s=e;for(e=[],o=0;o<s.length;o++)e.push(i.transform.call(void 0,s[o]))}var a,u,l,c,h=t.csv.helpers.collectPropertyNames(e);if("alpha"===i.sortOrder&&h.sort(),i.manualOrder.length>0){var f=[].concat(i.manualOrder);let e;for(e=0;e<h.length;e++)f.indexOf(h[e])<0&&f.push(h[e]);h=f}for(i.headers&&(void 0).push(h),a=0;a<e.length;a++){for(l=[],u=0;u<h.length;u++)(c=h[u])in e[a]&&"function"!=typeof e[a][c]?l.push(e[a][c]):l.push("");(void 0).push(l)}return t.csv.fromArrays(void 0,n,i.callback)}},t.csvEntry2Array=t.csv.toArray,t.csv2Array=t.csv.toArrays,t.csv2Dictionary=t.csv.toObjects,void 0!==e&&e.exports&&(e.exports=t.csv)}.call(this)},function(e,t,n){"use strict";(function(e,t){n(60);t.FeedItems=function(n,r){if(n instanceof Function&&void 0==r){let r=function(){function n(e){return e=$.csv.toObjects(e),Object.keys(e[0]).length>1?e:(e=$.csv.toObjects(CHUNKS_DICT[entry],{separator:"\t"}),Object.keys(e[0]).length>1?e:null)}if(t.hasOwnProperty("defaultTable")){let e=n(t.defaultTable);if(e)return e}for(let e in CHUNKS_DICT){if(e.match(/\.(html?|mp3)$/i))continue;let t=n(CHUNKS_DICT[e]);if(t)return t}return e}();if(r==e)return e;r=new class{constructor(t){if(!(t instanceof Array)||t.length<2||Object.keys(t[0]).length<2)return e;this.table=t;for(let e in t[0])e.match(/^item$/i)&&(this.item=e),e.match(/^group$/i)&&(this.group=e),e.match(/^label$/i)&&(this.label=e)}setItem(t){if(!this.table[0].hasOwnProperty(t))return console.log("Error when setting table's item column: no column found with the name "+t),e;this.item=t}setGroup(t){if(!this.table[0].hasOwnProperty(t))return console.log("Error when setting table's item column: no column found with the name "+t),e;this.group=t}setLabel(t){if(!this.table[0].hasOwnProperty(t))return console.log("Error when setting table's item column: no column found with the name "+t),e;this.label=t}}(r),window.items instanceof Array||(window.items=[]),window.items=window.items.concat(function(t,n){let r=[],i={};for(let e in t.table){let o=n(t.table[e]);o instanceof Array||(o=["PennController",o]);let s=["Item-"+e];for(let e in o)s.push(o[e]);if(t.label&&t.table[e].hasOwnProperty(t.label)?s[0]=t.table[e][t.label]:t.item&&t.table[e].hasOwnProperty(t.item)&&(s[0]="Item-"+t.table[e][t.item]),t.item&&t.group){let n=t.table[e][t.item],r=t.table[e][t.group];i.hasOwnProperty(n)||(i[n]={}),i[n][r]=s}else r.push(s)}if(t.item&&t.group){let t=Object.keys(i[Object.keys(i)[0]]);for(let n in i){for(let o in t){if(!i[n].hasOwnProperty(t[o]))return console.log("Error: item "+n+" has no entry for group "+t[o]),e;let s=i[n][t[o]];s[0]=[s[0],n],r.push(s)}t.unshift(t.pop())}}return r}(r,n))}else if("string"==typeof n)return e}}).call(this,n(0).Abort,n(0).PennController)},function(e,t,n){"use strict";(function(e,t,r,i){var o=n(2);const s=window.MutationObserver||window.WebKitMutationObserver||window.MozMutationObserver;var a={};$(document).ready(function(){var e=document.createElement("script");e.src="https://www.youtube.com/iframe_api";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t),window.onYouTubeIframeAPIReady=function(){for(let e in a)a[e].call()}});i.instruction.yt=function(n){return new class extends e{constructor(e){if(super(e,"youtube"),e!=t){let t=this,n=function(){t.origin.player=new YT.Player(e,{videoId:e,events:{onReady:function(e){t.origin._ready(e)},onStateChange:function(e){e.data==YT.PlayerState.ENDED?t.origin._ended(e):e.data==YT.PlayerState.BUFFERING?t.origin._buffering(e):e.data==YT.PlayerState.PLAYING?t.origin._playing(e):e.data==YT.PlayerState.CUED?t.origin._canPlay(e):e.data==YT.PlayerState.PAUSED&&t.origin._paused(e)}}})};this.iframeLoaded=!1,this.iframe=$("<iframe>"),this.iframe.attr({src:"https://www.youtube-nocookie.com/embed/"+e+"?enablejsapi=1",id:e,frameborder:0}).bind("load",function(){t.origin.iframeLoaded=!0}),$("html").append(this.iframe.css({display:"none",position:"absolute"})),this.setElement($("<div>")),a.hasOwnProperty(e)||(a[e]=function(){t.origin.iframeLoaded?n():t.origin.iframe.bind("load",n)}),this.visual={top:0,left:0,width:0,height:0},this.autoPlay=!0,this.commandsQueue=[],this.hasPlayed=!1,o.c&&this.origin._addToPreload()}}run(){if(super.run()==t)return t;let e=this.origin;new s(function(t){if($.contains(document.body,e.element[0])&&e.element[0].offsetParent){let t=e.element.width(),n=e.element.height();t==e.visual.width&&n==e.visual.height||(e.iframe.css({width:t,height:n,display:"block"}),e.visual.width=t,e.visual.height=n);let r=e.element.offset(),i=r.left,o=r.top;i==e.visual.left&&o==e.visual.top||(e.iframe.css({left:i,top:o,display:"block"}),e.visual.left=i,e.visual.top=o)}}).observe(document.body,{childList:!0,attributes:!0,subtree:!0}),this._addElement(this.parentElement),e.origin.player&&e.origin.autoPlay&&e._play(),r.running.callbackBeforeFinish(function(){e._forcePause()})}_forcePlay(){let e=this.origin,t=0,n=setInterval(function(){e.player.getPlayerState()==YT.PlayerState.PLAYING||t>=5e3?clearInterval(n):e.player.playVideo(),t++},1)}_forcePause(){let e=this.origin,t=0,n=setInterval(function(){e.player.getPlayerState()==YT.PlayerState.PAUSED||e.player.getPlayerState()==YT.PlayerState.ENDED||t>=5e3?clearInterval(n):e.player.pauseVideo(),t++},1)}_play(){this.origin.player&&(this.origin.commandsQueue.push("play"),this._forcePlay())}_pause(){this.origin.player&&(this.origin.commandsQueue.push("pause"),this._forcePause())}_paused(e){0==this.origin.commandsQueue.indexOf("pause")&&this.origin.commandsQueue.splice(0,1),this.origin.commandsQueue.length>0&&"play"==this.origin.commandsQueue[0]&&this._forcePlay()}_playing(e){0==this.origin.commandsQueue.indexOf("play")&&this.origin.commandsQueue.splice(0,1),this.origin.commandsQueue.length>0&&"pause"==this.origin.commandsQueue[0]&&this.origin.player.pauseVideo(),this.origin.loaded||(this.origin.loaded=!0,this.origin.buffering&&!this.origin.canPlay&&this.origin._canPlay(e)),this.origin.buffering&&(this.origin.buffering=!1),this.origin.hasBeenRun&&!this.origin.isDone&&this.origin.done()}_buffering(e){this.origin.buffering||(this.origin.buffering=!0)}_canPlay(e){this.origin.canPlay||(this.origin.canPlay=!0,this.origin._setResource(this.iframe),this.hasBeenRun&&e.target.getPlayerState()!=YT.PlayerState.PLAYING?this._play():this.hasBeenRun||e.target.getPlayerState()!=YT.PlayerState.PLAYING||this._pause())}_ended(e){this.hasPlayed=!0}_ready(e){this._play()}wait(){if(this.origin.hasPlayed)return this.newMeta(function(){this.done()});let e=this.newMeta();return this.origin._ended=this.origin.extend("_ended",function(){e.done()}),e}pause(){return this.newMeta(function(){this._pause(),this.done()})}play(){return this.newMeta(function(){this._play(),this.done()})}preload(){return this.origin._addToPreload(),this.newMeta(function(){this.done()})}}(n)}}).call(this,n(3).Instruction,n(0).Abort,n(0).Ctrlr,n(0).PennController)},function(e,t){(function(t){e.exports=t}).call(this,{})},function(e,t){e.exports=function(){throw new Error("define cannot be used indirect")}},function(e,t,n){"use strict";(function(e,t,r,i){var o,s,a=n(20),u=n(0),l=n(57),c=[],h="",f=!1,d="This experiment collects voice recordings from its participants. Your browser should now be asking for your permission to use your recording device (if applicable). By giving you authorization to record and by participating in this experiment, you are giving permission to the designer(s) of this experiment to anonymously collect the voice  samples recorded during this experiment. The output audio files will be uploaded to and hosted on a server designated by the experimenter(s). ";function p(t){if(!navigator.mediaDevices)return t.element.append($("<p>Sorry, you cannot complete this experiment because your browser does not support voice recording.</p>")),e;let n=dget(t.options,"permissionMessage",d);t.element.append($("<p>"+n+"</p>"));var r=[];navigator.mediaDevices.getUserMedia({audio:!0}).then(function(e){(o=new MediaRecorder(e)).onstop=function(e){console.log("data available after MediaRecorder.stop() called."),s.filename="msr-"+(new Date).toISOString().replace(/:|\./g,"-")+".ogg",console.log("Filename:",s.filename),s.blob=new Blob(r,{type:"audio/ogg; codecs=opus"}),console.log("Blob:",s.blob),s.audioPlayer.src=URL.createObjectURL(s.blob),console.log("src:",s.audioPlayer.src),r=[],s=null,console.log("recorder stopped")},o.ondataavailable=function(e){r.push(e.data)};t.element.append($("<a>By clicking this link I understand that I grant this experiment's script access to my recording device for the purpose of uploading voice recordings to the server designated by the experimenter(s).</a>").addClass("Message-continue-link").click(t.finishedCallback))}).catch(function(n){return t.element.append($("<p>The following error occurred: "+n+"</p>")),e})}function g(e){e.element.append($("<p>Please wait while the archive is being uploaded to the server...</p>"));var n=new a;for(let e in c){var r=c[e];n.file(r.name,r.data)}console.log("Generating compressed archive..."),n.generateAsync({compression:"DEFLATE",type:"blob"}).then(function(n){t.downloadVoiceRecordingsArchive=function(){Object(l.saveAs)(n,"VoiceRecordingsArchive.zip")},console.log("Compression complete!");var r="msr-"+(new Date).toISOString().replace(/:|\./g,"-")+".zip",i=new File([n],r);console.log("File object created:",i);var o=new FormData;o.append("fileName",r),o.append("file",i),o.append("mimeType","application/zip"),console.log("Upload URL:",h);var s=new XMLHttpRequest;s.open("POST",h,!0),s.onreadystatechange=function(){4==s.readyState&&(200!=s.status||s.responseText.match(/problem|error/i)?(alert("There was an error uploading the recordings ("+s.responseText+")."),console.log("Ajax post failed. ("+s.status+")",s.responseText),e.finishedCallback([[["VoiceRecordingsFilename",r],["UploadStatus","Failed"],["Error Text",s.responseText],["Status",s.status]]])):(console.log("Ajax post was successful. ",s.responseText),e.finishedCallback([[["VoiceRecordingsFilename",r],["UploadStatus","Success"]]])))},s.send(o)})}Object(u.changeRunningOrder)(function(e){if(!f)return e;let t=!1,n=[-1,-1];for(let r=0;r<e.length;++r)for(let i=0;i<e[r].length;++i)"PennController"==e[r][i].controller?e[r][i].options.hasOwnProperty("custom")&&e[r][i].options.custom==g&&(t=!0,n[0]>=0&&alert("WARNING: upload of voice archive set AFTER sending of results; check the 'items' and 'shuffleSequence' variables.")):"__SendResults__"==e[r][i].controller&&n[0]<0&&!t&&(n=[r,i]);if(!t){console.log("No manual upload");let t=new DynamicElement("PennController",{custom:g});n[0]>=0?e[n[0]].splice(n[1],0,t):e.push([t])}return console.log("Returning ro from voice:",e),e}),t.InitiateRecorder=function(e,t){return e.match(/^http.+/i)?(h=e,f=!0,{custom:p,permissionMessage:t}):console.log("ERROR: save URL is incorrect",e)},t.DownloadVoiceButton=function(e){return"<button type=\"button\" onclick=\"if (PennController.hasOwnProperty('downloadVoiceRecordingsArchive'))  PennController.downloadVoiceRecordingsArchive();  else  alert('ERROR: could not find an archive for voice recordings');\">"+e+"</button>"};t.instruction.voiceRecorder=function(){return new class extends r{constructor(t){if(super(t,"voice"),t!=e){this.recording=!1,this.audioPlayer=document.createElement("audio");let e=$("<span>").addClass("PennController-VoiceRecorderUI"),t=$("<button>").addClass("PennController-VoiceRecorderRecord"),n=$("<div>").addClass("PennController-VoiceRecorderStatus"),r=$("<button>").addClass("PennController-VoiceRecorderPlay"),i=$("<div>"),o=$("<button>").addClass("PennController-VoiceRecorderStop"),s=$("<div>");$([t,r,o]).each(function(){this.css({width:"25px",height:"25px",position:"relative"})}),$([i,s,n]).each(function(){this.css({position:"absolute",left:"2px",top:"4px",width:"15px",height:"15px"})}),t.css({"background-color":"red","border-radius":"50%","margin-right":"10px"}),n.css({"background-color":"brown","border-radius":"50%",left:"6px",top:"6px",width:"10px",height:"10px"}),i.css({width:0,height:0,"background-color":"transparent",padding:0,"border-top":"7.5px solid transparent","border-bottom":"7.5px solid transparent","border-right":"0px solid transparent","border-left":"15px solid green"}),s.css({"background-color":"brown"});let a=function(e){r.css("display","inline-block"),o.css("display","none"),e?(i.css("border-left","15px solid green"),r.attr("disabled",!1)):(i.css("border-left","15px solid gray"),r.attr("disabled",!0))},u=function(e){o.css("display","inline-block"),r.css("display","none"),e?(s.css("background-color","brown"),o.attr("disabled",!1)):(s.css("background-color","gray"),o.attr("disabled",!0))};a(!1);let l=this,c=null;t.click(function(){l.recording?(l.audioPlayer.currentTime>0&&(l.audioPlayer.pause(),l.audioPlayer.currentTime=0,a(!1)),l.recording=!1,clearInterval(c),n.css("background-color","brown"),a(!0),l._stop()):(n.css("background-color","lightgreen"),c=setInterval(function(){"rgb(255, 255, 255)"==n.css("background-color")?n.css("background-color","lightgreen"):n.css("background-color","white")},750),a(!1),l.recording=!0,l._start())}),r.click(function(){u(!0),l.audioPlayer.currentTime=0,l.audioPlayer.play()}),o.click(function(){l.audioPlayer.currentTime>0&&(l.audioPlayer.pause(),l.audioPlayer.currentTime=0,a(!0))}),this.audioPlayer.onended=function(){a(!0)},e.append(t.append(n)).append(r.append(i)).append(o.append(s)),this.setElement(e)}}run(){if(super.run()==e)return e;if(void 0===o)return console.log("ERROR: recorder not initiated. Make sure your items variable contains an InitiateRecorder controller.");let t=this;i.running.callbackBeforeFinish(function(){t.blob&&c.push({name:t.filename,data:t.blob}),t.StartRecording&&i.running.save("VoiceRecorder","StartRecording",t.StartRecording,t._id),t.StopRecording&&i.running.save("VoiceRecorder","StopRecording",t.StopRecording,t._id),t.filename&&i.running.save("VoiceRecorder","Filename",t.filename,t._id)}),this._addElement(this.parentElement),this.done()}_start(){this.recording=!0,this.StartRecording=Date.now(),o.start()}_stop(){this.recording=!1,this.StopRecording=Date.now(),s=this,o.stop()}}}}).call(this,n(0).Abort,n(0).PennController,n(3).Instruction,n(0).Ctrlr)},function(e,t,n){(function(e,t,n,r){r.instruction.timer=function(r,i){return new class extends e{constructor(e,n){super(e,"timer"),e!=t&&(this.delay=e,this.setElement($("<timer>")),this.step=10,this.callback=n,this.cleared=!1)}run(){if(super.run()==t)return t;this.left=this.delay;let e=this;this.timer=setTimeout(function(){e._elapsed()},this.delay),n.running.timers.push(this.timer),this.done()}_elapsed(){this.cleared=!0,this.callback instanceof Function?this.callback():this.callback instanceof e&&(this.callback.parentElement=n.running.element,this.callback.run())}stop(e){let t=this,n=this.newMeta(function(){t.done});return n.run=function(){clearInterval(t.origin.timer),e&&t.origin.done()},n}step(e){return this.origin.step=e,this.newMeta(function(){this.done()})}wait(t){return this.newMeta(function(){let n=this,r=function(){n.done(),t instanceof Function?t():t instanceof e&&!t.hasBeenRun&&t.run()};cleared?r():this.origin._elapsed=this.origin.extend("_elapsed",r)})}}(r,i)}}).call(this,n(3).Instruction,n(0).Abort,n(0).Ctrlr,n(0).PennController)},function(e,t,n){(function(e,t,n){n.instruction.text=function(n){return new class extends e{constructor(e){super(e,"text"),e!=t&&this.setElement($("<span>").html(e))}run(){if(super.run()==t)return t;this._addElement(this.parentElement),this.done()}text(e){return this.newMeta(function(){this.origin.content=e,this.origin.element.html(e),this.done()})}}(n)}}).call(this,n(3).Instruction,n(0).Abort,n(0).PennController)},function(e,t,n){(function(e,t,n,r){r.instruction.selector=function(){return new class extends e{constructor(e){super(e,"selector"),e!=t&&(this.instructions=e,this.shuffledInstructions=e,this.enabled=!0,this.canClick=!0,this.keyList=[],this.shuffledKeyList=[],this.selectedElement=null,this.selectedInstruction=null,this.callbackFunction=null,this.setElement($("<div>").addClass("PennController-Selector")),this.selections=[])}run(){if(super.run()==t)return t;let r=this;for(let t in this.instructions){let n=this.instructions[t];n instanceof e?(n.origin.hasBeenRun||(n.origin.parentElement=this.element),n.hasBeenRun||n.run(),n.origin.element.bind("click",function(){r.canClick&&r._select(n)})):console.log("Warning: selector's entry #"+t+" is not a proper instruction.")}n.running.safeBind($(document),"keydown",function(e){if(!r.keyList.length)return t;for(let t in r.shuffledKeyList)("number"==typeof r.shuffledKeyList[t]&&r.shuffledKeyList[t]==e.keyCode||r.shuffledKeyList[t]instanceof Array&&r.shuffledKeyList[t].indexOf(e.keyCode)>=0)&&r._select(r.shuffledInstructions[t])}),_addElement(this.parentElement),this.done()}_select(n){if(!this.enabled)return t;let r=this.origin;if(n instanceof e){r.selectedElement=n.origin.element,r.selectedInstruction=n.origin,n.origin.element.addClass("PennController-selected");for(let e in r.instructions)r.instructions[e].origin==n.origin?n.origin._id?r.selections.push([n.origin._id,Date.now()]):r.selections.push([e,Date.now()]):r.instructions[e].origin.element!=n.element&&r.instructions[e].origin.element.removeClass("PennController-selected");r.callbackFunction instanceof Function&&r.callbackFunction(n)}}selected(t){let n=this.origin,r=arguments;return function(){if(r.hasOwnProperty("1")){for(let t in r)if(r[t]instanceof e&&r[t].origin==n.selectedInstruction)return!0;return!1}return t instanceof e?t.origin==n.selectedInstruction:n.selectedInstruction}}select(e){return this.newMeta(function(){this.origin._select(e),this.done()})}clickable(e){return this.newMeta(function(){this.origin.canClick=e,this.done()})}callback(t){return this.newMeta(function(){this.origin._select=this.origin.extend("_select",function(){t instanceof e?t.run():t instanceof Function&&t.apply(n.running.variables,[this.origin.selectedInstruction])}),this.done()})}keys(){let e=arguments;return this.newMeta(function(){if(e.hasOwnProperty("0")){if("string"==typeof e[0]){let t=e.hasOwnProperty("1");for(let n=0;n<e[0].length;n++)this.origin.instructions.hasOwnProperty(n)&&(t?this.origin.keyList.push(e[0].charCodeAt(n)):this.origin.keyList.push([e[0].toUpperCase().charCodeAt(n),e[0].toLowerCase().charCodeAt(n)]))}if("number"==typeof e[0])for(let t in e)e[t]<0?console.log("Warning: invalid key code for selector instruction #"+t+", not attaching keys to it."):this.origin.keyList.push(e[t])}this.origin.shuffledKeyList=this.origin.keyList,this.done()})}shuffle(t){let n=this.origin;return this.newMeta(function(){let r=[];if(void 0===t)for(let e in n.instructions)r.push(e);else for(let t in arguments){let i=arguments[t];if("number"==typeof i&&n.instructions.hasOwnProperty(i)&&r.indexOf(i)<0)r.push(i);else if(i instanceof e)for(let e in this.origin.instructions)n.instructions[e].origin==i.origin&&r.indexOf(e)<0&&r.push(e)}let i=[].concat(r);fisherYates(r),n.shuffledInstructions=$.extend({},n.instructions),n.shuffledKeyList=[].concat(n.keyList);for(let e in r){let t=i[e],o=r[e],s=n.instructions[o].origin;n.shuffledInstructions[t]=n.instructions[o],t<n.keyList.length&&(n.shuffledKeyList[t]=n.keyList[o]);let a=$("<shuffle>").attr("id",t).css({position:n.instructions[o].origin.element.css("position"),left:n.instructions[o].origin.element.css("left"),top:n.instructions[o].origin.element.css("top")});s.element.before(a)}$("shuffle").each(function(){let e=$(this).attr("id");$(this).after(n.instructions[e].origin.element),n.instructions[e].origin.element.css({position:$(this).css("position"),left:$(this).css("left"),top:$(this).css("top")})}),$("shuffle").remove(),this.done()})}once(){let e=this.origin;return e._select=e.extend("_select",function(){e.enabled=!1}),this.newMeta(function(){this.done()})}enable(e){return void 0===e&&(e=!0),this.newMeta(function(){this.origin.enabled=e,this.done()})}record(e){return this.newMeta(function(){let r=this.origin;n.running.callbackBeforeFinish(function(){if(!r.selections.length)return t;if("string"==typeof e)if("first"==e)n.running.save("selection",r.selections[0][0],r.selections[0][1],"NULL");else if("last"==e)n.running.save("selection",r.selections[r.selections.length-1][0],r.selections[r.selections.length-1][1],"NULL");else for(let e in r.selections)n.running.save("selection",r.selections[e][0],r.selections[e][1],"NULL");else for(let e in r.selections)n.running.save("selection",r.selections[e][0],r.selections[e][1],"NULL")}),this.done()})}wait(){return this.newMeta(function(){let e=this;this.origin.selected().call()?this.done():this.origin._select=this.origin.extend("_select",function(){e.done()})})}}(arguments)}}).call(this,n(3).Instruction,n(0).Abort,n(0).Ctrlr,n(0).PennController)},function(e,t,n){(function(e,t,n,r){r.instruction.save=function(){return new class extends e{constructor(e){super(e,"save"),e!=t&&(this.setElement($("<save>")),this.parameter=e[0],this.value=e[1],this.comment=e[2])}run(){if(super.run()==t)return t;n.running.save(this.parameter,this.value,Date.now(),this.comment),this.done()}}(arguments)}}).call(this,n(3).Instruction,n(0).Abort,n(0).Ctrlr,n(0).PennController)},function(e,t,n){(function(e,t,n,r){r.instruction.radioButtons=function(r,i){return new class extends e{constructor(e,n){if(super({label:e,length:n},"radio"),e!=t){this.label=e,this.length=n,this.values=[],this.times=[],this.setElement($("<span>"));for(let t=0;t<n;t++){let n=this,r=$("<input type='radio'>").attr({name:e,value:t});r.click(function(){n._clicked($(this).attr("value"))}),n.element.append(r)}}}run(){if(super.run()==t)return t;this._addElement(this.parentElement),this.done()}_whenToInsist(e){this._clicked=this.extend("_clicked",e)}_clicked(e){this.values.push(e),this.times.push(Date.now())}selected(e){let t=this.origin;return function(){let n=t.values[t.values.length-1];return void 0===e?n:"number"==typeof e||"string"==typeof e?n==e:e instanceof Array?e.indexOf(n)>=0||e.indexOf(parseInt(n))>=0:void 0}}wait(e){let t=this.newMeta();return this.origin._clicked=this.origin.extend("_clicked",function(n){"number"==typeof e?n==e&&t.done():e instanceof Array?e.indexOf(n)>=0&&t.done():t.done()}),t}record(e,t){let r=this.origin;return this.newMeta(function(){n.running.callbackBeforeFinish(function(){if("string"!=typeof e||"last"==e)n.running.save(r.label,r.values[r.values.length-1],r.times[r.times.length-1],t);else if("first"==e&&1==r.values.length)n.running.save(r.label,r.values[0],r.times[0],t);else if("all"==e)for(let e in r.values)n.running.save(r.label,r.values[e],r.times[e],t)}),this.done()})}}(r,i)}}).call(this,n(3).Instruction,n(0).Abort,n(0).Ctrlr,n(0).PennController)},function(e,t,n){(function(e,t,n,r){r.instruction.key=function(r){return new class extends e{constructor(e,n){if(super(e,"key"),e!=t)if(this.setElement($("<key>")),this.keys=[],"number"==typeof e)this.keys.push(e);else if("string"==typeof e)for(let t in e)if(n)this.keys.push(e.charCodeAt(t));else{let n=e.toUpperCase(),r=e.toLowerCase();this.keys.push(r.charCodeAt(t)),this.keys.push(n.charCodeAt(t))}}run(){if(super.run()==t)return t;let e=this;n.running.safeBind($(document),"keydown",function(t){(0==e.keys.length||e.keys.indexOf(t.keyCode)>=0)&&e._pressed(t.keyCode)})}_whenToInsist(e){this.origin._pressed=this.origin.extend("_pressed",e)}_pressed(e){this.isDone||(this.origin.key=String.fromCharCode(e),this.origin.time=Date.now(),this.origin.done())}pressed(e){let t=this.origin;return function(){let n=t.key;return!!n&&("string"==typeof e?RegExp(n,"i").test(e):"number"==typeof e?e==n.charCodeAt(0):n.charCodeAt(0))}}record(e){return this.newMeta(function(){let t=this;n.running.callbackBeforeFinish(function(){n.running.save("keypress",t.origin.key,t.origin.time,e)}),this.done()})}}(r)}}).call(this,n(3).Instruction,n(0).Abort,n(0).Ctrlr,n(0).PennController)},function(e,t,n){"use strict";(function(e,t,r){var i=n(2);r.instruction.image=function(n,r,o){return new class extends e{constructor(e,n,r){if(super(e,"image"),e!=t){let t=$("<div>").css("display","inline-block");"number"==typeof n&&"number"==typeof r&&t.css({width:n,height:r}),this.setElement(t),this.image=null,i.b&&this.origin._addToPreload(),this.origin.fetchResource(e,"image")}}run(){if(super.run()==t)return t;this._addElement(this.parentElement),this.done()}_setResource(e){return this.origin.image?t:super._setResource(e)==t?t:(this.origin.image=e.clone(),this.origin.element.append(this.origin.image),void this.origin.image.css({width:"100%",height:"100%",display:"inherit"}))}move(e,t){return this.newMeta(function(){this.origin.element.css({left:e,top:t,position:"absolute"}),this.done()})}preload(){return this.origin._addToPreload(),this.newMeta(function(){this.done()})}}(n,r,o)}}).call(this,n(3).Instruction,n(0).Abort,n(0).PennController)},function(e,t,n){(function(e,t,n){n.instruction.if=function(n,r,i){return new class extends e{constructor(e,n,r){super(arguments,"if"),e!=t&&(this.setElement($("<div>").addClass("PennController-Condition")),this.condition=e,this.success=n,this.failure=r)}run(){if(super.run()==t)return t;if(!this.success instanceof e)return t;if(!this.condition instanceof Function)return t;let n=this;this.condition()?(this.success.done=this.success.extend("done",function(){n.done()}),this.success.run()):this.failure instanceof e?(this.failure.done=this.failure.extend("done",function(){n.done()}),this.failure.run()):this.done()}}(n,r,i)}}).call(this,n(3).Instruction,n(0).Abort,n(0).PennController)},function(e,t,n){(function(e,t,n,r){r.instruction.func=function(r){return new class extends e{constructor(e){super(e,"function"),e!=t&&(this.setElement($("<function>")),this.func=e)}run(){if(super.run()==t)return t;this.func.apply(n.running.variables),this.done()}}(r)}}).call(this,n(3).Instruction,n(0).Abort,n(0).Ctrlr,n(0).PennController)},function(e,t,n){(function(e,t,n){n.instruction.end=function(){return new class extends e{constructor(){super("end","end")}run(){super.run(),this.hasBeenRun=!0,this.done=!0,t.running.end()}}}}).call(this,n(3).Instruction,n(0).Ctrlr,n(0).PennController)},function(e,t,n){(function(e,t,n){class r extends e{constructor(e){super(e,"complex"),e!=t&&(this.table=$("<table>").addClass("PennController-Complex"),this.toBeDone=[],this.setElement(this.table))}run(){if(super.run()==t)return t;let n=this,i=$("<tr>");for(let t in this.content){let s=n.content[t],a=$("<td>");function o(e){e.parentElement=e instanceof r?n.table:a,"meta"!=e.type||e.source.parentElement||o(e.source)}s instanceof e&&(s.hasBeenRun||(n.toBeDone.push(s),o(s),s instanceof r?(i.children().length&&n.table.append(i),i=$("<tr>")):i.append(a),s.done=s.extend("done",function(){n._executed(s)}),s.run()))}i.children().length&&n.table.append(i),this.parentElement&&this.parentElement.is("table")?this.table.find("tr").each(function(){n._addElement(n.parentElement,$(this))}):this.element.is("table")?this._addElement(this.parentElement):this._addElement(this.parentElement,$("<table>").append(this.element)),this.done()}_executed(e){let t=this.toBeDone.indexOf(e);t>=0&&this.toBeDone.splice(t,1),this.toBeDone.length<1&&$.contains(document.body,this.element[0])&&this.done()}newMeta(e){let t=this.origin.content;this.origin.content=null;let n=super.newMeta(e);return this.origin.content=t,n}validation(n){let r=this.newMeta(function(){(this.origin.toBeDone.length<1||"any"==n&&this.origin.toBeDone.length<Object.keys(this.origin.content).length||"number"==typeof n&&n in this.origin.content&&this.origin.content[n].isDone)&&this.done()});return this.origin._executed=this.origin.extend("_executed",function(i){if(r.isDone)return t;"any"==n?r.done():"number"==typeof n&&n in this.origin.content?r.origin.content[n]==i&&r.done():n instanceof e&&n==i?r.done():r.origin.toBeDone.length<1&&r.done()}),r}}n.instruction.sequence=function(){return new r(arguments)}}).call(this,n(3).Instruction,n(0).Abort,n(0).PennController)},function(e,t,n){(function(e,t){t.instruction.clear=function(){return new class extends e{constructor(){super("clear","clear")}run(){super.run(),this.hasBeenRun=!0,$(".PennController-PennController div").detach(),this.done()}}}}).call(this,n(3).Instruction,n(0).PennController)},function(e,t,n){(function(e,t,n){n.instruction.canvas=function(n,r){return new class extends e{constructor(e,n){if(super({width:e,height:n},"canvas"),e!=t){if("number"!=typeof e||"number"!=typeof n||e<0||n<0)return t;let r=$("<div>").css({width:e,height:n,position:"relative"}).addClass("PennController-Canvas");this.setElement(r),this.objects=[]}}run(){if(super.run()==t)return t;for(let t in this.objects){let n=this.objects[t],r=n[0];r instanceof e?r.hasBeenRun||(r.run(),r.done=r.extend("done",function(){r.element.css({position:"absolute",left:n[1],top:n[2],"z-index":n[3]})})):console.log("Warning: element #"+t+" of canvas is not a proper instruction; ignoring it.")}this._addElement(this.parentElement),this.done()}_addObject(n,r,i,o){if("number"!=typeof r||"number"!=typeof i)return t;if(!(n instanceof e))return t;let s=n.origin,a=!1;for(let e in this.origin.objects){let t=this.origin.objects[e];t[0]==s&&(t[1]=r,t[2]=i,"number"==typeof o&&(t[3]=o),a=!0)}a||this.origin.objects.push([s,r,i,"number"==typeof o?o:this.origin.objects.length]),s.parentElement=this.origin.element,n.hasBeenRun&&n.isDone?(s.element.appendTo(this.origin.element),s.element.css({position:"absolute",left:r,top:i,"z-index":o})):this.origin.hasBeenRun&&(s.done=s.extend("done",function(){s.element.css({position:"absolute",left:r,top:i,"z-index":o})}),n.run())}put(e,t,n,r){return this.newMeta(function(){this.origin._addObject(e,t,n,r),this.done()})}}(n,r)}}).call(this,n(3).Instruction,n(0).Abort,n(0).PennController)},function(e,t,n){"use strict";(function(e,t,r,i){var o=n(2);i.instruction.audio=function(n){return new class extends e{constructor(e){if(super(e,"audio"),e!=t){if(!e.match(/\.(ogg|wav|mp3)$/i))return console.log("Error: "+e+" is not a valid audio file."),t;this.autoPlay=!0,this.controls=!1,this.ended=!1,this.eventsRecord=[],this.savePlays=!1,this.savePauses=!1,this.saveEnds=!1,this.saveSeeks=!1,this.setElement($("<span>")),o.a&&this.origin._addToPreload(),this.origin.fetchResource(e,"audio")}}run(){if(super.run()==t)return t;if(this.audio){let e=this;this.origin.audio.bind("ended",function(){e._whenEnded()}),this.audio.readyState<4&&o.e.indexOf(this.origin)>=0&&r.running.save("ERROR_PRELOADING_AUDIO",this.content,Date.now(),"Audio was not fully loaded"),this.controls?(this.audio.attr("controls",!0),this.audio.css("display","inherit")):this.audio.css("display","none"),this.element.append(this.audio),this._addElement(this.parentElement),this.autoPlay&&this.audio[0].play()}this.done()}_setResource(e){if(this.origin.audio)return t;if(super._setResource(e)==t)return t;let n=this.origin;this.origin.audio=e,e.bind("play",function(){let t=setInterval(function(){!e[0].paused&&e[0].currentTime&&(n.eventsRecord.push(["play",Date.now(),e[0].currentTime]),clearInterval(t))},1)}).bind("ended",function(){n.eventsRecord.push(["end",Date.now(),e[0].currentTime])}).bind("pause",function(){n.eventsRecord.push(["pause",Date.now(),e[0].currentTime])}).bind("seeked",function(){n.eventsRecord.push(["seek",Date.now(),e[0].currentTime])}),this.origin.hasBeenRun&&(this.origin.hasBeenRun=!1,this.origin.run())}_whenEnded(){this.origin.ended=!0}show(e){return void 0===e&&(e=!0),this.newMeta(function(){this.origin.controls=e,this.done()})}clickToStart(){return this.newMeta(function(){this.origin.controls||(this.origin.controls=!0),this.origin.auto=!1,this.done()})}wait(){if(this.origin.ended)return this.newMeta(function(){this.done()});let e=this.newMeta();return this.origin._whenEnded=this.origin.extend("_whenEnded",function(){e.done()}),e}record(e){let n=this.origin,i=function(e){if("play"==e){if(n.savePlays)return t;n.savePlays=!0}else if("pause"==e){if(n.savePauses)return t;n.savePauses=!0}else if("end"==e){if(n.saveEnds)return t;n.saveEnds=!0}else{if("seek"!=e)return t;if(n.saveSeeks)return t;n.saveSeeks=!0}n.done=n.extend("done",function(){r.running.callbackBeforeFinish(function(){for(let t in n.eventsRecord){let i=n.eventsRecord[t];i[0]==e&&r.running.save(n.content,i[0],i[1],i[2])}})})};if(1==arguments.length&&"string"==typeof e)i(e);else if(arguments.length>1)for(let e=0;e<arguments.length;e++)i(arguments[e]);else i("play"),i("pause"),i("end"),i("seek");return this.newMeta(function(){this.done()})}preload(){return this.origin._addToPreload(),this.newMeta(function(){this.done()})}}(n)}}).call(this,n(3).Instruction,n(0).Abort,n(0).Ctrlr,n(0).PennController)},function(e,t,n){"use strict";var r=n(32),i=n(1),o=n(23),s=n(22),a=n(11),u=n(39),l=n(6);function c(e,t){this.options=e,this.loadOptions=t}c.prototype={isEncrypted:function(){return 1==(1&this.bitFlag)},useUTF8:function(){return 2048==(2048&this.bitFlag)},readLocalPart:function(e){var t,n;if(e.skip(22),this.fileNameLength=e.readInt(2),n=e.readInt(2),this.fileName=e.readData(this.fileNameLength),e.skip(n),-1===this.compressedSize||-1===this.uncompressedSize)throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory (compressedSize === -1 || uncompressedSize === -1)");if(null===(t=function(e){for(var t in u)if(u.hasOwnProperty(t)&&u[t].magic===e)return u[t];return null}(this.compressionMethod)))throw new Error("Corrupted zip : compression "+i.pretty(this.compressionMethod)+" unknown (inner file : "+i.transformTo("string",this.fileName)+")");this.decompressed=new o(this.compressedSize,this.uncompressedSize,this.crc32,t,e.readData(this.compressedSize))},readCentralPart:function(e){this.versionMadeBy=e.readInt(2),e.skip(2),this.bitFlag=e.readInt(2),this.compressionMethod=e.readString(2),this.date=e.readDate(),this.crc32=e.readInt(4),this.compressedSize=e.readInt(4),this.uncompressedSize=e.readInt(4);var t=e.readInt(2);if(this.extraFieldsLength=e.readInt(2),this.fileCommentLength=e.readInt(2),this.diskNumberStart=e.readInt(2),this.internalFileAttributes=e.readInt(2),this.externalFileAttributes=e.readInt(4),this.localHeaderOffset=e.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");e.skip(t),this.readExtraFields(e),this.parseZIP64ExtraField(e),this.fileComment=e.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var e=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),0===e&&(this.dosPermissions=63&this.externalFileAttributes),3===e&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||"/"!==this.fileNameStr.slice(-1)||(this.dir=!0)},parseZIP64ExtraField:function(e){if(this.extraFields[1]){var t=r(this.extraFields[1].value);this.uncompressedSize===i.MAX_VALUE_32BITS&&(this.uncompressedSize=t.readInt(8)),this.compressedSize===i.MAX_VALUE_32BITS&&(this.compressedSize=t.readInt(8)),this.localHeaderOffset===i.MAX_VALUE_32BITS&&(this.localHeaderOffset=t.readInt(8)),this.diskNumberStart===i.MAX_VALUE_32BITS&&(this.diskNumberStart=t.readInt(4))}},readExtraFields:function(e){var t,n,r,i=e.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});e.index<i;)t=e.readInt(2),n=e.readInt(2),r=e.readData(n),this.extraFields[t]={id:t,length:n,value:r}},handleUTF8:function(){var e=l.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=a.utf8decode(this.fileName),this.fileCommentStr=a.utf8decode(this.fileComment);else{var t=this.findExtraFieldUnicodePath();if(null!==t)this.fileNameStr=t;else{var n=i.transformTo(e,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(n)}var r=this.findExtraFieldUnicodeComment();if(null!==r)this.fileCommentStr=r;else{var o=i.transformTo(e,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(o)}}},findExtraFieldUnicodePath:function(){var e=this.extraFields[28789];if(e){var t=r(e.value);return 1!==t.readInt(1)?null:s(this.fileName)!==t.readInt(4)?null:a.utf8decode(t.readData(e.length-5))}return null},findExtraFieldUnicodeComment:function(){var e=this.extraFields[25461];if(e){var t=r(e.value);return 1!==t.readInt(1)?null:s(this.fileComment)!==t.readInt(4)?null:a.utf8decode(t.readData(e.length-5))}return null}},e.exports=c},function(e,t,n){"use strict";var r=n(29);function i(e){r.call(this,e)}n(1).inherits(i,r),i.prototype.readData=function(e){this.checkOffset(e);var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},e.exports=i},function(e,t,n){"use strict";var r=n(30);function i(e){r.call(this,e)}n(1).inherits(i,r),i.prototype.byteAt=function(e){return this.data.charCodeAt(this.zero+e)},i.prototype.lastIndexOfSignature=function(e){return this.data.lastIndexOf(e)-this.zero},i.prototype.readAndCheckSignature=function(e){return e===this.readData(4)},i.prototype.readData=function(e){this.checkOffset(e);var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},e.exports=i},function(e,t,n){"use strict";var r=n(32),i=n(1),o=n(33),s=n(80),a=(n(11),n(6));function u(e){this.files=[],this.loadOptions=e}u.prototype={checkSignature:function(e){if(!this.reader.readAndCheckSignature(e)){this.reader.index-=4;var t=this.reader.readString(4);throw new Error("Corrupted zip or bug: unexpected signature ("+i.pretty(t)+", expected "+i.pretty(e)+")")}},isSignature:function(e,t){var n=this.reader.index;this.reader.setIndex(e);var r=this.reader.readString(4)===t;return this.reader.setIndex(n),r},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var e=this.reader.readData(this.zipCommentLength),t=a.uint8array?"uint8array":"array",n=i.transformTo(t,e);this.zipComment=this.loadOptions.decodeFileName(n)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var e,t,n,r=this.zip64EndOfCentralSize-44;0<r;)e=this.reader.readInt(2),t=this.reader.readInt(4),n=this.reader.readData(t),this.zip64ExtensibleData[e]={id:e,length:t,value:n}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),this.disksCount>1)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var e,t;for(e=0;e<this.files.length;e++)t=this.files[e],this.reader.setIndex(t.localHeaderOffset),this.checkSignature(o.LOCAL_FILE_HEADER),t.readLocalPart(this.reader),t.handleUTF8(),t.processAttributes()},readCentralDir:function(){var e;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(o.CENTRAL_FILE_HEADER);)(e=new s({zip64:this.zip64},this.loadOptions)).readCentralPart(this.reader),this.files.push(e);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var e=this.reader.lastIndexOfSignature(o.CENTRAL_DIRECTORY_END);if(e<0)throw!this.isSignature(0,o.LOCAL_FILE_HEADER)?new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html"):new Error("Corrupted zip: can't find end of central directory");this.reader.setIndex(e);var t=e;if(this.checkSignature(o.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===i.MAX_VALUE_16BITS||this.diskWithCentralDirStart===i.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===i.MAX_VALUE_16BITS||this.centralDirRecords===i.MAX_VALUE_16BITS||this.centralDirSize===i.MAX_VALUE_32BITS||this.centralDirOffset===i.MAX_VALUE_32BITS){if(this.zip64=!0,(e=this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR))<0)throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(e),this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,o.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var n=this.centralDirOffset+this.centralDirSize;this.zip64&&(n+=20,n+=12+this.zip64EndOfCentralSize);var r=t-n;if(r>0)this.isSignature(t,o.CENTRAL_FILE_HEADER)||(this.reader.zero=r);else if(r<0)throw new Error("Corrupted zip: missing "+Math.abs(r)+" bytes.")},prepareReader:function(e){this.reader=r(e)},load:function(e){this.prepareReader(e),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},e.exports=u},function(e,t,n){"use strict";var r=n(1),i=n(12),o=n(11),s=(r=n(1),n(83)),a=n(40),u=n(16);function l(e){return new i.Promise(function(t,n){var r=e.decompressed.getContentWorker().pipe(new a);r.on("error",function(e){n(e)}).on("end",function(){r.streamInfo.crc32!==e.decompressed.crc32?n(new Error("Corrupted zip : CRC32 mismatch")):t()}).resume()})}e.exports=function(e,t){var n=this;return t=r.extend(t||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:o.utf8decode}),u.isNode&&u.isStream(e)?i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")):r.prepareContent("the loaded zip file",e,!0,t.optimizedBinaryString,t.base64).then(function(e){var n=new s(t);return n.load(e),n}).then(function(e){var n=[i.Promise.resolve(e)],r=e.files;if(t.checkCRC32)for(var o=0;o<r.length;o++)n.push(l(r[o]));return i.Promise.all(n)}).then(function(e){for(var r=e.shift(),i=r.files,o=0;o<i.length;o++){var s=i[o];n.file(s.fileNameStr,s.decompressed,{binary:!0,optimizedBinaryString:!0,date:s.date,dir:s.dir,comment:s.fileCommentStr.length?s.fileCommentStr:null,unixPermissions:s.unixPermissions,dosPermissions:s.dosPermissions,createFolders:t.createFolders})}return r.zipComment.length&&(n.comment=r.zipComment),n})}},function(e,t,n){"use strict";var r=n(1),i=n(4);function o(e,t){i.call(this,"Nodejs stream input adapter for "+e),this._upstreamEnded=!1,this._bindStream(t)}r.inherits(o,i),o.prototype._bindStream=function(e){var t=this;this._stream=e,e.pause(),e.on("data",function(e){t.push({data:e,meta:{percent:0}})}).on("error",function(e){t.isPaused?this.generatedError=e:t.error(e)}).on("end",function(){t.isPaused?t._upstreamEnded=!0:t.end()})},o.prototype.pause=function(){return!!i.prototype.pause.call(this)&&(this._stream.pause(),!0)},o.prototype.resume=function(){return!!i.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},e.exports=o},function(e,t,n){"use strict";var r=n(1),i=n(4),o=n(11),s=n(22),a=n(33),u=function(e,t){var n,r="";for(n=0;n<t;n++)r+=String.fromCharCode(255&e),e>>>=8;return r},l=function(e,t,n,i,l,c){var h,f,d=e.file,p=e.compression,g=c!==o.utf8encode,m=r.transformTo("string",c(d.name)),y=r.transformTo("string",o.utf8encode(d.name)),v=d.comment,b=r.transformTo("string",c(v)),w=r.transformTo("string",o.utf8encode(v)),_=y.length!==d.name.length,k=w.length!==v.length,x="",E="",S="",C=d.dir,P=d.date,R={crc32:0,compressedSize:0,uncompressedSize:0};t&&!n||(R.crc32=e.crc32,R.compressedSize=e.compressedSize,R.uncompressedSize=e.uncompressedSize);var A=0;t&&(A|=8),g||!_&&!k||(A|=2048);var T,O,I=0,B=0;C&&(I|=16),"UNIX"===l?(B=798,I|=(T=d.unixPermissions,O=T,T||(O=C?16893:33204),(65535&O)<<16)):(B=20,I|=63&(d.dosPermissions||0)),h=P.getUTCHours(),h<<=6,h|=P.getUTCMinutes(),h<<=5,h|=P.getUTCSeconds()/2,f=P.getUTCFullYear()-1980,f<<=4,f|=P.getUTCMonth()+1,f<<=5,f|=P.getUTCDate(),_&&(E=u(1,1)+u(s(m),4)+y,x+="up"+u(E.length,2)+E),k&&(S=u(1,1)+u(s(b),4)+w,x+="uc"+u(S.length,2)+S);var L="";return L+="\n\0",L+=u(A,2),L+=p.magic,L+=u(h,2),L+=u(f,2),L+=u(R.crc32,4),L+=u(R.compressedSize,4),L+=u(R.uncompressedSize,4),L+=u(m.length,2),L+=u(x.length,2),{fileRecord:a.LOCAL_FILE_HEADER+L+m+x,dirRecord:a.CENTRAL_FILE_HEADER+u(B,2)+L+u(b.length,2)+"\0\0\0\0"+u(I,4)+u(i,4)+m+x+b}};function c(e,t,n,r){i.call(this,"ZipFileWorker"),this.bytesWritten=0,this.zipComment=t,this.zipPlatform=n,this.encodeFileName=r,this.streamFiles=e,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[]}r.inherits(c,i),c.prototype.push=function(e){var t=e.meta.percent||0,n=this.entriesCount,r=this._sources.length;this.accumulate?this.contentBuffer.push(e):(this.bytesWritten+=e.data.length,i.prototype.push.call(this,{data:e.data,meta:{currentFile:this.currentFile,percent:n?(t+100*(n-r-1))/n:100}}))},c.prototype.openedSource=function(e){this.currentSourceOffset=this.bytesWritten,this.currentFile=e.file.name;var t=this.streamFiles&&!e.file.dir;if(t){var n=l(e,t,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:n.fileRecord,meta:{percent:0}})}else this.accumulate=!0},c.prototype.closedSource=function(e){this.accumulate=!1;var t=this.streamFiles&&!e.file.dir,n=l(e,t,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(n.dirRecord),t)this.push({data:function(e){return a.DATA_DESCRIPTOR+u(e.crc32,4)+u(e.compressedSize,4)+u(e.uncompressedSize,4)}(e),meta:{percent:100}});else for(this.push({data:n.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null},c.prototype.flush=function(){for(var e=this.bytesWritten,t=0;t<this.dirRecords.length;t++)this.push({data:this.dirRecords[t],meta:{percent:100}});var n=this.bytesWritten-e,i=function(e,t,n,i,o){var s=r.transformTo("string",o(i));return a.CENTRAL_DIRECTORY_END+"\0\0\0\0"+u(e,2)+u(e,2)+u(t,4)+u(n,4)+u(s.length,2)+s}(this.dirRecords.length,n,e,this.zipComment,this.encodeFileName);this.push({data:i,meta:{percent:100}})},c.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume()},c.prototype.registerPrevious=function(e){this._sources.push(e);var t=this;return e.on("data",function(e){t.processChunk(e)}),e.on("end",function(){t.closedSource(t.previous.streamInfo),t._sources.length?t.prepareNextSource():t.end()}),e.on("error",function(e){t.error(e)}),this},c.prototype.resume=function(){return!!i.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},c.prototype.error=function(e){var t=this._sources;if(!i.prototype.error.call(this,e))return!1;for(var n=0;n<t.length;n++)try{t[n].error(e)}catch(e){}return!0},c.prototype.lock=function(){i.prototype.lock.call(this);for(var e=this._sources,t=0;t<e.length;t++)e[t].lock()},e.exports=c},function(e,t,n){"use strict";e.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}},function(e,t,n){"use strict";var r=n(5),i=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],o=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],s=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],a=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];e.exports=function(e,t,n,u,l,c,h,f){var d,p,g,m,y,v,b,w,_,k=f.bits,x=0,E=0,S=0,C=0,P=0,R=0,A=0,T=0,O=0,I=0,B=null,L=0,D=new r.Buf16(16),N=new r.Buf16(16),z=null,M=0;for(x=0;x<=15;x++)D[x]=0;for(E=0;E<u;E++)D[t[n+E]]++;for(P=k,C=15;C>=1&&0===D[C];C--);if(P>C&&(P=C),0===C)return l[c++]=20971520,l[c++]=20971520,f.bits=1,0;for(S=1;S<C&&0===D[S];S++);for(P<S&&(P=S),T=1,x=1;x<=15;x++)if(T<<=1,(T-=D[x])<0)return-1;if(T>0&&(0===e||1!==C))return-1;for(N[1]=0,x=1;x<15;x++)N[x+1]=N[x]+D[x];for(E=0;E<u;E++)0!==t[n+E]&&(h[N[t[n+E]]++]=E);if(0===e?(B=z=h,v=19):1===e?(B=i,L-=257,z=o,M-=257,v=256):(B=s,z=a,v=-1),I=0,E=0,x=S,y=c,R=P,A=0,g=-1,m=(O=1<<P)-1,1===e&&O>852||2===e&&O>592)return 1;for(;;){b=x-A,h[E]<v?(w=0,_=h[E]):h[E]>v?(w=z[M+h[E]],_=B[L+h[E]]):(w=96,_=0),d=1<<x-A,S=p=1<<R;do{l[y+(I>>A)+(p-=d)]=b<<24|w<<16|_|0}while(0!==p);for(d=1<<x-1;I&d;)d>>=1;if(0!==d?(I&=d-1,I+=d):I=0,E++,0==--D[x]){if(x===C)break;x=t[n+h[E]]}if(x>P&&(I&m)!==g){for(0===A&&(A=P),y+=S,T=1<<(R=x-A);R+A<C&&!((T-=D[R+A])<=0);)R++,T<<=1;if(O+=1<<R,1===e&&O>852||2===e&&O>592)return 1;l[g=I&m]=P<<24|R<<16|y-c|0}}return 0!==I&&(l[y+I]=x-A<<24|64<<16|0),f.bits=P,0}},function(e,t,n){"use strict";e.exports=function(e,t){var n,r,i,o,s,a,u,l,c,h,f,d,p,g,m,y,v,b,w,_,k,x,E,S,C;n=e.state,r=e.next_in,S=e.input,i=r+(e.avail_in-5),o=e.next_out,C=e.output,s=o-(t-e.avail_out),a=o+(e.avail_out-257),u=n.dmax,l=n.wsize,c=n.whave,h=n.wnext,f=n.window,d=n.hold,p=n.bits,g=n.lencode,m=n.distcode,y=(1<<n.lenbits)-1,v=(1<<n.distbits)-1;e:do{p<15&&(d+=S[r++]<<p,p+=8,d+=S[r++]<<p,p+=8),b=g[d&y];t:for(;;){if(d>>>=w=b>>>24,p-=w,0===(w=b>>>16&255))C[o++]=65535&b;else{if(!(16&w)){if(0==(64&w)){b=g[(65535&b)+(d&(1<<w)-1)];continue t}if(32&w){n.mode=12;break e}e.msg="invalid literal/length code",n.mode=30;break e}_=65535&b,(w&=15)&&(p<w&&(d+=S[r++]<<p,p+=8),_+=d&(1<<w)-1,d>>>=w,p-=w),p<15&&(d+=S[r++]<<p,p+=8,d+=S[r++]<<p,p+=8),b=m[d&v];n:for(;;){if(d>>>=w=b>>>24,p-=w,!(16&(w=b>>>16&255))){if(0==(64&w)){b=m[(65535&b)+(d&(1<<w)-1)];continue n}e.msg="invalid distance code",n.mode=30;break e}if(k=65535&b,p<(w&=15)&&(d+=S[r++]<<p,(p+=8)<w&&(d+=S[r++]<<p,p+=8)),(k+=d&(1<<w)-1)>u){e.msg="invalid distance too far back",n.mode=30;break e}if(d>>>=w,p-=w,k>(w=o-s)){if((w=k-w)>c&&n.sane){e.msg="invalid distance too far back",n.mode=30;break e}if(x=0,E=f,0===h){if(x+=l-w,w<_){_-=w;do{C[o++]=f[x++]}while(--w);x=o-k,E=C}}else if(h<w){if(x+=l+h-w,(w-=h)<_){_-=w;do{C[o++]=f[x++]}while(--w);if(x=0,h<_){_-=w=h;do{C[o++]=f[x++]}while(--w);x=o-k,E=C}}}else if(x+=h-w,w<_){_-=w;do{C[o++]=f[x++]}while(--w);x=o-k,E=C}for(;_>2;)C[o++]=E[x++],C[o++]=E[x++],C[o++]=E[x++],_-=3;_&&(C[o++]=E[x++],_>1&&(C[o++]=E[x++]))}else{x=o-k;do{C[o++]=C[x++],C[o++]=C[x++],C[o++]=C[x++],_-=3}while(_>2);_&&(C[o++]=C[x++],_>1&&(C[o++]=C[x++]))}break}}break}}while(r<i&&o<a);r-=_=p>>3,d&=(1<<(p-=_<<3))-1,e.next_in=r,e.next_out=o,e.avail_in=r<i?i-r+5:5-(r-i),e.avail_out=o<a?a-o+257:257-(o-a),n.hold=d,n.bits=p}},function(e,t,n){"use strict";var r=n(5),i=n(38),o=n(37),s=n(89),a=n(88),u=0,l=1,c=2,h=4,f=5,d=6,p=0,g=1,m=2,y=-2,v=-3,b=-4,w=-5,_=8,k=1,x=2,E=3,S=4,C=5,P=6,R=7,A=8,T=9,O=10,I=11,B=12,L=13,D=14,N=15,z=16,M=17,U=18,F=19,j=20,W=21,$=22,Y=23,Z=24,V=25,H=26,q=27,K=28,X=29,Q=30,G=31,J=32,ee=852,te=592,ne=15;function re(e){return(e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24)}function ie(e){var t;return e&&e.state?(t=e.state,e.total_in=e.total_out=t.total=0,e.msg="",t.wrap&&(e.adler=1&t.wrap),t.mode=k,t.last=0,t.havedict=0,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new r.Buf32(ee),t.distcode=t.distdyn=new r.Buf32(te),t.sane=1,t.back=-1,p):y}function oe(e){var t;return e&&e.state?((t=e.state).wsize=0,t.whave=0,t.wnext=0,ie(e)):y}function se(e,t){var n,r;return e&&e.state?(r=e.state,t<0?(n=0,t=-t):(n=1+(t>>4),t<48&&(t&=15)),t&&(t<8||t>15)?y:(null!==r.window&&r.wbits!==t&&(r.window=null),r.wrap=n,r.wbits=t,oe(e))):y}function ae(e,t){var n,i;return e?(i=new function(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new r.Buf16(320),this.work=new r.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0},e.state=i,i.window=null,(n=se(e,t))!==p&&(e.state=null),n):y}var ue,le,ce=!0;function he(e){if(ce){var t;for(ue=new r.Buf32(512),le=new r.Buf32(32),t=0;t<144;)e.lens[t++]=8;for(;t<256;)e.lens[t++]=9;for(;t<280;)e.lens[t++]=7;for(;t<288;)e.lens[t++]=8;for(a(l,e.lens,0,288,ue,0,e.work,{bits:9}),t=0;t<32;)e.lens[t++]=5;a(c,e.lens,0,32,le,0,e.work,{bits:5}),ce=!1}e.lencode=ue,e.lenbits=9,e.distcode=le,e.distbits=5}function fe(e,t,n,i){var o,s=e.state;return null===s.window&&(s.wsize=1<<s.wbits,s.wnext=0,s.whave=0,s.window=new r.Buf8(s.wsize)),i>=s.wsize?(r.arraySet(s.window,t,n-s.wsize,s.wsize,0),s.wnext=0,s.whave=s.wsize):((o=s.wsize-s.wnext)>i&&(o=i),r.arraySet(s.window,t,n-i,o,s.wnext),(i-=o)?(r.arraySet(s.window,t,n-i,i,0),s.wnext=i,s.whave=s.wsize):(s.wnext+=o,s.wnext===s.wsize&&(s.wnext=0),s.whave<s.wsize&&(s.whave+=o))),0}t.inflateReset=oe,t.inflateReset2=se,t.inflateResetKeep=ie,t.inflateInit=function(e){return ae(e,ne)},t.inflateInit2=ae,t.inflate=function(e,t){var n,ee,te,ne,ie,oe,se,ae,ue,le,ce,de,pe,ge,me,ye,ve,be,we,_e,ke,xe,Ee,Se,Ce=0,Pe=new r.Buf8(4),Re=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!e||!e.state||!e.output||!e.input&&0!==e.avail_in)return y;(n=e.state).mode===B&&(n.mode=L),ie=e.next_out,te=e.output,se=e.avail_out,ne=e.next_in,ee=e.input,oe=e.avail_in,ae=n.hold,ue=n.bits,le=oe,ce=se,xe=p;e:for(;;)switch(n.mode){case k:if(0===n.wrap){n.mode=L;break}for(;ue<16;){if(0===oe)break e;oe--,ae+=ee[ne++]<<ue,ue+=8}if(2&n.wrap&&35615===ae){n.check=0,Pe[0]=255&ae,Pe[1]=ae>>>8&255,n.check=o(n.check,Pe,2,0),ae=0,ue=0,n.mode=x;break}if(n.flags=0,n.head&&(n.head.done=!1),!(1&n.wrap)||(((255&ae)<<8)+(ae>>8))%31){e.msg="incorrect header check",n.mode=Q;break}if((15&ae)!==_){e.msg="unknown compression method",n.mode=Q;break}if(ue-=4,ke=8+(15&(ae>>>=4)),0===n.wbits)n.wbits=ke;else if(ke>n.wbits){e.msg="invalid window size",n.mode=Q;break}n.dmax=1<<ke,e.adler=n.check=1,n.mode=512&ae?O:B,ae=0,ue=0;break;case x:for(;ue<16;){if(0===oe)break e;oe--,ae+=ee[ne++]<<ue,ue+=8}if(n.flags=ae,(255&n.flags)!==_){e.msg="unknown compression method",n.mode=Q;break}if(57344&n.flags){e.msg="unknown header flags set",n.mode=Q;break}n.head&&(n.head.text=ae>>8&1),512&n.flags&&(Pe[0]=255&ae,Pe[1]=ae>>>8&255,n.check=o(n.check,Pe,2,0)),ae=0,ue=0,n.mode=E;case E:for(;ue<32;){if(0===oe)break e;oe--,ae+=ee[ne++]<<ue,ue+=8}n.head&&(n.head.time=ae),512&n.flags&&(Pe[0]=255&ae,Pe[1]=ae>>>8&255,Pe[2]=ae>>>16&255,Pe[3]=ae>>>24&255,n.check=o(n.check,Pe,4,0)),ae=0,ue=0,n.mode=S;case S:for(;ue<16;){if(0===oe)break e;oe--,ae+=ee[ne++]<<ue,ue+=8}n.head&&(n.head.xflags=255&ae,n.head.os=ae>>8),512&n.flags&&(Pe[0]=255&ae,Pe[1]=ae>>>8&255,n.check=o(n.check,Pe,2,0)),ae=0,ue=0,n.mode=C;case C:if(1024&n.flags){for(;ue<16;){if(0===oe)break e;oe--,ae+=ee[ne++]<<ue,ue+=8}n.length=ae,n.head&&(n.head.extra_len=ae),512&n.flags&&(Pe[0]=255&ae,Pe[1]=ae>>>8&255,n.check=o(n.check,Pe,2,0)),ae=0,ue=0}else n.head&&(n.head.extra=null);n.mode=P;case P:if(1024&n.flags&&((de=n.length)>oe&&(de=oe),de&&(n.head&&(ke=n.head.extra_len-n.length,n.head.extra||(n.head.extra=new Array(n.head.extra_len)),r.arraySet(n.head.extra,ee,ne,de,ke)),512&n.flags&&(n.check=o(n.check,ee,de,ne)),oe-=de,ne+=de,n.length-=de),n.length))break e;n.length=0,n.mode=R;case R:if(2048&n.flags){if(0===oe)break e;de=0;do{ke=ee[ne+de++],n.head&&ke&&n.length<65536&&(n.head.name+=String.fromCharCode(ke))}while(ke&&de<oe);if(512&n.flags&&(n.check=o(n.check,ee,de,ne)),oe-=de,ne+=de,ke)break e}else n.head&&(n.head.name=null);n.length=0,n.mode=A;case A:if(4096&n.flags){if(0===oe)break e;de=0;do{ke=ee[ne+de++],n.head&&ke&&n.length<65536&&(n.head.comment+=String.fromCharCode(ke))}while(ke&&de<oe);if(512&n.flags&&(n.check=o(n.check,ee,de,ne)),oe-=de,ne+=de,ke)break e}else n.head&&(n.head.comment=null);n.mode=T;case T:if(512&n.flags){for(;ue<16;){if(0===oe)break e;oe--,ae+=ee[ne++]<<ue,ue+=8}if(ae!==(65535&n.check)){e.msg="header crc mismatch",n.mode=Q;break}ae=0,ue=0}n.head&&(n.head.hcrc=n.flags>>9&1,n.head.done=!0),e.adler=n.check=0,n.mode=B;break;case O:for(;ue<32;){if(0===oe)break e;oe--,ae+=ee[ne++]<<ue,ue+=8}e.adler=n.check=re(ae),ae=0,ue=0,n.mode=I;case I:if(0===n.havedict)return e.next_out=ie,e.avail_out=se,e.next_in=ne,e.avail_in=oe,n.hold=ae,n.bits=ue,m;e.adler=n.check=1,n.mode=B;case B:if(t===f||t===d)break e;case L:if(n.last){ae>>>=7&ue,ue-=7&ue,n.mode=q;break}for(;ue<3;){if(0===oe)break e;oe--,ae+=ee[ne++]<<ue,ue+=8}switch(n.last=1&ae,ue-=1,3&(ae>>>=1)){case 0:n.mode=D;break;case 1:if(he(n),n.mode=j,t===d){ae>>>=2,ue-=2;break e}break;case 2:n.mode=M;break;case 3:e.msg="invalid block type",n.mode=Q}ae>>>=2,ue-=2;break;case D:for(ae>>>=7&ue,ue-=7&ue;ue<32;){if(0===oe)break e;oe--,ae+=ee[ne++]<<ue,ue+=8}if((65535&ae)!=(ae>>>16^65535)){e.msg="invalid stored block lengths",n.mode=Q;break}if(n.length=65535&ae,ae=0,ue=0,n.mode=N,t===d)break e;case N:n.mode=z;case z:if(de=n.length){if(de>oe&&(de=oe),de>se&&(de=se),0===de)break e;r.arraySet(te,ee,ne,de,ie),oe-=de,ne+=de,se-=de,ie+=de,n.length-=de;break}n.mode=B;break;case M:for(;ue<14;){if(0===oe)break e;oe--,ae+=ee[ne++]<<ue,ue+=8}if(n.nlen=257+(31&ae),ae>>>=5,ue-=5,n.ndist=1+(31&ae),ae>>>=5,ue-=5,n.ncode=4+(15&ae),ae>>>=4,ue-=4,n.nlen>286||n.ndist>30){e.msg="too many length or distance symbols",n.mode=Q;break}n.have=0,n.mode=U;case U:for(;n.have<n.ncode;){for(;ue<3;){if(0===oe)break e;oe--,ae+=ee[ne++]<<ue,ue+=8}n.lens[Re[n.have++]]=7&ae,ae>>>=3,ue-=3}for(;n.have<19;)n.lens[Re[n.have++]]=0;if(n.lencode=n.lendyn,n.lenbits=7,Ee={bits:n.lenbits},xe=a(u,n.lens,0,19,n.lencode,0,n.work,Ee),n.lenbits=Ee.bits,xe){e.msg="invalid code lengths set",n.mode=Q;break}n.have=0,n.mode=F;case F:for(;n.have<n.nlen+n.ndist;){for(;ye=(Ce=n.lencode[ae&(1<<n.lenbits)-1])>>>16&255,ve=65535&Ce,!((me=Ce>>>24)<=ue);){if(0===oe)break e;oe--,ae+=ee[ne++]<<ue,ue+=8}if(ve<16)ae>>>=me,ue-=me,n.lens[n.have++]=ve;else{if(16===ve){for(Se=me+2;ue<Se;){if(0===oe)break e;oe--,ae+=ee[ne++]<<ue,ue+=8}if(ae>>>=me,ue-=me,0===n.have){e.msg="invalid bit length repeat",n.mode=Q;break}ke=n.lens[n.have-1],de=3+(3&ae),ae>>>=2,ue-=2}else if(17===ve){for(Se=me+3;ue<Se;){if(0===oe)break e;oe--,ae+=ee[ne++]<<ue,ue+=8}ue-=me,ke=0,de=3+(7&(ae>>>=me)),ae>>>=3,ue-=3}else{for(Se=me+7;ue<Se;){if(0===oe)break e;oe--,ae+=ee[ne++]<<ue,ue+=8}ue-=me,ke=0,de=11+(127&(ae>>>=me)),ae>>>=7,ue-=7}if(n.have+de>n.nlen+n.ndist){e.msg="invalid bit length repeat",n.mode=Q;break}for(;de--;)n.lens[n.have++]=ke}}if(n.mode===Q)break;if(0===n.lens[256]){e.msg="invalid code -- missing end-of-block",n.mode=Q;break}if(n.lenbits=9,Ee={bits:n.lenbits},xe=a(l,n.lens,0,n.nlen,n.lencode,0,n.work,Ee),n.lenbits=Ee.bits,xe){e.msg="invalid literal/lengths set",n.mode=Q;break}if(n.distbits=6,n.distcode=n.distdyn,Ee={bits:n.distbits},xe=a(c,n.lens,n.nlen,n.ndist,n.distcode,0,n.work,Ee),n.distbits=Ee.bits,xe){e.msg="invalid distances set",n.mode=Q;break}if(n.mode=j,t===d)break e;case j:n.mode=W;case W:if(oe>=6&&se>=258){e.next_out=ie,e.avail_out=se,e.next_in=ne,e.avail_in=oe,n.hold=ae,n.bits=ue,s(e,ce),ie=e.next_out,te=e.output,se=e.avail_out,ne=e.next_in,ee=e.input,oe=e.avail_in,ae=n.hold,ue=n.bits,n.mode===B&&(n.back=-1);break}for(n.back=0;ye=(Ce=n.lencode[ae&(1<<n.lenbits)-1])>>>16&255,ve=65535&Ce,!((me=Ce>>>24)<=ue);){if(0===oe)break e;oe--,ae+=ee[ne++]<<ue,ue+=8}if(ye&&0==(240&ye)){for(be=me,we=ye,_e=ve;ye=(Ce=n.lencode[_e+((ae&(1<<be+we)-1)>>be)])>>>16&255,ve=65535&Ce,!(be+(me=Ce>>>24)<=ue);){if(0===oe)break e;oe--,ae+=ee[ne++]<<ue,ue+=8}ae>>>=be,ue-=be,n.back+=be}if(ae>>>=me,ue-=me,n.back+=me,n.length=ve,0===ye){n.mode=H;break}if(32&ye){n.back=-1,n.mode=B;break}if(64&ye){e.msg="invalid literal/length code",n.mode=Q;break}n.extra=15&ye,n.mode=$;case $:if(n.extra){for(Se=n.extra;ue<Se;){if(0===oe)break e;oe--,ae+=ee[ne++]<<ue,ue+=8}n.length+=ae&(1<<n.extra)-1,ae>>>=n.extra,ue-=n.extra,n.back+=n.extra}n.was=n.length,n.mode=Y;case Y:for(;ye=(Ce=n.distcode[ae&(1<<n.distbits)-1])>>>16&255,ve=65535&Ce,!((me=Ce>>>24)<=ue);){if(0===oe)break e;oe--,ae+=ee[ne++]<<ue,ue+=8}if(0==(240&ye)){for(be=me,we=ye,_e=ve;ye=(Ce=n.distcode[_e+((ae&(1<<be+we)-1)>>be)])>>>16&255,ve=65535&Ce,!(be+(me=Ce>>>24)<=ue);){if(0===oe)break e;oe--,ae+=ee[ne++]<<ue,ue+=8}ae>>>=be,ue-=be,n.back+=be}if(ae>>>=me,ue-=me,n.back+=me,64&ye){e.msg="invalid distance code",n.mode=Q;break}n.offset=ve,n.extra=15&ye,n.mode=Z;case Z:if(n.extra){for(Se=n.extra;ue<Se;){if(0===oe)break e;oe--,ae+=ee[ne++]<<ue,ue+=8}n.offset+=ae&(1<<n.extra)-1,ae>>>=n.extra,ue-=n.extra,n.back+=n.extra}if(n.offset>n.dmax){e.msg="invalid distance too far back",n.mode=Q;break}n.mode=V;case V:if(0===se)break e;if(de=ce-se,n.offset>de){if((de=n.offset-de)>n.whave&&n.sane){e.msg="invalid distance too far back",n.mode=Q;break}de>n.wnext?(de-=n.wnext,pe=n.wsize-de):pe=n.wnext-de,de>n.length&&(de=n.length),ge=n.window}else ge=te,pe=ie-n.offset,de=n.length;de>se&&(de=se),se-=de,n.length-=de;do{te[ie++]=ge[pe++]}while(--de);0===n.length&&(n.mode=W);break;case H:if(0===se)break e;te[ie++]=n.length,se--,n.mode=W;break;case q:if(n.wrap){for(;ue<32;){if(0===oe)break e;oe--,ae|=ee[ne++]<<ue,ue+=8}if(ce-=se,e.total_out+=ce,n.total+=ce,ce&&(e.adler=n.check=n.flags?o(n.check,te,ce,ie-ce):i(n.check,te,ce,ie-ce)),ce=se,(n.flags?ae:re(ae))!==n.check){e.msg="incorrect data check",n.mode=Q;break}ae=0,ue=0}n.mode=K;case K:if(n.wrap&&n.flags){for(;ue<32;){if(0===oe)break e;oe--,ae+=ee[ne++]<<ue,ue+=8}if(ae!==(4294967295&n.total)){e.msg="incorrect length check",n.mode=Q;break}ae=0,ue=0}n.mode=X;case X:xe=g;break e;case Q:xe=v;break e;case G:return b;case J:default:return y}return e.next_out=ie,e.avail_out=se,e.next_in=ne,e.avail_in=oe,n.hold=ae,n.bits=ue,(n.wsize||ce!==e.avail_out&&n.mode<Q&&(n.mode<q||t!==h))&&fe(e,e.output,e.next_out,ce-e.avail_out)?(n.mode=G,b):(le-=e.avail_in,ce-=e.avail_out,e.total_in+=le,e.total_out+=ce,n.total+=ce,n.wrap&&ce&&(e.adler=n.check=n.flags?o(n.check,te,ce,e.next_out-ce):i(n.check,te,ce,e.next_out-ce)),e.data_type=n.bits+(n.last?64:0)+(n.mode===B?128:0)+(n.mode===j||n.mode===N?256:0),(0===le&&0===ce||t===h)&&xe===p&&(xe=w),xe)},t.inflateEnd=function(e){if(!e||!e.state)return y;var t=e.state;return t.window&&(t.window=null),e.state=null,p},t.inflateGetHeader=function(e,t){var n;return e&&e.state?0==(2&(n=e.state).wrap)?y:(n.head=t,t.done=!1,p):y},t.inflateSetDictionary=function(e,t){var n,r=t.length;return e&&e.state?0!==(n=e.state).wrap&&n.mode!==I?y:n.mode===I&&i(1,t,r,0)!==n.check?v:fe(e,t,r,r)?(n.mode=G,b):(n.havedict=1,p):y},t.inflateInfo="pako inflate (from Nodeca project)"},function(e,t,n){"use strict";var r=n(90),i=n(5),o=n(36),s=n(34),a=n(21),u=n(35),l=n(87),c=Object.prototype.toString;function h(e){if(!(this instanceof h))return new h(e);this.options=i.assign({chunkSize:16384,windowBits:0,to:""},e||{});var t=this.options;t.raw&&t.windowBits>=0&&t.windowBits<16&&(t.windowBits=-t.windowBits,0===t.windowBits&&(t.windowBits=-15)),!(t.windowBits>=0&&t.windowBits<16)||e&&e.windowBits||(t.windowBits+=32),t.windowBits>15&&t.windowBits<48&&0==(15&t.windowBits)&&(t.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new u,this.strm.avail_out=0;var n=r.inflateInit2(this.strm,t.windowBits);if(n!==s.Z_OK)throw new Error(a[n]);this.header=new l,r.inflateGetHeader(this.strm,this.header)}function f(e,t){var n=new h(t);if(n.push(e,!0),n.err)throw n.msg||a[n.err];return n.result}h.prototype.push=function(e,t){var n,a,u,l,h,f,d=this.strm,p=this.options.chunkSize,g=this.options.dictionary,m=!1;if(this.ended)return!1;a=t===~~t?t:!0===t?s.Z_FINISH:s.Z_NO_FLUSH,"string"==typeof e?d.input=o.binstring2buf(e):"[object ArrayBuffer]"===c.call(e)?d.input=new Uint8Array(e):d.input=e,d.next_in=0,d.avail_in=d.input.length;do{if(0===d.avail_out&&(d.output=new i.Buf8(p),d.next_out=0,d.avail_out=p),(n=r.inflate(d,s.Z_NO_FLUSH))===s.Z_NEED_DICT&&g&&(f="string"==typeof g?o.string2buf(g):"[object ArrayBuffer]"===c.call(g)?new Uint8Array(g):g,n=r.inflateSetDictionary(this.strm,f)),n===s.Z_BUF_ERROR&&!0===m&&(n=s.Z_OK,m=!1),n!==s.Z_STREAM_END&&n!==s.Z_OK)return this.onEnd(n),this.ended=!0,!1;d.next_out&&(0!==d.avail_out&&n!==s.Z_STREAM_END&&(0!==d.avail_in||a!==s.Z_FINISH&&a!==s.Z_SYNC_FLUSH)||("string"===this.options.to?(u=o.utf8border(d.output,d.next_out),l=d.next_out-u,h=o.buf2string(d.output,u),d.next_out=l,d.avail_out=p-l,l&&i.arraySet(d.output,d.output,u,l,0),this.onData(h)):this.onData(i.shrinkBuf(d.output,d.next_out)))),0===d.avail_in&&0===d.avail_out&&(m=!0)}while((d.avail_in>0||0===d.avail_out)&&n!==s.Z_STREAM_END);return n===s.Z_STREAM_END&&(a=s.Z_FINISH),a===s.Z_FINISH?(n=r.inflateEnd(this.strm),this.onEnd(n),this.ended=!0,n===s.Z_OK):a!==s.Z_SYNC_FLUSH||(this.onEnd(s.Z_OK),d.avail_out=0,!0)},h.prototype.onData=function(e){this.chunks.push(e)},h.prototype.onEnd=function(e){e===s.Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=i.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg},t.Inflate=h,t.inflate=f,t.inflateRaw=function(e,t){return(t=t||{}).raw=!0,f(e,t)},t.ungzip=f},function(e,t,n){"use strict";var r=n(5),i=4,o=0,s=1,a=2;function u(e){for(var t=e.length;--t>=0;)e[t]=0}var l=0,c=1,h=2,f=29,d=256,p=d+1+f,g=30,m=19,y=2*p+1,v=15,b=16,w=7,_=256,k=16,x=17,E=18,S=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],C=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],P=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],R=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],A=new Array(2*(p+2));u(A);var T=new Array(2*g);u(T);var O=new Array(512);u(O);var I=new Array(256);u(I);var B=new Array(f);u(B);var L,D,N,z=new Array(g);function M(e,t,n,r,i){this.static_tree=e,this.extra_bits=t,this.extra_base=n,this.elems=r,this.max_length=i,this.has_stree=e&&e.length}function U(e,t){this.dyn_tree=e,this.max_code=0,this.stat_desc=t}function F(e){return e<256?O[e]:O[256+(e>>>7)]}function j(e,t){e.pending_buf[e.pending++]=255&t,e.pending_buf[e.pending++]=t>>>8&255}function W(e,t,n){e.bi_valid>b-n?(e.bi_buf|=t<<e.bi_valid&65535,j(e,e.bi_buf),e.bi_buf=t>>b-e.bi_valid,e.bi_valid+=n-b):(e.bi_buf|=t<<e.bi_valid&65535,e.bi_valid+=n)}function $(e,t,n){W(e,n[2*t],n[2*t+1])}function Y(e,t){var n=0;do{n|=1&e,e>>>=1,n<<=1}while(--t>0);return n>>>1}function Z(e,t,n){var r,i,o=new Array(v+1),s=0;for(r=1;r<=v;r++)o[r]=s=s+n[r-1]<<1;for(i=0;i<=t;i++){var a=e[2*i+1];0!==a&&(e[2*i]=Y(o[a]++,a))}}function V(e){var t;for(t=0;t<p;t++)e.dyn_ltree[2*t]=0;for(t=0;t<g;t++)e.dyn_dtree[2*t]=0;for(t=0;t<m;t++)e.bl_tree[2*t]=0;e.dyn_ltree[2*_]=1,e.opt_len=e.static_len=0,e.last_lit=e.matches=0}function H(e){e.bi_valid>8?j(e,e.bi_buf):e.bi_valid>0&&(e.pending_buf[e.pending++]=e.bi_buf),e.bi_buf=0,e.bi_valid=0}function q(e,t,n,r){var i=2*t,o=2*n;return e[i]<e[o]||e[i]===e[o]&&r[t]<=r[n]}function K(e,t,n){for(var r=e.heap[n],i=n<<1;i<=e.heap_len&&(i<e.heap_len&&q(t,e.heap[i+1],e.heap[i],e.depth)&&i++,!q(t,r,e.heap[i],e.depth));)e.heap[n]=e.heap[i],n=i,i<<=1;e.heap[n]=r}function X(e,t,n){var r,i,o,s,a=0;if(0!==e.last_lit)do{r=e.pending_buf[e.d_buf+2*a]<<8|e.pending_buf[e.d_buf+2*a+1],i=e.pending_buf[e.l_buf+a],a++,0===r?$(e,i,t):($(e,(o=I[i])+d+1,t),0!==(s=S[o])&&W(e,i-=B[o],s),$(e,o=F(--r),n),0!==(s=C[o])&&W(e,r-=z[o],s))}while(a<e.last_lit);$(e,_,t)}function Q(e,t){var n,r,i,o=t.dyn_tree,s=t.stat_desc.static_tree,a=t.stat_desc.has_stree,u=t.stat_desc.elems,l=-1;for(e.heap_len=0,e.heap_max=y,n=0;n<u;n++)0!==o[2*n]?(e.heap[++e.heap_len]=l=n,e.depth[n]=0):o[2*n+1]=0;for(;e.heap_len<2;)o[2*(i=e.heap[++e.heap_len]=l<2?++l:0)]=1,e.depth[i]=0,e.opt_len--,a&&(e.static_len-=s[2*i+1]);for(t.max_code=l,n=e.heap_len>>1;n>=1;n--)K(e,o,n);i=u;do{n=e.heap[1],e.heap[1]=e.heap[e.heap_len--],K(e,o,1),r=e.heap[1],e.heap[--e.heap_max]=n,e.heap[--e.heap_max]=r,o[2*i]=o[2*n]+o[2*r],e.depth[i]=(e.depth[n]>=e.depth[r]?e.depth[n]:e.depth[r])+1,o[2*n+1]=o[2*r+1]=i,e.heap[1]=i++,K(e,o,1)}while(e.heap_len>=2);e.heap[--e.heap_max]=e.heap[1],function(e,t){var n,r,i,o,s,a,u=t.dyn_tree,l=t.max_code,c=t.stat_desc.static_tree,h=t.stat_desc.has_stree,f=t.stat_desc.extra_bits,d=t.stat_desc.extra_base,p=t.stat_desc.max_length,g=0;for(o=0;o<=v;o++)e.bl_count[o]=0;for(u[2*e.heap[e.heap_max]+1]=0,n=e.heap_max+1;n<y;n++)(o=u[2*u[2*(r=e.heap[n])+1]+1]+1)>p&&(o=p,g++),u[2*r+1]=o,r>l||(e.bl_count[o]++,s=0,r>=d&&(s=f[r-d]),a=u[2*r],e.opt_len+=a*(o+s),h&&(e.static_len+=a*(c[2*r+1]+s)));if(0!==g){do{for(o=p-1;0===e.bl_count[o];)o--;e.bl_count[o]--,e.bl_count[o+1]+=2,e.bl_count[p]--,g-=2}while(g>0);for(o=p;0!==o;o--)for(r=e.bl_count[o];0!==r;)(i=e.heap[--n])>l||(u[2*i+1]!==o&&(e.opt_len+=(o-u[2*i+1])*u[2*i],u[2*i+1]=o),r--)}}(e,t),Z(o,l,e.bl_count)}function G(e,t,n){var r,i,o=-1,s=t[1],a=0,u=7,l=4;for(0===s&&(u=138,l=3),t[2*(n+1)+1]=65535,r=0;r<=n;r++)i=s,s=t[2*(r+1)+1],++a<u&&i===s||(a<l?e.bl_tree[2*i]+=a:0!==i?(i!==o&&e.bl_tree[2*i]++,e.bl_tree[2*k]++):a<=10?e.bl_tree[2*x]++:e.bl_tree[2*E]++,a=0,o=i,0===s?(u=138,l=3):i===s?(u=6,l=3):(u=7,l=4))}function J(e,t,n){var r,i,o=-1,s=t[1],a=0,u=7,l=4;for(0===s&&(u=138,l=3),r=0;r<=n;r++)if(i=s,s=t[2*(r+1)+1],!(++a<u&&i===s)){if(a<l)do{$(e,i,e.bl_tree)}while(0!=--a);else 0!==i?(i!==o&&($(e,i,e.bl_tree),a--),$(e,k,e.bl_tree),W(e,a-3,2)):a<=10?($(e,x,e.bl_tree),W(e,a-3,3)):($(e,E,e.bl_tree),W(e,a-11,7));a=0,o=i,0===s?(u=138,l=3):i===s?(u=6,l=3):(u=7,l=4)}}u(z);var ee=!1;function te(e,t,n,i){W(e,(l<<1)+(i?1:0),3),function(e,t,n,i){H(e),i&&(j(e,n),j(e,~n)),r.arraySet(e.pending_buf,e.window,t,n,e.pending),e.pending+=n}(e,t,n,!0)}t._tr_init=function(e){ee||(function(){var e,t,n,r,i,o=new Array(v+1);for(n=0,r=0;r<f-1;r++)for(B[r]=n,e=0;e<1<<S[r];e++)I[n++]=r;for(I[n-1]=r,i=0,r=0;r<16;r++)for(z[r]=i,e=0;e<1<<C[r];e++)O[i++]=r;for(i>>=7;r<g;r++)for(z[r]=i<<7,e=0;e<1<<C[r]-7;e++)O[256+i++]=r;for(t=0;t<=v;t++)o[t]=0;for(e=0;e<=143;)A[2*e+1]=8,e++,o[8]++;for(;e<=255;)A[2*e+1]=9,e++,o[9]++;for(;e<=279;)A[2*e+1]=7,e++,o[7]++;for(;e<=287;)A[2*e+1]=8,e++,o[8]++;for(Z(A,p+1,o),e=0;e<g;e++)T[2*e+1]=5,T[2*e]=Y(e,5);L=new M(A,S,d+1,p,v),D=new M(T,C,0,g,v),N=new M(new Array(0),P,0,m,w)}(),ee=!0),e.l_desc=new U(e.dyn_ltree,L),e.d_desc=new U(e.dyn_dtree,D),e.bl_desc=new U(e.bl_tree,N),e.bi_buf=0,e.bi_valid=0,V(e)},t._tr_stored_block=te,t._tr_flush_block=function(e,t,n,r){var u,l,f=0;e.level>0?(e.strm.data_type===a&&(e.strm.data_type=function(e){var t,n=4093624447;for(t=0;t<=31;t++,n>>>=1)if(1&n&&0!==e.dyn_ltree[2*t])return o;if(0!==e.dyn_ltree[18]||0!==e.dyn_ltree[20]||0!==e.dyn_ltree[26])return s;for(t=32;t<d;t++)if(0!==e.dyn_ltree[2*t])return s;return o}(e)),Q(e,e.l_desc),Q(e,e.d_desc),f=function(e){var t;for(G(e,e.dyn_ltree,e.l_desc.max_code),G(e,e.dyn_dtree,e.d_desc.max_code),Q(e,e.bl_desc),t=m-1;t>=3&&0===e.bl_tree[2*R[t]+1];t--);return e.opt_len+=3*(t+1)+5+5+4,t}(e),u=e.opt_len+3+7>>>3,(l=e.static_len+3+7>>>3)<=u&&(u=l)):u=l=n+5,n+4<=u&&-1!==t?te(e,t,n,r):e.strategy===i||l===u?(W(e,(c<<1)+(r?1:0),3),X(e,A,T)):(W(e,(h<<1)+(r?1:0),3),function(e,t,n,r){var i;for(W(e,t-257,5),W(e,n-1,5),W(e,r-4,4),i=0;i<r;i++)W(e,e.bl_tree[2*R[i]+1],3);J(e,e.dyn_ltree,t-1),J(e,e.dyn_dtree,n-1)}(e,e.l_desc.max_code+1,e.d_desc.max_code+1,f+1),X(e,e.dyn_ltree,e.dyn_dtree)),V(e),r&&H(e)},t._tr_tally=function(e,t,n){return e.pending_buf[e.d_buf+2*e.last_lit]=t>>>8&255,e.pending_buf[e.d_buf+2*e.last_lit+1]=255&t,e.pending_buf[e.l_buf+e.last_lit]=255&n,e.last_lit++,0===t?e.dyn_ltree[2*n]++:(e.matches++,t--,e.dyn_ltree[2*(I[n]+d+1)]++,e.dyn_dtree[2*F(t)]++),e.last_lit===e.lit_bufsize-1},t._tr_align=function(e){W(e,c<<1,3),$(e,_,A),function(e){16===e.bi_valid?(j(e,e.bi_buf),e.bi_buf=0,e.bi_valid=0):e.bi_valid>=8&&(e.pending_buf[e.pending++]=255&e.bi_buf,e.bi_buf>>=8,e.bi_valid-=8)}(e)}},function(e,t,n){"use strict";var r,i=n(5),o=n(92),s=n(38),a=n(37),u=n(21),l=0,c=1,h=3,f=4,d=5,p=0,g=1,m=-2,y=-3,v=-5,b=-1,w=1,_=2,k=3,x=4,E=0,S=2,C=8,P=9,R=15,A=8,T=286,O=30,I=19,B=2*T+1,L=15,D=3,N=258,z=N+D+1,M=32,U=42,F=69,j=73,W=91,$=103,Y=113,Z=666,V=1,H=2,q=3,K=4,X=3;function Q(e,t){return e.msg=u[t],t}function G(e){return(e<<1)-(e>4?9:0)}function J(e){for(var t=e.length;--t>=0;)e[t]=0}function ee(e){var t=e.state,n=t.pending;n>e.avail_out&&(n=e.avail_out),0!==n&&(i.arraySet(e.output,t.pending_buf,t.pending_out,n,e.next_out),e.next_out+=n,t.pending_out+=n,e.total_out+=n,e.avail_out-=n,t.pending-=n,0===t.pending&&(t.pending_out=0))}function te(e,t){o._tr_flush_block(e,e.block_start>=0?e.block_start:-1,e.strstart-e.block_start,t),e.block_start=e.strstart,ee(e.strm)}function ne(e,t){e.pending_buf[e.pending++]=t}function re(e,t){e.pending_buf[e.pending++]=t>>>8&255,e.pending_buf[e.pending++]=255&t}function ie(e,t){var n,r,i=e.max_chain_length,o=e.strstart,s=e.prev_length,a=e.nice_match,u=e.strstart>e.w_size-z?e.strstart-(e.w_size-z):0,l=e.window,c=e.w_mask,h=e.prev,f=e.strstart+N,d=l[o+s-1],p=l[o+s];e.prev_length>=e.good_match&&(i>>=2),a>e.lookahead&&(a=e.lookahead);do{if(l[(n=t)+s]===p&&l[n+s-1]===d&&l[n]===l[o]&&l[++n]===l[o+1]){o+=2,n++;do{}while(l[++o]===l[++n]&&l[++o]===l[++n]&&l[++o]===l[++n]&&l[++o]===l[++n]&&l[++o]===l[++n]&&l[++o]===l[++n]&&l[++o]===l[++n]&&l[++o]===l[++n]&&o<f);if(r=N-(f-o),o=f-N,r>s){if(e.match_start=t,s=r,r>=a)break;d=l[o+s-1],p=l[o+s]}}}while((t=h[t&c])>u&&0!=--i);return s<=e.lookahead?s:e.lookahead}function oe(e){var t,n,r,o,u,l,c,h,f,d,p=e.w_size;do{if(o=e.window_size-e.lookahead-e.strstart,e.strstart>=p+(p-z)){i.arraySet(e.window,e.window,p,p,0),e.match_start-=p,e.strstart-=p,e.block_start-=p,t=n=e.hash_size;do{r=e.head[--t],e.head[t]=r>=p?r-p:0}while(--n);t=n=p;do{r=e.prev[--t],e.prev[t]=r>=p?r-p:0}while(--n);o+=p}if(0===e.strm.avail_in)break;if(l=e.strm,c=e.window,h=e.strstart+e.lookahead,f=o,d=void 0,(d=l.avail_in)>f&&(d=f),n=0===d?0:(l.avail_in-=d,i.arraySet(c,l.input,l.next_in,d,h),1===l.state.wrap?l.adler=s(l.adler,c,d,h):2===l.state.wrap&&(l.adler=a(l.adler,c,d,h)),l.next_in+=d,l.total_in+=d,d),e.lookahead+=n,e.lookahead+e.insert>=D)for(u=e.strstart-e.insert,e.ins_h=e.window[u],e.ins_h=(e.ins_h<<e.hash_shift^e.window[u+1])&e.hash_mask;e.insert&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[u+D-1])&e.hash_mask,e.prev[u&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=u,u++,e.insert--,!(e.lookahead+e.insert<D)););}while(e.lookahead<z&&0!==e.strm.avail_in)}function se(e,t){for(var n,r;;){if(e.lookahead<z){if(oe(e),e.lookahead<z&&t===l)return V;if(0===e.lookahead)break}if(n=0,e.lookahead>=D&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+D-1])&e.hash_mask,n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!==n&&e.strstart-n<=e.w_size-z&&(e.match_length=ie(e,n)),e.match_length>=D)if(r=o._tr_tally(e,e.strstart-e.match_start,e.match_length-D),e.lookahead-=e.match_length,e.match_length<=e.max_lazy_match&&e.lookahead>=D){e.match_length--;do{e.strstart++,e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+D-1])&e.hash_mask,n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart}while(0!=--e.match_length);e.strstart++}else e.strstart+=e.match_length,e.match_length=0,e.ins_h=e.window[e.strstart],e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+1])&e.hash_mask;else r=o._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++;if(r&&(te(e,!1),0===e.strm.avail_out))return V}return e.insert=e.strstart<D-1?e.strstart:D-1,t===f?(te(e,!0),0===e.strm.avail_out?q:K):e.last_lit&&(te(e,!1),0===e.strm.avail_out)?V:H}function ae(e,t){for(var n,r,i;;){if(e.lookahead<z){if(oe(e),e.lookahead<z&&t===l)return V;if(0===e.lookahead)break}if(n=0,e.lookahead>=D&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+D-1])&e.hash_mask,n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),e.prev_length=e.match_length,e.prev_match=e.match_start,e.match_length=D-1,0!==n&&e.prev_length<e.max_lazy_match&&e.strstart-n<=e.w_size-z&&(e.match_length=ie(e,n),e.match_length<=5&&(e.strategy===w||e.match_length===D&&e.strstart-e.match_start>4096)&&(e.match_length=D-1)),e.prev_length>=D&&e.match_length<=e.prev_length){i=e.strstart+e.lookahead-D,r=o._tr_tally(e,e.strstart-1-e.prev_match,e.prev_length-D),e.lookahead-=e.prev_length-1,e.prev_length-=2;do{++e.strstart<=i&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+D-1])&e.hash_mask,n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart)}while(0!=--e.prev_length);if(e.match_available=0,e.match_length=D-1,e.strstart++,r&&(te(e,!1),0===e.strm.avail_out))return V}else if(e.match_available){if((r=o._tr_tally(e,0,e.window[e.strstart-1]))&&te(e,!1),e.strstart++,e.lookahead--,0===e.strm.avail_out)return V}else e.match_available=1,e.strstart++,e.lookahead--}return e.match_available&&(r=o._tr_tally(e,0,e.window[e.strstart-1]),e.match_available=0),e.insert=e.strstart<D-1?e.strstart:D-1,t===f?(te(e,!0),0===e.strm.avail_out?q:K):e.last_lit&&(te(e,!1),0===e.strm.avail_out)?V:H}function ue(e,t,n,r,i){this.good_length=e,this.max_lazy=t,this.nice_length=n,this.max_chain=r,this.func=i}function le(e){var t;return e&&e.state?(e.total_in=e.total_out=0,e.data_type=S,(t=e.state).pending=0,t.pending_out=0,t.wrap<0&&(t.wrap=-t.wrap),t.status=t.wrap?U:Y,e.adler=2===t.wrap?0:1,t.last_flush=l,o._tr_init(t),p):Q(e,m)}function ce(e){var t,n=le(e);return n===p&&((t=e.state).window_size=2*t.w_size,J(t.head),t.max_lazy_match=r[t.level].max_lazy,t.good_match=r[t.level].good_length,t.nice_match=r[t.level].nice_length,t.max_chain_length=r[t.level].max_chain,t.strstart=0,t.block_start=0,t.lookahead=0,t.insert=0,t.match_length=t.prev_length=D-1,t.match_available=0,t.ins_h=0),n}function he(e,t,n,r,o,s){if(!e)return m;var a=1;if(t===b&&(t=6),r<0?(a=0,r=-r):r>15&&(a=2,r-=16),o<1||o>P||n!==C||r<8||r>15||t<0||t>9||s<0||s>x)return Q(e,m);8===r&&(r=9);var u=new function(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=C,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new i.Buf16(2*B),this.dyn_dtree=new i.Buf16(2*(2*O+1)),this.bl_tree=new i.Buf16(2*(2*I+1)),J(this.dyn_ltree),J(this.dyn_dtree),J(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new i.Buf16(L+1),this.heap=new i.Buf16(2*T+1),J(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new i.Buf16(2*T+1),J(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0};return e.state=u,u.strm=e,u.wrap=a,u.gzhead=null,u.w_bits=r,u.w_size=1<<u.w_bits,u.w_mask=u.w_size-1,u.hash_bits=o+7,u.hash_size=1<<u.hash_bits,u.hash_mask=u.hash_size-1,u.hash_shift=~~((u.hash_bits+D-1)/D),u.window=new i.Buf8(2*u.w_size),u.head=new i.Buf16(u.hash_size),u.prev=new i.Buf16(u.w_size),u.lit_bufsize=1<<o+6,u.pending_buf_size=4*u.lit_bufsize,u.pending_buf=new i.Buf8(u.pending_buf_size),u.d_buf=1*u.lit_bufsize,u.l_buf=3*u.lit_bufsize,u.level=t,u.strategy=s,u.method=n,ce(e)}r=[new ue(0,0,0,0,function(e,t){var n=65535;for(n>e.pending_buf_size-5&&(n=e.pending_buf_size-5);;){if(e.lookahead<=1){if(oe(e),0===e.lookahead&&t===l)return V;if(0===e.lookahead)break}e.strstart+=e.lookahead,e.lookahead=0;var r=e.block_start+n;if((0===e.strstart||e.strstart>=r)&&(e.lookahead=e.strstart-r,e.strstart=r,te(e,!1),0===e.strm.avail_out))return V;if(e.strstart-e.block_start>=e.w_size-z&&(te(e,!1),0===e.strm.avail_out))return V}return e.insert=0,t===f?(te(e,!0),0===e.strm.avail_out?q:K):(e.strstart>e.block_start&&(te(e,!1),e.strm.avail_out),V)}),new ue(4,4,8,4,se),new ue(4,5,16,8,se),new ue(4,6,32,32,se),new ue(4,4,16,16,ae),new ue(8,16,32,32,ae),new ue(8,16,128,128,ae),new ue(8,32,128,256,ae),new ue(32,128,258,1024,ae),new ue(32,258,258,4096,ae)],t.deflateInit=function(e,t){return he(e,t,C,R,A,E)},t.deflateInit2=he,t.deflateReset=ce,t.deflateResetKeep=le,t.deflateSetHeader=function(e,t){return e&&e.state?2!==e.state.wrap?m:(e.state.gzhead=t,p):m},t.deflate=function(e,t){var n,i,s,u;if(!e||!e.state||t>d||t<0)return e?Q(e,m):m;if(i=e.state,!e.output||!e.input&&0!==e.avail_in||i.status===Z&&t!==f)return Q(e,0===e.avail_out?v:m);if(i.strm=e,n=i.last_flush,i.last_flush=t,i.status===U)if(2===i.wrap)e.adler=0,ne(i,31),ne(i,139),ne(i,8),i.gzhead?(ne(i,(i.gzhead.text?1:0)+(i.gzhead.hcrc?2:0)+(i.gzhead.extra?4:0)+(i.gzhead.name?8:0)+(i.gzhead.comment?16:0)),ne(i,255&i.gzhead.time),ne(i,i.gzhead.time>>8&255),ne(i,i.gzhead.time>>16&255),ne(i,i.gzhead.time>>24&255),ne(i,9===i.level?2:i.strategy>=_||i.level<2?4:0),ne(i,255&i.gzhead.os),i.gzhead.extra&&i.gzhead.extra.length&&(ne(i,255&i.gzhead.extra.length),ne(i,i.gzhead.extra.length>>8&255)),i.gzhead.hcrc&&(e.adler=a(e.adler,i.pending_buf,i.pending,0)),i.gzindex=0,i.status=F):(ne(i,0),ne(i,0),ne(i,0),ne(i,0),ne(i,0),ne(i,9===i.level?2:i.strategy>=_||i.level<2?4:0),ne(i,X),i.status=Y);else{var y=C+(i.w_bits-8<<4)<<8;y|=(i.strategy>=_||i.level<2?0:i.level<6?1:6===i.level?2:3)<<6,0!==i.strstart&&(y|=M),y+=31-y%31,i.status=Y,re(i,y),0!==i.strstart&&(re(i,e.adler>>>16),re(i,65535&e.adler)),e.adler=1}if(i.status===F)if(i.gzhead.extra){for(s=i.pending;i.gzindex<(65535&i.gzhead.extra.length)&&(i.pending!==i.pending_buf_size||(i.gzhead.hcrc&&i.pending>s&&(e.adler=a(e.adler,i.pending_buf,i.pending-s,s)),ee(e),s=i.pending,i.pending!==i.pending_buf_size));)ne(i,255&i.gzhead.extra[i.gzindex]),i.gzindex++;i.gzhead.hcrc&&i.pending>s&&(e.adler=a(e.adler,i.pending_buf,i.pending-s,s)),i.gzindex===i.gzhead.extra.length&&(i.gzindex=0,i.status=j)}else i.status=j;if(i.status===j)if(i.gzhead.name){s=i.pending;do{if(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>s&&(e.adler=a(e.adler,i.pending_buf,i.pending-s,s)),ee(e),s=i.pending,i.pending===i.pending_buf_size)){u=1;break}u=i.gzindex<i.gzhead.name.length?255&i.gzhead.name.charCodeAt(i.gzindex++):0,ne(i,u)}while(0!==u);i.gzhead.hcrc&&i.pending>s&&(e.adler=a(e.adler,i.pending_buf,i.pending-s,s)),0===u&&(i.gzindex=0,i.status=W)}else i.status=W;if(i.status===W)if(i.gzhead.comment){s=i.pending;do{if(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>s&&(e.adler=a(e.adler,i.pending_buf,i.pending-s,s)),ee(e),s=i.pending,i.pending===i.pending_buf_size)){u=1;break}u=i.gzindex<i.gzhead.comment.length?255&i.gzhead.comment.charCodeAt(i.gzindex++):0,ne(i,u)}while(0!==u);i.gzhead.hcrc&&i.pending>s&&(e.adler=a(e.adler,i.pending_buf,i.pending-s,s)),0===u&&(i.status=$)}else i.status=$;if(i.status===$&&(i.gzhead.hcrc?(i.pending+2>i.pending_buf_size&&ee(e),i.pending+2<=i.pending_buf_size&&(ne(i,255&e.adler),ne(i,e.adler>>8&255),e.adler=0,i.status=Y)):i.status=Y),0!==i.pending){if(ee(e),0===e.avail_out)return i.last_flush=-1,p}else if(0===e.avail_in&&G(t)<=G(n)&&t!==f)return Q(e,v);if(i.status===Z&&0!==e.avail_in)return Q(e,v);if(0!==e.avail_in||0!==i.lookahead||t!==l&&i.status!==Z){var b=i.strategy===_?function(e,t){for(var n;;){if(0===e.lookahead&&(oe(e),0===e.lookahead)){if(t===l)return V;break}if(e.match_length=0,n=o._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++,n&&(te(e,!1),0===e.strm.avail_out))return V}return e.insert=0,t===f?(te(e,!0),0===e.strm.avail_out?q:K):e.last_lit&&(te(e,!1),0===e.strm.avail_out)?V:H}(i,t):i.strategy===k?function(e,t){for(var n,r,i,s,a=e.window;;){if(e.lookahead<=N){if(oe(e),e.lookahead<=N&&t===l)return V;if(0===e.lookahead)break}if(e.match_length=0,e.lookahead>=D&&e.strstart>0&&(r=a[i=e.strstart-1])===a[++i]&&r===a[++i]&&r===a[++i]){s=e.strstart+N;do{}while(r===a[++i]&&r===a[++i]&&r===a[++i]&&r===a[++i]&&r===a[++i]&&r===a[++i]&&r===a[++i]&&r===a[++i]&&i<s);e.match_length=N-(s-i),e.match_length>e.lookahead&&(e.match_length=e.lookahead)}if(e.match_length>=D?(n=o._tr_tally(e,1,e.match_length-D),e.lookahead-=e.match_length,e.strstart+=e.match_length,e.match_length=0):(n=o._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++),n&&(te(e,!1),0===e.strm.avail_out))return V}return e.insert=0,t===f?(te(e,!0),0===e.strm.avail_out?q:K):e.last_lit&&(te(e,!1),0===e.strm.avail_out)?V:H}(i,t):r[i.level].func(i,t);if(b!==q&&b!==K||(i.status=Z),b===V||b===q)return 0===e.avail_out&&(i.last_flush=-1),p;if(b===H&&(t===c?o._tr_align(i):t!==d&&(o._tr_stored_block(i,0,0,!1),t===h&&(J(i.head),0===i.lookahead&&(i.strstart=0,i.block_start=0,i.insert=0))),ee(e),0===e.avail_out))return i.last_flush=-1,p}return t!==f?p:i.wrap<=0?g:(2===i.wrap?(ne(i,255&e.adler),ne(i,e.adler>>8&255),ne(i,e.adler>>16&255),ne(i,e.adler>>24&255),ne(i,255&e.total_in),ne(i,e.total_in>>8&255),ne(i,e.total_in>>16&255),ne(i,e.total_in>>24&255)):(re(i,e.adler>>>16),re(i,65535&e.adler)),ee(e),i.wrap>0&&(i.wrap=-i.wrap),0!==i.pending?p:g)},t.deflateEnd=function(e){var t;return e&&e.state?(t=e.state.status)!==U&&t!==F&&t!==j&&t!==W&&t!==$&&t!==Y&&t!==Z?Q(e,m):(e.state=null,t===Y?Q(e,y):p):m},t.deflateSetDictionary=function(e,t){var n,r,o,a,u,l,c,h,f=t.length;if(!e||!e.state)return m;if(2===(a=(n=e.state).wrap)||1===a&&n.status!==U||n.lookahead)return m;for(1===a&&(e.adler=s(e.adler,t,f,0)),n.wrap=0,f>=n.w_size&&(0===a&&(J(n.head),n.strstart=0,n.block_start=0,n.insert=0),h=new i.Buf8(n.w_size),i.arraySet(h,t,f-n.w_size,n.w_size,0),t=h,f=n.w_size),u=e.avail_in,l=e.next_in,c=e.input,e.avail_in=f,e.next_in=0,e.input=t,oe(n);n.lookahead>=D;){r=n.strstart,o=n.lookahead-(D-1);do{n.ins_h=(n.ins_h<<n.hash_shift^n.window[r+D-1])&n.hash_mask,n.prev[r&n.w_mask]=n.head[n.ins_h],n.head[n.ins_h]=r,r++}while(--o);n.strstart=r,n.lookahead=D-1,oe(n)}return n.strstart+=n.lookahead,n.block_start=n.strstart,n.insert=n.lookahead,n.lookahead=0,n.match_length=n.prev_length=D-1,n.match_available=0,e.next_in=l,e.input=c,e.avail_in=u,n.wrap=a,p},t.deflateInfo="pako deflate (from Nodeca project)"},function(e,t,n){"use strict";var r=n(93),i=n(5),o=n(36),s=n(21),a=n(35),u=Object.prototype.toString,l=0,c=-1,h=0,f=8;function d(e){if(!(this instanceof d))return new d(e);this.options=i.assign({level:c,method:f,chunkSize:16384,windowBits:15,memLevel:8,strategy:h,to:""},e||{});var t=this.options;t.raw&&t.windowBits>0?t.windowBits=-t.windowBits:t.gzip&&t.windowBits>0&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new a,this.strm.avail_out=0;var n=r.deflateInit2(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(n!==l)throw new Error(s[n]);if(t.header&&r.deflateSetHeader(this.strm,t.header),t.dictionary){var p;if(p="string"==typeof t.dictionary?o.string2buf(t.dictionary):"[object ArrayBuffer]"===u.call(t.dictionary)?new Uint8Array(t.dictionary):t.dictionary,(n=r.deflateSetDictionary(this.strm,p))!==l)throw new Error(s[n]);this._dict_set=!0}}function p(e,t){var n=new d(t);if(n.push(e,!0),n.err)throw n.msg||s[n.err];return n.result}d.prototype.push=function(e,t){var n,s,a=this.strm,c=this.options.chunkSize;if(this.ended)return!1;s=t===~~t?t:!0===t?4:0,"string"==typeof e?a.input=o.string2buf(e):"[object ArrayBuffer]"===u.call(e)?a.input=new Uint8Array(e):a.input=e,a.next_in=0,a.avail_in=a.input.length;do{if(0===a.avail_out&&(a.output=new i.Buf8(c),a.next_out=0,a.avail_out=c),1!==(n=r.deflate(a,s))&&n!==l)return this.onEnd(n),this.ended=!0,!1;0!==a.avail_out&&(0!==a.avail_in||4!==s&&2!==s)||("string"===this.options.to?this.onData(o.buf2binstring(i.shrinkBuf(a.output,a.next_out))):this.onData(i.shrinkBuf(a.output,a.next_out)))}while((a.avail_in>0||0===a.avail_out)&&1!==n);return 4===s?(n=r.deflateEnd(this.strm),this.onEnd(n),this.ended=!0,n===l):2!==s||(this.onEnd(l),a.avail_out=0,!0)},d.prototype.onData=function(e){this.chunks.push(e)},d.prototype.onEnd=function(e){e===l&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=i.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg},t.Deflate=d,t.deflate=p,t.deflateRaw=function(e,t){return(t=t||{}).raw=!0,p(e,t)},t.gzip=function(e,t){return(t=t||{}).gzip=!0,p(e,t)}},function(e,t,n){"use strict";var r={};(0,n(5).assign)(r,n(94),n(91),n(34)),e.exports=r},function(e,t,n){"use strict";var r="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,i=n(95),o=n(1),s=n(4),a=r?"uint8array":"array";function u(e,t){s.call(this,"FlateWorker/"+e),this._pako=null,this._pakoAction=e,this._pakoOptions=t,this.meta={}}t.magic="\b\0",o.inherits(u,s),u.prototype.processChunk=function(e){this.meta=e.meta,null===this._pako&&this._createPako(),this._pako.push(o.transformTo(a,e.data),!1)},u.prototype.flush=function(){s.prototype.flush.call(this),null===this._pako&&this._createPako(),this._pako.push([],!0)},u.prototype.cleanUp=function(){s.prototype.cleanUp.call(this),this._pako=null},u.prototype._createPako=function(){this._pako=new i[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var e=this;this._pako.onData=function(t){e.push({data:t,meta:e.meta})}},t.compressWorker=function(e){return new u("Deflate",e)},t.uncompressWorker=function(){return new u("Inflate",{})}},function(e,t,n){"use strict";var r=n(39),i=n(86);t.generateWorker=function(e,t,n){var o=new i(t.streamFiles,n,t.platform,t.encodeFileName),s=0;try{e.forEach(function(e,n){s++;var i=function(e,t){var n=e||t,i=r[n];if(!i)throw new Error(n+" is not a valid compression method !");return i}(n.options.compression,t.compression),a=n.options.compressionOptions||t.compressionOptions||{},u=n.dir,l=n.date;n._compressWorker(i,a).withStreamInfo("file",{name:e,dir:u,date:l,comment:n.comment||"",unixPermissions:n.unixPermissions,dosPermissions:n.dosPermissions}).pipe(o)}),o.entriesCount=s}catch(e){o.error(e)}return o}},function(e,t,n){"use strict";var r=n(44),i=n(42),o=n(11),s=n(23),a=n(4),u=function(e,t,n){this.name=e,this.dir=n.dir,this.date=n.date,this.comment=n.comment,this.unixPermissions=n.unixPermissions,this.dosPermissions=n.dosPermissions,this._data=t,this._dataBinary=n.binary,this.options={compression:n.compression,compressionOptions:n.compressionOptions}};u.prototype={internalStream:function(e){var t=null,n="string";try{if(!e)throw new Error("No output type specified.");var i="string"===(n=e.toLowerCase())||"text"===n;"binarystring"!==n&&"text"!==n||(n="string"),t=this._decompressWorker();var s=!this._dataBinary;s&&!i&&(t=t.pipe(new o.Utf8EncodeWorker)),!s&&i&&(t=t.pipe(new o.Utf8DecodeWorker))}catch(e){(t=new a("error")).error(e)}return new r(t,n,"")},async:function(e,t){return this.internalStream(e).accumulate(t)},nodeStream:function(e,t){return this.internalStream(e||"nodebuffer").toNodejsStream(t)},_compressWorker:function(e,t){if(this._data instanceof s&&this._data.compression.magic===e.magic)return this._data.getCompressedWorker();var n=this._decompressWorker();return this._dataBinary||(n=n.pipe(new o.Utf8EncodeWorker)),s.createWorkerFrom(n,e,t)},_decompressWorker:function(){return this._data instanceof s?this._data.getContentWorker():this._data instanceof a?this._data:new i(this._data)}};for(var l=["asText","asBinary","asNodeBuffer","asUint8Array","asArrayBuffer"],c=function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},h=0;h<l.length;h++)u.prototype[l[h]]=c;e.exports=u},function(e,t,n){"use strict";var r=n(55).Readable;function i(e,t,n){r.call(this,t),this._helper=e;var i=this;e.on("data",function(e,t){i.push(e)||i._helper.pause(),n&&n(t)}).on("error",function(e){i.emit("error",e)}).on("end",function(){i.push(null)})}n(1).inherits(i,r),i.prototype._read=function(){this._helper.resume()},e.exports=i},function(e,t,n){"use strict";var r=n(4),i=n(1);function o(e){r.call(this,"ConvertWorker to "+e),this.destType=e}i.inherits(o,r),o.prototype.processChunk=function(e){this.push({data:i.transformTo(this.destType,e.data),meta:e.meta})},e.exports=o},function(e,t,n){"use strict";(function(t){var n,r,i=t.MutationObserver||t.WebKitMutationObserver;if(i){var o=0,s=new i(c),a=t.document.createTextNode("");s.observe(a,{characterData:!0}),n=function(){a.data=o=++o%2}}else if(t.setImmediate||void 0===t.MessageChannel)n="document"in t&&"onreadystatechange"in t.document.createElement("script")?function(){var e=t.document.createElement("script");e.onreadystatechange=function(){c(),e.onreadystatechange=null,e.parentNode.removeChild(e),e=null},t.document.documentElement.appendChild(e)}:function(){setTimeout(c,0)};else{var u=new t.MessageChannel;u.port1.onmessage=c,n=function(){u.port2.postMessage(0)}}var l=[];function c(){var e,t;r=!0;for(var n=l.length;n;){for(t=l,l=[],e=-1;++e<n;)t[e]();n=l.length}r=!1}e.exports=function(e){1!==l.push(e)||r||n()}}).call(this,n(9))},function(e,t,n){"use strict";var r=n(101);function i(){}var o={},s=["REJECTED"],a=["FULFILLED"],u=["PENDING"];function l(e){if("function"!=typeof e)throw new TypeError("resolver must be a function");this.state=u,this.queue=[],this.outcome=void 0,e!==i&&d(this,e)}function c(e,t,n){this.promise=e,"function"==typeof t&&(this.onFulfilled=t,this.callFulfilled=this.otherCallFulfilled),"function"==typeof n&&(this.onRejected=n,this.callRejected=this.otherCallRejected)}function h(e,t,n){r(function(){var r;try{r=t(n)}catch(t){return o.reject(e,t)}r===e?o.reject(e,new TypeError("Cannot resolve promise with itself")):o.resolve(e,r)})}function f(e){var t=e&&e.then;if(e&&("object"==typeof e||"function"==typeof e)&&"function"==typeof t)return function(){t.apply(e,arguments)}}function d(e,t){var n=!1;function r(t){n||(n=!0,o.reject(e,t))}function i(t){n||(n=!0,o.resolve(e,t))}var s=p(function(){t(i,r)});"error"===s.status&&r(s.value)}function p(e,t){var n={};try{n.value=e(t),n.status="success"}catch(e){n.status="error",n.value=e}return n}e.exports=l,l.prototype.catch=function(e){return this.then(null,e)},l.prototype.then=function(e,t){if("function"!=typeof e&&this.state===a||"function"!=typeof t&&this.state===s)return this;var n=new this.constructor(i);this.state!==u?h(n,this.state===a?e:t,this.outcome):this.queue.push(new c(n,e,t));return n},c.prototype.callFulfilled=function(e){o.resolve(this.promise,e)},c.prototype.otherCallFulfilled=function(e){h(this.promise,this.onFulfilled,e)},c.prototype.callRejected=function(e){o.reject(this.promise,e)},c.prototype.otherCallRejected=function(e){h(this.promise,this.onRejected,e)},o.resolve=function(e,t){var n=p(f,t);if("error"===n.status)return o.reject(e,n.value);var r=n.value;if(r)d(e,r);else{e.state=a,e.outcome=t;for(var i=-1,s=e.queue.length;++i<s;)e.queue[i].callFulfilled(t)}return e},o.reject=function(e,t){e.state=s,e.outcome=t;for(var n=-1,r=e.queue.length;++n<r;)e.queue[n].callRejected(t);return e},l.resolve=function(e){if(e instanceof this)return e;return o.resolve(new this(i),e)},l.reject=function(e){var t=new this(i);return o.reject(t,e)},l.all=function(e){var t=this;if("[object Array]"!==Object.prototype.toString.call(e))return this.reject(new TypeError("must be an array"));var n=e.length,r=!1;if(!n)return this.resolve([]);var s=new Array(n),a=0,u=-1,l=new this(i);for(;++u<n;)c(e[u],u);return l;function c(e,i){t.resolve(e).then(function(e){s[i]=e,++a!==n||r||(r=!0,o.resolve(l,s))},function(e){r||(r=!0,o.reject(l,e))})}},l.race=function(e){var t=this;if("[object Array]"!==Object.prototype.toString.call(e))return this.reject(new TypeError("must be an array"));var n=e.length,r=!1;if(!n)return this.resolve([]);var s=-1,a=new this(i);for(;++s<n;)u=e[s],t.resolve(u).then(function(e){r||(r=!0,o.resolve(a,e))},function(e){r||(r=!0,o.reject(a,e))});var u;return a}},function(e,t){var n={}.toString;e.exports=function(e){return n.call(e).slice(8,-1)}},function(e,t,n){e.exports=n(15).document&&document.documentElement},function(e,t){e.exports=function(e,t,n){var r=void 0===n;switch(t.length){case 0:return r?e():e.call(n);case 1:return r?e(t[0]):e.call(n,t[0]);case 2:return r?e(t[0],t[1]):e.call(n,t[0],t[1]);case 3:return r?e(t[0],t[1],t[2]):e.call(n,t[0],t[1],t[2]);case 4:return r?e(t[0],t[1],t[2],t[3]):e.call(n,t[0],t[1],t[2],t[3])}return e.apply(n,t)}},function(e,t,n){var r,i,o,s=n(47),a=n(105),u=n(104),l=n(45),c=n(15),h=c.process,f=c.setImmediate,d=c.clearImmediate,p=c.MessageChannel,g=0,m={},y=function(){var e=+this;if(m.hasOwnProperty(e)){var t=m[e];delete m[e],t()}},v=function(e){y.call(e.data)};f&&d||(f=function(e){for(var t=[],n=1;arguments.length>n;)t.push(arguments[n++]);return m[++g]=function(){a("function"==typeof e?e:Function(e),t)},r(g),g},d=function(e){delete m[e]},"process"==n(103)(h)?r=function(e){h.nextTick(s(y,e,1))}:p?(o=(i=new p).port2,i.port1.onmessage=v,r=s(o.postMessage,o,1)):c.addEventListener&&"function"==typeof postMessage&&!c.importScripts?(r=function(e){c.postMessage(e+"","*")},c.addEventListener("message",v,!1)):r="onreadystatechange"in l("script")?function(e){u.appendChild(l("script")).onreadystatechange=function(){u.removeChild(this),y.call(e)}}:function(e){setTimeout(s(y,e,1),0)}),e.exports={set:f,clear:d}},function(e,t){e.exports=function(e,t){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}}},function(e,t,n){var r=n(25);e.exports=function(e,t){if(!r(e))return e;var n,i;if(t&&"function"==typeof(n=e.toString)&&!r(i=n.call(e)))return i;if("function"==typeof(n=e.valueOf)&&!r(i=n.call(e)))return i;if(!t&&"function"==typeof(n=e.toString)&&!r(i=n.call(e)))return i;throw TypeError("Can't convert object to primitive value")}},function(e,t,n){e.exports=!n(24)&&!n(46)(function(){return 7!=Object.defineProperty(n(45)("div"),"a",{get:function(){return 7}}).a})},function(e,t,n){var r=n(25);e.exports=function(e){if(!r(e))throw TypeError(e+" is not an object!");return e}},function(e,t,n){var r=n(110),i=n(109),o=n(108),s=Object.defineProperty;t.f=n(24)?Object.defineProperty:function(e,t,n){if(r(e),t=o(t,!0),r(n),i)try{return s(e,t,n)}catch(e){}if("get"in n||"set"in n)throw TypeError("Accessors not supported!");return"value"in n&&(e[t]=n.value),e}},function(e,t,n){var r=n(111),i=n(107);e.exports=n(24)?function(e,t,n){return r.f(e,t,i(1,n))}:function(e,t,n){return e[t]=n,e}},function(e,t){e.exports=function(e){if("function"!=typeof e)throw TypeError(e+" is not a function!");return e}},function(e,t,n){var r=n(15),i=n(48),o=n(47),s=n(112),a=function(e,t,n){var u,l,c,h=e&a.F,f=e&a.G,d=e&a.S,p=e&a.P,g=e&a.B,m=e&a.W,y=f?i:i[t]||(i[t]={}),v=y.prototype,b=f?r:d?r[t]:(r[t]||{}).prototype;for(u in f&&(n=t),n)(l=!h&&b&&void 0!==b[u])&&u in y||(c=l?b[u]:n[u],y[u]=f&&"function"!=typeof b[u]?n[u]:g&&l?o(c,r):m&&b[u]==c?function(e){var t=function(t,n,r){if(this instanceof e){switch(arguments.length){case 0:return new e;case 1:return new e(t);case 2:return new e(t,n)}return new e(t,n,r)}return e.apply(this,arguments)};return t.prototype=e.prototype,t}(c):p&&"function"==typeof c?o(Function.call,c):c,p&&((y.virtual||(y.virtual={}))[u]=c,e&a.R&&v&&!v[u]&&s(v,u,c)))};a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,e.exports=a},function(e,t,n){var r=n(114),i=n(106);r(r.G+r.B,{setImmediate:i.set,clearImmediate:i.clear})},function(e,t,n){n(115),e.exports=n(48).setImmediate},function(e,t,n){e.exports=n(27).PassThrough},function(e,t,n){e.exports=n(27).Transform},function(e,t,n){e.exports=n(8)},function(e,t,n){e.exports=n(26)},function(e,t,n){"use strict";e.exports=o;var r=n(50),i=n(13);function o(e){if(!(this instanceof o))return new o(e);r.call(this,e)}i.inherits=n(10),i.inherits(o,r),o.prototype._transform=function(e,t,n){n(null,e)}},function(e,t,n){(function(t){function n(e){try{if(!t.localStorage)return!1}catch(e){return!1}var n=t.localStorage[e];return null!=n&&"true"===String(n).toLowerCase()}e.exports=function(e,t){if(n("noDeprecation"))return e;var r=!1;return function(){if(!r){if(n("throwDeprecation"))throw new Error(t);n("traceDeprecation")?console.trace(t):console.warn(t),r=!0}return e.apply(this,arguments)}}}).call(this,n(9))},function(e,t,n){(function(e,t){!function(e,n){"use strict";if(!e.setImmediate){var r,i,o,s,a,u=1,l={},c=!1,h=e.document,f=Object.getPrototypeOf&&Object.getPrototypeOf(e);f=f&&f.setTimeout?f:e,"[object process]"==={}.toString.call(e.process)?r=function(e){t.nextTick(function(){p(e)})}:!function(){if(e.postMessage&&!e.importScripts){var t=!0,n=e.onmessage;return e.onmessage=function(){t=!1},e.postMessage("","*"),e.onmessage=n,t}}()?e.MessageChannel?((o=new MessageChannel).port1.onmessage=function(e){p(e.data)},r=function(e){o.port2.postMessage(e)}):h&&"onreadystatechange"in h.createElement("script")?(i=h.documentElement,r=function(e){var t=h.createElement("script");t.onreadystatechange=function(){p(e),t.onreadystatechange=null,i.removeChild(t),t=null},i.appendChild(t)}):r=function(e){setTimeout(p,0,e)}:(s="setImmediate$"+Math.random()+"$",a=function(t){t.source===e&&"string"==typeof t.data&&0===t.data.indexOf(s)&&p(+t.data.slice(s.length))},e.addEventListener?e.addEventListener("message",a,!1):e.attachEvent("onmessage",a),r=function(t){e.postMessage(s+t,"*")}),f.setImmediate=function(e){"function"!=typeof e&&(e=new Function(""+e));for(var t=new Array(arguments.length-1),n=0;n<t.length;n++)t[n]=arguments[n+1];var i={callback:e,args:t};return l[u]=i,r(u),u++},f.clearImmediate=d}function d(e){delete l[e]}function p(e){if(c)setTimeout(p,0,e);else{var t=l[e];if(t){c=!0;try{!function(e){var t=e.callback,r=e.args;switch(r.length){case 0:t();break;case 1:t(r[0]);break;case 2:t(r[0],r[1]);break;case 3:t(r[0],r[1],r[2]);break;default:t.apply(n,r)}}(t)}finally{d(e),c=!1}}}}}("undefined"==typeof self?void 0===e?this:e:self)}).call(this,n(9),n(19))},function(e,t,n){(function(e){var r=void 0!==e&&e||"undefined"!=typeof self&&self||window,i=Function.prototype.apply;function o(e,t){this._id=e,this._clearFn=t}t.setTimeout=function(){return new o(i.call(setTimeout,r,arguments),clearTimeout)},t.setInterval=function(){return new o(i.call(setInterval,r,arguments),clearInterval)},t.clearTimeout=t.clearInterval=function(e){e&&e.close()},o.prototype.unref=o.prototype.ref=function(){},o.prototype.close=function(){this._clearFn.call(r,this._id)},t.enroll=function(e,t){clearTimeout(e._idleTimeoutId),e._idleTimeout=t},t.unenroll=function(e){clearTimeout(e._idleTimeoutId),e._idleTimeout=-1},t._unrefActive=t.active=function(e){clearTimeout(e._idleTimeoutId);var t=e._idleTimeout;t>=0&&(e._idleTimeoutId=setTimeout(function(){e._onTimeout&&e._onTimeout()},t))},n(123),t.setImmediate="undefined"!=typeof self&&self.setImmediate||void 0!==e&&e.setImmediate||this&&this.setImmediate,t.clearImmediate="undefined"!=typeof self&&self.clearImmediate||void 0!==e&&e.clearImmediate||this&&this.clearImmediate}).call(this,n(9))},function(e,t){},function(e,t,n){"use strict";var r=n(17).Buffer,i=n(125);e.exports=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.head=null,this.tail=null,this.length=0}return e.prototype.push=function(e){var t={data:e,next:null};this.length>0?this.tail.next=t:this.head=t,this.tail=t,++this.length},e.prototype.unshift=function(e){var t={data:e,next:this.head};0===this.length&&(this.tail=t),this.head=t,++this.length},e.prototype.shift=function(){if(0!==this.length){var e=this.head.data;return 1===this.length?this.head=this.tail=null:this.head=this.head.next,--this.length,e}},e.prototype.clear=function(){this.head=this.tail=null,this.length=0},e.prototype.join=function(e){if(0===this.length)return"";for(var t=this.head,n=""+t.data;t=t.next;)n+=e+t.data;return n},e.prototype.concat=function(e){if(0===this.length)return r.alloc(0);if(1===this.length)return this.head.data;for(var t,n,i,o=r.allocUnsafe(e>>>0),s=this.head,a=0;s;)t=s.data,n=o,i=a,t.copy(n,i),a+=s.data.length,s=s.next;return o},e}(),i&&i.inspect&&i.inspect.custom&&(e.exports.prototype[i.inspect.custom]=function(){var e=i.inspect({length:this.length});return this.constructor.name+" "+e})},function(e,t){},function(e,t,n){e.exports=i;var r=n(28).EventEmitter;function i(){r.call(this)}n(10)(i,r),i.Readable=n(27),i.Writable=n(120),i.Duplex=n(119),i.Transform=n(118),i.PassThrough=n(117),i.Stream=i,i.prototype.pipe=function(e,t){var n=this;function i(t){e.writable&&!1===e.write(t)&&n.pause&&n.pause()}function o(){n.readable&&n.resume&&n.resume()}n.on("data",i),e.on("drain",o),e._isStdio||t&&!1===t.end||(n.on("end",a),n.on("close",u));var s=!1;function a(){s||(s=!0,e.end())}function u(){s||(s=!0,"function"==typeof e.destroy&&e.destroy())}function l(e){if(c(),0===r.listenerCount(this,"error"))throw e}function c(){n.removeListener("data",i),e.removeListener("drain",o),n.removeListener("end",a),n.removeListener("close",u),n.removeListener("error",l),e.removeListener("error",l),n.removeListener("end",c),n.removeListener("close",c),e.removeListener("close",c)}return n.on("error",l),e.on("error",l),n.on("end",c),n.on("close",c),e.on("close",c),e.emit("pipe",n),e}},function(e,t){t.read=function(e,t,n,r,i){var o,s,a=8*i-r-1,u=(1<<a)-1,l=u>>1,c=-7,h=n?i-1:0,f=n?-1:1,d=e[t+h];for(h+=f,o=d&(1<<-c)-1,d>>=-c,c+=a;c>0;o=256*o+e[t+h],h+=f,c-=8);for(s=o&(1<<-c)-1,o>>=-c,c+=r;c>0;s=256*s+e[t+h],h+=f,c-=8);if(0===o)o=1-l;else{if(o===u)return s?NaN:1/0*(d?-1:1);s+=Math.pow(2,r),o-=l}return(d?-1:1)*s*Math.pow(2,o-r)},t.write=function(e,t,n,r,i,o){var s,a,u,l=8*o-i-1,c=(1<<l)-1,h=c>>1,f=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,d=r?0:o-1,p=r?1:-1,g=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(a=isNaN(t)?1:0,s=c):(s=Math.floor(Math.log(t)/Math.LN2),t*(u=Math.pow(2,-s))<1&&(s--,u*=2),(t+=s+h>=1?f/u:f*Math.pow(2,1-h))*u>=2&&(s++,u/=2),s+h>=c?(a=0,s=c):s+h>=1?(a=(t*u-1)*Math.pow(2,i),s+=h):(a=t*Math.pow(2,h-1)*Math.pow(2,i),s=0));i>=8;e[n+d]=255&a,d+=p,a/=256,i-=8);for(s=s<<i|a,l+=i;l>0;e[n+d]=255&s,d+=p,s/=256,l-=8);e[n+d-p]|=128*g}},function(e,t,n){"use strict";t.byteLength=function(e){var t=l(e),n=t[0],r=t[1];return 3*(n+r)/4-r},t.toByteArray=function(e){for(var t,n=l(e),r=n[0],s=n[1],a=new o(function(e,t,n){return 3*(t+n)/4-n}(0,r,s)),u=0,c=s>0?r-4:r,h=0;h<c;h+=4)t=i[e.charCodeAt(h)]<<18|i[e.charCodeAt(h+1)]<<12|i[e.charCodeAt(h+2)]<<6|i[e.charCodeAt(h+3)],a[u++]=t>>16&255,a[u++]=t>>8&255,a[u++]=255&t;2===s&&(t=i[e.charCodeAt(h)]<<2|i[e.charCodeAt(h+1)]>>4,a[u++]=255&t);1===s&&(t=i[e.charCodeAt(h)]<<10|i[e.charCodeAt(h+1)]<<4|i[e.charCodeAt(h+2)]>>2,a[u++]=t>>8&255,a[u++]=255&t);return a},t.fromByteArray=function(e){for(var t,n=e.length,i=n%3,o=[],s=0,a=n-i;s<a;s+=16383)o.push(c(e,s,s+16383>a?a:s+16383));1===i?(t=e[n-1],o.push(r[t>>2]+r[t<<4&63]+"==")):2===i&&(t=(e[n-2]<<8)+e[n-1],o.push(r[t>>10]+r[t>>4&63]+r[t<<2&63]+"="));return o.join("")};for(var r=[],i=[],o="undefined"!=typeof Uint8Array?Uint8Array:Array,s="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",a=0,u=s.length;a<u;++a)r[a]=s[a],i[s.charCodeAt(a)]=a;function l(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var n=e.indexOf("=");return-1===n&&(n=t),[n,n===t?0:4-n%4]}function c(e,t,n){for(var i,o,s=[],a=t;a<n;a+=3)i=(e[a]<<16&16711680)+(e[a+1]<<8&65280)+(255&e[a+2]),s.push(r[(o=i)>>18&63]+r[o>>12&63]+r[o>>6&63]+r[63&o]);return s.join("")}i["-".charCodeAt(0)]=62,i["_".charCodeAt(0)]=63},function(e,t,n){"use strict";var r=n(11),i=n(1),o=n(4),s=n(44),a=n(43),u=n(23),l=n(98),c=n(97),h=n(16),f=n(85),d=function(e,t,n){var r,s=i.getTypeOf(t),c=i.extend(n||{},a);c.date=c.date||new Date,null!==c.compression&&(c.compression=c.compression.toUpperCase()),"string"==typeof c.unixPermissions&&(c.unixPermissions=parseInt(c.unixPermissions,8)),c.unixPermissions&&16384&c.unixPermissions&&(c.dir=!0),c.dosPermissions&&16&c.dosPermissions&&(c.dir=!0),c.dir&&(e=g(e)),c.createFolders&&(r=p(e))&&m.call(this,r,!0);var d="string"===s&&!1===c.binary&&!1===c.base64;n&&void 0!==n.binary||(c.binary=!d),(t instanceof u&&0===t.uncompressedSize||c.dir||!t||0===t.length)&&(c.base64=!1,c.binary=!0,t="",c.compression="STORE",s="string");var y=null;y=t instanceof u||t instanceof o?t:h.isNode&&h.isStream(t)?new f(e,t):i.prepareContent(e,t,c.binary,c.optimizedBinaryString,c.base64);var v=new l(e,y,c);this.files[e]=v},p=function(e){"/"===e.slice(-1)&&(e=e.substring(0,e.length-1));var t=e.lastIndexOf("/");return t>0?e.substring(0,t):""},g=function(e){return"/"!==e.slice(-1)&&(e+="/"),e},m=function(e,t){return t=void 0!==t?t:a.createFolders,e=g(e),this.files[e]||d.call(this,e,null,{dir:!0,createFolders:t}),this.files[e]};function y(e){return"[object RegExp]"===Object.prototype.toString.call(e)}var v={load:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},forEach:function(e){var t,n,r;for(t in this.files)this.files.hasOwnProperty(t)&&(r=this.files[t],(n=t.slice(this.root.length,t.length))&&t.slice(0,this.root.length)===this.root&&e(n,r))},filter:function(e){var t=[];return this.forEach(function(n,r){e(n,r)&&t.push(r)}),t},file:function(e,t,n){if(1===arguments.length){if(y(e)){var r=e;return this.filter(function(e,t){return!t.dir&&r.test(e)})}var i=this.files[this.root+e];return i&&!i.dir?i:null}return e=this.root+e,d.call(this,e,t,n),this},folder:function(e){if(!e)return this;if(y(e))return this.filter(function(t,n){return n.dir&&e.test(t)});var t=this.root+e,n=m.call(this,t),r=this.clone();return r.root=n.name,r},remove:function(e){e=this.root+e;var t=this.files[e];if(t||("/"!==e.slice(-1)&&(e+="/"),t=this.files[e]),t&&!t.dir)delete this.files[e];else for(var n=this.filter(function(t,n){return n.name.slice(0,e.length)===e}),r=0;r<n.length;r++)delete this.files[n[r].name];return this},generate:function(e){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},generateInternalStream:function(e){var t,n={};try{if((n=i.extend(e||{},{streamFiles:!1,compression:"STORE",compressionOptions:null,type:"",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:r.utf8encode})).type=n.type.toLowerCase(),n.compression=n.compression.toUpperCase(),"binarystring"===n.type&&(n.type="string"),!n.type)throw new Error("No output type specified.");i.checkSupport(n.type),"darwin"!==n.platform&&"freebsd"!==n.platform&&"linux"!==n.platform&&"sunos"!==n.platform||(n.platform="UNIX"),"win32"===n.platform&&(n.platform="DOS");var a=n.comment||this.comment||"";t=c.generateWorker(this,n,a)}catch(e){(t=new o("error")).error(e)}return new s(t,n.type||"string",n.mimeType)},generateAsync:function(e,t){return this.generateInternalStream(e).accumulate(t)},generateNodeStream:function(e,t){return(e=e||{}).type||(e.type="nodebuffer"),this.generateInternalStream(e).toNodejsStream(t)}};e.exports=v},function(e,t,n){"use strict";n.r(t),function(e){n(0),n(2),n(7),n(3),n(79),n(78),n(77),n(76),n(75),n(74),n(73),n(72),n(71),n(70),n(69),n(68),n(67),n(66),n(65),n(62),n(61),n(59);window.PennController=e}.call(this,n(0).PennController)}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcHJlbG9hZC9wcmVsb2FkLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnN0cnVjdGlvbnMvaW5zdHJ1Y3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vR2VuZXJpY1dvcmtlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvY29tbW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3VwcG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcHJlbG9hZC9wcmVsb2FkWmlwLmpzIiwid2VicGFjazovLy8vVXNlcnMvamVyZW15emVoci9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8vVXNlcnMvamVyZW15emVoci9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3V0ZjguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9leHRlcm5hbC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2plcmVteXplaHIvbm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2plcmVteXplaHIvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9ub2RlanNVdGlscy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2plcmVteXplaHIvbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovLy8vVXNlcnMvamVyZW15emVoci9ub2RlX21vZHVsZXMvcHJvY2Vzcy1uZXh0aWNrLWFyZ3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9qZXJlbXl6ZWhyL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9tZXNzYWdlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2NyYzMyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvY29tcHJlc3NlZE9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9qZXJlbXl6ZWhyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9qZXJlbXl6ZWhyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2plcmVteXplaHIvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvVWludDhBcnJheVJlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9EYXRhUmVhZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL0FycmF5UmVhZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL3JlYWRlckZvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3NpZ25hdHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvenN0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvc3RyaW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jcmMzMi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9hZGxlcjMyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvY29tcHJlc3Npb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL0NyYzMyUHJvYmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vRGF0YUxlbmd0aFByb2JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL0RhdGFXb3JrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9TdHJlYW1IZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2Jhc2U2NC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2plcmVteXplaHIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9qZXJlbXl6ZWhyL25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9qZXJlbXl6ZWhyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2plcmVteXplaHIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2plcmVteXplaHIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRhYmxlLXN0cmVhbS1icm93c2VyLmpzIiwid2VicGFjazovLy8vVXNlcnMvamVyZW15emVoci9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmlsZS1zYXZlci9GaWxlU2F2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwLXV0aWxzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZGVmaW5lX2liZXhfY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5LWNzdi9zcmMvanF1ZXJ5LmNzdi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZmVlZFRhYmxlLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnN0cnVjdGlvbnMveW91dHViZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2FtZC1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luc3RydWN0aW9ucy92b2ljZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5zdHJ1Y3Rpb25zL3RpbWVyLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnN0cnVjdGlvbnMvdGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5zdHJ1Y3Rpb25zL3NlbGVjdG9yLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnN0cnVjdGlvbnMvc2F2ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5zdHJ1Y3Rpb25zL3JhZGlvLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnN0cnVjdGlvbnMva2V5LmpzIiwid2VicGFjazovLy8uL3NyYy9pbnN0cnVjdGlvbnMvaW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luc3RydWN0aW9ucy9pZi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5zdHJ1Y3Rpb25zL2Z1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnN0cnVjdGlvbnMvZW5kLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnN0cnVjdGlvbnMvY29tcGxleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5zdHJ1Y3Rpb25zL2NsZWFyLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnN0cnVjdGlvbnMvY2FudmFzLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnN0cnVjdGlvbnMvYXVkaW8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi96aXBFbnRyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9Ob2RlQnVmZmVyUmVhZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL1N0cmluZ1JlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3ppcEVudHJpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9sb2FkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvbm9kZWpzL05vZGVqc1N0cmVhbUlucHV0QWRhcHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2dlbmVyYXRlL1ppcEZpbGVXb3JrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZ3poZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mdHJlZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mZmFzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZsYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi9pbmZsYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3RyZWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2RlZmxhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL2RlZmxhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9mbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2dlbmVyYXRlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvemlwT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvbm9kZWpzL05vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vQ29udmVydFdvcmtlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1tZWRpYXRlL2xpYi9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saWUvbGliL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2h0bWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW52b2tlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Rhc2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zZXQtaW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8vVXNlcnMvamVyZW15emVoci9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwid2VicGFjazovLy8vVXNlcnMvamVyZW15emVoci9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2plcmVteXplaHIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9kdXBsZXgtYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2plcmVteXplaHIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS1icm93c2VyLmpzIiwid2VicGFjazovLy8vVXNlcnMvamVyZW15emVoci9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwid2VicGFjazovLy8vVXNlcnMvamVyZW15emVoci9ub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2plcmVteXplaHIvbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9qZXJlbXl6ZWhyL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8vVXNlcnMvamVyZW15emVoci9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9qZXJlbXl6ZWhyL25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2plcmVteXplaHIvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9qZXJlbXl6ZWhyL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIl0sIm5hbWVzIjpbImluc3RhbGxlZE1vZHVsZXMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibW9kdWxlSWQiLCJleHBvcnRzIiwibW9kdWxlIiwiaSIsImwiLCJtb2R1bGVzIiwiY2FsbCIsIm0iLCJjIiwiZCIsIm5hbWUiLCJnZXR0ZXIiLCJvIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiciIsInZhbHVlIiwibiIsIl9fZXNNb2R1bGUiLCJvYmplY3QiLCJwcm9wZXJ0eSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwicCIsInMiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwiUGVubkNvbnRyb2xsZXIiLCJBYm9ydCIsIndpbmRvdyIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJXZWJLaXRNdXRhdGlvbk9ic2VydmVyIiwiTW96TXV0YXRpb25PYnNlcnZlciIsIkN0cmxyIiwiYnVpbGRpbmciLCJydW5uaW5nIiwibGlzdCIsImZ1bmN0aW9uc1J1bm5pbmdPcmRlciIsImNoYW5nZVJ1bm5pbmdPcmRlciIsImZ1bmMiLCJGdW5jdGlvbiIsImNvbnNvbGUiLCJsb2ciLCJwdXNoIiwiZ2V0Q2hhbmdlUnVubmluZ09yZGVyIiwiaWQiLCJsZW5ndGgiLCJzZXF1ZW5jZSIsImFyZ3VtZW50cyIsImluc3RydWN0aW9ucyIsIkNvbmZpZ3VyZSIsInBhcmFtZXRlcnMiLCJwYXJhbWV0ZXIiLCJpbmRleE9mIiwiQWRkSG9zdCIsImhvc3RzIiwiYSIsIm1hdGNoIiwiUmVtb3ZlUHJlZml4Iiwic3VwcG9ydCIsImJhc2U2NCIsIm5vZGVqc1V0aWxzIiwic2V0SW1tZWRpYXRlIiwiZXh0ZXJuYWwiLCJpZGVudGl0eSIsImlucHV0Iiwic3RyaW5nVG9BcnJheUxpa2UiLCJzdHIiLCJhcnJheSIsImNoYXJDb2RlQXQiLCJuZXdCbG9iIiwicGFydCIsInR5cGUiLCJjaGVja1N1cHBvcnQiLCJCbG9iIiwiZSIsImJ1aWxkZXIiLCJzZWxmIiwiQmxvYkJ1aWxkZXIiLCJXZWJLaXRCbG9iQnVpbGRlciIsIk1vekJsb2JCdWlsZGVyIiwiTVNCbG9iQnVpbGRlciIsImFwcGVuZCIsImdldEJsb2IiLCJFcnJvciIsImFycmF5VG9TdHJpbmdIZWxwZXIiLCJzdHJpbmdpZnlCeUNodW5rIiwiY2h1bmsiLCJyZXN1bHQiLCJrIiwibGVuIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYXBwbHkiLCJzbGljZSIsIk1hdGgiLCJtaW4iLCJzdWJhcnJheSIsImpvaW4iLCJzdHJpbmdpZnlCeUNoYXIiLCJyZXN1bHRTdHIiLCJhcHBseUNhbkJlVXNlZCIsInVpbnQ4YXJyYXkiLCJVaW50OEFycmF5Iiwibm9kZWJ1ZmZlciIsImFsbG9jQnVmZmVyIiwiYXJyYXlMaWtlVG9TdHJpbmciLCJnZXRUeXBlT2YiLCJjYW5Vc2VBcHBseSIsImZsb29yIiwiYXJyYXlMaWtlVG9BcnJheUxpa2UiLCJhcnJheUZyb20iLCJhcnJheVRvIiwiYXBwbHlGcm9tQ2hhckNvZGUiLCJ0cmFuc2Zvcm0iLCJzdHJpbmciLCJBcnJheSIsImFycmF5YnVmZmVyIiwiYnVmZmVyIiwibmV3QnVmZmVyRnJvbSIsImJ5dGVMZW5ndGgiLCJ0cmFuc2Zvcm1UbyIsIm91dHB1dFR5cGUiLCJpbnB1dFR5cGUiLCJ0b1N0cmluZyIsImlzQnVmZmVyIiwiQXJyYXlCdWZmZXIiLCJ0b0xvd2VyQ2FzZSIsIk1BWF9WQUxVRV8xNkJJVFMiLCJNQVhfVkFMVUVfMzJCSVRTIiwicHJldHR5IiwiY29kZSIsInJlcyIsInRvVXBwZXJDYXNlIiwiZGVsYXkiLCJjYWxsYmFjayIsImFyZ3MiLCJpbmhlcml0cyIsImN0b3IiLCJzdXBlckN0b3IiLCJPYmoiLCJleHRlbmQiLCJhdHRyIiwicHJlcGFyZUNvbnRlbnQiLCJpbnB1dERhdGEiLCJpc0JpbmFyeSIsImlzT3B0aW1pemVkQmluYXJ5U3RyaW5nIiwiaXNCYXNlNjQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJkYXRhIiwiYmxvYiIsIkZpbGVSZWFkZXIiLCJyZWplY3QiLCJyZWFkZXIiLCJvbmxvYWQiLCJ0YXJnZXQiLCJvbmVycm9yIiwiZXJyb3IiLCJyZWFkQXNBcnJheUJ1ZmZlciIsImRhdGFUeXBlIiwiZGVjb2RlIiwiX2F1dG9QcmVsb2FkQXVkaW8iLCJfYXV0b1ByZWxvYWRJbWFnZXMiLCJfYXV0b1ByZWxvYWRWaWRlb3MiLCJfZ2xvYmFsUHJlbG9hZCIsIl9pbnN0cnVjdGlvbnNUb1ByZWxvYWQiLCJfdGltZW91dFByZWxvYWQiLCJfd2FpdFdoaWxlUHJlbG9hZGluZ01lc3NhZ2UiLCJfY2hlY2tQcmVsb2FkIiwiY29udHJvbGxlciIsImxhYmVsUHJlZGljYXRlcyIsIm9wdGlvbnMiLCJwcmVsb2FkIiwicHJlZGljYXRlIiwiYW55VHlwZSIsImZpbHRlcmVkSXRlbXMiLCJpdGVtcyIsImNvdW50ZXIiLCJsYXRpblNxdWFyZWQiLCJpdGVtIiwia2V5IiwiY291bnRlck92ZXJyaWRlIiwiX19jb3VudGVyX3ZhbHVlX2Zyb21fc2VydmVyX18iLCJrZXlzIiwiaXRlbXNJbkdyb3VwIiwibG9jYWxDb3VudGVyIiwiX2ZpbHRlcmVkSXRlbXMiLCJsYWJlbCIsInByZXZpb3VzSXNQZW5uQ29udHJvbGxlciIsImVsIiwiZWxlbWVudCIsImNvbmNhdCIsInByZWxvYWRpbmdJbnN0cnVjdGlvbnMiLCJ3YWl0IiwiJCIsImluc3RydWN0aW9uIiwidG9QcmVsb2FkIiwiX3NldFJlc291cmNlIiwiaW5kZXgiLCJzcGxpY2UiLCJqUXVlcnkiLCJjb250YWlucyIsImRvY3VtZW50IiwicmVtb3ZlIiwiZmluaXNoZWRDYWxsYmFjayIsInNldFRpbWVvdXQiLCJ0aW1lb3V0IiwiQ2hlY2tQcmVsb2FkIiwiY3VzdG9tIiwiY291bnRzRm9yUHJvZ3Jlc3NCYXIiLCJBdXRvUHJlbG9hZCIsImltYWdlcyIsImF1ZGlvIiwidmlkZW9zIiwiX2xvY2FsSW5zdHJ1Y3Rpb25zIiwiSW5zdHJ1Y3Rpb24iLCJbb2JqZWN0IE9iamVjdF0iLCJjb250ZW50IiwidGhpcyIsImhhc0JlZW5SdW4iLCJpc0RvbmUiLCJwYXJlbnRFbGVtZW50Iiwib3JpZ2luIiwiaXR2bFdoZW4iLCJyZXNvdXJjZSIsImoiLCJ0byIsIm9ic2VydmVyIiwibXV0YXRpb25zIiwiYWRkZWROb2RlcyIsImRpc2Nvbm5lY3QiLCJvYnNlcnZlIiwiY2hpbGRMaXN0IiwidGkiLCJuZXdNZXRhIiwiZG9uZSIsIl9wcmVsb2FkX3ByZWxvYWRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyIsImlkeCIsInNyYyIsIl9wcmVsb2FkX3ByZWxvYWRaaXBfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyIsImZldGNoUmVzb3VyY2UiLCJldmVudCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImV4dGVuc2lvbiIsImZpbGUiLCJyZXBsYWNlIiwiaCIsImNzcyIsInJlYWR5U3RhdGUiLCJvbmUiLCJiaW5kIiwicHJldmlvdXNJbnN0cnVjdGlvbiIsImNsZWFySW50ZXJ2YWwiLCJtZXRob2QiLCJ0cnlUb1ZhbGlkYXRlIiwiY2xpY2thYmxlIiwiY2xpY2siLCJzZXRJbnRlcnZhbCIsImNvbmRpdGlvbmFsRnVuY3Rpb24iLCJpZkZhaWx1cmUiLCJydW4iLCJfd2hlblRvSW5zaXN0IiwiYmVmb3JlIiwic291cmNlIiwiaW5zdHIiLCJjb25zdHJ1Y3RvciIsInNvdXJjZUNhbGxiYWNrIiwiY3VycmVudEluc3RydWN0aW9uIiwic2V0RWxlbWVudCIsImRldGFjaCIsIndoZXJlIiwiQ29tcGxleEluc3RyIiwiaXMiLCJwYXJlbnQiLCJhZnRlciIsInciLCJ3aWR0aCIsImhlaWdodCIsIngiLCJ5IiwibGVmdCIsInRvcCIsImFyZyIsInNob3VsZEhpZGUiLCJhZGRDbGFzcyIsImNzc1ByZWZpeCIsInZhcmlhYmxlcyIsIl9pZCIsIkdlbmVyaWNXb3JrZXIiLCJzdHJlYW1JbmZvIiwiZ2VuZXJhdGVkRXJyb3IiLCJleHRyYVN0cmVhbUluZm8iLCJpc1BhdXNlZCIsImlzRmluaXNoZWQiLCJpc0xvY2tlZCIsIl9saXN0ZW5lcnMiLCJlbmQiLCJwcmV2aW91cyIsImVtaXQiLCJmbHVzaCIsImNsZWFuVXAiLCJvbiIsImxpc3RlbmVyIiwicGlwZSIsIm5leHQiLCJyZWdpc3RlclByZXZpb3VzIiwibWVyZ2VTdHJlYW1JbmZvIiwicHJvY2Vzc0NodW5rIiwicGF1c2UiLCJyZXN1bWUiLCJ3aXRoRXJyb3IiLCJ3aXRoU3RyZWFtSW5mbyIsImxvY2siLCJtZSIsIlRZUEVEX09LIiwiVWludDE2QXJyYXkiLCJJbnQzMkFycmF5IiwiX2hhcyIsIm9iaiIsImFzc2lnbiIsInNvdXJjZXMiLCJzaGlmdCIsIlR5cGVFcnJvciIsInNocmlua0J1ZiIsImJ1ZiIsInNpemUiLCJmblR5cGVkIiwiYXJyYXlTZXQiLCJkZXN0Iiwic3JjX29mZnMiLCJkZXN0X29mZnMiLCJzZXQiLCJmbGF0dGVuQ2h1bmtzIiwiY2h1bmtzIiwicG9zIiwiZm5VbnR5cGVkIiwic2V0VHlwZWQiLCJCdWY4IiwiQnVmMTYiLCJCdWYzMiIsIkJ1ZmZlciIsIm5vZGVzdHJlYW0iLCJSZWFkYWJsZSIsIl9VUkxzVG9Mb2FkIiwiX3ppcFByaW9yaXR5IiwiX3VuemlwcGVkUmVzb3VyY2VzIiwiX3ppcENhbGxiYWNrcyIsIlByZWxvYWRaaXAiLCJ1cmwiLCJyZWFkeSIsImdldFppcEZpbGUiLCJyZW1vdmVVUkwiLCJmIiwiemlwIiwianN6aXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyIsImpzemlwX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18iLCJsb2FkQXN5bmMiLCJ1bnppcHBlZEZpbGVzU29GYXIiLCJmb3JFYWNoIiwicGF0aCIsImFzeW5jIiwiZmlsZW5hbWUiLCJmaWxlcyIsInUiLCJfcHJlbG9hZFppcCIsInBuYSIsIm9iamVjdEtleXMiLCJEdXBsZXgiLCJ1dGlsIiwiV3JpdGFibGUiLCJ2IiwicmVhZGFibGUiLCJ3cml0YWJsZSIsImFsbG93SGFsZk9wZW4iLCJvbmNlIiwib25lbmQiLCJfd3JpdGFibGVTdGF0ZSIsImVuZGVkIiwibmV4dFRpY2siLCJvbkVuZE5UIiwiaGlnaFdhdGVyTWFyayIsInVuZGVmaW5lZCIsIl9yZWFkYWJsZVN0YXRlIiwiZGVzdHJveWVkIiwiX2Rlc3Ryb3kiLCJlcnIiLCJjYiIsImciLCJldmFsIiwiY3JlYXRlIiwic3VwZXJfIiwiVGVtcEN0b3IiLCJ1dGlscyIsIl91dGY4bGVuIiwiVXRmOERlY29kZVdvcmtlciIsImxlZnRPdmVyIiwiVXRmOEVuY29kZVdvcmtlciIsInV0ZjhlbmNvZGUiLCJjMiIsIm1fcG9zIiwic3RyX2xlbiIsImJ1Zl9sZW4iLCJzdHJpbmcyYnVmIiwidXRmOGRlY29kZSIsIm91dCIsImNfbGVuIiwidXRmMTZidWYiLCJidWYyc3RyaW5nIiwicHJldmlvdXNEYXRhIiwibmV4dEJvdW5kYXJ5IiwibWF4IiwidXRmOGJvcmRlciIsInVzYWJsZURhdGEiLCJtZXRhIiwiRVM2UHJvbWlzZSIsIm9iamVjdFRvU3RyaW5nIiwiaXNBcnJheSIsImlzQm9vbGVhbiIsImlzTnVsbCIsImlzTnVsbE9yVW5kZWZpbmVkIiwiaXNOdW1iZXIiLCJpc1N0cmluZyIsImlzU3ltYm9sIiwiaXNVbmRlZmluZWQiLCJpc1JlZ0V4cCIsInJlIiwiaXNPYmplY3QiLCJpc0RhdGUiLCJpc0Vycm9yIiwiaXNGdW5jdGlvbiIsImlzUHJpbWl0aXZlIiwiZ2xvYmFsIiwiaWVlZTc1NCIsImtNYXhMZW5ndGgiLCJUWVBFRF9BUlJBWV9TVVBQT1JUIiwiY3JlYXRlQnVmZmVyIiwidGhhdCIsIlJhbmdlRXJyb3IiLCJfX3Byb3RvX18iLCJlbmNvZGluZ09yT2Zmc2V0IiwiYWxsb2NVbnNhZmUiLCJmcm9tIiwiYnl0ZU9mZnNldCIsImZyb21BcnJheUxpa2UiLCJmcm9tQXJyYXlCdWZmZXIiLCJlbmNvZGluZyIsImlzRW5jb2RpbmciLCJhY3R1YWwiLCJ3cml0ZSIsImZyb21TdHJpbmciLCJjaGVja2VkIiwiY29weSIsInZhbCIsImZyb21PYmplY3QiLCJhc3NlcnRTaXplIiwiaXNWaWV3IiwibG93ZXJlZENhc2UiLCJ1dGY4VG9CeXRlcyIsImJhc2U2NFRvQnl0ZXMiLCJzd2FwIiwiYiIsImJpZGlyZWN0aW9uYWxJbmRleE9mIiwiZGlyIiwiaXNOYU4iLCJhcnJheUluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImFyciIsImluZGV4U2l6ZSIsImFyckxlbmd0aCIsInZhbExlbmd0aCIsInJlYWQiLCJyZWFkVUludDE2QkUiLCJmb3VuZEluZGV4IiwiZm91bmQiLCJoZXhXcml0ZSIsIm9mZnNldCIsIk51bWJlciIsInJlbWFpbmluZyIsInN0ckxlbiIsInBhcnNlZCIsInBhcnNlSW50Iiwic3Vic3RyIiwidXRmOFdyaXRlIiwiYmxpdEJ1ZmZlciIsImFzY2lpV3JpdGUiLCJieXRlQXJyYXkiLCJhc2NpaVRvQnl0ZXMiLCJsYXRpbjFXcml0ZSIsImJhc2U2NFdyaXRlIiwidWNzMldyaXRlIiwidW5pdHMiLCJoaSIsImxvIiwidXRmMTZsZVRvQnl0ZXMiLCJiYXNlNjRTbGljZSIsInN0YXJ0IiwiZnJvbUJ5dGVBcnJheSIsInV0ZjhTbGljZSIsInNlY29uZEJ5dGUiLCJ0aGlyZEJ5dGUiLCJmb3VydGhCeXRlIiwidGVtcENvZGVQb2ludCIsImZpcnN0Qnl0ZSIsImNvZGVQb2ludCIsImJ5dGVzUGVyU2VxdWVuY2UiLCJjb2RlUG9pbnRzIiwiTUFYX0FSR1VNRU5UU19MRU5HVEgiLCJkZWNvZGVDb2RlUG9pbnRzQXJyYXkiLCJTbG93QnVmZmVyIiwiYWxsb2MiLCJJTlNQRUNUX01BWF9CWVRFUyIsImZvbyIsInR5cGVkQXJyYXlTdXBwb3J0IiwicG9vbFNpemUiLCJfYXVnbWVudCIsIlN5bWJvbCIsInNwZWNpZXMiLCJmaWxsIiwiYWxsb2NVbnNhZmVTbG93IiwiX2lzQnVmZmVyIiwiY29tcGFyZSIsInN3YXAxNiIsInN3YXAzMiIsInN3YXA2NCIsImhleFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwidXRmMTZsZVNsaWNlIiwiZXF1YWxzIiwiaW5zcGVjdCIsInRoaXNTdGFydCIsInRoaXNFbmQiLCJ0aGlzQ29weSIsInRhcmdldENvcHkiLCJpbmNsdWRlcyIsImlzRmluaXRlIiwidG9KU09OIiwiX2FyciIsInJldCIsInRvSGV4IiwiYnl0ZXMiLCJjaGVja09mZnNldCIsImV4dCIsImNoZWNrSW50Iiwib2JqZWN0V3JpdGVVSW50MTYiLCJsaXR0bGVFbmRpYW4iLCJvYmplY3RXcml0ZVVJbnQzMiIsImNoZWNrSUVFRTc1NCIsIndyaXRlRmxvYXQiLCJub0Fzc2VydCIsIndyaXRlRG91YmxlIiwibmV3QnVmIiwic2xpY2VMZW4iLCJyZWFkVUludExFIiwibXVsIiwicmVhZFVJbnRCRSIsInJlYWRVSW50OCIsInJlYWRVSW50MTZMRSIsInJlYWRVSW50MzJMRSIsInJlYWRVSW50MzJCRSIsInJlYWRJbnRMRSIsInBvdyIsInJlYWRJbnRCRSIsInJlYWRJbnQ4IiwicmVhZEludDE2TEUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQzMkxFIiwicmVhZEludDMyQkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwid3JpdGVVSW50TEUiLCJ3cml0ZVVJbnRCRSIsIndyaXRlVUludDgiLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVSW50MTZCRSIsIndyaXRlVUludDMyTEUiLCJ3cml0ZVVJbnQzMkJFIiwid3JpdGVJbnRMRSIsImxpbWl0Iiwic3ViIiwid3JpdGVJbnRCRSIsIndyaXRlSW50OCIsIndyaXRlSW50MTZMRSIsIndyaXRlSW50MTZCRSIsIndyaXRlSW50MzJMRSIsIndyaXRlSW50MzJCRSIsIndyaXRlRmxvYXRMRSIsIndyaXRlRmxvYXRCRSIsIndyaXRlRG91YmxlTEUiLCJ3cml0ZURvdWJsZUJFIiwidGFyZ2V0U3RhcnQiLCJJTlZBTElEX0JBU0U2NF9SRSIsIkluZmluaXR5IiwibGVhZFN1cnJvZ2F0ZSIsInRvQnl0ZUFycmF5IiwidHJpbSIsInN0cmluZ3RyaW0iLCJiYXNlNjRjbGVhbiIsImRzdCIsIl9fZyIsImlzTm9kZSIsImlzU3RyZWFtIiwiY29weVByb3BzIiwiU2FmZUJ1ZmZlciIsInByb2Nlc3MiLCJ2ZXJzaW9uIiwiZm4iLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwiY2xlYXJUaW1lb3V0IiwiY3VycmVudFF1ZXVlIiwicXVldWUiLCJkcmFpbmluZyIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJkcmFpblF1ZXVlIiwibWFya2VyIiwicnVuQ2xlYXJUaW1lb3V0IiwiSXRlbSIsIm5vb3AiLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbnMiLCJhZGRMaXN0ZW5lciIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsInVtYXNrIiwiSlNaaXAiLCJjb21tZW50Iiwicm9vdCIsImNsb25lIiwibmV3T2JqIiwiZGVmYXVsdHMiLCIyIiwiMSIsIjAiLCItMSIsIi0yIiwiLTMiLCItNCIsIi01IiwiLTYiLCJjcmNUYWJsZSIsInRhYmxlIiwibWFrZVRhYmxlIiwiY3JjIiwidCIsImNyYzMyIiwiY3JjMzJzdHIiLCJEYXRhV29ya2VyIiwiRGF0YUxlbmd0aFByb2JlIiwiQ3JjMzJQcm9iZSIsIkNvbXByZXNzZWRPYmplY3QiLCJjb21wcmVzc2VkU2l6ZSIsInVuY29tcHJlc3NlZFNpemUiLCJjb21wcmVzc2lvbiIsImNvbXByZXNzZWRDb250ZW50IiwiZ2V0Q29udGVudFdvcmtlciIsIndvcmtlciIsInVuY29tcHJlc3NXb3JrZXIiLCJnZXRDb21wcmVzc2VkV29ya2VyIiwiY3JlYXRlV29ya2VyRnJvbSIsInVuY29tcHJlc3NlZFdvcmtlciIsImNvbXByZXNzaW9uT3B0aW9ucyIsImNvbXByZXNzV29ya2VyIiwiaXQiLCJDb3JrZWRSZXF1ZXN0Iiwic3RhdGUiLCJfdGhpcyIsImVudHJ5IiwiZmluaXNoIiwiY29ya1JlcSIsInBlbmRpbmdjYiIsImNvcmtlZFJlcXVlc3RzRnJlZSIsIm9uQ29ya2VkRmluaXNoIiwiYXN5bmNXcml0ZSIsIldyaXRhYmxlU3RhdGUiLCJpbnRlcm5hbFV0aWwiLCJkZXByZWNhdGUiLCJTdHJlYW0iLCJPdXJVaW50OEFycmF5IiwicmVhbEhhc0luc3RhbmNlIiwiZGVzdHJveUltcGwiLCJub3AiLCJzdHJlYW0iLCJpc0R1cGxleCIsIm9iamVjdE1vZGUiLCJ3cml0YWJsZU9iamVjdE1vZGUiLCJod20iLCJ3cml0YWJsZUh3bSIsIndyaXRhYmxlSGlnaFdhdGVyTWFyayIsImRlZmF1bHRId20iLCJmaW5hbENhbGxlZCIsIm5lZWREcmFpbiIsImVuZGluZyIsImZpbmlzaGVkIiwibm9EZWNvZGUiLCJkZWNvZGVTdHJpbmdzIiwiZGVmYXVsdEVuY29kaW5nIiwid3JpdGluZyIsImNvcmtlZCIsInN5bmMiLCJidWZmZXJQcm9jZXNzaW5nIiwib253cml0ZSIsImVyIiwid3JpdGVjYiIsIndyaXRlbGVuIiwib253cml0ZVN0YXRlVXBkYXRlIiwiZmluaXNoTWF5YmUiLCJlcnJvckVtaXR0ZWQiLCJvbndyaXRlRXJyb3IiLCJuZWVkRmluaXNoIiwiYnVmZmVyZWRSZXF1ZXN0IiwiY2xlYXJCdWZmZXIiLCJhZnRlcldyaXRlIiwibGFzdEJ1ZmZlcmVkUmVxdWVzdCIsInByZWZpbmlzaGVkIiwiYnVmZmVyZWRSZXF1ZXN0Q291bnQiLCJfd3JpdGUiLCJ3cml0ZXYiLCJfd3JpdGV2IiwiZGVzdHJveSIsImZpbmFsIiwiX2ZpbmFsIiwiZG9Xcml0ZSIsIm9ud3JpdGVEcmFpbiIsImhvbGRlciIsImNvdW50IiwiYWxsQnVmZmVycyIsImlzQnVmIiwiY2FsbEZpbmFsIiwibmVlZCIsInByZWZpbmlzaCIsImdldEJ1ZmZlciIsImN1cnJlbnQiLCJfIiwiaGFzSW5zdGFuY2UiLCJfdWludDhBcnJheVRvQnVmZmVyIiwid3JpdGVBZnRlckVuZCIsInZhbGlkIiwidmFsaWRDaHVuayIsIm5ld0NodW5rIiwiZGVjb2RlQ2h1bmsiLCJsYXN0Iiwid3JpdGVPckJ1ZmZlciIsImNvcmsiLCJ1bmNvcmsiLCJzZXREZWZhdWx0RW5jb2RpbmciLCJlbmRXcml0YWJsZSIsIl91bmRlc3Ryb3kiLCJ1bmRlc3Ryb3kiLCJUcmFuc2Zvcm0iLCJQYXNzVGhyb3VnaCIsIkV2ZW50RW1pdHRlciIsIl9ldmVudHMiLCJfbWF4TGlzdGVuZXJzIiwiZGVmYXVsdE1heExpc3RlbmVycyIsInNldE1heExpc3RlbmVycyIsImhhbmRsZXIiLCJjb250ZXh0IiwibmV3TGlzdGVuZXIiLCJ3YXJuZWQiLCJ0cmFjZSIsImZpcmVkIiwicG9zaXRpb24iLCJsaXN0ZW5lckNvdW50IiwiZXZsaXN0ZW5lciIsImVtaXR0ZXIiLCJBcnJheVJlYWRlciIsIlVpbnQ4QXJyYXlSZWFkZXIiLCJyZWFkRGF0YSIsInplcm8iLCJEYXRhUmVhZGVyIiwiY2hlY2tJbmRleCIsIm5ld0luZGV4Iiwic2V0SW5kZXgiLCJza2lwIiwiYnl0ZUF0IiwicmVhZEludCIsInJlYWRTdHJpbmciLCJsYXN0SW5kZXhPZlNpZ25hdHVyZSIsInNpZyIsInJlYWRBbmRDaGVja1NpZ25hdHVyZSIsInJlYWREYXRlIiwiZG9zdGltZSIsIkRhdGUiLCJVVEMiLCJzaWcwIiwic2lnMSIsInNpZzIiLCJzaWczIiwiU3RyaW5nUmVhZGVyIiwiTm9kZUJ1ZmZlclJlYWRlciIsIkxPQ0FMX0ZJTEVfSEVBREVSIiwiQ0VOVFJBTF9GSUxFX0hFQURFUiIsIkNFTlRSQUxfRElSRUNUT1JZX0VORCIsIlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0xPQ0FUT1IiLCJaSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQiLCJEQVRBX0RFU0NSSVBUT1IiLCJaX05PX0ZMVVNIIiwiWl9QQVJUSUFMX0ZMVVNIIiwiWl9TWU5DX0ZMVVNIIiwiWl9GVUxMX0ZMVVNIIiwiWl9GSU5JU0giLCJaX0JMT0NLIiwiWl9UUkVFUyIsIlpfT0siLCJaX1NUUkVBTV9FTkQiLCJaX05FRURfRElDVCIsIlpfRVJSTk8iLCJaX1NUUkVBTV9FUlJPUiIsIlpfREFUQV9FUlJPUiIsIlpfQlVGX0VSUk9SIiwiWl9OT19DT01QUkVTU0lPTiIsIlpfQkVTVF9TUEVFRCIsIlpfQkVTVF9DT01QUkVTU0lPTiIsIlpfREVGQVVMVF9DT01QUkVTU0lPTiIsIlpfRklMVEVSRUQiLCJaX0hVRkZNQU5fT05MWSIsIlpfUkxFIiwiWl9GSVhFRCIsIlpfREVGQVVMVF9TVFJBVEVHWSIsIlpfQklOQVJZIiwiWl9URVhUIiwiWl9VTktOT1dOIiwiWl9ERUZMQVRFRCIsIm5leHRfaW4iLCJhdmFpbF9pbiIsInRvdGFsX2luIiwib3V0cHV0IiwibmV4dF9vdXQiLCJhdmFpbF9vdXQiLCJ0b3RhbF9vdXQiLCJtc2ciLCJkYXRhX3R5cGUiLCJhZGxlciIsIlNUUl9BUFBMWV9PSyIsIlNUUl9BUFBMWV9VSUFfT0siLCJfXyIsInEiLCJidWYyYmluc3RyaW5nIiwiYmluc3RyaW5nMmJ1ZiIsInMxIiwiczIiLCJTVE9SRSIsIm1hZ2ljIiwiREVGTEFURSIsInByb3BOYW1lIiwiZGF0YVAiLCJkYXRhSXNSZWFkeSIsIl90aWNrU2NoZWR1bGVkIiwiX3RpY2tBbmRSZXBlYXQiLCJfdGljayIsIm5leHRJbmRleCIsInN1YnN0cmluZyIsInBlcmNlbnQiLCJiaW5hcnkiLCJjcmVhdGVGb2xkZXJzIiwiZGF0ZSIsInVuaXhQZXJtaXNzaW9ucyIsImRvc1Blcm1pc3Npb25zIiwiQ29udmVydFdvcmtlciIsIk5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIiLCJhY2N1bXVsYXRlIiwiaGVscGVyIiwidXBkYXRlQ2FsbGJhY2siLCJkYXRhQXJyYXkiLCJjaHVua1R5cGUiLCJfaW50ZXJuYWxUeXBlIiwicmVzdWx0VHlwZSIsIl9vdXRwdXRUeXBlIiwibWltZVR5cGUiLCJfbWltZVR5cGUiLCJlbmNvZGUiLCJ0cmFuc2Zvcm1aaXBPdXRwdXQiLCJ0b3RhbExlbmd0aCIsIlN0cmVhbUhlbHBlciIsImludGVybmFsVHlwZSIsIl93b3JrZXIiLCJ1cGRhdGVDYiIsImV2dCIsInRvTm9kZWpzU3RyZWFtIiwiY3JlYXRlRWxlbWVudCIsImV4ZWMiLCJhRnVuY3Rpb24iLCJjb3JlIiwiX19lIiwiX2tleVN0ciIsImNocjEiLCJjaHIyIiwiY2hyMyIsImVuYzEiLCJlbmMyIiwiZW5jMyIsImVuYzQiLCJyZW1haW5pbmdCeXRlcyIsImNoYXJBdCIsInJlc3VsdEluZGV4IiwiX3RyYW5zZm9ybVN0YXRlIiwiYWZ0ZXJUcmFuc2Zvcm0iLCJ0cyIsInRyYW5zZm9ybWluZyIsIndyaXRlY2h1bmsiLCJycyIsInJlYWRpbmciLCJuZWVkUmVhZGFibGUiLCJfcmVhZCIsIm5lZWRUcmFuc2Zvcm0iLCJ3cml0ZWVuY29kaW5nIiwiX3RyYW5zZm9ybSIsIl9mbHVzaCIsIl90aGlzMiIsImVycjIiLCJTdHJpbmdEZWNvZGVyIiwibmIiLCJlbmMiLCJuZW5jIiwicmV0cmllZCIsIl9ub3JtYWxpemVFbmNvZGluZyIsIm5vcm1hbGl6ZUVuY29kaW5nIiwidGV4dCIsInV0ZjE2VGV4dCIsInV0ZjE2RW5kIiwiZmlsbExhc3QiLCJ1dGY4RmlsbExhc3QiLCJiYXNlNjRUZXh0IiwiYmFzZTY0RW5kIiwic2ltcGxlV3JpdGUiLCJzaW1wbGVFbmQiLCJsYXN0TmVlZCIsImxhc3RUb3RhbCIsImxhc3RDaGFyIiwidXRmOENoZWNrQnl0ZSIsImJ5dGUiLCJ1dGY4Q2hlY2tFeHRyYUJ5dGVzIiwidG90YWwiLCJ1dGY4Q2hlY2tJbmNvbXBsZXRlIiwiZW1pdEVycm9yTlQiLCJyZWFkYWJsZURlc3Ryb3llZCIsIndyaXRhYmxlRGVzdHJveWVkIiwiZW5kRW1pdHRlZCIsIlJlYWRhYmxlU3RhdGUiLCJFRWxpc3RlbmVyQ291bnQiLCJkZWJ1Z1V0aWwiLCJkZWJ1ZyIsImRlYnVnbG9nIiwiQnVmZmVyTGlzdCIsImtQcm94eUV2ZW50cyIsInJlYWRhYmxlT2JqZWN0TW9kZSIsInJlYWRhYmxlSHdtIiwicmVhZGFibGVIaWdoV2F0ZXJNYXJrIiwicGlwZXMiLCJwaXBlc0NvdW50IiwiZmxvd2luZyIsImVtaXR0ZWRSZWFkYWJsZSIsInJlYWRhYmxlTGlzdGVuaW5nIiwicmVzdW1lU2NoZWR1bGVkIiwiYXdhaXREcmFpbiIsInJlYWRpbmdNb3JlIiwiZGVjb2RlciIsInJlYWRhYmxlQWRkQ2h1bmsiLCJhZGRUb0Zyb250Iiwic2tpcENodW5rQ2hlY2siLCJlbWl0UmVhZGFibGUiLCJvbkVvZkNodW5rIiwiY2h1bmtJbnZhbGlkIiwiZ2V0UHJvdG90eXBlT2YiLCJhZGRDaHVuayIsIm1heWJlUmVhZE1vcmUiLCJuZWVkTW9yZURhdGEiLCJ1bnNoaWZ0Iiwic2V0RW5jb2RpbmciLCJNQVhfSFdNIiwiaG93TXVjaFRvUmVhZCIsImhlYWQiLCJjb21wdXRlTmV3SGlnaFdhdGVyTWFyayIsImVtaXRSZWFkYWJsZV8iLCJmbG93IiwibWF5YmVSZWFkTW9yZV8iLCJuUmVhZGluZ05leHRUaWNrIiwicmVzdW1lXyIsImZyb21MaXN0IiwiY2xlYXIiLCJoYXNTdHJpbmdzIiwidGFpbCIsImNvcHlGcm9tQnVmZmVyU3RyaW5nIiwiY29weUZyb21CdWZmZXIiLCJmcm9tTGlzdFBhcnRpYWwiLCJlbmRSZWFkYWJsZSIsImVuZFJlYWRhYmxlTlQiLCJ4cyIsIm5PcmlnIiwiZG9SZWFkIiwicGlwZU9wdHMiLCJlbmRGbiIsInN0ZG91dCIsInN0ZGVyciIsInVucGlwZSIsIm9udW5waXBlIiwidW5waXBlSW5mbyIsImhhc1VucGlwZWQiLCJvbmNsb3NlIiwib25maW5pc2giLCJvbmRyYWluIiwib25kYXRhIiwiY2xlYW5lZFVwIiwicGlwZU9uRHJhaW4iLCJpbmNyZWFzZWRBd2FpdERyYWluIiwiZGVzdHMiLCJldiIsIndyYXAiLCJwYXVzZWQiLCJfZnJvbUxpc3QiLCJfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyIsInNhdmVBcyIsInZpZXciLCJuYXZpZ2F0b3IiLCJ0ZXN0IiwidXNlckFnZW50IiwiZ2V0X1VSTCIsIndlYmtpdFVSTCIsInNhdmVfbGluayIsImNyZWF0ZUVsZW1lbnROUyIsImNhbl91c2Vfc2F2ZV9saW5rIiwiaXNfc2FmYXJpIiwiSFRNTEVsZW1lbnQiLCJzYWZhcmkiLCJpc19jaHJvbWVfaW9zIiwidGhyb3dfb3V0c2lkZSIsImV4IiwicmV2b2tlIiwicmV2b2tlT2JqZWN0VVJMIiwiYXV0b19ib20iLCJGaWxlU2F2ZXIiLCJub19hdXRvX2JvbSIsIm9iamVjdF91cmwiLCJmaWxlc2F2ZXIiLCJmb3JjZSIsImRpc3BhdGNoX2FsbCIsImV2ZW50X3R5cGVzIiwiZGlzcGF0Y2giLCJzcGxpdCIsIklOSVQiLCJub2RlIiwiaHJlZiIsImRvd25sb2FkIiwiTW91c2VFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJET05FIiwib25sb2FkZW5kIiwib3BlbiIsImxvY2F0aW9uIiwicmVhZEFzRGF0YVVSTCIsImZzX2Vycm9yIiwiRlNfcHJvdG8iLCJtc1NhdmVPck9wZW5CbG9iIiwiYWJvcnQiLCJXUklUSU5HIiwib253cml0ZXN0YXJ0Iiwib25wcm9ncmVzcyIsIm9uYWJvcnQiLCJvbndyaXRlZW5kIiwiSlNaaXBVdGlscyIsImNyZWF0ZVN0YW5kYXJkWEhSIiwiWE1MSHR0cFJlcXVlc3QiLCJfZ2V0QmluYXJ5RnJvbVhIUiIsInhociIsInJlc3BvbnNlIiwicmVzcG9uc2VUZXh0IiwiY3JlYXRlWEhSIiwiQWN0aXZlWE9iamVjdCIsImNyZWF0ZUFjdGl2ZVhIUiIsImdldEJpbmFyeUNvbnRlbnQiLCJyZXNwb25zZVR5cGUiLCJvdmVycmlkZU1pbWVUeXBlIiwib25yZWFkeXN0YXRlY2hhbmdlIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsInNlbmQiLCJfcHJlbG9hZGVkRmlsZXMiLCJkZWZpbmVfaWJleF9jb250cm9sbGVyIiwianF1ZXJ5V2lkZ2V0IiwiX2luaXQiLCJfdCIsIl9jc3NQcmVmaXgiLCJfdXRpbHMiLCJfZmluaXNoZWRDYWxsYmFjayIsInRvU2F2ZSIsInRvUnVuQmVmb3JlRmluaXNoIiwidGltZXJzIiwic2F2ZSIsInRpbWUiLCJjYWxsYmFja0JlZm9yZUZpbmlzaCIsImFwcGVuZFRvIiwiZWFjaCIsImN1cnJlbnRUaW1lIiwibm93IiwiYWRkVG9QcmVsb2FkIiwiaHRtbCIsInByb3BlcnRpZXMiLCJvYmxpZ2F0b3J5IiwiaHRtbERlc2NyaXB0aW9uIiwibW9kaWZ5UnVubmluZ09yZGVyIiwicm8iLCJfY29udHJvbGxlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fIiwiUmVnRXhwIiwiZXNjYXBlIiwiY3N2Iiwic2VwYXJhdG9yIiwiZGVsaW1pdGVyIiwiaGVhZGVycyIsImhvb2tzIiwiY2FzdFRvU2NhbGFyIiwicGFyc2VGbG9hdCIsImludGVnZXIiLCJwYXJzZXJzIiwicGFyc2UiLCJyb3dOdW0iLCJjb2xOdW0iLCJleGl0IiwiZW5kT2ZFbnRyeSIsIm9uUGFyc2VFbnRyeSIsImhvb2tWYWwiLCJlbmRPZlZhbHVlIiwib25QYXJzZVZhbHVlIiwiaG9vayIsImVzY1NlcGFyYXRvciIsImVzY0RlbGltaXRlciIsIm1hdGNoU3JjIiwibTAiLCJzcGxpdExpbmVzIiwiZW50cmllcyIsImVuZE9mTGluZSIsInByZXZDaGFyIiwicGFyc2VFbnRyeSIsImhlbHBlcnMiLCJjb2xsZWN0UHJvcGVydHlOYW1lcyIsIm9iamVjdHMiLCJwcm9wcyIsInRvQXJyYXkiLCJjb25maWciLCJ0b0FycmF5cyIsIm9uUHJlUGFyc2UiLCJvblBvc3RQYXJzZSIsInRvT2JqZWN0cyIsImxpbmVzIiwiaGVhZGVyT3B0aW9ucyIsImhlYWRlckxpbmUiLCJmcm9tQXJyYXlzIiwiYXJyYXlzIiwibGluZSIsImxpbmVWYWx1ZXMiLCJzdHJWYWx1ZSIsImVzY01hdGNoZXIiLCJzZWFyY2giLCJmcm9tT2JqZWN0cyIsInNvcnRPcmRlciIsIm1hbnVhbE9yZGVyIiwib3JpZ09iamVjdHMiLCJzb3J0IiwicHJvcHNNYW51YWwiLCJjc3ZFbnRyeTJBcnJheSIsImNzdjJBcnJheSIsImNzdjJEaWN0aW9uYXJ5IiwiRmVlZEl0ZW1zIiwicGFyYW0xIiwicGFyYW0yIiwiX2NoZWNrVGFibGUiLCJDSFVOS1NfRElDVCIsImRlZmF1bHRUYWJsZSIsIl9zbWFydFRhYmxlRGV0ZWN0aW9uIiwiY29sIiwiZ3JvdXAiLCJwZW5uZnVuYyIsImdyb3VwcyIsInJvdyIsIml0ZW1JRCIsImdyb3VwSUQiLCJncm91cExpc3QiLCJwb3AiLCJfZ2V0SXRlbXNGcm9tIiwiX3lvdXR1YmVWaWRlb3MiLCJ0YWciLCJmaXJzdFNjcmlwdFRhZyIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwicGFyZW50Tm9kZSIsImluc2VydEJlZm9yZSIsIm9uWW91VHViZUlmcmFtZUFQSVJlYWR5IiwieXQiLCJzdXBlciIsImNyZWF0ZVBsYXllciIsInBsYXllciIsIllUIiwiUGxheWVyIiwidmlkZW9JZCIsImV2ZW50cyIsIm9uUmVhZHkiLCJfcmVhZHkiLCJvblN0YXRlQ2hhbmdlIiwiUGxheWVyU3RhdGUiLCJFTkRFRCIsIl9lbmRlZCIsIkJVRkZFUklORyIsIl9idWZmZXJpbmciLCJQTEFZSU5HIiwiX3BsYXlpbmciLCJDVUVEIiwiX2NhblBsYXkiLCJQQVVTRUQiLCJfcGF1c2VkIiwiaWZyYW1lTG9hZGVkIiwiaWZyYW1lIiwiZnJhbWVib3JkZXIiLCJkaXNwbGF5IiwidmlzdWFsIiwiYXV0b1BsYXkiLCJjb21tYW5kc1F1ZXVlIiwiaGFzUGxheWVkIiwiX2FkZFRvUHJlbG9hZCIsImJvZHkiLCJvZmZzZXRQYXJlbnQiLCJhdHRyaWJ1dGVzIiwic3VidHJlZSIsIl9hZGRFbGVtZW50IiwiX3BsYXkiLCJfZm9yY2VQYXVzZSIsIml2bCIsImdldFBsYXllclN0YXRlIiwicGxheVZpZGVvIiwicGF1c2VWaWRlbyIsIl9mb3JjZVBsYXkiLCJsb2FkZWQiLCJidWZmZXJpbmciLCJjYW5QbGF5IiwiX3BhdXNlIiwiX193ZWJwYWNrX2FtZF9vcHRpb25zX18iLCJtZWRpYVJlY29yZGVyIiwiY3VycmVudFZvaWNlSW5zdHJ1Y3Rpb24iLCJmaWxlX3NhdmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18iLCJhdWRpb1N0cmVhbXMiLCJ1cGxvYWRVUkwiLCJpbml0aWF0ZWQiLCJwZXJtaXNzaW9uTWVzc2FnZSIsImluaXRpYXRlUmVjb3JkZXIiLCJtZWRpYURldmljZXMiLCJtZXNzYWdlIiwiZGdldCIsImdldFVzZXJNZWRpYSIsIk1lZGlhUmVjb3JkZXIiLCJvbnN0b3AiLCJ0b0lTT1N0cmluZyIsImF1ZGlvUGxheWVyIiwib25kYXRhYXZhaWxhYmxlIiwiY2F0Y2giLCJ1cGxvYWRSZWNvcmRpbmdzIiwiZ2VuZXJhdGVBc3luYyIsInpjIiwiZG93bmxvYWRWb2ljZVJlY29yZGluZ3NBcmNoaXZlIiwiZmlsZU5hbWUiLCJmaWxlT2JqIiwiRmlsZSIsImZkIiwiRm9ybURhdGEiLCJhbGVydCIsIm1hbnVhbFVwbG9hZCIsInNlbmRSZXN1bHRzSUQiLCJ1cGxvYWRFbGVtZW50IiwiRHluYW1pY0VsZW1lbnQiLCJJbml0aWF0ZVJlY29yZGVyIiwic2F2ZVVSTCIsIkRvd25sb2FkVm9pY2VCdXR0b24iLCJ2b2ljZVJlY29yZGVyIiwicmVjb3JkaW5nIiwicmVjb3JkZXJVSSIsInJlY29yZEJ1dHRvbiIsInJlY29yZFN0YXR1cyIsInBsYXlCdXR0b24iLCJwbGF5SW5uZXIiLCJzdG9wQnV0dG9uIiwic3RvcElubmVyIiwiYmFja2dyb3VuZC1jb2xvciIsImJvcmRlci1yYWRpdXMiLCJtYXJnaW4tcmlnaHQiLCJwYWRkaW5nIiwiYm9yZGVyLXRvcCIsImJvcmRlci1ib3R0b20iLCJib3JkZXItcmlnaHQiLCJib3JkZXItbGVmdCIsInNob3dQbGF5IiwiZW5hYmxlZCIsInNob3dTdG9wIiwic3RhdHVzSW50ZXJ2YWwiLCJfc3RvcCIsIl9zdGFydCIsInBsYXkiLCJvbmVuZGVkIiwiU3RhcnRSZWNvcmRpbmciLCJTdG9wUmVjb3JkaW5nIiwic3RvcCIsInRpbWVyIiwic3RlcCIsImNsZWFyZWQiLCJfZWxhcHNlZCIsInRpbWVyQ2xlYXJlZCIsInNlbGVjdG9yIiwic2h1ZmZsZWRJbnN0cnVjdGlvbnMiLCJjYW5DbGljayIsImtleUxpc3QiLCJzaHVmZmxlZEtleUxpc3QiLCJzZWxlY3RlZEVsZW1lbnQiLCJzZWxlY3RlZEluc3RydWN0aW9uIiwiY2FsbGJhY2tGdW5jdGlvbiIsInNlbGVjdGlvbnMiLCJfc2VsZWN0Iiwic2FmZUJpbmQiLCJrZXlDb2RlIiwicmVtb3ZlQ2xhc3MiLCJpbnN0ck9yRnVuYyIsImNhc2VTZW5zaXRpdmUiLCJpbnN0cnVjdGlvbkluZGljZXMiLCJpMiIsInVuc2h1ZmZsZWQiLCJmaXNoZXJZYXRlcyIsIm9sZEluZGV4Iiwic2h1ZiIsImFjdGl2ZSIsInNlbGVjdGVkIiwicmFkaW9CdXR0b25zIiwidmFsdWVzIiwidGltZXMiLCJfY2xpY2tlZCIsImxhc3R2YWx1ZSIsInVwcGVyS2V5cyIsImxvd2VyS2V5cyIsIl9wcmVzc2VkIiwiaW1hZ2UiLCJkaXYiLCJpZiIsImNvbmRpdGlvbiIsInN1Y2Nlc3MiLCJmYWlsdXJlIiwidG9CZURvbmUiLCJ0ciIsInRkIiwiYWRkUGFyZW50RWxlbWVudCIsImNoaWxkcmVuIiwiX2V4ZWN1dGVkIiwiZmluZCIsImN0IiwicnRuIiwid2hpY2giLCJjYW52YXMiLCJ6LWluZGV4IiwieiIsImFscmVhZHlJbiIsIl9hZGRPYmplY3QiLCJjb250cm9scyIsImV2ZW50c1JlY29yZCIsInNhdmVQbGF5cyIsInNhdmVQYXVzZXMiLCJzYXZlRW5kcyIsInNhdmVTZWVrcyIsIl93aGVuRW5kZWQiLCJhY3R1YWxQbGF5IiwiZG9TaG93IiwiYXV0byIsInNhdmVGY3QiLCJyZWNvcmQiLCJyZWFkZXJGb3IiLCJjcmMzMmZuIiwidXRmOCIsImNvbXByZXNzaW9ucyIsIlppcEVudHJ5IiwibG9hZE9wdGlvbnMiLCJpc0VuY3J5cHRlZCIsImJpdEZsYWciLCJ1c2VVVEY4IiwicmVhZExvY2FsUGFydCIsImxvY2FsRXh0cmFGaWVsZHNMZW5ndGgiLCJmaWxlTmFtZUxlbmd0aCIsImNvbXByZXNzaW9uTWV0aG9kIiwiZmluZENvbXByZXNzaW9uIiwiZGVjb21wcmVzc2VkIiwicmVhZENlbnRyYWxQYXJ0IiwidmVyc2lvbk1hZGVCeSIsImV4dHJhRmllbGRzTGVuZ3RoIiwiZmlsZUNvbW1lbnRMZW5ndGgiLCJkaXNrTnVtYmVyU3RhcnQiLCJpbnRlcm5hbEZpbGVBdHRyaWJ1dGVzIiwiZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyIsImxvY2FsSGVhZGVyT2Zmc2V0IiwicmVhZEV4dHJhRmllbGRzIiwicGFyc2VaSVA2NEV4dHJhRmllbGQiLCJmaWxlQ29tbWVudCIsInByb2Nlc3NBdHRyaWJ1dGVzIiwibWFkZUJ5IiwiZmlsZU5hbWVTdHIiLCJleHRyYUZpZWxkcyIsImV4dHJhUmVhZGVyIiwiZXh0cmFGaWVsZElkIiwiZXh0cmFGaWVsZExlbmd0aCIsImV4dHJhRmllbGRWYWx1ZSIsImhhbmRsZVVURjgiLCJkZWNvZGVQYXJhbVR5cGUiLCJmaWxlQ29tbWVudFN0ciIsInVwYXRoIiwiZmluZEV4dHJhRmllbGRVbmljb2RlUGF0aCIsImZpbGVOYW1lQnl0ZUFycmF5IiwiZGVjb2RlRmlsZU5hbWUiLCJ1Y29tbWVudCIsImZpbmRFeHRyYUZpZWxkVW5pY29kZUNvbW1lbnQiLCJjb21tZW50Qnl0ZUFycmF5IiwidXBhdGhGaWVsZCIsInVjb21tZW50RmllbGQiLCJaaXBFbnRyaWVzIiwiY2hlY2tTaWduYXR1cmUiLCJleHBlY3RlZFNpZ25hdHVyZSIsInNpZ25hdHVyZSIsImlzU2lnbmF0dXJlIiwiYXNrZWRJbmRleCIsImN1cnJlbnRJbmRleCIsInJlYWRCbG9ja0VuZE9mQ2VudHJhbCIsImRpc2tOdW1iZXIiLCJkaXNrV2l0aENlbnRyYWxEaXJTdGFydCIsImNlbnRyYWxEaXJSZWNvcmRzT25UaGlzRGlzayIsImNlbnRyYWxEaXJSZWNvcmRzIiwiY2VudHJhbERpclNpemUiLCJjZW50cmFsRGlyT2Zmc2V0IiwiemlwQ29tbWVudExlbmd0aCIsInppcENvbW1lbnQiLCJkZWNvZGVDb250ZW50IiwicmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWwiLCJ6aXA2NEVuZE9mQ2VudHJhbFNpemUiLCJ6aXA2NEV4dGVuc2libGVEYXRhIiwiZXh0cmFEYXRhU2l6ZSIsInJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsTG9jYXRvciIsImRpc2tXaXRoWmlwNjRDZW50cmFsRGlyU3RhcnQiLCJyZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyIiwiZGlza3NDb3VudCIsInJlYWRMb2NhbEZpbGVzIiwicmVhZENlbnRyYWxEaXIiLCJ6aXA2NCIsInJlYWRFbmRPZkNlbnRyYWwiLCJlbmRPZkNlbnRyYWxEaXJPZmZzZXQiLCJleHBlY3RlZEVuZE9mQ2VudHJhbERpck9mZnNldCIsImV4dHJhQnl0ZXMiLCJhYnMiLCJwcmVwYXJlUmVhZGVyIiwibG9hZCIsImNoZWNrRW50cnlDUkMzMiIsInppcEVudHJ5IiwiY2hlY2tDUkMzMiIsIm9wdGltaXplZEJpbmFyeVN0cmluZyIsInppcEVudHJpZXMiLCJwcm9taXNlcyIsImFsbCIsInJlc3VsdHMiLCJOb2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIiLCJfdXBzdHJlYW1FbmRlZCIsIl9iaW5kU3RyZWFtIiwiX3N0cmVhbSIsImRlY1RvSGV4IiwiZGVjIiwiaGV4IiwiZ2VuZXJhdGVaaXBQYXJ0cyIsInN0cmVhbWVkQ29udGVudCIsInN0cmVhbWluZ0VuZGVkIiwicGxhdGZvcm0iLCJlbmNvZGVGaWxlTmFtZSIsImRvc1RpbWUiLCJkb3NEYXRlIiwidXNlQ3VzdG9tRW5jb2RpbmciLCJlbmNvZGVkRmlsZU5hbWUiLCJ1dGZFbmNvZGVkRmlsZU5hbWUiLCJlbmNvZGVkQ29tbWVudCIsInV0ZkVuY29kZWRDb21tZW50IiwidXNlVVRGOEZvckZpbGVOYW1lIiwidXNlVVRGOEZvckNvbW1lbnQiLCJ1bmljb2RlUGF0aEV4dHJhRmllbGQiLCJ1bmljb2RlQ29tbWVudEV4dHJhRmllbGQiLCJkYXRhSW5mbyIsImJpdGZsYWciLCJleHRGaWxlQXR0ciIsImdldFVUQ0hvdXJzIiwiZ2V0VVRDTWludXRlcyIsImdldFVUQ1NlY29uZHMiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsImhlYWRlciIsImZpbGVSZWNvcmQiLCJkaXJSZWNvcmQiLCJaaXBGaWxlV29ya2VyIiwic3RyZWFtRmlsZXMiLCJieXRlc1dyaXR0ZW4iLCJ6aXBQbGF0Zm9ybSIsImNvbnRlbnRCdWZmZXIiLCJkaXJSZWNvcmRzIiwiY3VycmVudFNvdXJjZU9mZnNldCIsImVudHJpZXNDb3VudCIsImN1cnJlbnRGaWxlIiwiX3NvdXJjZXMiLCJjdXJyZW50RmlsZVBlcmNlbnQiLCJyZW1haW5pbmdGaWxlcyIsIm9wZW5lZFNvdXJjZSIsImNsb3NlZFNvdXJjZSIsImdlbmVyYXRlRGF0YURlc2NyaXB0b3JzIiwibG9jYWxEaXJMZW5ndGgiLCJjZW50cmFsRGlyTGVuZ3RoIiwiZGlyRW5kIiwiZ2VuZXJhdGVDZW50cmFsRGlyZWN0b3J5RW5kIiwicHJlcGFyZU5leHRTb3VyY2UiLCJ4ZmxhZ3MiLCJvcyIsImV4dHJhIiwiZXh0cmFfbGVuIiwiaGNyYyIsImxiYXNlIiwibGV4dCIsImRiYXNlIiwiZGV4dCIsImxlbnMiLCJsZW5zX2luZGV4IiwiY29kZXMiLCJ0YWJsZV9pbmRleCIsIndvcmsiLCJvcHRzIiwiaW5jciIsImxvdyIsIm1hc2siLCJoZXJlX2JpdHMiLCJoZXJlX29wIiwiaGVyZV92YWwiLCJiaXRzIiwic3ltIiwiY3VyciIsImRyb3AiLCJ1c2VkIiwiaHVmZiIsImJhc2UiLCJiYXNlX2luZGV4IiwiTUFYQklUUyIsIm9mZnMiLCJleHRyYV9pbmRleCIsInN0cm0iLCJfaW4iLCJfb3V0IiwiYmVnIiwiZG1heCIsIndzaXplIiwid2hhdmUiLCJ3bmV4dCIsInNfd2luZG93IiwiaG9sZCIsImxjb2RlIiwiZGNvZGUiLCJsbWFzayIsImRtYXNrIiwiaGVyZSIsIm9wIiwiZGlzdCIsImZyb21fc291cmNlIiwibGVuY29kZSIsImRpc3Rjb2RlIiwibGVuYml0cyIsImRpc3RiaXRzIiwiZG9sZW4iLCJtb2RlIiwiZG9kaXN0Iiwic2FuZSIsImFkbGVyMzIiLCJpbmZsYXRlX2Zhc3QiLCJpbmZsYXRlX3RhYmxlIiwiQ09ERVMiLCJMRU5TIiwiRElTVFMiLCJaX01FTV9FUlJPUiIsIkhFQUQiLCJGTEFHUyIsIlRJTUUiLCJPUyIsIkVYTEVOIiwiRVhUUkEiLCJOQU1FIiwiQ09NTUVOVCIsIkhDUkMiLCJESUNUSUQiLCJESUNUIiwiVFlQRSIsIlRZUEVETyIsIlNUT1JFRCIsIkNPUFlfIiwiQ09QWSIsIlRBQkxFIiwiTEVOTEVOUyIsIkNPREVMRU5TIiwiTEVOXyIsIkxFTiIsIkxFTkVYVCIsIkRJU1QiLCJESVNURVhUIiwiTUFUQ0giLCJMSVQiLCJDSEVDSyIsIkxFTkdUSCIsIkJBRCIsIk1FTSIsIlNZTkMiLCJFTk9VR0hfTEVOUyIsIkVOT1VHSF9ESVNUUyIsIkRFRl9XQklUUyIsInpzd2FwMzIiLCJpbmZsYXRlUmVzZXRLZWVwIiwiaGF2ZWRpY3QiLCJsZW5keW4iLCJkaXN0ZHluIiwiYmFjayIsImluZmxhdGVSZXNldCIsImluZmxhdGVSZXNldDIiLCJ3aW5kb3dCaXRzIiwid2JpdHMiLCJpbmZsYXRlSW5pdDIiLCJmbGFncyIsImNoZWNrIiwibmNvZGUiLCJubGVuIiwibmRpc3QiLCJoYXZlIiwid2FzIiwibGVuZml4IiwiZGlzdGZpeCIsInZpcmdpbiIsImZpeGVkdGFibGVzIiwidXBkYXRld2luZG93IiwiaW5mbGF0ZUluaXQiLCJpbmZsYXRlIiwicHV0IiwibGFzdF9iaXRzIiwibGFzdF9vcCIsImxhc3RfdmFsIiwiaGJ1ZiIsIm9yZGVyIiwiaW5mX2xlYXZlIiwiaW5mbGF0ZUVuZCIsImluZmxhdGVHZXRIZWFkZXIiLCJpbmZsYXRlU2V0RGljdGlvbmFyeSIsImRpY3Rpb25hcnkiLCJkaWN0TGVuZ3RoIiwiaW5mbGF0ZUluZm8iLCJ6bGliX2luZmxhdGUiLCJzdHJpbmdzIiwiWlN0cmVhbSIsIkdaaGVhZGVyIiwiSW5mbGF0ZSIsImNodW5rU2l6ZSIsIm9wdCIsInJhdyIsImluZmxhdG9yIiwiX21vZGUiLCJuZXh0X291dF91dGY4IiwidXRmOHN0ciIsImRpY3QiLCJhbGxvd0J1ZkVycm9yIiwib25FbmQiLCJvbkRhdGEiLCJpbmZsYXRlUmF3IiwidW5nemlwIiwiU1RPUkVEX0JMT0NLIiwiU1RBVElDX1RSRUVTIiwiRFlOX1RSRUVTIiwiTEVOR1RIX0NPREVTIiwiTElURVJBTFMiLCJMX0NPREVTIiwiRF9DT0RFUyIsIkJMX0NPREVTIiwiSEVBUF9TSVpFIiwiTUFYX0JJVFMiLCJCdWZfc2l6ZSIsIk1BWF9CTF9CSVRTIiwiRU5EX0JMT0NLIiwiUkVQXzNfNiIsIlJFUFpfM18xMCIsIlJFUFpfMTFfMTM4IiwiZXh0cmFfbGJpdHMiLCJleHRyYV9kYml0cyIsImV4dHJhX2JsYml0cyIsImJsX29yZGVyIiwic3RhdGljX2x0cmVlIiwic3RhdGljX2R0cmVlIiwiX2Rpc3RfY29kZSIsIl9sZW5ndGhfY29kZSIsIk1BWF9NQVRDSCIsImJhc2VfbGVuZ3RoIiwic3RhdGljX2xfZGVzYyIsInN0YXRpY19kX2Rlc2MiLCJzdGF0aWNfYmxfZGVzYyIsImJhc2VfZGlzdCIsIlN0YXRpY1RyZWVEZXNjIiwic3RhdGljX3RyZWUiLCJleHRyYV9iaXRzIiwiZXh0cmFfYmFzZSIsImVsZW1zIiwibWF4X2xlbmd0aCIsImhhc19zdHJlZSIsIlRyZWVEZXNjIiwiZHluX3RyZWUiLCJzdGF0X2Rlc2MiLCJtYXhfY29kZSIsImRfY29kZSIsInB1dF9zaG9ydCIsInBlbmRpbmdfYnVmIiwicGVuZGluZyIsInNlbmRfYml0cyIsImJpX3ZhbGlkIiwiYmlfYnVmIiwic2VuZF9jb2RlIiwidHJlZSIsImJpX3JldmVyc2UiLCJnZW5fY29kZXMiLCJibF9jb3VudCIsIm5leHRfY29kZSIsImluaXRfYmxvY2siLCJkeW5fbHRyZWUiLCJkeW5fZHRyZWUiLCJibF90cmVlIiwib3B0X2xlbiIsInN0YXRpY19sZW4iLCJsYXN0X2xpdCIsIm1hdGNoZXMiLCJiaV93aW5kdXAiLCJzbWFsbGVyIiwiZGVwdGgiLCJfbjIiLCJfbTIiLCJwcWRvd25oZWFwIiwiaGVhcCIsImhlYXBfbGVuIiwiY29tcHJlc3NfYmxvY2siLCJsdHJlZSIsImR0cmVlIiwibGMiLCJseCIsImRfYnVmIiwibF9idWYiLCJidWlsZF90cmVlIiwiZGVzYyIsInN0cmVlIiwiaGVhcF9tYXgiLCJ4Yml0cyIsIm92ZXJmbG93IiwiZ2VuX2JpdGxlbiIsInNjYW5fdHJlZSIsImN1cmxlbiIsInByZXZsZW4iLCJuZXh0bGVuIiwibWF4X2NvdW50IiwibWluX2NvdW50Iiwic2VuZF90cmVlIiwic3RhdGljX2luaXRfZG9uZSIsIl90cl9zdG9yZWRfYmxvY2siLCJzdG9yZWRfbGVuIiwiY29weV9ibG9jayIsIl90cl9pbml0IiwidHJfc3RhdGljX2luaXQiLCJsX2Rlc2MiLCJkX2Rlc2MiLCJibF9kZXNjIiwiX3RyX2ZsdXNoX2Jsb2NrIiwib3B0X2xlbmIiLCJzdGF0aWNfbGVuYiIsIm1heF9ibGluZGV4IiwibGV2ZWwiLCJibGFja19tYXNrIiwiZGV0ZWN0X2RhdGFfdHlwZSIsImJ1aWxkX2JsX3RyZWUiLCJzdHJhdGVneSIsImxjb2RlcyIsImRjb2RlcyIsImJsY29kZXMiLCJyYW5rIiwic2VuZF9hbGxfdHJlZXMiLCJfdHJfdGFsbHkiLCJsaXRfYnVmc2l6ZSIsIl90cl9hbGlnbiIsImJpX2ZsdXNoIiwiY29uZmlndXJhdGlvbl90YWJsZSIsInRyZWVzIiwiTUFYX01FTV9MRVZFTCIsIk1BWF9XQklUUyIsIkRFRl9NRU1fTEVWRUwiLCJNSU5fTUFUQ0giLCJNSU5fTE9PS0FIRUFEIiwiUFJFU0VUX0RJQ1QiLCJJTklUX1NUQVRFIiwiRVhUUkFfU1RBVEUiLCJOQU1FX1NUQVRFIiwiQ09NTUVOVF9TVEFURSIsIkhDUkNfU1RBVEUiLCJCVVNZX1NUQVRFIiwiRklOSVNIX1NUQVRFIiwiQlNfTkVFRF9NT1JFIiwiQlNfQkxPQ0tfRE9ORSIsIkJTX0ZJTklTSF9TVEFSVEVEIiwiQlNfRklOSVNIX0RPTkUiLCJPU19DT0RFIiwiZXJyb3JDb2RlIiwiZmx1c2hfcGVuZGluZyIsInBlbmRpbmdfb3V0IiwiZmx1c2hfYmxvY2tfb25seSIsImJsb2NrX3N0YXJ0Iiwic3Ryc3RhcnQiLCJwdXRfYnl0ZSIsInB1dFNob3J0TVNCIiwibG9uZ2VzdF9tYXRjaCIsImN1cl9tYXRjaCIsImNoYWluX2xlbmd0aCIsIm1heF9jaGFpbl9sZW5ndGgiLCJzY2FuIiwiYmVzdF9sZW4iLCJwcmV2X2xlbmd0aCIsIm5pY2VfbWF0Y2giLCJ3X3NpemUiLCJfd2luIiwid21hc2siLCJ3X21hc2siLCJwcmV2Iiwic3RyZW5kIiwic2Nhbl9lbmQxIiwic2Nhbl9lbmQiLCJnb29kX21hdGNoIiwibG9va2FoZWFkIiwibWF0Y2hfc3RhcnQiLCJmaWxsX3dpbmRvdyIsIm1vcmUiLCJfd19zaXplIiwid2luZG93X3NpemUiLCJoYXNoX3NpemUiLCJpbnNlcnQiLCJpbnNfaCIsImhhc2hfc2hpZnQiLCJoYXNoX21hc2siLCJkZWZsYXRlX2Zhc3QiLCJoYXNoX2hlYWQiLCJiZmx1c2giLCJtYXRjaF9sZW5ndGgiLCJtYXhfbGF6eV9tYXRjaCIsImRlZmxhdGVfc2xvdyIsIm1heF9pbnNlcnQiLCJwcmV2X21hdGNoIiwibWF0Y2hfYXZhaWxhYmxlIiwiQ29uZmlnIiwiZ29vZF9sZW5ndGgiLCJtYXhfbGF6eSIsIm5pY2VfbGVuZ3RoIiwibWF4X2NoYWluIiwiZGVmbGF0ZVJlc2V0S2VlcCIsImxhc3RfZmx1c2giLCJkZWZsYXRlUmVzZXQiLCJkZWZsYXRlSW5pdDIiLCJtZW1MZXZlbCIsInBlbmRpbmdfYnVmX3NpemUiLCJnemhlYWQiLCJnemluZGV4Iiwid19iaXRzIiwiaGFzaF9iaXRzIiwibWF4X2Jsb2NrX3NpemUiLCJtYXhfc3RhcnQiLCJkZWZsYXRlSW5pdCIsImRlZmxhdGVTZXRIZWFkZXIiLCJkZWZsYXRlIiwib2xkX2ZsdXNoIiwiYnN0YXRlIiwiZGVmbGF0ZV9odWZmIiwiZGVmbGF0ZV9ybGUiLCJkZWZsYXRlRW5kIiwiZGVmbGF0ZVNldERpY3Rpb25hcnkiLCJhdmFpbCIsInRtcERpY3QiLCJkZWZsYXRlSW5mbyIsInpsaWJfZGVmbGF0ZSIsIkRlZmxhdGUiLCJnemlwIiwiX2RpY3Rfc2V0IiwiZGVmbGF0b3IiLCJkZWZsYXRlUmF3IiwicGFrbyIsIlVTRV9UWVBFREFSUkFZIiwiVWludDMyQXJyYXkiLCJBUlJBWV9UWVBFIiwiRmxhdGVXb3JrZXIiLCJhY3Rpb24iLCJfcGFrbyIsIl9wYWtvQWN0aW9uIiwiX3Bha29PcHRpb25zIiwiX2NyZWF0ZVBha28iLCJnZW5lcmF0ZVdvcmtlciIsInppcEZpbGVXb3JrZXIiLCJyZWxhdGl2ZVBhdGgiLCJmaWxlQ29tcHJlc3Npb24iLCJ6aXBDb21wcmVzc2lvbiIsImNvbXByZXNzaW9uTmFtZSIsImdldENvbXByZXNzaW9uIiwiX2NvbXByZXNzV29ya2VyIiwiWmlwT2JqZWN0IiwiX2RhdGEiLCJfZGF0YUJpbmFyeSIsImludGVybmFsU3RyZWFtIiwiYXNrVW5pY29kZVN0cmluZyIsIl9kZWNvbXByZXNzV29ya2VyIiwiaXNVbmljb2RlU3RyaW5nIiwib25VcGRhdGUiLCJub2RlU3RyZWFtIiwicmVtb3ZlZE1ldGhvZHMiLCJyZW1vdmVkRm4iLCJfaGVscGVyIiwiZGVzdFR5cGUiLCJzY2hlZHVsZURyYWluIiwiTXV0YXRpb24iLCJjYWxsZWQiLCJjcmVhdGVUZXh0Tm9kZSIsImNoYXJhY3RlckRhdGEiLCJNZXNzYWdlQ2hhbm5lbCIsInNjcmlwdEVsIiwicmVtb3ZlQ2hpbGQiLCJkb2N1bWVudEVsZW1lbnQiLCJhcHBlbmRDaGlsZCIsImNoYW5uZWwiLCJwb3J0MSIsIm9ubWVzc2FnZSIsInBvcnQyIiwicG9zdE1lc3NhZ2UiLCJvbGRRdWV1ZSIsInRhc2siLCJpbW1lZGlhdGUiLCJJTlRFUk5BTCIsImhhbmRsZXJzIiwiUkVKRUNURUQiLCJGVUxGSUxMRUQiLCJQRU5ESU5HIiwicmVzb2x2ZXIiLCJvdXRjb21lIiwic2FmZWx5UmVzb2x2ZVRoZW5hYmxlIiwiUXVldWVJdGVtIiwicHJvbWlzZSIsIm9uRnVsZmlsbGVkIiwib25SZWplY3RlZCIsImNhbGxGdWxmaWxsZWQiLCJvdGhlckNhbGxGdWxmaWxsZWQiLCJjYWxsUmVqZWN0ZWQiLCJvdGhlckNhbGxSZWplY3RlZCIsInVud3JhcCIsInJldHVyblZhbHVlIiwiZ2V0VGhlbiIsInRoZW5hYmxlIiwib25FcnJvciIsIm9uU3VjY2VzcyIsInRyeUNhdGNoIiwicmVhc29uIiwiaXRlcmFibGUiLCJyZXNvbHZlZCIsImFsbFJlc29sdmVyIiwib3V0VmFsdWUiLCJyYWNlIiwidW4iLCJkZWZlciIsInBvcnQiLCJjdHgiLCJpbnZva2UiLCJjZWwiLCJzZXRUYXNrIiwiY2xlYXJUYXNrIiwiY2xlYXJJbW1lZGlhdGUiLCJhZGRFdmVudExpc3RlbmVyIiwiaW1wb3J0U2NyaXB0cyIsImJpdG1hcCIsIlMiLCJ2YWx1ZU9mIiwiYW5PYmplY3QiLCJJRThfRE9NX0RFRklORSIsInRvUHJpbWl0aXZlIiwiZFAiLCJPIiwiUCIsIkF0dHJpYnV0ZXMiLCJjcmVhdGVEZXNjIiwiaGlkZSIsIiRleHBvcnQiLCJvd24iLCJJU19GT1JDRUQiLCJGIiwiSVNfR0xPQkFMIiwiRyIsIklTX1NUQVRJQyIsIklTX1BST1RPIiwiSVNfQklORCIsIkIiLCJJU19XUkFQIiwiVyIsImV4cFByb3RvIiwiQyIsInZpcnR1YWwiLCJSIiwiVSIsIiR0YXNrIiwibG9jYWxTdG9yYWdlIiwid2FybiIsInJlZ2lzdGVySW1tZWRpYXRlIiwibWVzc2FnZVByZWZpeCIsIm9uR2xvYmFsTWVzc2FnZSIsIm5leHRIYW5kbGUiLCJ0YXNrc0J5SGFuZGxlIiwiY3VycmVudGx5UnVubmluZ0FUYXNrIiwiZG9jIiwiYXR0YWNoVG8iLCJoYW5kbGUiLCJydW5JZlByZXNlbnQiLCJwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzIiwib2xkT25NZXNzYWdlIiwiY2FuVXNlUG9zdE1lc3NhZ2UiLCJzY3JpcHQiLCJyYW5kb20iLCJhdHRhY2hFdmVudCIsInNjb3BlIiwiVGltZW91dCIsImNsZWFyRm4iLCJfY2xlYXJGbiIsImNsb3NlIiwidW5yZWYiLCJyZWYiLCJlbnJvbGwiLCJtc2VjcyIsIl9pZGxlVGltZW91dElkIiwiX2lkbGVUaW1lb3V0IiwidW5lbnJvbGwiLCJfdW5yZWZBY3RpdmUiLCJfb25UaW1lb3V0IiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIl9jbGFzc0NhbGxDaGVjayIsIkVFIiwiX2lzU3RkaW8iLCJkaWRPbkVuZCIsImNsZWFudXAiLCJpc0xFIiwibUxlbiIsIm5CeXRlcyIsImVMZW4iLCJlTWF4IiwiZUJpYXMiLCJuQml0cyIsIk5hTiIsInJ0IiwiTE4yIiwiYjY0IiwiZ2V0TGVucyIsInZhbGlkTGVuIiwicGxhY2VIb2xkZXJzTGVuIiwidG1wIiwiQXJyIiwiX2J5dGVMZW5ndGgiLCJjdXJCeXRlIiwicmV2TG9va3VwIiwidWludDgiLCJwYXJ0cyIsImxlbjIiLCJlbmNvZGVDaHVuayIsImxvb2t1cCIsIm51bSIsImdlbmVyYXRlIiwiZmlsZUFkZCIsIm9yaWdpbmFsT3B0aW9ucyIsImZvcmNlVHJhaWxpbmdTbGFzaCIsInBhcmVudEZvbGRlciIsImZvbGRlckFkZCIsInppcE9iamVjdENvbnRlbnQiLCJsYXN0U2xhc2giLCJmaWx0ZXIiLCJyZWdleHAiLCJmb2xkZXIiLCJuZXdGb2xkZXIiLCJraWRzIiwiZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbSIsImdlbmVyYXRlTm9kZVN0cmVhbSJdLCJtYXBwaW5ncyI6ImFBQ0EsSUFBQUEsS0FHQSxTQUFBQyxFQUFBQyxHQUdBLEdBQUFGLEVBQUFFLEdBQ0EsT0FBQUYsRUFBQUUsR0FBQUMsUUFHQSxJQUFBQyxFQUFBSixFQUFBRSxJQUNBRyxFQUFBSCxFQUNBSSxHQUFBLEVBQ0FILFlBVUEsT0FOQUksRUFBQUwsR0FBQU0sS0FBQUosRUFBQUQsUUFBQUMsSUFBQUQsUUFBQUYsR0FHQUcsRUFBQUUsR0FBQSxFQUdBRixFQUFBRCxRQUtBRixFQUFBUSxFQUFBRixFQUdBTixFQUFBUyxFQUFBVixFQUdBQyxFQUFBVSxFQUFBLFNBQUFSLEVBQUFTLEVBQUFDLEdBQ0FaLEVBQUFhLEVBQUFYLEVBQUFTLElBQ0FHLE9BQUFDLGVBQUFiLEVBQUFTLEdBQ0FLLGNBQUEsRUFDQUMsWUFBQSxFQUNBQyxJQUFBTixLQU1B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QTAxRCx1QkFBQXo0RCxHQUFBdXNCLFdBQUF1aEMsSUFNQTRLLG1CQUFBLFNBQUExNEQsRUFBQTh0RCxHQUtBLE9BSkE5dEQsU0FDQXJHLE9BQ0FxRyxFQUFBckcsS0FBQSxjQUVBb0osS0FBQTAxRCx1QkFBQXo0RCxHQUFBeXRCLGVBQUFxZ0MsS0FHQTM0RCxFQUFBRCxRQUFBd1osNktDcFlBMVosRUFBQSxJQXVDQWdDLE9BQUFGIiwiZmlsZSI6IlBlbm5Db250cm9sbGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxMzIpO1xuIiwiLy8gRHVtbXkgb2JqZWN0LCBBQk9SVCBrZXl3b3JkXG4vLyB1c2VkIGluIHRoZSBpbnN0cnVjdGlvbnMnIEVYVEVORCBtZXRob2QgdG8gYWJvcnQgY2hhaW4gb2YgZXhlY3V0aW9uXG5leHBvcnQgdmFyIEFib3J0ID0gbmV3IE9iamVjdDtcblxuLy8gTWFraW5nIHN1cmUgdGhhdCBNdXRhdGlvbk9ic2VydmVyIGlzIGRlZmluZWQgYWNyb3NzIGJyb3dzZXJzXG5jb25zdCBNdXRhdGlvbk9ic2VydmVyID1cbiAgICB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciB8fCB3aW5kb3cuV2ViS2l0TXV0YXRpb25PYnNlcnZlciB8fCB3aW5kb3cuTW96TXV0YXRpb25PYnNlcnZlcjtcblxuLy8gT2JqZWN0IHBvaW50aW5nIHRvLi4uXG5leHBvcnQgdmFyIEN0cmxyID0ge1xuICAgIGJ1aWxkaW5nOiB7fSwgICAvLyAuLi4gdGhlIFBlbm5Db250cm9sbGVyIGJlaW5nIGJ1aWx0IHdoZW4gZGVmaW5pbmcgaXRlbXNcbiAgICBydW5uaW5nOiB7fSwgICAgLy8gLi4uIHRoZSBQZW5uQ29udHJvbGxlciBjdXJyZW50bHkgcnVubmluZyBpbiBJYmV4XG4gICAgbGlzdDogW10gICAgICAgIC8vIC4uLiB0aGUgbGlzdCBvZiBQZW5uQ29udHJvbGxlcnMgY3JlYXRlZCBzbyBmYXJcbn07XG5cbi8vIEhhbmRsZXIgZm9yIG1vZGlmaWNhdGlvbnMgdG8gdGhlIHJ1bm5pbmcgb3JkZXJcbi8vIEFueSBtb2RpZmljYXRpb24gYWRkZWQgdGhyb3VnaCBjaGFuZ2VSdW5uaW5nT3JkZXIgaXMgZXhlY3V0ZWQgaW4gbW9kaWZ5UnVubmluZ09yZGVyIGluIGRlZmluZV9pYmV4X2NvbnRyb2xsZXIuanNcbnZhciBmdW5jdGlvbnNSdW5uaW5nT3JkZXIgPSBbXTtcbi8vIEltcG9ydCBhbmQgY2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGFkZCBhIGNoYW5nZSB0byB0aGUgcnVubmluZyBvcmRlclxuZXhwb3J0IGZ1bmN0aW9uIGNoYW5nZVJ1bm5pbmdPcmRlcihmdW5jKSB7XG4gICAgaWYgKGZ1bmMgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlB1c2hlZCBhIGZ1bmN0aW9uIHRvIG1vZGlmeSBydW5uaW5nIG9yZGVyXCIpO1xuICAgICAgICBmdW5jdGlvbnNSdW5uaW5nT3JkZXIucHVzaChmdW5jKTtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gY29uc29sZS5sb2coXCJFUlJPUjogY2hhbmdlUnVubmluZ09yZGVyIG9ubHkgdGFrZXMgZnVuY3Rpb25zIGFzIHBhcmFtZXRlcnNcIik7XG59O1xuLy8gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgZGVmaW5lX2liZXhfY29udHJvbGxlci5qcyBpbiBtb2RpZnlSdW5uaW5nT3JkZXIgdG8gYWN0dWFsbHkgYXBwbHkgdGhlIGNoYW5nZXNcbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGFuZ2VSdW5uaW5nT3JkZXIoZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbnNSdW5uaW5nT3JkZXI7XG59O1xuXG5cbi8vICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy9cbi8vICAgICAgUEVOTkNPTlRST0xMRVIgT0JKRUNUXG4vL1xuLy8gID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8vIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGluc3RydWN0aW9ucyBwYXNzZWQgYXMgYXJndW1lbnRzXG4vLyBUaGUgb2JqZWN0IHdpbGwgYmUgZ2l2ZW4gdG8gdGhlIGFjdHVhbCBjb250cm9sbGVyXG5leHBvcnQgdmFyIFBlbm5Db250cm9sbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgbGV0IGlkID0gQ3RybHIubGlzdC5sZW5ndGgsIHNlcXVlbmNlID0gYXJndW1lbnRzO1xuICAgIC8vIEFkZCB0aGUgY29udHJvbGxlciB1bmRlciBjb25zdHJ1Y3Rpb24gdG8gdGhlIGxpc3RcbiAgICBDdHJsci5idWlsZGluZy5pZCA9IGlkO1xuICAgIEN0cmxyLmJ1aWxkaW5nLnNlcXVlbmNlID0gc2VxdWVuY2U7XG4gICAgQ3RybHIubGlzdC5wdXNoKEN0cmxyLmJ1aWxkaW5nKTtcbiAgICBjb25zb2xlLmxvZyhcIkp1c3QgYWRkZWQgY29udHJvbGxlcjpcIiwgQ3RybHIuYnVpbGRpbmcpO1xuICAgIC8vIFJlc2V0dGluZyBDdHJsci5idWlsZGluZyBmb3IgbmV4dCBvbmVcbiAgICBDdHJsci5idWlsZGluZyA9IHt9O1xuICAgIC8vIElEIGlzIF9pbnN0cnVjdGlvbnMnIGxlbmd0aCBtaW51cyAyOiB3ZSBqdXN0IHB1c2hlZCBmb3IgTkVYVCBjb250cm9sbGVyXG4gICAgcmV0dXJuIHtpbnN0cnVjdGlvbnM6IHNlcXVlbmNlLCBpZDogaWR9O1xufTtcblxuLy8gR2VuZXJhbCBzZXR0aW5nc1xuUGVubkNvbnRyb2xsZXIuQ29uZmlndXJlID0gZnVuY3Rpb24ocGFyYW1ldGVycyl7XG4gICAgZm9yIChsZXQgcGFyYW1ldGVyIGluIHBhcmFtZXRlcnMpe1xuICAgICAgICBpZiAocGFyYW1ldGVyLmluZGV4T2ZbXCJQcmVsb2FkUmVzb3VyY2VzXCIsXCJDb25maWd1cmVcIl0gPCAwKSAvLyBEb24ndCBvdmVycmlkZSBidWlsdC1pbiBmdW5jdGlvbnMvcGFyYW1ldGVyc1xuICAgICAgICAgICAgUGVubkNvbnRyb2xsZXJbcGFyYW1ldGVyXSA9IHBhcmFtZXRlcnNbcGFyYW1ldGVyXTtcbiAgICB9XG4gICAgLypcbiAgICAgICAgYmFzZVVSTDogXCJodHRwOi8vLi4uL1wiLFxuICAgICAgICBJbWFnZVVSTDogXCJodHRwOi8vLi4uL1wiLFxuICAgICAgICBBdWRpb1VSTDogXCJodHRwOi8vLi4uL1wiLFxuICAgICAgICAuLi5cbiAgICAqL1xufTtcblxuLy8gVGhpcyBhZGRzIGEgVVJMIHdoZXJlIHJlc291cmNlcyB3aWxsIGJlIGxvb2tlZCBmb3JcblBlbm5Db250cm9sbGVyLkFkZEhvc3QgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIVBlbm5Db250cm9sbGVyLmhhc093blByb3BlcnR5KFwiaG9zdHNcIikpXG4gICAgICAgIFBlbm5Db250cm9sbGVyLmhvc3RzID0gW107XG4gICAgZm9yIChsZXQgYSA9IDA7IGEgPCBhcmd1bWVudHMubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgaWYgKHR5cGVvZihhcmd1bWVudHNbYV0pPT1cInN0cmluZ1wiICYmIGFyZ3VtZW50c1thXS5tYXRjaCgvXmh0dHBzPzpcXC9cXC8vaSkpXG4gICAgICAgICAgICBQZW5uQ29udHJvbGxlci5ob3N0cy5wdXNoKGFyZ3VtZW50c1thXSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV2FybmluZzogaG9zdCAjXCIrYStcIiBpcyBub3QgYSB2YWxpZCBVUkwuXCIsIGFyZ3VtZW50c1thXSk7XG4gICAgfVxufVxuXG4vLyBUaGlzIGFsbG93cyB0aGUgdXNlcnMgdG8gY2FsbCB0aGUgaW5zdHJ1Y3Rpb24gbWV0aG9kcyBhcyBnbG9iYWwgZnVuY3Rpb25zXG5QZW5uQ29udHJvbGxlci5SZW1vdmVQcmVmaXggPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKGxldCBpIGluIFBlbm5Db250cm9sbGVyLmluc3RydWN0aW9ucylcbiAgICAgICAgd2luZG93W2ldID0gUGVubkNvbnRyb2xsZXIuaW5zdHJ1Y3Rpb25zW2ldO1xufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcbnZhciBiYXNlNjQgPSByZXF1aXJlKCcuL2Jhc2U2NCcpO1xudmFyIG5vZGVqc1V0aWxzID0gcmVxdWlyZSgnLi9ub2RlanNVdGlscycpO1xudmFyIHNldEltbWVkaWF0ZSA9IHJlcXVpcmUoJ2NvcmUtanMvbGlicmFyeS9mbi9zZXQtaW1tZWRpYXRlJyk7XG52YXIgZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcblxuXG4vKipcbiAqIENvbnZlcnQgYSBzdHJpbmcgdGhhdCBwYXNzIGFzIGEgXCJiaW5hcnkgc3RyaW5nXCI6IGl0IHNob3VsZCByZXByZXNlbnQgYSBieXRlXG4gKiBhcnJheSBidXQgbWF5IGhhdmUgPiAyNTUgY2hhciBjb2Rlcy4gQmUgc3VyZSB0byB0YWtlIG9ubHkgdGhlIGZpcnN0IGJ5dGVcbiAqIGFuZCByZXR1cm5zIHRoZSBieXRlIGFycmF5LlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHRyYW5zZm9ybS5cbiAqIEByZXR1cm4ge0FycmF5fFVpbnQ4QXJyYXl9IHRoZSBzdHJpbmcgaW4gYSBiaW5hcnkgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBzdHJpbmcyYmluYXJ5KHN0cikge1xuICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHN0ci5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBuZXcgQXJyYXkoc3RyLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmdUb0FycmF5TGlrZShzdHIsIHJlc3VsdCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGJsb2Igd2l0aCB0aGUgZ2l2ZW4gY29udGVudCBhbmQgdGhlIGdpdmVuIHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheUJ1ZmZlcn0gcGFydCB0aGUgY29udGVudCB0byBwdXQgaW4gdGhlIGJsb2IuIERPIE5PVCB1c2VcbiAqIGFuIFVpbnQ4QXJyYXkgYmVjYXVzZSB0aGUgc3RvY2sgYnJvd3NlciBvZiBhbmRyb2lkIDQgd29uJ3QgYWNjZXB0IGl0IChpdFxuICogd2lsbCBiZSBzaWxlbnRseSBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcsIFwiW29iamVjdCBVaW50OEFycmF5XVwiKS5cbiAqXG4gKiBVc2Ugb25seSBPTkUgcGFydCB0byBidWlsZCB0aGUgYmxvYiB0byBhdm9pZCBhIG1lbW9yeSBsZWFrIGluIElFMTEgLyBFZGdlOlxuICogd2hlbiBhIGxhcmdlIGFtb3VudCBvZiBBcnJheSBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgQmxvYiwgdGhlIGFtb3VudCBvZlxuICogbWVtb3J5IGNvbnN1bWVkIGlzIG5lYXJseSAxMDAgdGltZXMgdGhlIG9yaWdpbmFsIGRhdGEgYW1vdW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSBtaW1lIHR5cGUgb2YgdGhlIGJsb2IuXG4gKiBAcmV0dXJuIHtCbG9ifSB0aGUgY3JlYXRlZCBibG9iLlxuICovXG5leHBvcnRzLm5ld0Jsb2IgPSBmdW5jdGlvbihwYXJ0LCB0eXBlKSB7XG4gICAgZXhwb3J0cy5jaGVja1N1cHBvcnQoXCJibG9iXCIpO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQmxvYiBjb25zdHJ1Y3RvclxuICAgICAgICByZXR1cm4gbmV3IEJsb2IoW3BhcnRdLCB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBkZXByZWNhdGVkLCBicm93c2VyIG9ubHksIG9sZCB3YXlcbiAgICAgICAgICAgIHZhciBCdWlsZGVyID0gc2VsZi5CbG9iQnVpbGRlciB8fCBzZWxmLldlYktpdEJsb2JCdWlsZGVyIHx8IHNlbGYuTW96QmxvYkJ1aWxkZXIgfHwgc2VsZi5NU0Jsb2JCdWlsZGVyO1xuICAgICAgICAgICAgdmFyIGJ1aWxkZXIgPSBuZXcgQnVpbGRlcigpO1xuICAgICAgICAgICAgYnVpbGRlci5hcHBlbmQocGFydCk7XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRlci5nZXRCbG9iKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG5cbiAgICAgICAgICAgIC8vIHdlbGwsIGZ1Y2sgPyFcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZyA6IGNhbid0IGNvbnN0cnVjdCB0aGUgQmxvYi5cIik7XG4gICAgICAgIH1cbiAgICB9XG5cblxufTtcbi8qKlxuICogVGhlIGlkZW50aXR5IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0IHRoZSBpbnB1dC5cbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIHNhbWUgaW5wdXQuXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0O1xufVxuXG4vKipcbiAqIEZpbGwgaW4gYW4gYXJyYXkgd2l0aCBhIHN0cmluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byB1c2UuXG4gKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheSB0aGUgYXJyYXkgdG8gZmlsbCBpbiAod2lsbCBiZSBtdXRhdGVkKS5cbiAqIEByZXR1cm4ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSB0aGUgdXBkYXRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9BcnJheUxpa2Uoc3RyLCBhcnJheSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGFycmF5W2ldID0gc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQW4gaGVscGVyIGZvciB0aGUgZnVuY3Rpb24gYXJyYXlMaWtlVG9TdHJpbmcuXG4gKiBUaGlzIGNvbnRhaW5zIHN0YXRpYyBpbmZvcm1hdGlvbnMgYW5kIGZ1bmN0aW9ucyB0aGF0XG4gKiBjYW4gYmUgb3B0aW1pemVkIGJ5IHRoZSBicm93c2VyIEpJVCBjb21waWxlci5cbiAqL1xudmFyIGFycmF5VG9TdHJpbmdIZWxwZXIgPSB7XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIGFuIGFycmF5IG9mIGludCBpbnRvIGEgc3RyaW5nLCBjaHVuayBieSBjaHVuay5cbiAgICAgKiBTZWUgdGhlIHBlcmZvcm1hbmNlcyBub3RlcyBvbiBhcnJheUxpa2VUb1N0cmluZy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheSB0aGUgYXJyYXkgdG8gdHJhbnNmb3JtLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIHRoZSBhcnJheS5cbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGNodW5rIHRoZSBjaHVuayBzaXplLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHJlc3VsdGluZyBzdHJpbmcuXG4gICAgICogQHRocm93cyBFcnJvciBpZiB0aGUgY2h1bmsgaXMgdG9vIGJpZyBmb3IgdGhlIHN0YWNrLlxuICAgICAqL1xuICAgIHN0cmluZ2lmeUJ5Q2h1bms6IGZ1bmN0aW9uKGFycmF5LCB0eXBlLCBjaHVuaykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW10sIGsgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIC8vIHNob3J0Y3V0XG4gICAgICAgIGlmIChsZW4gPD0gY2h1bmspIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoayA8IGxlbikge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYXJyYXlcIiB8fCB0eXBlID09PSBcIm5vZGVidWZmZXJcIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkuc2xpY2UoaywgTWF0aC5taW4oayArIGNodW5rLCBsZW4pKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhcnJheS5zdWJhcnJheShrLCBNYXRoLm1pbihrICsgY2h1bmssIGxlbikpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrICs9IGNodW5rO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENhbGwgU3RyaW5nLmZyb21DaGFyQ29kZSBvbiBldmVyeSBpdGVtIGluIHRoZSBhcnJheS5cbiAgICAgKiBUaGlzIGlzIHRoZSBuYWl2ZSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggZ2VuZXJhdGUgQSBMT1Qgb2YgaW50ZXJtZWRpYXRlIHN0cmluZy5cbiAgICAgKiBUaGlzIHNob3VsZCBiZSB1c2VkIHdoZW4gZXZlcnl0aGluZyBlbHNlIGZhaWwuXG4gICAgICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXkgdGhlIGFycmF5IHRvIHRyYW5zZm9ybS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSByZXN1bHQuXG4gICAgICovXG4gICAgc3RyaW5naWZ5QnlDaGFyOiBmdW5jdGlvbihhcnJheSl7XG4gICAgICAgIHZhciByZXN1bHRTdHIgPSBcIlwiO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFycmF5W2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0U3RyO1xuICAgIH0sXG4gICAgYXBwbHlDYW5CZVVzZWQgOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnVlIGlmIHRoZSBicm93c2VyIGFjY2VwdHMgdG8gdXNlIFN0cmluZy5mcm9tQ2hhckNvZGUgb24gVWludDhBcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgdWludDhhcnJheSA6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdXBwb3J0LnVpbnQ4YXJyYXkgJiYgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSkubGVuZ3RoID09PSAxO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRydWUgaWYgdGhlIGJyb3dzZXIgYWNjZXB0cyB0byB1c2UgU3RyaW5nLmZyb21DaGFyQ29kZSBvbiBub2RlanMgQnVmZmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgbm9kZWJ1ZmZlciA6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdXBwb3J0Lm5vZGVidWZmZXIgJiYgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBub2RlanNVdGlscy5hbGxvY0J1ZmZlcigxKSkubGVuZ3RoID09PSAxO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKVxuICAgIH1cbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgc3RyaW5nLlxuICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXkgdGhlIGFycmF5IHRvIHRyYW5zZm9ybS5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlVG9TdHJpbmcoYXJyYXkpIHtcbiAgICAvLyBQZXJmb3JtYW5jZXMgbm90ZXMgOlxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhcnJheSkgaXMgdGhlIGZhc3Rlc3QsIHNlZVxuICAgIC8vIHNlZSBodHRwOi8vanNwZXJmLmNvbS9jb252ZXJ0aW5nLWEtdWludDhhcnJheS10by1hLXN0cmluZy8yXG4gICAgLy8gYnV0IHRoZSBzdGFjayBpcyBsaW1pdGVkIChhbmQgd2UgY2FuIGdldCBodWdlIGFycmF5cyAhKS5cbiAgICAvL1xuICAgIC8vIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFycmF5W2ldKTsgZ2VuZXJhdGUgdG9vIG1hbnkgc3RyaW5ncyAhXG4gICAgLy9cbiAgICAvLyBUaGlzIGNvZGUgaXMgaW5zcGlyZWQgYnkgaHR0cDovL2pzcGVyZi5jb20vYXJyYXlidWZmZXItdG8tc3RyaW5nLWFwcGx5LXBlcmZvcm1hbmNlLzJcbiAgICAvLyBUT0RPIDogd2Ugbm93IGhhdmUgd29ya2VycyB0aGF0IHNwbGl0IHRoZSB3b3JrLiBEbyB3ZSBzdGlsbCBuZWVkIHRoYXQgP1xuICAgIHZhciBjaHVuayA9IDY1NTM2LFxuICAgICAgICB0eXBlID0gZXhwb3J0cy5nZXRUeXBlT2YoYXJyYXkpLFxuICAgICAgICBjYW5Vc2VBcHBseSA9IHRydWU7XG4gICAgaWYgKHR5cGUgPT09IFwidWludDhhcnJheVwiKSB7XG4gICAgICAgIGNhblVzZUFwcGx5ID0gYXJyYXlUb1N0cmluZ0hlbHBlci5hcHBseUNhbkJlVXNlZC51aW50OGFycmF5O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJub2RlYnVmZmVyXCIpIHtcbiAgICAgICAgY2FuVXNlQXBwbHkgPSBhcnJheVRvU3RyaW5nSGVscGVyLmFwcGx5Q2FuQmVVc2VkLm5vZGVidWZmZXI7XG4gICAgfVxuXG4gICAgaWYgKGNhblVzZUFwcGx5KSB7XG4gICAgICAgIHdoaWxlIChjaHVuayA+IDEpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5VG9TdHJpbmdIZWxwZXIuc3RyaW5naWZ5QnlDaHVuayhhcnJheSwgdHlwZSwgY2h1bmspO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNodW5rID0gTWF0aC5mbG9vcihjaHVuayAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gbm8gYXBwbHkgb3IgY2h1bmsgZXJyb3IgOiBzbG93IGFuZCBwYWluZnVsIGFsZ29yaXRobVxuICAgIC8vIGRlZmF1bHQgYnJvd3NlciBvbiBhbmRyb2lkIDQuKlxuICAgIHJldHVybiBhcnJheVRvU3RyaW5nSGVscGVyLnN0cmluZ2lmeUJ5Q2hhcihhcnJheSk7XG59XG5cbmV4cG9ydHMuYXBwbHlGcm9tQ2hhckNvZGUgPSBhcnJheUxpa2VUb1N0cmluZztcblxuXG4vKipcbiAqIENvcHkgdGhlIGRhdGEgZnJvbSBhbiBhcnJheS1saWtlIHRvIGFuIG90aGVyIGFycmF5LWxpa2UuXG4gKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheUZyb20gdGhlIG9yaWdpbiBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5VG8gdGhlIGRlc3RpbmF0aW9uIGFycmF5IHdoaWNoIHdpbGwgYmUgbXV0YXRlZC5cbiAqIEByZXR1cm4ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSB0aGUgdXBkYXRlZCBkZXN0aW5hdGlvbiBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlVG9BcnJheUxpa2UoYXJyYXlGcm9tLCBhcnJheVRvKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheUZyb20ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyYXlUb1tpXSA9IGFycmF5RnJvbVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5VG87XG59XG5cbi8vIGEgbWF0cml4IGNvbnRhaW5pbmcgZnVuY3Rpb25zIHRvIHRyYW5zZm9ybSBldmVyeXRoaW5nIGludG8gZXZlcnl0aGluZy5cbnZhciB0cmFuc2Zvcm0gPSB7fTtcblxuLy8gc3RyaW5nIHRvID9cbnRyYW5zZm9ybVtcInN0cmluZ1wiXSA9IHtcbiAgICBcInN0cmluZ1wiOiBpZGVudGl0eSxcbiAgICBcImFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdUb0FycmF5TGlrZShpbnB1dCwgbmV3IEFycmF5KGlucHV0Lmxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJhcnJheWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtW1wic3RyaW5nXCJdW1widWludDhhcnJheVwiXShpbnB1dCkuYnVmZmVyO1xuICAgIH0sXG4gICAgXCJ1aW50OGFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdUb0FycmF5TGlrZShpbnB1dCwgbmV3IFVpbnQ4QXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcIm5vZGVidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1RvQXJyYXlMaWtlKGlucHV0LCBub2RlanNVdGlscy5hbGxvY0J1ZmZlcihpbnB1dC5sZW5ndGgpKTtcbiAgICB9XG59O1xuXG4vLyBhcnJheSB0byA/XG50cmFuc2Zvcm1bXCJhcnJheVwiXSA9IHtcbiAgICBcInN0cmluZ1wiOiBhcnJheUxpa2VUb1N0cmluZyxcbiAgICBcImFycmF5XCI6IGlkZW50aXR5LFxuICAgIFwiYXJyYXlidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChuZXcgVWludDhBcnJheShpbnB1dCkpLmJ1ZmZlcjtcbiAgICB9LFxuICAgIFwidWludDhhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xuICAgIH0sXG4gICAgXCJub2RlYnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBub2RlanNVdGlscy5uZXdCdWZmZXJGcm9tKGlucHV0KTtcbiAgICB9XG59O1xuXG4vLyBhcnJheWJ1ZmZlciB0byA/XG50cmFuc2Zvcm1bXCJhcnJheWJ1ZmZlclwiXSA9IHtcbiAgICBcInN0cmluZ1wiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gYXJyYXlMaWtlVG9TdHJpbmcobmV3IFVpbnQ4QXJyYXkoaW5wdXQpKTtcbiAgICB9LFxuICAgIFwiYXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXlMaWtlKG5ldyBVaW50OEFycmF5KGlucHV0KSwgbmV3IEFycmF5KGlucHV0LmJ5dGVMZW5ndGgpKTtcbiAgICB9LFxuICAgIFwiYXJyYXlidWZmZXJcIjogaWRlbnRpdHksXG4gICAgXCJ1aW50OGFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShpbnB1dCk7XG4gICAgfSxcbiAgICBcIm5vZGVidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVqc1V0aWxzLm5ld0J1ZmZlckZyb20obmV3IFVpbnQ4QXJyYXkoaW5wdXQpKTtcbiAgICB9XG59O1xuXG4vLyB1aW50OGFycmF5IHRvID9cbnRyYW5zZm9ybVtcInVpbnQ4YXJyYXlcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogYXJyYXlMaWtlVG9TdHJpbmcsXG4gICAgXCJhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gYXJyYXlMaWtlVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwiYXJyYXlidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LmJ1ZmZlcjtcbiAgICB9LFxuICAgIFwidWludDhhcnJheVwiOiBpZGVudGl0eSxcbiAgICBcIm5vZGVidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVqc1V0aWxzLm5ld0J1ZmZlckZyb20oaW5wdXQpO1xuICAgIH1cbn07XG5cbi8vIG5vZGVidWZmZXIgdG8gP1xudHJhbnNmb3JtW1wibm9kZWJ1ZmZlclwiXSA9IHtcbiAgICBcInN0cmluZ1wiOiBhcnJheUxpa2VUb1N0cmluZyxcbiAgICBcImFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5TGlrZShpbnB1dCwgbmV3IEFycmF5KGlucHV0Lmxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJhcnJheWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtW1wibm9kZWJ1ZmZlclwiXVtcInVpbnQ4YXJyYXlcIl0oaW5wdXQpLmJ1ZmZlcjtcbiAgICB9LFxuICAgIFwidWludDhhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gYXJyYXlMaWtlVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBVaW50OEFycmF5KGlucHV0Lmxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJub2RlYnVmZmVyXCI6IGlkZW50aXR5XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBpbnB1dCBpbnRvIGFueSB0eXBlLlxuICogVGhlIHN1cHBvcnRlZCBvdXRwdXQgdHlwZSBhcmUgOiBzdHJpbmcsIGFycmF5LCB1aW50OGFycmF5LCBhcnJheWJ1ZmZlciwgbm9kZWJ1ZmZlci5cbiAqIElmIG5vIG91dHB1dCB0eXBlIGlzIHNwZWNpZmllZCwgdGhlIHVubW9kaWZpZWQgaW5wdXQgd2lsbCBiZSByZXR1cm5lZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvdXRwdXRUeXBlIHRoZSBvdXRwdXQgdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBpbnB1dCB0aGUgaW5wdXQgdG8gY29udmVydC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBhbiBFcnJvciBpZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlIHJlcXVlc3RlZCBvdXRwdXQgdHlwZS5cbiAqL1xuZXhwb3J0cy50cmFuc2Zvcm1UbyA9IGZ1bmN0aW9uKG91dHB1dFR5cGUsIGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgICAvLyB1bmRlZmluZWQsIG51bGwsIGV0Y1xuICAgICAgICAvLyBhbiBlbXB0eSBzdHJpbmcgd29uJ3QgaGFybS5cbiAgICAgICAgaW5wdXQgPSBcIlwiO1xuICAgIH1cbiAgICBpZiAoIW91dHB1dFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICBleHBvcnRzLmNoZWNrU3VwcG9ydChvdXRwdXRUeXBlKTtcbiAgICB2YXIgaW5wdXRUeXBlID0gZXhwb3J0cy5nZXRUeXBlT2YoaW5wdXQpO1xuICAgIHZhciByZXN1bHQgPSB0cmFuc2Zvcm1baW5wdXRUeXBlXVtvdXRwdXRUeXBlXShpbnB1dCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSB0eXBlIG9mIHRoZSBpbnB1dC5cbiAqIFRoZSB0eXBlIHdpbGwgYmUgaW4gYSBmb3JtYXQgdmFsaWQgZm9yIEpTWmlwLnV0aWxzLnRyYW5zZm9ybVRvIDogc3RyaW5nLCBhcnJheSwgdWludDhhcnJheSwgYXJyYXlidWZmZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgdGhlIGlucHV0IHRvIGlkZW50aWZ5LlxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgKGxvd2VyY2FzZSkgdHlwZSBvZiB0aGUgaW5wdXQuXG4gKi9cbmV4cG9ydHMuZ2V0VHlwZU9mID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgIHJldHVybiBcImFycmF5XCI7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0Lm5vZGVidWZmZXIgJiYgbm9kZWpzVXRpbHMuaXNCdWZmZXIoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBcIm5vZGVidWZmZXJcIjtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSAmJiBpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIFwidWludDhhcnJheVwiO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydC5hcnJheWJ1ZmZlciAmJiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBcImFycmF5YnVmZmVyXCI7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUaHJvdyBhbiBleGNlcHRpb24gaWYgdGhlIHR5cGUgaXMgbm90IHN1cHBvcnRlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIHRvIGNoZWNrLlxuICogQHRocm93cyB7RXJyb3J9IGFuIEVycm9yIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgcmVxdWVzdGVkIHR5cGUuXG4gKi9cbmV4cG9ydHMuY2hlY2tTdXBwb3J0ID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHZhciBzdXBwb3J0ZWQgPSBzdXBwb3J0W3R5cGUudG9Mb3dlckNhc2UoKV07XG4gICAgaWYgKCFzdXBwb3J0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHR5cGUgKyBcIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcGxhdGZvcm1cIik7XG4gICAgfVxufTtcblxuZXhwb3J0cy5NQVhfVkFMVUVfMTZCSVRTID0gNjU1MzU7XG5leHBvcnRzLk1BWF9WQUxVRV8zMkJJVFMgPSAtMTsgLy8gd2VsbCwgXCJcXHhGRlxceEZGXFx4RkZcXHhGRlxceEZGXFx4RkZcXHhGRlxceEZGXCIgaXMgcGFyc2VkIGFzIC0xXG5cbi8qKlxuICogUHJldHRpZnkgYSBzdHJpbmcgcmVhZCBhcyBiaW5hcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gcHJldHRpZnkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGEgcHJldHR5IHN0cmluZy5cbiAqL1xuZXhwb3J0cy5wcmV0dHkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICB2YXIgcmVzID0gJycsXG4gICAgICAgIGNvZGUsIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IChzdHIgfHwgXCJcIikubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICByZXMgKz0gJ1xcXFx4JyArIChjb2RlIDwgMTYgPyBcIjBcIiA6IFwiXCIpICsgY29kZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8qKlxuICogRGVmZXIgdGhlIGNhbGwgb2YgYSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRoZSBmdW5jdGlvbiB0byBjYWxsIGFzeW5jaHJvbm91c2x5LlxuICogQHBhcmFtIHtBcnJheX0gYXJncyB0aGUgYXJndW1lbnRzIHRvIGdpdmUgdG8gdGhlIGNhbGxiYWNrLlxuICovXG5leHBvcnRzLmRlbGF5ID0gZnVuY3Rpb24oY2FsbGJhY2ssIGFyZ3MsIHNlbGYpIHtcbiAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjay5hcHBseShzZWxmIHx8IG51bGwsIGFyZ3MgfHwgW10pO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBFeHRlbmRzIGEgcHJvdG90eXBlIHdpdGggYW4gb3RoZXIsIHdpdGhvdXQgY2FsbGluZyBhIGNvbnN0cnVjdG9yIHdpdGhcbiAqIHNpZGUgZWZmZWN0cy4gSW5zcGlyZWQgYnkgbm9kZWpzJyBgdXRpbHMuaW5oZXJpdHNgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdG9yIHRoZSBjb25zdHJ1Y3RvciB0byBhdWdtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdXBlckN0b3IgdGhlIHBhcmVudCBjb25zdHJ1Y3RvciB0byB1c2VcbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IGZ1bmN0aW9uIChjdG9yLCBzdXBlckN0b3IpIHtcbiAgICB2YXIgT2JqID0gZnVuY3Rpb24oKSB7fTtcbiAgICBPYmoucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZTtcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBPYmooKTtcbn07XG5cbi8qKlxuICogTWVyZ2UgdGhlIG9iamVjdHMgcGFzc2VkIGFzIHBhcmFtZXRlcnMgaW50byBhIG5ldyBvbmUuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsuLi5PYmplY3R9IHZhcl9hcmdzIEFsbCBvYmplY3RzIHRvIG1lcmdlLlxuICogQHJldHVybiB7T2JqZWN0fSBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgZGF0YSBvZiB0aGUgb3RoZXJzLlxuICovXG5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXN1bHQgPSB7fSwgaSwgYXR0cjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IC8vIGFyZ3VtZW50cyBpcyBub3QgZW51bWVyYWJsZSBpbiBzb21lIGJyb3dzZXJzXG4gICAgICAgIGZvciAoYXR0ciBpbiBhcmd1bWVudHNbaV0pIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0uaGFzT3duUHJvcGVydHkoYXR0cikgJiYgdHlwZW9mIHJlc3VsdFthdHRyXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdFthdHRyXSA9IGFyZ3VtZW50c1tpXVthdHRyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYXJiaXRyYXJ5IGNvbnRlbnQgaW50byBhIFByb21pc2UuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBhIG5hbWUgZm9yIHRoZSBjb250ZW50IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGEgdGhlIGNvbnRlbnQgdG8gcHJvY2Vzcy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNCaW5hcnkgdHJ1ZSBpZiB0aGUgY29udGVudCBpcyBub3QgYW4gdW5pY29kZSBzdHJpbmdcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNPcHRpbWl6ZWRCaW5hcnlTdHJpbmcgdHJ1ZSBpZiB0aGUgc3RyaW5nIGNvbnRlbnQgb25seSBoYXMgb25lIGJ5dGUgcGVyIGNoYXJhY3Rlci5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNCYXNlNjQgdHJ1ZSBpZiB0aGUgc3RyaW5nIGNvbnRlbnQgaXMgZW5jb2RlZCB3aXRoIGJhc2U2NC5cbiAqIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSBpbiBhIGZvcm1hdCB1c2FibGUgYnkgSlNaaXAuXG4gKi9cbmV4cG9ydHMucHJlcGFyZUNvbnRlbnQgPSBmdW5jdGlvbihuYW1lLCBpbnB1dERhdGEsIGlzQmluYXJ5LCBpc09wdGltaXplZEJpbmFyeVN0cmluZywgaXNCYXNlNjQpIHtcblxuICAgIC8vIGlmIGlucHV0RGF0YSBpcyBhbHJlYWR5IGEgcHJvbWlzZSwgdGhpcyBmbGF0dGVuIGl0LlxuICAgIHZhciBwcm9taXNlID0gZXh0ZXJuYWwuUHJvbWlzZS5yZXNvbHZlKGlucHV0RGF0YSkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgdmFyIGlzQmxvYiA9IHN1cHBvcnQuYmxvYiAmJiAoZGF0YSBpbnN0YW5jZW9mIEJsb2IgfHwgWydbb2JqZWN0IEZpbGVdJywgJ1tvYmplY3QgQmxvYl0nXS5pbmRleE9mKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSkgIT09IC0xKTtcblxuICAgICAgICBpZiAoaXNCbG9iICYmIHR5cGVvZiBGaWxlUmVhZGVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGV4dGVybmFsLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShlLnRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlLnRhcmdldC5lcnJvcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIGRhdGFUeXBlID0gZXhwb3J0cy5nZXRUeXBlT2YoZGF0YSk7XG5cbiAgICAgICAgaWYgKCFkYXRhVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dGVybmFsLlByb21pc2UucmVqZWN0KFxuICAgICAgICAgICAgICAgIG5ldyBFcnJvcihcIkNhbid0IHJlYWQgdGhlIGRhdGEgb2YgJ1wiICsgbmFtZSArIFwiJy4gSXMgaXQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcImluIGEgc3VwcG9ydGVkIEphdmFTY3JpcHQgdHlwZSAoU3RyaW5nLCBCbG9iLCBBcnJheUJ1ZmZlciwgZXRjKSA/XCIpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSA6IGl0J3Mgd2F5IGVhc2llciB0byB3b3JrIHdpdGggVWludDhBcnJheSB0aGFuIHdpdGggQXJyYXlCdWZmZXJcbiAgICAgICAgaWYgKGRhdGFUeXBlID09PSBcImFycmF5YnVmZmVyXCIpIHtcbiAgICAgICAgICAgIGRhdGEgPSBleHBvcnRzLnRyYW5zZm9ybVRvKFwidWludDhhcnJheVwiLCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhVHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKGlzQmFzZTY0KSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGJhc2U2NC5kZWNvZGUoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0JpbmFyeSkge1xuICAgICAgICAgICAgICAgIC8vIG9wdGltaXplZEJpbmFyeVN0cmluZyA9PT0gdHJ1ZSBtZWFucyB0aGF0IHRoZSBmaWxlIGhhcyBhbHJlYWR5IGJlZW4gZmlsdGVyZWQgd2l0aCBhIDB4RkYgbWFza1xuICAgICAgICAgICAgICAgIGlmIChpc09wdGltaXplZEJpbmFyeVN0cmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgc3RyaW5nLCBub3QgaW4gYSBiYXNlNjQgZm9ybWF0LlxuICAgICAgICAgICAgICAgICAgICAvLyBCZSBzdXJlIHRoYXQgdGhpcyBpcyBhIGNvcnJlY3QgXCJiaW5hcnkgc3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHN0cmluZzJiaW5hcnkoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0pO1xufTtcbiIsIi8vIFdoZXRoZXIgYWxsIGF1ZGlvIGluc3RydWN0aW9ucyBzaG91bGQgYXV0b21hdGljYWxseSBwcmVsb2FkXG5leHBvcnQgdmFyIF9hdXRvUHJlbG9hZEF1ZGlvID0gdHJ1ZTtcblxuLy8gV2hldGhlciBhbGwgYXVkaW8gaW5zdHJ1Y3Rpb25zIHNob3VsZCBhdXRvbWF0aWNhbGx5IHByZWxvYWRcbmV4cG9ydCB2YXIgX2F1dG9QcmVsb2FkSW1hZ2VzID0gdHJ1ZTtcblxuLy8gV2hldGhlciBhbGwgdmlkZW8gaW5zdHJ1Y3Rpb25zIHNob3VsZCBhdXRvbWF0aWNhbGx5IHByZWxvYWRcbmV4cG9ydCB2YXIgX2F1dG9QcmVsb2FkVmlkZW9zID0gdHJ1ZTtcblxuLy8gV2hldGhlciBBTEwgcmVzb3VyY2VzIHNob3VsZCBiZSBwcmVsb2FkZWQgYXQgb25jZSBhbmQgYXNhcFxuZXhwb3J0IHZhciBfZ2xvYmFsUHJlbG9hZCA9IHRydWU7XG5cbi8vIEFycmF5IG9mIGluc3RydWN0aW9ucyB0byBwcmVsb2FkXG5leHBvcnQgdmFyIF9pbnN0cnVjdGlvbnNUb1ByZWxvYWQgPSBbXTtcblxuLy8gSG93IGxvbmcgdGhlIHByZWxvYWRlciBzaG91bGQgd2FpdCBiZWZvcmUgaWdub3JpbmcgZmFpbHVyZSB0byBwcmVsb2FkIChtcylcbmV4cG9ydCB2YXIgX3RpbWVvdXRQcmVsb2FkID0gMTIwMDAwO1xuXG4vLyBUaGUgbWVzc2FnZSB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWQgd2hpbGUgcHJlbG9hZGluZ1xuZXhwb3J0IHZhciBfd2FpdFdoaWxlUHJlbG9hZGluZ01lc3NhZ2UgPSBcIlBsZWFzZSB3YWl0IHdoaWxlIHRoZSByZXNvdXJjZXMgYXJlIHByZWxvYWRpbmcuIFRoaXMgcHJvY2VzcyBtYXkgdGFrZSB1cCB0byAyIG1pbnV0ZXMuXCI7XG5cbi8vIFJldHVybnMgb25seSB0aGUgaXRlbXMgdGhhdCB3aWxsIGJlIHJ1biAoc2VlIGxhdGluLXNxdWFyZWQgZGVzaWducylcbi8vIGNhbGxlZCBieSBfY2hlY2tQcmVsb2FkIChidXQgY291bGQgYmUgdXNlZnVsIGZvciBvdGhlciB0cmlja3MpXG5mdW5jdGlvbiBfZmlsdGVyZWRJdGVtcyhpdGVtcykge1xuICAgIGxldCBmaWx0ZXJlZEl0ZW1zID0gW107XG4gICAgbGV0IGxhdGluU3F1YXJlZCA9IHt9O1xuICAgIC8vIEdvaW5nIHRocm91Z2ggdGhlIGl0ZW1zXG4gICAgZm9yIChsZXQgaSBpbiBpdGVtcykge1xuICAgICAgICBsZXQgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICAvLyBJZiBpdGVtIGlzIG5vdCBsYXRpbi1zcXVhcmVkLCBhZGQgaXQgdG8gZmlsdGVyZWRJdGVtc1xuICAgICAgICBpZiAoIShpdGVtWzBdIGluc3RhbmNlb2YgQXJyYXkpKVxuICAgICAgICAgICAgZmlsdGVyZWRJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAvLyBJZiBpdCBpcyBsYXRpbi1zcXVhcmVkLCBhZGQgaXQgdG8gbGF0aW5TcXVhcmVkIHVuZGVyIGl0cyBrZXlcbiAgICAgICAgZWxzZSBpZiAoaXRlbVswXS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsZXQga2V5ID0gaXRlbVswXVsxXTtcbiAgICAgICAgICAgIGlmICghbGF0aW5TcXVhcmVkLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICAgICAgbGF0aW5TcXVhcmVkW2tleV0gPSBbXTtcbiAgICAgICAgICAgIGxhdGluU3F1YXJlZFtrZXldLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNvdW50ZXI7XG4gICAgaWYgKHR5cGVvZihjb3VudGVyT3ZlcnJpZGUpICE9IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIGNvdW50ZXIgPSBjb3VudGVyT3ZlcnJpZGU7XG4gICAgZWxzZVxuICAgICAgICBjb3VudGVyID0gX19jb3VudGVyX3ZhbHVlX2Zyb21fc2VydmVyX187XG4gICAgLy8gTm93IGdvIHRocm91Z2ggdGhlIGxhdGluLXNxdWFyZWQgaXRlbXNcbiAgICBmb3IgKGxldCBsID0gMDsgbCA8IE9iamVjdC5rZXlzKGxhdGluU3F1YXJlZCkubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgbGV0IGl0ZW1zSW5Hcm91cCA9IGxhdGluU3F1YXJlZFsgT2JqZWN0LmtleXMobGF0aW5TcXVhcmVkKVtsXSBdO1xuICAgICAgICBsZXQgbG9jYWxDb3VudGVyID0gKChjb3VudGVyICUgaXRlbXNJbkdyb3VwLmxlbmd0aCkgKyBsKSAlIGl0ZW1zSW5Hcm91cC5sZW5ndGg7XG4gICAgICAgIGZpbHRlcmVkSXRlbXMucHVzaChpdGVtc0luR3JvdXBbbG9jYWxDb3VudGVyXSk7XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJlZEl0ZW1zO1xufTtcblxuLy8gRmVlZHMgdGhlIHBhc3NlZCBjb250cm9sbGVyIHNvIGFzIHRvIHdhaXQgZm9yIHRoZSByZXNvdXJjZXMgb2YgdGhlIG1hdGNoaW5nIGl0ZW1zIHRvIGJlIHByZWxvYWRlZFxuLy8gY2FsbGVkIGJ5IHRoZSBjb250cm9sbGVyIChzZWUgZGVmaW5lX2liZXhfY29udHJvbGxlciBiZWxvdylcbmV4cG9ydCBmdW5jdGlvbiBfY2hlY2tQcmVsb2FkKGNvbnRyb2xsZXIpIHtcbiAgICAvLyA9PT09ICAgICBCVUlMRCBMSVNUIE9GIFJFU09VUkNFUyAgICAgPT09PVxuICAgIC8vXG4gICAgbGV0IGluc3RydWN0aW9ucyA9IFtdO1xuXG4gICAgLy8gQnVpbGQgdGhlIGxpc3Qgb2YgbGFiZWwgcHJlZGljYXRlcyAoc2VlIElCRVggc2h1ZmZsZS5qcylcbiAgICBsZXQgbGFiZWxQcmVkaWNhdGVzID0gW107XG4gICAgLy8gSWYgbGFiZWwgcHJlZGljYXRlcyBhcmUgcGFzc2VkLCBnbyB0aHJvdWdoIHRoZW1cbiAgICBpZiAoY29udHJvbGxlci5vcHRpb25zLnByZWxvYWQuaGFzT3duUHJvcGVydHkoMCkpIHtcbiAgICAgICAgZm9yIChsZXQgYyBpbiBjb250cm9sbGVyLm9wdGlvbnMucHJlbG9hZCkge1xuICAgICAgICAgICAgbGV0IHByZWRpY2F0ZSA9IGNvbnRyb2xsZXIub3B0aW9ucy5wcmVsb2FkW2NdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZihwcmVkaWNhdGUpID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IGFueSBzdHJpbmcgaW50byBhIHByZWRpY2F0ZSAoc2VlIElCRVgncyBzaHVmZmxlLmpzKVxuICAgICAgICAgICAgaWYgKHR5cGVvZihwcmVkaWNhdGUpID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgcHJlZGljYXRlID0gKHMpID0+IHMgPT0gY29udHJvbGxlci5vcHRpb25zLnByZWxvYWRbY107XG4gICAgICAgICAgICBsYWJlbFByZWRpY2F0ZXMucHVzaChwcmVkaWNhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE5vIHByZWRpY2F0ZSBwYXNzZWQ6IGFsbCBsYWJlbHMgYXJlIGluXG4gICAgZWxzZVxuICAgICAgICBsYWJlbFByZWRpY2F0ZXMgPSBbYW55VHlwZV07XG4gICAgLy8gR2V0IHRoZSBsaXN0IG9mIGl0ZW1zIHRoYXQgd2lsbCBiZSBydW4gKGV4Y2x1ZGUgaXRlbXMgbm90IHRhcmdldCBieSBsYXRpbi1zcXVhcmVkIGRlc2lnbnMpXG4gICAgbGV0IGZpbHRlcmVkSXRlbXMgPSBfZmlsdGVyZWRJdGVtcyhpdGVtcyk7XG4gICAgLy8gR28gdGhyb3VnaCB0aGUgbGlzdCBvZiBpdGVtc1xuICAgIGZvciAobGV0IGkgaW4gZmlsdGVyZWRJdGVtcykge1xuICAgICAgICBsZXQgaXRlbSA9IGZpbHRlcmVkSXRlbXNbaV07XG4gICAgICAgIC8vIEdldCB0aGUgbGFiZWwgb2YgdGhlIGl0ZW1cbiAgICAgICAgbGV0IGxhYmVsID0gaXRlbVswXTtcbiAgICAgICAgLy8gSWYgdGhlIGl0ZW0gaXMgbGF0aW4tc3F1YXJlZCAoaWUuLCBsYWJlbCBpcyBhbiBhcnJheSkgbGFiZWwgaXMgYWN0dWFsbHkgbGFiZWwncyBmaXJzdCBlbGVtZW50XG4gICAgICAgIGlmIChsYWJlbCBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgbGFiZWwgPSBpdGVtWzBdWzBdO1xuICAgICAgICAvLyBHbyB0aHJvdWdoIHRoZSBsYWJlbCBwcmVkaWNhdGVzXG4gICAgICAgIGxldCBtYXRjaCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBsIGluIGxhYmVsUHJlZGljYXRlcykge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGxhYmVsIHNhdGlzZmllcyBhIHByZWRpY2F0ZSwgdGhlbiB3aWxsIGFkZCBpdHMgaW5zdHJ1Y3Rpb25zIHRvIHRoZSBsaXN0XG4gICAgICAgICAgICBpZiAobGFiZWxQcmVkaWNhdGVzW2xdKGxhYmVsKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyBtYXRjaCB3YXMgZm91bmQsIGdvIHRvIHRoZSBuZXh0IGl0ZW1cbiAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZXJlIGFyZSBQZW5uQ29udHJvbGxlciBlbGVtZW50cyBpbiB0aGUgaXRlbVxuICAgICAgICBsZXQgcHJldmlvdXNJc1Blbm5Db250cm9sbGVyID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGVsIGluIGl0ZW0pIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IGVsZW1lbnQgaXMgbGFiZWwgWysgbGF0aW4tc3F1YXJlXVxuICAgICAgICAgICAgaWYgKGVsID09IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgZWxlbWVudCA9IGl0ZW1bZWxdO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIGVsZW1lbnQgd2FzIHRoZSBzdHJpbmcgXCJQZW5uQ29udHJvbGxlclwiXG4gICAgICAgICAgICBpZiAocHJldmlvdXNJc1Blbm5Db250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgZm9yIG5leHQgZWxlbWVudHNcbiAgICAgICAgICAgICAgICBwcmV2aW91c0lzUGVubkNvbnRyb2xsZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBNYWtpbmcgc3VyZSB0aGUgY3VycmVudCBlbGVtZW50IGlzIGluZGVlZCBhIHBlbm5jb250cm9sbGVyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBPYmplY3QgJiYgZWxlbWVudC5oYXNPd25Qcm9wZXJ0eShcImlkXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgUGVubkNvbnRyb2xsZXIncyByZXNvdXJjZXNcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb25zLmNvbmNhdChDdHJsci5saXN0W2VsZW1lbnQuaWRdLnByZWxvYWRpbmdJbnN0cnVjdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGVsZW1lbnQgaXMgdGhlIHN0cmluZyBcIlBlbm5Db250cm9sbGVyLFwiIG5vdGUgaXQgZG93blxuICAgICAgICAgICAgaWYgKGVsID4gMCAmJiBlbGVtZW50ID09IFwiUGVubkNvbnRyb2xsZXJcIilcbiAgICAgICAgICAgICAgICBwcmV2aW91c0lzUGVubkNvbnRyb2xsZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vID09PT0gICAgIENSRUFURSBDT05UUk9MTEVSJ1MgQ09OVEVOVCAoQU5EIFRJTUVSKSAgICAgPT09PVxuICAgIC8vICAgICAgICBcbiAgICAvLyBBZGQgdGhlIHByZWxvYWRpbmcgbWVzc2FnZVxuICAgIGxldCB3YWl0ID0gJChcIjxkaXYgaWQ9J3dhaXRXaGlsZVByZWxvYWRpbmcnPlwiKS5hcHBlbmQoX3dhaXRXaGlsZVByZWxvYWRpbmdNZXNzYWdlKTtcbiAgICBjb250cm9sbGVyLmVsZW1lbnQuYXBwZW5kKCB3YWl0ICk7XG4gICAgLy8gR28gdGhyb3VnaCB0aGUgaW5zdHJ1Y3Rpb25zIHRvIHByZWxvYWRcbiAgICBmb3IgKGxldCBpIGluIGluc3RydWN0aW9ucykge1xuICAgICAgICBsZXQgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbnNbaV07XG4gICAgICAgIGlmIChpbnN0cnVjdGlvbiAmJiBfaW5zdHJ1Y3Rpb25zVG9QcmVsb2FkLmluZGV4T2YoaW5zdHJ1Y3Rpb24pPj0wKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRyb2xsZXIudG9QcmVsb2FkKVxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIudG9QcmVsb2FkID0gW107XG4gICAgICAgICAgICAvLyBBZGQgdGhlIGluc3RydWN0aW9uIG9ubHkgaWYgbm90IGFscmVhZHkgbGlzdGVkXG4gICAgICAgICAgICBpZiAoY29udHJvbGxlci50b1ByZWxvYWQuaW5kZXhPZihpbnN0cnVjdGlvbikgPCAwKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci50b1ByZWxvYWQucHVzaChpbnN0cnVjdGlvbik7XG4gICAgICAgICAgICAgICAgLy8gRXh0ZW5kIF9zZXRSZXNvdXJjZSAoY2FsbGVkIHdoZW4gcHJlbG9hZCBpcyBkb25lKVxuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLl9zZXRSZXNvdXJjZSA9IGluc3RydWN0aW9uLmV4dGVuZChcIl9zZXRSZXNvdXJjZVwiLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGVudHJ5IChzZXQgaW5kZXggaGVyZSwgYXMgaXQgbWF5IGhhdmUgY2hhbmdlZCBieSB0aGUgdGltZSBjYWxsYmFjayBpcyBjYWxsZWQpXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IGNvbnRyb2xsZXIudG9QcmVsb2FkLmluZGV4T2YoaW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIudG9QcmVsb2FkLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vIG1vcmUgZmlsZSB0byBwcmVsb2FkLCBmaW5pc2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIudG9QcmVsb2FkLmxlbmd0aCA8PSAwICYmIGpRdWVyeS5jb250YWlucyhkb2N1bWVudCwgd2FpdFswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhaXQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmZpbmlzaGVkQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIGFsbCByZXNvdXJjZXMgYWxyZWFkeSBwcmVsb2FkZWQgYW55d2F5LCBwcm9jZWVkXG4gICAgaWYgKCghY29udHJvbGxlci50b1ByZWxvYWQgfHwgY29udHJvbGxlci50b1ByZWxvYWQubGVuZ3RoIDw9IDApICYmIGpRdWVyeS5jb250YWlucyhkb2N1bWVudCwgd2FpdFswXSkpIHtcbiAgICAgICAgd2FpdC5yZW1vdmUoKTtcbiAgICAgICAgY29udHJvbGxlci5maW5pc2hlZENhbGxiYWNrKCk7XG4gICAgfVxuICAgIC8vIEVsc2UsIG1ha2Ugc3VyZSB0byBzZXQgYSB0aW1lb3V0XG4gICAgZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIC8vIEFib3J0IGlmIHdhaXQgbm8gbG9uZ2VyIGRpc3BsYXllZCAoaWUuLCBwcmVsb2FkaW5nJ3MgZG9uZSlcbiAgICAgICAgICAgIGlmICghalF1ZXJ5LmNvbnRhaW5zKGRvY3VtZW50LCB3YWl0WzBdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gQWJvcnQ7XG4gICAgICAgICAgICB3YWl0LnJlbW92ZSgpO1xuICAgICAgICAgICAgY29udHJvbGxlci5maW5pc2hlZENhbGxiYWNrKCk7XG4gICAgICAgIH0sIGNvbnRyb2xsZXIub3B0aW9ucy50aW1lb3V0KTtcbiAgICB9XG4gICAgcmV0dXJuIEFib3J0O1xufTtcblxuLy8gQ3JlYXRlcyBhIENoZWNrUHJlbG9hZCBpdGVtLCB0byBiZSB1c2VkIGluIGFuIGl0ZW0gZGVmaW5pdGlvbiBpbiBwbGFjZSBvZiBQZW5uQ29udHJvbGxlclxuLy8gc2VlIGRlZmluZV9pYmV4X2NvbnRyb2xsZXIgZm9yIGhvdyBpdCBjb250cmlidXRlcyB0byBjYWxsaW5nIF9jaGVja1ByZWxvYWRcblBlbm5Db250cm9sbGVyLkNoZWNrUHJlbG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBJZiBDaGVja1ByZWxvYWQgd2FzIGNhbGxlZCwgdGhlbiBvdmVycmlkZSBfZ2xvYmFsUHJlbG9hZFxuICAgIF9nbG9iYWxQcmVsb2FkID0gZmFsc2U7XG4gICAgbGV0IHRpbWVvdXQgPSBhcmd1bWVudHNbT2JqZWN0LmtleXMoYXJndW1lbnRzKS5sZW5ndGgtMV07XG4gICAgaWYgKHR5cGVvZih0aW1lb3V0KSAhPSBcIm51bWJlclwiIHx8IHRpbWVvdXQgPD0gMClcbiAgICAgICAgdGltZW91dCA9IF90aW1lb3V0UHJlbG9hZFxuICAgIC8vIFJldHVybiB0aGUgb2JqZWN0IGJlbG93OyB0aGUgY29udHJvbGxlciB3aWxsIGtub3cgaG93IHRvIGRlYWwgd2l0aCBpdCAoc2VlIGRlZmluZV9pYmV4X2NvbnRyb2xsZXIgYmVsb3cpXG4gICAgcmV0dXJuIHtjdXN0b206IF9jaGVja1ByZWxvYWQsIHByZWxvYWQ6IGFyZ3VtZW50cywgdGltZW91dDogdGltZW91dCwgY291bnRzRm9yUHJvZ3Jlc3NCYXI6IGZhbHNlfTtcbn07XG5cbi8vIFNldHRpbmdzIGZvciBhdXRvIHByZWxvYWRpbmdcblBlbm5Db250cm9sbGVyLkF1dG9QcmVsb2FkID0gZnVuY3Rpb24gKHBhcmFtZXRlcikge1xuICAgIGlmIChwYXJhbWV0ZXIgPT0gXCJpbWFnZXNcIikge1xuICAgICAgICBfYXV0b1ByZWxvYWRWaWRlb3MgPSBmYWxzZTtcbiAgICAgICAgX2F1dG9QcmVsb2FkQXVkaW8gPSBmYWxzZTtcbiAgICAgICAgX2F1dG9QcmVsb2FkSW1hZ2VzID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFyYW1ldGVyID09IFwiYXVkaW9cIikge1xuICAgICAgICBfYXV0b1ByZWxvYWRBdWRpbyA9IHRydWU7XG4gICAgICAgIF9hdXRvUHJlbG9hZEltYWdlcyA9IGZhbHNlO1xuICAgICAgICBfYXV0b1ByZWxvYWRWaWRlb3MgPSBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFyYW1ldGVycyA9PSBcInZpZGVvXCIpIHtcbiAgICAgICAgX2F1dG9QcmVsb2FkVmlkZW9zID0gdHJ1ZTtcbiAgICAgICAgX2F1dG9QcmVsb2FkQXVkaW8gPSBmYWxzZTtcbiAgICAgICAgX2F1dG9QcmVsb2FkSW1hZ2VzID0gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZihwYXJhbWV0ZXIpID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKHBhcmFtZXRlci5oYXNPd25Qcm9wZXJ0eShcImltYWdlc1wiKSlcbiAgICAgICAgICAgIF9hdXRvUHJlbG9hZEltYWdlcyA9IHBhcmFtZXRlci5pbWFnZXM7XG4gICAgICAgIGlmIChwYXJhbWV0ZXIuaGFzT3duUHJvcGVydHkoXCJhdWRpb1wiKSlcbiAgICAgICAgICAgIF9hdXRvUHJlbG9hZEF1ZGlvID0gcGFyYW1ldGVyLmF1ZGlvO1xuICAgICAgICBpZiAocGFyYW1ldGVyLmhhc093blByb3BlcnR5KFwidmlkZW9zXCIpKVxuICAgICAgICAgICAgX2F1dG9QcmVsb2FkVmlkZW9zID0gcGFyYW1ldGVyLnZpZGVvcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIF9hdXRvUHJlbG9hZEF1ZGlvID0gdHJ1ZTtcbiAgICAgICAgX2F1dG9QcmVsb2FkSW1hZ2VzID0gdHJ1ZTtcbiAgICAgICAgX2F1dG9QcmVsb2FkVmlkZW9zID0gdHJ1ZTtcbiAgICB9XG59OyIsImltcG9ydCB7X2luc3RydWN0aW9uc1RvUHJlbG9hZH0gZnJvbSBcIi4uL3ByZWxvYWQvcHJlbG9hZC5qc1wiO1xuaW1wb3J0IHtfVVJMc1RvTG9hZCwgX3ppcFByaW9yaXR5LCBfdW56aXBwZWRSZXNvdXJjZXMsIF96aXBDYWxsYmFja3N9IGZyb20gXCIuLi9wcmVsb2FkL3ByZWxvYWRaaXAuanNcIjtcblxuY29uc3QgTXV0YXRpb25PYnNlcnZlciA9XG4gICAgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93LldlYktpdE11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93Lk1vek11dGF0aW9uT2JzZXJ2ZXI7XG5cbi8vIFRoZSBpbnN0cnVjdGlvbnMgb2YgZWFjaCBjb250cm9sbGVyXG52YXIgX2xvY2FsSW5zdHJ1Y3Rpb25zID0gW3t9XTtcblxuLy8gVGhlIEluc3RydWN0aW9uIGNsYXNzIGl0c2VsZlxuZXhwb3J0IGNsYXNzIEluc3RydWN0aW9uIHtcblxuICAgIGNvbnN0cnVjdG9yKGNvbnRlbnQsIHR5cGUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy5oYXNCZWVuUnVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNEb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFyZW50RWxlbWVudCA9IG51bGw7ICAgICAgICAgIC8vIFRvIGJlIHNldCBieSBjYWxsZXJcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcmlnaW4gPSB0aGlzO1xuICAgICAgICB0aGlzLml0dmxXaGVuID0gbnVsbDsgICAgICAgICAgICAgICAvLyBVc2VkIGluIFdIRU5cbiAgICAgICAgdGhpcy5yZXNvdXJjZSA9IG51bGw7XG4gICAgICAgIC8vIEogcHJvdmlkZXMgd2l0aCBjb3BpZXMgb2YgdGhlIGVsZW1lbnQncyBtZXRob2RzL2F0dHJpYnV0ZXMgdGhhdCByZXR1cm4gaW5zdHJ1Y3Rpb25zL2NvbmRpdGlvbmFsIGZ1bmN0aW9uc1xuICAgICAgICB0aGlzLmogPSB7fVxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ3JlYXRlZCBpbnN0cnVjdGlvbiBvZiB0eXBlIFwiK3R5cGUrXCIgd2l0aCBcIit0aGlzLmNvbnRlbnQpO1xuICAgICAgICAvLyBBZGQgaW5zdHJ1Y3Rpb24gdG8gdGhlIGN1cnJlbnQgY29udHJvbGxlclxuICAgICAgICBpZiAoIUN0cmxyLmJ1aWxkaW5nLmhhc093blByb3BlcnR5KFwiaW5zdHJ1Y3Rpb25zXCIpKVxuICAgICAgICAgICAgQ3RybHIuYnVpbGRpbmcuaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgIEN0cmxyLmJ1aWxkaW5nLmluc3RydWN0aW9ucy5wdXNoKHRoaXMpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkNyZWF0ZWQgYSBuZXcgaW5zdHJ1Y3Rpb24sIGFkZGluZyB0byBjb250cm9sbGVyOlwiLCBDdHJsci5idWlsZGluZyk7XG4gICAgfVxuXG4gICAgLy8gQWRkcyB0aGlzJ3MgZWxlbWVudCB0byBhIGdpdmVuIGVsZW1lbnRcbiAgICBfYWRkRWxlbWVudCh0bywgZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICB0byA9IEN0cmxyLnJ1bm5pbmcuZWxlbWVudDtcbiAgICAgICAgaWYgKGVsZW1lbnQgPT0gbnVsbClcbiAgICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBqUXVlcnkpIHx8ICEodG8gaW5zdGFuY2VvZiBqUXVlcnkpKVxuICAgICAgICAgICAgcmV0dXJuIEFib3J0O1xuICAgICAgICAvLyBJZiBhZGRpbmcgZGlyZWN0bHkgdG8gdGhlIGNvbnRyb2xsZXIsIGVtYmVkIGluIGEgRElWXG4gICAgICAgIGlmICh0byA9PSBDdHJsci5ydW5uaW5nLmVsZW1lbnQpXG4gICAgICAgICAgICBlbGVtZW50ID0gJChcIjxkaXY+XCIpLmFwcGVuZChlbGVtZW50KTtcbiAgICAgICAgLy8gRnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zODU4ODc0MS9oYXZpbmctYS1yZWZlcmVuY2UtdG8tYW4tZWxlbWVudC1ob3ctdG8tZGV0ZWN0LW9uY2UtaXQtYXBwZW5kZWQtdG8tdGhlLWRvY3VtZW50XG4gICAgICAgIGlmIChjYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIE11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGxldCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobXV0YXRpb25zWzBdLmFkZGVkTm9kZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwobXV0YXRpb25zWzBdLmFkZGVkTm9kZXMsIGVsZW1lbnRbMF0pID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUodG9bMF0sIHtcbiAgICAgICAgICAgICAgICBjaGlsZExpc3Q6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRvLmFwcGVuZChlbGVtZW50KTtcbiAgICB9XG5cbiAgICAvLyBNZXRob2QgdG8gc2V0IHRoZSBqUXVlcnkgZWxlbWVudFxuICAgIC8vIEZlZWRzIHRoZSBKIGF0dHJpYnV0ZVxuICAgIHNldEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICAvLyBTZXQgdGhlIGVsZW1lbnRcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgbGV0IHRpID0gdGhpcztcbiAgICAgICAgLy8gQW5kIGZlZWQgSiB3aXRoIGNvcGllcyBvZiBtZXRob2RzL2F0dHJpYnV0ZXNcbiAgICAgICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdGhpcy5vcmlnaW4uZWxlbWVudCkge1xuICAgICAgICAgICAgLy8gSWYgbWV0aG9kLCBmdW5jdGlvbiB0aGF0IGNhbGxzIHRoZSBlbGVtZW50J3MgbWV0aG9kIGFuZCByZXR1cm5zIGFuIGluc3RydWN0aW9uIChkb25lIGltbWVkaWF0ZWx5KVxuICAgICAgICAgICAgaWYgKHR5cGVvZih0aS5vcmlnaW4uZWxlbWVudFtwcm9wZXJ0eV0pID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRpLmpbcHJvcGVydHldID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpLm9yaWdpbi5lbGVtZW50W3Byb3BlcnR5XS5hcHBseSh0aS5vcmlnaW4uZWxlbWVudCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpLm5ld01ldGEoZnVuY3Rpb24oKXsgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGF0dHJpYnV0ZSwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoYXQgYXR0cmlidXRlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGkualtwcm9wZXJ0eV0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRpLm9yaWdpbi5lbGVtZW50W3Byb3BlcnR5XTsgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkcyBhIGZpbGUgdG8gcHJlbG9hZGluZ1xuICAgIF9hZGRUb1ByZWxvYWQoKSB7XG4gICAgICAgIC8vIElmIHRoZSByZXNvdXJjZSBoYXMgYWxyZWFkeSBiZWVuIHNldCwgcHJlbG9hZGluZyBpcyBhbHJlYWR5IGRvbmVcbiAgICAgICAgaWYgKHRoaXMub3JpZ2luLnJlc291cmNlKVxuICAgICAgICAgICAgcmV0dXJuIEFib3J0O1xuICAgICAgICBpZiAoX2luc3RydWN0aW9uc1RvUHJlbG9hZC5pbmRleE9mKHRoaXMub3JpZ2luKTwwKVxuICAgICAgICAgICAgX2luc3RydWN0aW9uc1RvUHJlbG9hZC5wdXNoKHRoaXMub3JpZ2luKTtcbiAgICAgICAgLy8gQW5kIGFkZCB0aGUgZmlsZSB0byB0aGUgY3VycmVudCBjb250cm9sbGVyXG4gICAgICAgIGlmICghQ3RybHIuYnVpbGRpbmcuaGFzT3duUHJvcGVydHkoXCJwcmVsb2FkaW5nSW5zdHJ1Y3Rpb25zXCIpKVxuICAgICAgICAgICAgQ3RybHIuYnVpbGRpbmcucHJlbG9hZGluZ0luc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICBpZiAoQ3RybHIuYnVpbGRpbmcucHJlbG9hZGluZ0luc3RydWN0aW9ucy5pbmRleE9mKHRoaXMub3JpZ2luKTwwKVxuICAgICAgICAgICAgQ3RybHIuYnVpbGRpbmcucHJlbG9hZGluZ0luc3RydWN0aW9ucy5wdXNoKHRoaXMub3JpZ2luKTtcbiAgICB9XG5cbiAgICAvLyBNZXRob2QgdG8gc2V0IHRoZSByZXNvdXJjZVxuICAgIC8vIENhbiBiZSBBVURJTyBvciBJTUFHRVxuICAgIF9zZXRSZXNvdXJjZShyZXNvdXJjZSkge1xuICAgICAgICAvLyBJZiByZXNvdXJjZSBhbHJlYWR5IHNldCwgdGhyb3cgYSB3YXJuaW5nIGFuZCBhYm9ydFxuICAgICAgICBpZiAodGhpcy5vcmlnaW4ucmVzb3VyY2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV2FybmluZzogdHJ5aW5nIHRvIHJlcGxhY2UgcmVzb3VyY2UgZm9yIFwiK3RoaXMub3JpZ2luLmNvbnRlbnQrXCI7IHNldmVyYWwgaG9zdCBjb3BpZXMgb2YgdGhlIHNhbWUgZmlsZT8gSWdub3JpbmcgbmV3IHJlc291cmNlLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBBYm9ydDtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIGluc3RydWN0aW9uKCdzIG9yaWdpbikgZnJvbSB0aGUgbGlzdFxuICAgICAgICBsZXQgaWR4ID0gX2luc3RydWN0aW9uc1RvUHJlbG9hZC5pbmRleE9mKHRoaXMub3JpZ2luKTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKVxuICAgICAgICAgICAgX2luc3RydWN0aW9uc1RvUHJlbG9hZC5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgLy8gU2V0IHRoZSByZXNvdXJjZVxuICAgICAgICB0aGlzLm9yaWdpbi5yZXNvdXJjZSA9IHJlc291cmNlO1xuICAgIH1cblxuICAgIC8vIE1ldGhvZCB0byBmZXRjaCBhIHJlc291cmNlXG4gICAgLy8gVXNlZCBieSBBdWRpb0luc3RyLCBJbWFnZUluc3RyLCBWaWRlb0luc3RyIChZVEluc3RyIGRlYWxzIGRpZmZlcmVudGx5KVxuICAgIGZldGNoUmVzb3VyY2UocmVzb3VyY2UsIHR5cGUpIHtcbiAgICAgICAgbGV0IHRpID0gdGhpcztcblxuICAgICAgICAvLyBJZiByZXNvdXJjZSBhbHJlYWR5IHNldCwgc3RvcCBoZXJlXG4gICAgICAgIGlmICh0aGlzLm9yaWdpbi5yZXNvdXJjZSlcbiAgICAgICAgICAgIHJldHVybiBBYm9ydDtcblxuICAgICAgICAvLyBQcmlvcml0eSB0byB6aXBwZWQgcmVzb3VyY2VzOiB3YWl0IGZvciBldmVyeXRoaW5nIHRvIGJlIHVuemlwcGVkIGZpcnN0XG4gICAgICAgIGlmIChfemlwUHJpb3JpdHkgJiYgX1VSTHNUb0xvYWQubGVuZ3RoPjAgJiYgIXJlc291cmNlLm1hdGNoKC9eaHR0cC9pKSkge1xuICAgICAgICAgICAgX3ppcENhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRpLmZldGNoUmVzb3VyY2UocmVzb3VyY2UsIHR5cGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVsZW1lbnQ7XG4gICAgICAgIGxldCBzcmM7XG4gICAgICAgIGxldCBldmVudCA9IFwibG9hZFwiO1xuICAgICAgICAvLyBJZiByZXNvdXJjZSBpcyBwYXJ0IG9mIHVuemlwcGVkIHJlc291cmNlc1xuICAgICAgICBpZiAoX3VuemlwcGVkUmVzb3VyY2VzLmhhc093blByb3BlcnR5KHJlc291cmNlKSkge1xuICAgICAgICAgICAgdHlwZSA9IF91bnppcHBlZFJlc291cmNlc1tyZXNvdXJjZV0udHlwZTtcbiAgICAgICAgICAgIHNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoX3VuemlwcGVkUmVzb3VyY2VzW3Jlc291cmNlXS5ibG9iKTtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggd29uJ3QgcmVhY2ggcmVhZHlTdGF0ZSA0IHdpdGggYmxvYiBhdWRpb3MgKGJ1dCBkb2Vzbid0IG1hdHRlciBzaW5jZSBmaWxlIGlzIGxvY2FsKVxuICAgICAgICAgICAgaWYgKHR5cGUubWF0Y2goL2F1ZGlvLykpXG4gICAgICAgICAgICAgICAgZXZlbnQgPSBcImNhbnBsYXlcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gbG9hZCB0aGUgZmlsZSBhdCB0aGUgZ2l2ZW4gVVJMXG4gICAgICAgIGVsc2UgaWYgKHJlc291cmNlLm1hdGNoKC9eaHR0cC9pKSkge1xuICAgICAgICAgICAgbGV0IGV4dGVuc2lvbiA9IHJlc291cmNlLm1hdGNoKC9cXC4oW14uXSspJC8pO1xuICAgICAgICAgICAgLy8gUmVzb3VyY2Ugc2hvdWxkIGhhdmUgYW4gZXh0ZW5zaW9uXG4gICAgICAgICAgICBpZiAoIXR5cGUgJiYgIWV4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3I6IGV4dGVuc2lvbiBvZiByZXNvdXJjZSBcIitmaWxlK1wiIG5vdCByZWNvZ25pemVkXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBBYm9ydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldHRpbmcgdGhlIGV4dGVuc2lvbiBpdHNlbGYgcmF0aGVyIHRoYW4gdGhlIHdob2xlIG1hdGNoXG4gICAgICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb25bMV07XG4gICAgICAgICAgICAvLyBBVURJTyBGSUxFXG4gICAgICAgICAgICBpZiAodHlwZSA9PSBcImF1ZGlvXCIgfHwgZXh0ZW5zaW9uLm1hdGNoKC9tcDN8b2dnfHdhdi9pKSkge1xuICAgICAgICAgICAgICAgIHR5cGUgPSBcImF1ZGlvL1wiK2V4dGVuc2lvbi50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoXCJtcDNcIixcIm1wZWdcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBzcmMgPSByZXNvdXJjZTtcbiAgICAgICAgICAgICAgICBldmVudCA9IFwiY2FucGxheXRocm91Z2hcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElNQUdFXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IFwiaW1hZ2VcIiB8fCBleHRlbnNpb24ubWF0Y2goL2dpZnxwbmd8anBlP2cvaSkpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gXCJpbWFnZS9cIitleHRlbnNpb24ucmVwbGFjZSgvanBnL2ksXCJqcGVnXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgc3JjID0gcmVzb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBWSURFT1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSBcInZpZGVvXCIgfHwgZXh0ZW5zaW9uLm1hdGNoKC9tcDR8b2dnfHdlYm0vaSkpIHtcbiAgICAgICAgICAgICAgICAvLyBUTyBET1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEVsc2UsIGNhbGwgZmV0Y2hSZXNvdXJjZSB3aXRoIGVhY2ggaG9zdCBVUkwgKGlmIGFueSlcbiAgICAgICAgZWxzZSBpZiAoUGVubkNvbnRyb2xsZXIuaG9zdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBUcnlpbmcgdG8gZmV0Y2ggdGhlIGltYWdlIGZyb20gdGhlIGhvc3QgdXJsKHMpXG4gICAgICAgICAgICBmb3IgKGxldCBoIGluIFBlbm5Db250cm9sbGVyLmhvc3RzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihQZW5uQ29udHJvbGxlci5ob3N0c1toXSkgIT0gXCJzdHJpbmdcIiB8fCAhUGVubkNvbnRyb2xsZXIuaG9zdHNbaF0ubWF0Y2goL15odHRwL2kpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB0aS5mZXRjaFJlc291cmNlKFBlbm5Db250cm9sbGVyLmhvc3RzW2hdK3Jlc291cmNlLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIEF1ZGlvXG4gICAgICAgIGlmICh0eXBlLm1hdGNoKC9hdWRpby8pKSB7XG4gICAgICAgICAgICAvLyBBZGQgU09VUkNFIGluc2lkZSBBVURJTywgYW5kIGFkZCAncHJlbG9hZD1hdXRvJ1xuICAgICAgICAgICAgZWxlbWVudCA9ICQoXCI8YXVkaW8+XCIpLmFwcGVuZCgkKFwiPHNvdXJjZT5cIikuYXR0cih7c3JjOiBzcmMsIHR5cGU6IHR5cGV9KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jc3MoXCJkaXNwbGF5XCIsIFwibm9uZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoe3ByZWxvYWQ6IFwiYXV0b1wifSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZmlsZSB3YXMgc28gZmFzdCB0byBsb2FkIHRoYXQgaXQgY2FuIGFscmVhZHkgcGxheVxuICAgICAgICAgICAgaWYgKGVsZW1lbnQuZ2V0KDApLnJlYWR5U3RhdGUgPiAoNCAtIChldmVudD09XCJjYW5wbGF5XCIpKSlcbiAgICAgICAgICAgICAgICB0aS5fc2V0UmVzb3VyY2UoZWxlbWVudCk7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGJpbmQgYSBDQU5QTEFZVEhST1VHSCBldmVudFxuICAgICAgICAgICAgZWxzZSBcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm9uZShldmVudCwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25jZSBjYW4gcGxheSBUSFJPVUdILCByZW1vdmUgaW5zdHJ1Y3Rpb24gZnJvbSB0byBwcmVsb2FkXG4gICAgICAgICAgICAgICAgICAgIHRpLl9zZXRSZXNvdXJjZShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBpbWFnZSwgYWRkIGl0IGRpcmVjdGx5IChubyBuZWVkIHRvIHByZWxvYWQpXG4gICAgICAgIGVsc2UgaWYgKHR5cGUubWF0Y2goL2ltYWdlLykpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSAkKFwiPGltZz5cIikuYXR0cih7c3JjOiBzcmMsIHR5cGU6IHR5cGV9KTtcbiAgICAgICAgICAgIGVsZW1lbnQuYmluZChldmVudCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IHJlc291cmNlXG4gICAgICAgICAgICAgICAgdGkub3JpZ2luLl9zZXRSZXNvdXJjZShlbGVtZW50KTtcbiAgICAgICAgICAgIH0pLmJpbmQoXCJlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGNvdWxkIG5vdCBmaW5kIGltYWdlIFwiK3Jlc291cmNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFBSSVZBVEUgJiBJTlRSSU5TSUMgTUVUSE9EU1xuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIFJ1biBvbmNlIHRoZSBpbnN0cnVjdGlvbiBoYXMgdGFrZW4gZWZmZWN0XG4gICAgZG9uZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEb25lIHx8ICF0aGlzLmhhc0JlZW5SdW4pXG4gICAgICAgICAgICByZXR1cm4gQWJvcnQ7XG4gICAgICAgIC8vIENhbm5vdCBiZSBkb25lIGlmIGhhcyBhIHByZXZpb3VzIGluc3RydWN0aW9uIHRoYXQgaXMgbm90IGRvbmUgeWV0XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzSW5zdHJ1Y3Rpb24gaW5zdGFuY2VvZiBJbnN0cnVjdGlvbiAmJiAhdGhpcy5wcmV2aW91c0luc3RydWN0aW9uLmlzRG9uZSlcbiAgICAgICAgICAgIHJldHVybiBBYm9ydDtcbiAgICAgICAgLy8gSWYgaW5zdHJ1Y3Rpb24gd2FzIGNhbGxlZCB3aXRoIFdIRU4gY2xlYXIgYW55IHRpbWVvdXRcbiAgICAgICAgaWYgKHRoaXMuaXR2bFdoZW4pXG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaXR2bFdoZW4pO1xuICAgICAgICB0aGlzLmlzRG9uZSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gUnVuIGJ5IHByZXZpb3VzIGVsZW1lbnQgKGJ5IGRlZmF1bHQpXG4gICAgcnVuKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNCZWVuUnVuKVxuICAgICAgICAgICAgcmV0dXJuIEFib3J0O1xuICAgICAgICAvLyBDYW5ub3QgYmUgcnVuIGlmIGhhcyBhIHByZXZpb3VzIGluc3RydWN0aW9uIHRoYXQgaXMgbm90IGRvbmUgeWV0XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzSW5zdHJ1Y3Rpb24gaW5zdGFuY2VvZiBJbnN0cnVjdGlvbiAmJiAhdGhpcy5wcmV2aW91c0luc3RydWN0aW9uLmlzRG9uZSlcbiAgICAgICAgICAgIHJldHVybiBBYm9ydDtcbiAgICAgICAgdGhpcy5oYXNCZWVuUnVuID0gdHJ1ZTtcbiAgICB9XG5cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBJTlRFUk5BTCBNRVRIT0RTXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gUmV0dXJucyBhIG5ldyBmdW5jdGlvbiBleGVjdXRpbmcgdGhlIG9uZSBwYXNzZWQgYXMgYXJndW1lbnQgYWZ0ZXIgVEhJUyBvbmUgKGNoYWluIGNhbiBiZSBhYm9ydGVkKVxuICAgIGV4dGVuZChtZXRob2QsIGNvZGUpIHtcbiAgICAgICAgbGV0IHRpID0gdGhpcywgbSA9IHRpW21ldGhvZF07XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYgKG0uYXBwbHkodGksYXJndW1lbnRzKSA9PSBBYm9ydClcbiAgICAgICAgICAgICAgICByZXR1cm4gQWJvcnQ7XG4gICAgICAgICAgICByZXR1cm4gY29kZS5hcHBseSh0aSxhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0cyB3aGVuIGEgV0hFTiBpbnN0cnVjdGlvbiBpcyBkb25lXG4gICAgLy8gQnkgZGVmYXVsdDogdXBvbiBjbGljayBpZiBjbGlja2FibGUsIHRpbWVyIG90aGVyd2lzZVxuICAgIF93aGVuVG9JbnNpc3QodHJ5VG9WYWxpZGF0ZSkge1xuICAgICAgICBsZXQgdGkgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5vcmlnaW4uY2xpY2thYmxlKVxuICAgICAgICAgICAgdGhpcy5vcmlnaW4uZWxlbWVudC5jbGljayh0cnlUb1ZhbGlkYXRlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5pdHZsV2hlbiA9IHNldEludGVydmFsKHRyeVRvVmFsaWRhdGUsIDEwKTsgICAgICAgICAgICAgICAgICAgIFxuICAgIH1cblxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIE1FVEhPRFMgUkVUVVJOSU5HIE5FVyBJTlNUUlVDVElPTlNcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyBSZXR1cm5zIGFuIGluc3RydWN0aW9uIHRoYXQgcnVucyBpZkZhaWx1cmUgaWYgY29uZGl0aW9uYWxGdW5jdGlvbiBpcyBub3QgbWV0XG4gICAgLy8gRG9uZSB3aGVuIHNvdXJjZSBpcyBkb25lIGFuZCBjb25kaXRpb25hbEZ1bmN0aW9uIGlzIG1ldFxuICAgIHdoZW4oY29uZGl0aW9uYWxGdW5jdGlvbiwgaWZGYWlsdXJlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld01ldGEoZnVuY3Rpb24oKXsgXG4gICAgICAgICAgICAvLyBJbnN0cnVjdGlvbiBpbW1lZGlhdGVseSBkb25lIGlmIGNvbmRpdGlvbiBtZXRcbiAgICAgICAgICAgIGlmIChjb25kaXRpb25hbEZ1bmN0aW9uKCkpXG4gICAgICAgICAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgICAgICAgICAvLyBFbHNlLCBydW4gaWZGYWlsdXJlIGFuZCBmaW5kIHdheSB0byB2YWxpZGF0ZSBsYXRlclxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaWZGYWlsdXJlIGlzIGFuIGluc3RydWN0aW9uLCBydW4gaXRcbiAgICAgICAgICAgICAgICBpZiAoaWZGYWlsdXJlIGluc3RhbmNlb2YgSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWZGYWlsdXJlLnBhcmVudEVsZW1lbnQgPSBDdHJsci5ydW5uaW5nLmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmRmFpbHVyZS5ydW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgaWZGYWlsdXJlIGlzIGEgZnVuY3Rpb24sIGV4ZWN1dGUgaXRcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpZkZhaWx1cmUgaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgICAgICAgICAgICAgICAgaWZGYWlsdXJlKCk7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGluc2lzdFxuICAgICAgICAgICAgICAgIGxldCB0aSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2hlblRvSW5zaXN0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGkuaXNEb25lICYmIGNvbmRpdGlvbmFsRnVuY3Rpb24oKSkgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aS5kb25lKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIENvbnZlcnRzIGludG8gYSBNRVRBIGluc3RydWN0aW9uXG4gICAgbmV3TWV0YShjYWxsYmFjaywgYmVmb3JlKSB7XG4gICAgICAgIC8vIE1heWJlIG5ld01ldGEgc2hvdWxkbid0IHBhc3Mgb24gdGhlIHNvdXJjZSdzIGNvbnRlbnQ/XG4gICAgICAgIC8vbGV0IHNvdXJjZSA9IHRoaXMsIGluc3RyID0gbmV3IHRoaXMub3JpZ2luLmNvbnN0cnVjdG9yKHRoaXMuY29udGVudCk7XG4gICAgICAgIGxldCBzb3VyY2UgPSB0aGlzLCBpbnN0ciA9IG5ldyB0aGlzLm9yaWdpbi5jb25zdHJ1Y3RvcihBYm9ydCk7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgc291cmNlIGlzIHJ1biAoYWN0dWFsIHJ1bm5pbmcgb2YgdGhpcyBpbnN0cnVjdGlvbilcbiAgICAgICAgaW5zdHIuc291cmNlQ2FsbGJhY2sgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgLy8gQ2Fubm90IGJlIHJ1biBpZiBzb3VyY2VzIG5vdCBkb25lIHlldFxuICAgICAgICAgICAgbGV0IGN1cnJlbnRJbnN0cnVjdGlvbiA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudEluc3RydWN0aW9uLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGlmICghY3VycmVudEluc3RydWN0aW9uLnNvdXJjZS5pc0RvbmUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBBYm9ydDtcbiAgICAgICAgICAgICAgICBjdXJyZW50SW5zdHJ1Y3Rpb24gPSBjdXJyZW50SW5zdHJ1Y3Rpb24uc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdHIuaGFzQmVlblJ1biA9IHRydWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShpbnN0ciwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW5zdHIuYmVmb3JlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYmVmb3JlID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICBiZWZvcmUuYXBwbHkoaW5zdHIsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFJld3JpdGUgYW55IHNwZWNpZmljIERPTkUgbWV0aG9kXG4gICAgICAgIGluc3RyLmRvbmUgPSBmdW5jdGlvbigpeyBcbiAgICAgICAgICAgIGlmIChJbnN0cnVjdGlvbi5wcm90b3R5cGUuZG9uZS5hcHBseShpbnN0cikgPT0gQWJvcnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEFib3J0O1xuICAgICAgICAgICAgLy8gQ2Fubm90IGJlIGRvbmUgaWYgc291cmNlcyBub3QgZG9uZSB5ZXRcbiAgICAgICAgICAgIGxldCBjdXJyZW50SW5zdHJ1Y3Rpb24gPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRJbnN0cnVjdGlvbi5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRJbnN0cnVjdGlvbi5zb3VyY2UuaXNEb25lKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQWJvcnQ7XG4gICAgICAgICAgICAgICAgY3VycmVudEluc3RydWN0aW9uID0gY3VycmVudEluc3RydWN0aW9uLnNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmV3cml0ZSBhbnkgc3BlY2lmaWMgUlVOIG1ldGhvZFxuICAgICAgICBpbnN0ci5ydW4gPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYgKEluc3RydWN0aW9uLnByb3RvdHlwZS5ydW4uYXBwbHkoaW5zdHIpID09IEFib3J0KVxuICAgICAgICAgICAgICAgIHJldHVybiBBYm9ydDtcbiAgICAgICAgICAgIC8vIFNob3VsZCBub3QgYmUgY29uc2lkZXJlZCBydW4geWV0IChvbmx5IHNvIGluIGNhbGxiYWNrKVxuICAgICAgICAgICAgaW5zdHIuaGFzQmVlblJ1biA9IGZhbHNlO1xuICAgICAgICAgICAgaW5zdHIuYmVmb3JlKCk7XG4gICAgICAgICAgICBpZiAoIXNvdXJjZS5oYXNCZWVuUnVuKXtcbiAgICAgICAgICAgICAgICBzb3VyY2UuZG9uZSA9IHNvdXJjZS5leHRlbmQoXCJkb25lXCIsIGZ1bmN0aW9uKCl7IGluc3RyLnNvdXJjZUNhbGxiYWNrKCk7IH0pO1xuICAgICAgICAgICAgICAgIHNvdXJjZS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc3RyLnNvdXJjZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIEFsbCBvdGhlciBtZXRob2RzIGFyZSBsZWZ0IHVuYWZmZWN0ZWRcbiAgICAgICAgaW5zdHIudHlwZSA9IFwibWV0YVwiO1xuICAgICAgICBpbnN0ci5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIGluc3RyLnNldEVsZW1lbnQoc291cmNlLmVsZW1lbnQpO1xuICAgICAgICBpbnN0ci5vcmlnaW4gPSBzb3VyY2Uub3JpZ2luO1xuICAgICAgICBpbnN0ci50b1ByZWxvYWQgPSBzb3VyY2UudG9QcmVsb2FkO1xuICAgICAgICByZXR1cm4gaW5zdHI7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhbiBpbnN0cnVjdGlvbiB0byByZW1vdmUgdGhlIGVsZW1lbnQgKGlmIGFueSlcbiAgICAvLyBEb25lIGltbWVkaWF0ZWx5XG4gICAgcmVtb3ZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdNZXRhKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiAodGhpcy5vcmlnaW4uZWxlbWVudCBpbnN0YW5jZW9mIGpRdWVyeSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luLmVsZW1lbnQuZGV0YWNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhbiBpbnN0cnVjdGlvbiB0byBtb3ZlIHRoZSBvcmlnaW4ncyBlbGVtZW50XG4gICAgLy8gRG9uZSBpbW1lZGlhdGVseVxuICAgIG1vdmUod2hlcmUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV3TWV0YShmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYgKHdoZXJlIGluc3RhbmNlb2YgSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgICAgICBsZXQgb3JpZ2luID0gd2hlcmUub3JpZ2luLmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHdoZXJlIGluc3RhbmNlb2YgQ29tcGxleEluc3RyICYmICFvcmlnaW4uaXMoXCJ0YWJsZVwiKSlcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luID0gb3JpZ2luLnBhcmVudCgpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09IFwiYmVmb3JlXCIpXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbi5iZWZvcmUodGhpcy5vcmlnaW4uZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBvcmlnaW4uYWZ0ZXIodGhpcy5vcmlnaW4uZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhbiBpbnN0cnVjdGlvbiB0byByZXNpemUgdGhlIGltYWdlIHRvIFcsSFxuICAgIC8vIERvbmUgaW1tZWRpYXRlbHlcbiAgICByZXNpemUodyxoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld01ldGEoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luLmVsZW1lbnQuY3NzKHt3aWR0aDogdywgaGVpZ2h0OiBofSk7XG4gICAgICAgICAgICB0aGlzLmRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhbiBpbnN0cnVjdGlvbiB0byBjZW50ZXIgdGhlIGVsZW1lbnQgaW5zaWRlIGl0cyBwYXJlbnRcbiAgICAvLyBEb25lIGltbWVkaWF0ZWx5XG4gICAgY2VudGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdNZXRhKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbi5lbGVtZW50LnBhcmVudCgpLmNzcyhcInRleHQtYWxpZ25cIixcImNlbnRlclwiKTtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luLmVsZW1lbnQuY3NzKFwidGV4dC1hbGlnblwiLFwiY2VudGVyXCIpO1xuICAgICAgICAgICAgdGhpcy5vcmlnaW4uZWxlbWVudC5jc3MoXCJtYXJnaW5cIixcImF1dG9cIik7XG4gICAgICAgICAgICB0aGlzLmRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhbiBpbnN0cnVjdGlvbiB0byBzaGlmdCBYICYgWSdzIG9mZnNldHNcbiAgICAvLyBEb25lIGltbWVkaWF0ZWx5XG4gICAgc2hpZnQoeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdNZXRhKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiAodGhpcy5vcmlnaW4uZWxlbWVudC5jc3MoXCJwb3NpdGlvblwiKS5tYXRjaCgvc3RhdGljfHJlbGF0aXZlLykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9yaWdpbi5lbGVtZW50LmNzcyhcInBvc2l0aW9uXCIsIFwicmVsYXRpdmVcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5vcmlnaW4uZWxlbWVudC5jc3Moe2xlZnQ6IHgsIHRvcDogeX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcmlnaW4uZWxlbWVudC5jc3MoXCJwb3NpdGlvblwiKSA9PSBcImFic29sdXRlXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9yaWdpbi5lbGVtZW50LmNzcyh7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMub3JpZ2luLmVsZW1lbnQuY3NzKFwibGVmdFwiKSt4LFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHRoaXMub3JpZ2luLmVsZW1lbnQuY3NzKFwidG9wXCIpK3lcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIGFuIGluc3RydWN0aW9uIHRvIGR5bmFtaWNhbGx5IGNoYW5nZSBjc3NcbiAgICAvLyBEb25lIGltbWVkaWF0ZWx5XG4gICAgY3NzKCkge1xuICAgICAgICBsZXQgYXJnID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdNZXRhKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbi5lbGVtZW50LmNzcy5hcHBseSh0aGlzLm9yaWdpbi5lbGVtZW50LCBhcmcpO1xuICAgICAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYW4gaW5zdHJ1Y3Rpb24gdG8gaGlkZSB0aGUgb3JpZ2luJ3MgZWxlbWVudFxuICAgIC8vIERvbmUgaW1tZWRpYXRlbHlcbiAgICBoaWRlKHNob3VsZEhpZGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZihzaG91bGRIaWRlKT09XCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIHNob3VsZEhpZGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdNZXRhKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiAoc2hvdWxkSGlkZSlcbiAgICAgICAgICAgICAgICB0aGlzLm9yaWdpbi5lbGVtZW50LmNzcyhcInZpc2liaWxpdHlcIixcImhpZGRlblwiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLm9yaWdpbi5lbGVtZW50LmNzcyhcInZpc2liaWxpdHlcIixcInZpc2libGVcIik7XG4gICAgICAgICAgICB0aGlzLmRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhbiBpbnN0cnVjdGlvbiB0byB3YWl0IGZvciBhIGNsaWNrIG9uIHRoZSBlbGVtZW50XG4gICAgLy8gRG9uZSB1cG9uIGNsaWNrIG9uIHRoZSBvcmlnaW4ncyBlbGVtZW50XG4gICAgY2xpY2soY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV3TWV0YShmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5vcmlnaW4uY2xpY2thYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luLmVsZW1lbnQuYWRkQ2xhc3MoQ3RybHIucnVubmluZy5jc3NQcmVmaXggKyBcImNsaWNrYWJsZVwiKTtcbiAgICAgICAgICAgIGxldCB0aSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbi5lbGVtZW50LmNsaWNrKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrIGluc3RhbmNlb2YgSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sucGFyZW50RWxlbWVudCA9IEN0cmxyLnJ1bm5pbmcuZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sucnVuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KEN0cmxyLnJ1bm5pbmcudmFyaWFibGVzKTtcbiAgICAgICAgICAgICAgICB0aS5kb25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhbiBpbnN0cnVjdGlvbiB0byBhc3NpZ24gYW4gaWQgdG8gdGhlIGluc3RydWN0aW9uXG4gICAgLy8gRG9uZSBpbW1lZGlhdGVseVxuICAgIGlkKG5hbWUpIHtcbiAgICAgICAgX2xvY2FsSW5zdHJ1Y3Rpb25zW19sb2NhbEluc3RydWN0aW9ucy5sZW5ndGgtMV1bbmFtZV0gPSB0aGlzLm9yaWdpbjtcbiAgICAgICAgdGhpcy5vcmlnaW4uX2lkID0gbmFtZTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV3TWV0YShmdW5jdGlvbigpeyB0aGlzLmRvbmUoKTsgfSk7XG4gICAgfVxufVxuXG4vLyBSZXR1cm5zIGFuIGluc3RydWN0aW9uIGluIGZ1bmN0aW9uIG9mIHRoZSBhcmd1bWVudChzKSB0eXBlXG5QZW5uQ29udHJvbGxlci5pbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgaWYgKHR5cGVvZihpZCkhPVwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBBYm9ydDtcbiAgICAvLyBJZiB0aGVyZSdzIGFuIGluc3RydXRpb24gcmVmZXJlbmNlZCBhcyBBUkcgd2hpbGUgRVhFQ1VUSU5HIGEgY29udHJvbGxlclxuICAgIGlmIChDdHJsci5ydW5uaW5nICYmIF9sb2NhbEluc3RydWN0aW9uc1tDdHJsci5ydW5uaW5nLmlkXS5oYXNPd25Qcm9wZXJ0eShhcmcpKVxuICAgICAgICByZXR1cm4gX2xvY2FsSW5zdHJ1Y3Rpb25zW0N0cmxyLnJ1bm5pbmcuaWRdW2FyZ107XG4gICAgLy8gSWYgdGhlcmUncyBhbiBpbnN0cnV0aW9uIHJlZmVyZW5jZWQgYXMgQVJHIHdoaWxlIENSRUFUSU5HIGEgY29udHJvbGxlclxuICAgIGVsc2UgaWYgKCFDdHJsci5ydW5uaW5nICYmIF9sb2NhbEluc3RydWN0aW9uc1tfbG9jYWxJbnN0cnVjdGlvbnMubGVuZ3RoLTFdLmhhc093blByb3BlcnR5KGFyZykpXG4gICAgICAgIHJldHVybiBfbG9jYWxJbnN0cnVjdGlvbnNbX2xvY2FsSW5zdHJ1Y3Rpb25zLmxlbmd0aC0xXVthcmddO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSB3b3JrZXIgdGhhdCBkb2VzIG5vdGhpbmcgYnV0IHBhc3NpbmcgY2h1bmtzIHRvIHRoZSBuZXh0IG9uZS4gVGhpcyBpcyBsaWtlXG4gKiBhIG5vZGVqcyBzdHJlYW0gYnV0IHdpdGggc29tZSBkaWZmZXJlbmNlcy4gT24gdGhlIGdvb2Qgc2lkZSA6XG4gKiAtIGl0IHdvcmtzIG9uIElFIDYtOSB3aXRob3V0IGFueSBpc3N1ZSAvIHBvbHlmaWxsXG4gKiAtIGl0IHdlaWdodHMgbGVzcyB0aGFuIHRoZSBmdWxsIGRlcGVuZGVuY2llcyBidW5kbGVkIHdpdGggYnJvd3NlcmlmeVxuICogLSBpdCBmb3J3YXJkcyBlcnJvcnMgKG5vIG5lZWQgdG8gZGVjbGFyZSBhbiBlcnJvciBoYW5kbGVyIEVWRVJZV0hFUkUpXG4gKlxuICogQSBjaHVuayBpcyBhbiBvYmplY3Qgd2l0aCAyIGF0dHJpYnV0ZXMgOiBgbWV0YWAgYW5kIGBkYXRhYC4gVGhlIGZvcm1lciBpcyBhblxuICogb2JqZWN0IGNvbnRhaW5pbmcgYW55dGhpbmcgKGBwZXJjZW50YCBmb3IgZXhhbXBsZSksIHNlZSBlYWNoIHdvcmtlciBmb3IgbW9yZVxuICogZGV0YWlscy4gVGhlIGxhdHRlciBpcyB0aGUgcmVhbCBkYXRhIChTdHJpbmcsIFVpbnQ4QXJyYXksIGV0YykuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgc3RyZWFtIChtYWlubHkgdXNlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzKVxuICovXG5mdW5jdGlvbiBHZW5lcmljV29ya2VyKG5hbWUpIHtcbiAgICAvLyB0aGUgbmFtZSBvZiB0aGUgd29ya2VyXG4gICAgdGhpcy5uYW1lID0gbmFtZSB8fCBcImRlZmF1bHRcIjtcbiAgICAvLyBhbiBvYmplY3QgY29udGFpbmluZyBtZXRhZGF0YSBhYm91dCB0aGUgd29ya2VycyBjaGFpblxuICAgIHRoaXMuc3RyZWFtSW5mbyA9IHt9O1xuICAgIC8vIGFuIGVycm9yIHdoaWNoIGhhcHBlbmVkIHdoZW4gdGhlIHdvcmtlciB3YXMgcGF1c2VkXG4gICAgdGhpcy5nZW5lcmF0ZWRFcnJvciA9IG51bGw7XG4gICAgLy8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgbWV0YWRhdGEgdG8gYmUgbWVyZ2VkIGJ5IHRoaXMgd29ya2VyIGludG8gdGhlIGdlbmVyYWwgbWV0YWRhdGFcbiAgICB0aGlzLmV4dHJhU3RyZWFtSW5mbyA9IHt9O1xuICAgIC8vIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBwYXVzZWQgKGFuZCBzaG91bGQgbm90IGRvIGFueXRoaW5nKSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XG4gICAgLy8gdHJ1ZSBpZiB0aGUgc3RyZWFtIGlzIGZpbmlzaGVkIChhbmQgc2hvdWxkIG5vdCBkbyBhbnl0aGluZyksIGZhbHNlIG90aGVyd2lzZVxuICAgIHRoaXMuaXNGaW5pc2hlZCA9IGZhbHNlO1xuICAgIC8vIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBsb2NrZWQgdG8gcHJldmVudCBmdXJ0aGVyIHN0cnVjdHVyZSB1cGRhdGVzIChwaXBlKSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgdGhpcy5pc0xvY2tlZCA9IGZhbHNlO1xuICAgIC8vIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7XG4gICAgICAgICdkYXRhJzpbXSxcbiAgICAgICAgJ2VuZCc6W10sXG4gICAgICAgICdlcnJvcic6W11cbiAgICB9O1xuICAgIC8vIHRoZSBwcmV2aW91cyB3b3JrZXIsIGlmIGFueVxuICAgIHRoaXMucHJldmlvdXMgPSBudWxsO1xufVxuXG5HZW5lcmljV29ya2VyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBQdXNoIGEgY2h1bmsgdG8gdGhlIG5leHQgd29ya2Vycy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2h1bmsgdGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKi9cbiAgICBwdXNoIDogZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImRhdGFcIiwgY2h1bmspO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRW5kIHRoZSBzdHJlYW0uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGNhbGwgZW5kZWQgdGhlIHdvcmtlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGVuZCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpO1xuICAgICAgICAgICAgdGhpcy5jbGVhblVwKCk7XG4gICAgICAgICAgICB0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuZCB0aGUgc3RyZWFtIHdpdGggYW4gZXJyb3IuXG4gICAgICogQHBhcmFtIHtFcnJvcn0gZSB0aGUgZXJyb3Igd2hpY2ggY2F1c2VkIHRoZSBwcmVtYXR1cmUgZW5kLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhpcyBjYWxsIGVuZGVkIHRoZSB3b3JrZXIgd2l0aCBhbiBlcnJvciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGVycm9yIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5pc1BhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZWRFcnJvciA9IGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlKTtcblxuICAgICAgICAgICAgLy8gaW4gdGhlIHdvcmtlcnMgY2hhaW4gZXhwbG9kZWQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgY2hhaW4sXG4gICAgICAgICAgICAvLyB0aGUgZXJyb3IgZXZlbnQgd2lsbCBnbyBkb3dud2FyZCBidXQgd2UgYWxzbyBuZWVkIHRvIG5vdGlmeVxuICAgICAgICAgICAgLy8gd29ya2VycyB1cHdhcmQgdGhhdCB0aGVyZSBoYXMgYmVlbiBhbiBlcnJvci5cbiAgICAgICAgICAgIGlmKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNsZWFuVXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNhbGxiYWNrIG9uIGFuIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBldmVudCAoZGF0YSwgZW5kLCBlcnJvcilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciB0aGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWRcbiAgICAgKiBAcmV0dXJuIHtHZW5lcmljV29ya2VyfSB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIG9uIDogZnVuY3Rpb24gKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc1tuYW1lXS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDbGVhbiBhbnkgcmVmZXJlbmNlcyB3aGVuIGEgd29ya2VyIGlzIGVuZGluZy5cbiAgICAgKi9cbiAgICBjbGVhblVwIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0cmVhbUluZm8gPSB0aGlzLmdlbmVyYXRlZEVycm9yID0gdGhpcy5leHRyYVN0cmVhbUluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgYW4gZXZlbnQuIFRoaXMgd2lsbCBjYWxsIHJlZ2lzdGVyZWQgY2FsbGJhY2sgd2l0aCB0aGUgcHJvdmlkZWQgYXJnLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBldmVudCAoZGF0YSwgZW5kLCBlcnJvcilcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnIHRoZSBhcmd1bWVudCB0byBjYWxsIHRoZSBjYWxsYmFjayB3aXRoLlxuICAgICAqL1xuICAgIGVtaXQgOiBmdW5jdGlvbiAobmFtZSwgYXJnKSB7XG4gICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnNbbmFtZV0pIHtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9saXN0ZW5lcnNbbmFtZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbbmFtZV1baV0uY2FsbCh0aGlzLCBhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGFpbiBhIHdvcmtlciB3aXRoIGFuIG90aGVyLlxuICAgICAqIEBwYXJhbSB7V29ya2VyfSBuZXh0IHRoZSB3b3JrZXIgcmVjZWl2aW5nIGV2ZW50cyBmcm9tIHRoZSBjdXJyZW50IG9uZS5cbiAgICAgKiBAcmV0dXJuIHt3b3JrZXJ9IHRoZSBuZXh0IHdvcmtlciBmb3IgY2hhaW5hYmlsaXR5XG4gICAgICovXG4gICAgcGlwZSA6IGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXh0LnJlZ2lzdGVyUHJldmlvdXModGhpcyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTYW1lIGFzIGBwaXBlYCBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uLlxuICAgICAqIFVzaW5nIGFuIEFQSSB3aXRoIGBwaXBlKG5leHQpYCBpcyB2ZXJ5IGVhc3kuXG4gICAgICogSW1wbGVtZW50aW5nIHRoZSBBUEkgd2l0aCB0aGUgcG9pbnQgb2YgdmlldyBvZiB0aGUgbmV4dCBvbmUgcmVnaXN0ZXJpbmdcbiAgICAgKiBhIHNvdXJjZSBpcyBlYXNpZXIsIHNlZSB0aGUgWmlwRmlsZVdvcmtlci5cbiAgICAgKiBAcGFyYW0ge1dvcmtlcn0gcHJldmlvdXMgdGhlIHByZXZpb3VzIHdvcmtlciwgc2VuZGluZyBldmVudHMgdG8gdGhpcyBvbmVcbiAgICAgKiBAcmV0dXJuIHtXb3JrZXJ9IHRoZSBjdXJyZW50IHdvcmtlciBmb3IgY2hhaW5hYmlsaXR5XG4gICAgICovXG4gICAgcmVnaXN0ZXJQcmV2aW91cyA6IGZ1bmN0aW9uIChwcmV2aW91cykge1xuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0cmVhbSAnXCIgKyB0aGlzICsgXCInIGhhcyBhbHJlYWR5IGJlZW4gdXNlZC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaGFyaW5nIHRoZSBzdHJlYW1JbmZvLi4uXG4gICAgICAgIHRoaXMuc3RyZWFtSW5mbyA9IHByZXZpb3VzLnN0cmVhbUluZm87XG4gICAgICAgIC8vIC4uLiBhbmQgYWRkaW5nIG91ciBvd24gYml0c1xuICAgICAgICB0aGlzLm1lcmdlU3RyZWFtSW5mbygpO1xuICAgICAgICB0aGlzLnByZXZpb3VzID0gIHByZXZpb3VzO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHByZXZpb3VzLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICBzZWxmLnByb2Nlc3NDaHVuayhjaHVuayk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcmV2aW91cy5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5lbmQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByZXZpb3VzLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBzZWxmLmVycm9yKGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBQYXVzZSB0aGUgc3RyZWFtIHNvIGl0IGRvZXNuJ3Qgc2VuZCBldmVudHMgYW55bW9yZS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoaXMgY2FsbCBwYXVzZWQgdGhlIHdvcmtlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHBhdXNlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZih0aGlzLmlzUGF1c2VkIHx8IHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlc3VtZSBhIHBhdXNlZCBzdHJlYW0uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGNhbGwgcmVzdW1lZCB0aGUgd29ya2VyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcmVzdW1lIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZighdGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gaWYgdHJ1ZSwgdGhlIHdvcmtlciB0cmllZCB0byByZXN1bWUgYnV0IGZhaWxlZFxuICAgICAgICB2YXIgd2l0aEVycm9yID0gZmFsc2U7XG4gICAgICAgIGlmKHRoaXMuZ2VuZXJhdGVkRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IodGhpcy5nZW5lcmF0ZWRFcnJvcik7XG4gICAgICAgICAgICB3aXRoRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMucmVzdW1lKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gIXdpdGhFcnJvcjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEZsdXNoIGFueSByZW1haW5pbmcgYnl0ZXMgYXMgdGhlIHN0cmVhbSBpcyBlbmRpbmcuXG4gICAgICovXG4gICAgZmx1c2ggOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgY2h1bmsuIFRoaXMgaXMgdXN1YWxseSB0aGUgbWV0aG9kIG92ZXJyaWRkZW4uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNodW5rIHRoZSBjaHVuayB0byBwcm9jZXNzLlxuICAgICAqL1xuICAgIHByb2Nlc3NDaHVuayA6IGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgIHRoaXMucHVzaChjaHVuayk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBZGQgYSBrZXkvdmFsdWUgdG8gYmUgYWRkZWQgaW4gdGhlIHdvcmtlcnMgY2hhaW4gc3RyZWFtSW5mbyBvbmNlIGFjdGl2YXRlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IHRoZSBrZXkgdG8gdXNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIHRoZSBhc3NvY2lhdGVkIHZhbHVlXG4gICAgICogQHJldHVybiB7V29ya2VyfSB0aGUgY3VycmVudCB3b3JrZXIgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIHdpdGhTdHJlYW1JbmZvIDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5leHRyYVN0cmVhbUluZm9ba2V5XSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm1lcmdlU3RyZWFtSW5mbygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIE1lcmdlIHRoaXMgd29ya2VyJ3Mgc3RyZWFtSW5mbyBpbnRvIHRoZSBjaGFpbidzIHN0cmVhbUluZm8uXG4gICAgICovXG4gICAgbWVyZ2VTdHJlYW1JbmZvIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IodmFyIGtleSBpbiB0aGlzLmV4dHJhU3RyZWFtSW5mbykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmV4dHJhU3RyZWFtSW5mby5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0cmVhbUluZm9ba2V5XSA9IHRoaXMuZXh0cmFTdHJlYW1JbmZvW2tleV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTG9jayB0aGUgc3RyZWFtIHRvIHByZXZlbnQgZnVydGhlciB1cGRhdGVzIG9uIHRoZSB3b3JrZXJzIGNoYWluLlxuICAgICAqIEFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QsIGFsbCBjYWxscyB0byBwaXBlIHdpbGwgZmFpbC5cbiAgICAgKi9cbiAgICBsb2NrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTG9ja2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3RyZWFtICdcIiArIHRoaXMgKyBcIicgaGFzIGFscmVhZHkgYmVlbiB1c2VkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzTG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMubG9jaygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUHJldHR5IHByaW50IHRoZSB3b3JrZXJzIGNoYWluLlxuICAgICAqL1xuICAgIHRvU3RyaW5nIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWUgPSBcIldvcmtlciBcIiArIHRoaXMubmFtZTtcbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzICsgXCIgLT4gXCIgKyBtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2VuZXJpY1dvcmtlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgVFlQRURfT0sgPSAgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIFVpbnQxNkFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIEludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKTtcblxuZnVuY3Rpb24gX2hhcyhvYmosIGtleSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cblxuZXhwb3J0cy5hc3NpZ24gPSBmdW5jdGlvbiAob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHtcbiAgICB2YXIgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICAgIGlmICghc291cmNlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgbm9uLW9iamVjdCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHAgaW4gc291cmNlKSB7XG4gICAgICBpZiAoX2hhcyhzb3VyY2UsIHApKSB7XG4gICAgICAgIG9ialtwXSA9IHNvdXJjZVtwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vLyByZWR1Y2UgYnVmZmVyIHNpemUsIGF2b2lkaW5nIG1lbSBjb3B5XG5leHBvcnRzLnNocmlua0J1ZiA9IGZ1bmN0aW9uIChidWYsIHNpemUpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IHNpemUpIHsgcmV0dXJuIGJ1ZjsgfVxuICBpZiAoYnVmLnN1YmFycmF5KSB7IHJldHVybiBidWYuc3ViYXJyYXkoMCwgc2l6ZSk7IH1cbiAgYnVmLmxlbmd0aCA9IHNpemU7XG4gIHJldHVybiBidWY7XG59O1xuXG5cbnZhciBmblR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgaWYgKHNyYy5zdWJhcnJheSAmJiBkZXN0LnN1YmFycmF5KSB7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjX29mZnMsIHNyY19vZmZzICsgbGVuKSwgZGVzdF9vZmZzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gb3JkaW5hcnkgYXJyYXlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICB2YXIgaSwgbCwgbGVuLCBwb3MsIGNodW5rLCByZXN1bHQ7XG5cbiAgICAvLyBjYWxjdWxhdGUgZGF0YSBsZW5ndGhcbiAgICBsZW4gPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBqb2luIGNodW5rc1xuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgcG9zID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpO1xuICAgICAgcG9zICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG52YXIgZm5VbnR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldO1xuICAgIH1cbiAgfSxcbiAgLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxuICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbiAoY2h1bmtzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgY2h1bmtzKTtcbiAgfVxufTtcblxuXG4vLyBFbmFibGUvRGlzYWJsZSB0eXBlZCBhcnJheXMgdXNlLCBmb3IgdGVzdGluZ1xuLy9cbmV4cG9ydHMuc2V0VHlwZWQgPSBmdW5jdGlvbiAob24pIHtcbiAgaWYgKG9uKSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IFVpbnQ4QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYxNiA9IFVpbnQxNkFycmF5O1xuICAgIGV4cG9ydHMuQnVmMzIgPSBJbnQzMkFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVHlwZWQpO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQnVmOCAgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gQXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVW50eXBlZCk7XG4gIH1cbn07XG5cbmV4cG9ydHMuc2V0VHlwZWQoVFlQRURfT0spO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmJhc2U2NCA9IHRydWU7XG5leHBvcnRzLmFycmF5ID0gdHJ1ZTtcbmV4cG9ydHMuc3RyaW5nID0gdHJ1ZTtcbmV4cG9ydHMuYXJyYXlidWZmZXIgPSB0eXBlb2YgQXJyYXlCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCI7XG5leHBvcnRzLm5vZGVidWZmZXIgPSB0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiO1xuLy8gY29udGFpbnMgdHJ1ZSBpZiBKU1ppcCBjYW4gcmVhZC9nZW5lcmF0ZSBVaW50OEFycmF5LCBmYWxzZSBvdGhlcndpc2UuXG5leHBvcnRzLnVpbnQ4YXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIjtcblxuaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGV4cG9ydHMuYmxvYiA9IGZhbHNlO1xufVxuZWxzZSB7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICB0cnkge1xuICAgICAgICBleHBvcnRzLmJsb2IgPSBuZXcgQmxvYihbYnVmZmVyXSwge1xuICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi96aXBcIlxuICAgICAgICB9KS5zaXplID09PSAwO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIEJ1aWxkZXIgPSBzZWxmLkJsb2JCdWlsZGVyIHx8IHNlbGYuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgc2VsZi5Nb3pCbG9iQnVpbGRlciB8fCBzZWxmLk1TQmxvYkJ1aWxkZXI7XG4gICAgICAgICAgICB2YXIgYnVpbGRlciA9IG5ldyBCdWlsZGVyKCk7XG4gICAgICAgICAgICBidWlsZGVyLmFwcGVuZChidWZmZXIpO1xuICAgICAgICAgICAgZXhwb3J0cy5ibG9iID0gYnVpbGRlci5nZXRCbG9iKCdhcHBsaWNhdGlvbi96aXAnKS5zaXplID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBleHBvcnRzLmJsb2IgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudHJ5IHtcbiAgICBleHBvcnRzLm5vZGVzdHJlYW0gPSAhIXJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlJlYWRhYmxlO1xufSBjYXRjaChlKSB7XG4gICAgZXhwb3J0cy5ub2Rlc3RyZWFtID0gZmFsc2U7XG59XG4iLCJpbXBvcnQgKiBhcyBKU1ppcCBmcm9tICdqc3ppcCc7XG5pbXBvcnQgeyBnZXRCaW5hcnlDb250ZW50IH0gZnJvbSAnanN6aXAtdXRpbHMnO1xuXG4vLyBMaXN0IG9mIFVSTHMgdG8gWklQIGZpbGVzXG5leHBvcnQgdmFyIF9VUkxzVG9Mb2FkID0gW107XG4vL1xuLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIGxvb2tpbmcgaW4gemlwIGZpbGVzIGluIHByaW9yaXR5XG5leHBvcnQgdmFyIF96aXBQcmlvcml0eSA9IHRydWU7XG4vL1xuLy8gRGljdGlvbmFyeSBvZiBCbG9iJ3MgZm9yIHVuemlwcGVkIHJlc291cmNlc1xuZXhwb3J0IHZhciBfdW56aXBwZWRSZXNvdXJjZXMgPSB7fTtcbi8vXG4vLyBUaGUgbGlzdCBvZiBmdW5jdGlvbnMgdG8gY2FsbCB3aGVuIGFsbCB0aGUgZmlsZXMgaGF2ZSBiZWVuIHVuemlwcGVkXG5leHBvcnQgdmFyIF96aXBDYWxsYmFja3MgPSBbXTtcblxuXG4vLyBMb2FkcyB0aGUgZmlsZSBhdCBlYWNoIFVSTCBwYXNzZWQgYXMgYW4gYXJndW1lbnRcbi8vIEZpbGVzIGNhbiBiZSBaSVAgZmlsZXMsIGltYWdlIGZpbGVzIG9yIGF1ZGlvIGZpbGVzXG5QZW5uQ29udHJvbGxlci5QcmVsb2FkWmlwID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAobGV0IHVybCBpbiBhcmd1bWVudHMpXG4gICAgICAgIF9VUkxzVG9Mb2FkLnB1c2goYXJndW1lbnRzW3VybF0pO1xufTtcblxuLy8gSW50ZXJuYWwgbG9hZGluZyBvZiB0aGUgemlwIGZpbGVzXG4vLyBXaWxsIGJlIGV4ZWN1dGVkIHdoZW4galF1ZXJ5IGlzIHJlYWR5XG5mdW5jdGlvbiBfcHJlbG9hZFppcCAoKSB7XG4gICAgLy8gSWYgbm8gemlwIGZpbGUgdG8gZG93bmxvYWQsIHRoYXQncyBpdCwgd2UncmUgZG9uZVxuICAgIGlmICghX1VSTHNUb0xvYWQubGVuZ3RoKSByZXR1cm47XG4gICAgLy8gQ2FsbGVkIGZvciBlYWNoIFVSTCB0aGF0IHdhcyBwYXNzZWRcbiAgICB2YXIgZ2V0WmlwRmlsZSA9IGZ1bmN0aW9uKHVybCl7XG4gICAgICAgIC8vIENhbGxlZCB0byByZW1vdmUgYSBVUkwgZnJvbSB0aGUgYXJyYXkgKHdoZW4gdW56aXBwZWQgZG9uZSwgb3IgZXJyb3IpXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZVVSTCgpIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IF9VUkxzVG9Mb2FkLmluZGV4T2YodXJsKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKVxuICAgICAgICAgICAgICAgIF9VUkxzVG9Mb2FkLnNwbGljZShpbmRleCwxKTtcbiAgICAgICAgICAgIC8vIElmIGFsbCB0aGUgWklQIGFyY2hpdmVzIGhhdmUgYmVlbiB1bnppcHBlZCwgY2FsbCB0aGUgY2FsbGJhY2tzXG4gICAgICAgICAgICBpZiAoX1VSTHNUb0xvYWQubGVuZ3RoPD0wKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coX3VuemlwcGVkUmVzb3VyY2VzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBmIGluIF96aXBDYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF96aXBDYWxsYmFja3NbZl0gaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIF96aXBDYWxsYmFja3NbZl0uY2FsbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgemlwID0gbmV3IEpTWmlwKCk7XG4gICAgICAgIGdldEJpbmFyeUNvbnRlbnQodXJsLCBmdW5jdGlvbihlcnJvciwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJvYmxlbSB3aXRoIGRvd25sb2FkaW5nIHRoZSBmaWxlOiByZW1vdmUgdGhlIFVSTCBmcm9tIHRoZSBhcnJheVxuICAgICAgICAgICAgICAgIHJlbW92ZVVSTCgpO1xuICAgICAgICAgICAgICAgIC8vIFRocm93IHRoZSBlcnJvclxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTG9hZGluZyB0aGUgemlwIG9iamVjdCB3aXRoIHRoZSBkYXRhIHN0cmVhbVxuICAgICAgICAgICAgemlwLmxvYWRBc3luYyhkYXRhKS50aGVuKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJEb3dubG9hZCBvZiBcIit1cmwrXCIgY29tcGxldGVcIik7XG4gICAgICAgICAgICAgICAgLy8gTnVtYmVyIG9mIGZpbGVzIHVuemlwcGVkXG4gICAgICAgICAgICAgICAgdmFyIHVuemlwcGVkRmlsZXNTb0ZhciA9IDA7XG4gICAgICAgICAgICAgICAgLy8gR29pbmcgdGhyb3VnaCBlYWNoIHppcCBmaWxlXG4gICAgICAgICAgICAgICAgemlwLmZvckVhY2goZnVuY3Rpb24ocGF0aCwgZmlsZSl7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuemlwcGluZyB0aGUgZmlsZSwgYW5kIGNvdW50aW5nIGhvdyBmYXIgd2UgZ290XG4gICAgICAgICAgICAgICAgICAgIGZpbGUuYXN5bmMoJ2FycmF5YnVmZmVyJykudGhlbihmdW5jdGlvbihjb250ZW50KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4Y2x1ZGluZyB3ZWlyZCBNQUNPUyB6aXAgZmlsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGF0aC5tYXRjaCgvX19NQUNPUy4rXFwvXFwuW15cXC9dKyQvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldHRpbmcgcmlkIG9mIHBhdGgsIGtlZXBpbmcganVzdCBmaWxlbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWxlbmFtZSA9IHBhdGgucmVwbGFjZSgvXi4qPyhbXlxcL10rKSQvLFwiJDFcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHlwZSB3aWxsIGRldGVybWluZSB0aGUgdHlwZSBvZiBCbG9iIGFuZCBIVE1MIHRhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0eXBlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBVURJT1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlbmFtZS5tYXRjaCgvXFwuKHdhdnxtcDN8b2dnKSQvaSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcImF1ZGlvL1wiK2ZpbGVuYW1lLnJlcGxhY2UoL14uK1xcLihbXi5dKykkLyxcIiQxXCIpLnJlcGxhY2UoL21wMy9pLFwibXBlZ1wiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElNQUdFXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZmlsZW5hbWUubWF0Y2goL1xcLihwbmd8anBlP2d8Z2lmKSQvaSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcImltYWdlL1wiK2ZpbGVuYW1lLnJlcGxhY2UoL14uK1xcLihbXi5dKykkLyxcIiQxXCIpLnJlcGxhY2UoL2pwZy9pLFwianBlZ1wiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBibG9iIG9ubHkgaWYgdHlwZSB3YXMgcmVjb2duaXplZCAoaWUuIHR5cGUgIT0gXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIEJMT0Igb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF91bnppcHBlZFJlc291cmNlc1tmaWxlbmFtZV0gPSB7YmxvYjogbmV3IEJsb2IoW2NvbnRlbnRdLCB7dHlwZTogdHlwZX0pLCB0eXBlOiB0eXBlfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU1JDIGF0dHJpYnV0ZSBwb2ludHMgdG8gdGhlIGR5bmFtaWMgQmxvYiBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2xldCBhdHRyID0ge3NyYzogVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKSwgdHlwZTogdHlwZX07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB1bnppcHBlZEZpbGVzU29GYXIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBmaWxlcyB1bnppcHBlZDogcmVtb3ZlIHRoZSBVUkwgZnJvbSB0aGUgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bnppcHBlZEZpbGVzU29GYXIgPj0gT2JqZWN0LmtleXMoemlwLmZpbGVzKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlVVJMKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgXG4gICAgLy8gRmV0Y2ggdGhlIHppcCBmaWxlXG4gICAgZm9yIChsZXQgdSBpbiBfVVJMc1RvTG9hZCkge1xuICAgICAgICBsZXQgdXJsID0gX1VSTHNUb0xvYWRbdV07XG4gICAgICAgIGxldCBleHRlbnNpb24gPSB1cmwubWF0Y2goL15odHRwcz86XFwvXFwvLitcXC4oemlwKSQvaSk7XG4gICAgICAgIGlmICh0eXBlb2YodXJsKSAhPSBcInN0cmluZ1wiIHx8ICFleHRlbnNpb24pIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV2FybmluZyAoUHJlbG9hZCk6IGVudHJ5ICNcIit1K1wiIGlzIG5vdCBhIHZhbGlkIFVSTCwgaWdub3JpbmcgaXRcIik7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHRlbnNpb25bMV0udG9Mb3dlckNhc2UoKSA9PSBcInppcFwiKVxuICAgICAgICAgICAgZ2V0WmlwRmlsZSh1cmwpO1xuICAgIH1cbn07XG5cbi8vIFN0YXJ0IHRvIGRvd25sb2FkIHRoZSB6aXAgZmlsZXMgYXMgc29vbiBhcyB0aGUgZG9jdW1lbnQgaXMgcmVhZHlcbiQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCl7XG4gICAgLy8gUHJlbG9hZCBhbnkgemlwIGZpbGVcbiAgICBfcHJlbG9hZFppcCgpO1xufSk7IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1yZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxue1xuICAvLyBhdm9pZCBzY29wZSBjcmVlcCwgdGhlIGtleXMgYXJyYXkgY2FuIHRoZW4gYmUgY29sbGVjdGVkXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwbmEubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5EdXBsZXgucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICB0aGlzLmVuZCgpO1xuXG4gIHBuYS5uZXh0VGljayhjYiwgZXJyKTtcbn07IiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsIGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaCAoZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcbnZhciBub2RlanNVdGlscyA9IHJlcXVpcmUoJy4vbm9kZWpzVXRpbHMnKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi9zdHJlYW0vR2VuZXJpY1dvcmtlcicpO1xuXG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGNvbWUgZnJvbSBwYWtvLCBmcm9tIHBha28vbGliL3V0aWxzL3N0cmluZ3NcbiAqIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSwgc2VlIHBha28gaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvL1xuICovXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxudmFyIF91dGY4bGVuID0gbmV3IEFycmF5KDI1Nik7XG5mb3IgKHZhciBpPTA7IGk8MjU2OyBpKyspIHtcbiAgX3V0ZjhsZW5baV0gPSAoaSA+PSAyNTIgPyA2IDogaSA+PSAyNDggPyA1IDogaSA+PSAyNDAgPyA0IDogaSA+PSAyMjQgPyAzIDogaSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdPV91dGY4bGVuWzI1NF09MTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG52YXIgc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB2YXIgYnVmLCBjLCBjMiwgbV9wb3MsIGksIHN0cl9sZW4gPSBzdHIubGVuZ3RoLCBidWZfbGVuID0gMDtcblxuICAgIC8vIGNvdW50IGJpbmFyeSBzaXplXG4gICAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgICAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zKzEgPCBzdHJfbGVuKSkge1xuICAgICAgICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcysxKTtcbiAgICAgICAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgICAgICAgICBtX3BvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJ1Zl9sZW4gKz0gYyA8IDB4ODAgPyAxIDogYyA8IDB4ODAwID8gMiA6IGMgPCAweDEwMDAwID8gMyA6IDQ7XG4gICAgfVxuXG4gICAgLy8gYWxsb2NhdGUgYnVmZmVyXG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICBidWYgPSBuZXcgVWludDhBcnJheShidWZfbGVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBidWYgPSBuZXcgQXJyYXkoYnVmX2xlbik7XG4gICAgfVxuXG4gICAgLy8gY29udmVydFxuICAgIGZvciAoaT0wLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7XG4gICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MrMSA8IHN0cl9sZW4pKSB7XG4gICAgICAgICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKzEpO1xuICAgICAgICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICAgICAgICAgIG1fcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICAvKiBvbmUgYnl0ZSAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSBjO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICAvKiB0aHJlZSBieXRlcyAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSAweEUwIHwgKGMgPj4+IDEyKTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLyogZm91ciBieXRlcyAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSAweGYwIHwgKGMgPj4+IDE4KTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiAxMiAmIDB4M2YpO1xuICAgICAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xufTtcblxuLy8gQ2FsY3VsYXRlIG1heCBwb3NzaWJsZSBwb3NpdGlvbiBpbiB1dGY4IGJ1ZmZlcixcbi8vIHRoYXQgd2lsbCBub3QgYnJlYWsgc2VxdWVuY2UuIElmIHRoYXQncyBub3QgcG9zc2libGVcbi8vIC0gKHZlcnkgc21hbGwgbGltaXRzKSByZXR1cm4gbWF4IHNpemUgYXMgaXMuXG4vL1xuLy8gYnVmW10gLSB1dGY4IGJ5dGVzIGFycmF5XG4vLyBtYXggICAtIGxlbmd0aCBsaW1pdCAobWFuZGF0b3J5KTtcbnZhciB1dGY4Ym9yZGVyID0gZnVuY3Rpb24oYnVmLCBtYXgpIHtcbiAgICB2YXIgcG9zO1xuXG4gICAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gICAgaWYgKG1heCA+IGJ1Zi5sZW5ndGgpIHsgbWF4ID0gYnVmLmxlbmd0aDsgfVxuXG4gICAgLy8gZ28gYmFjayBmcm9tIGxhc3QgcG9zaXRpb24sIHVudGlsIHN0YXJ0IG9mIHNlcXVlbmNlIGZvdW5kXG4gICAgcG9zID0gbWF4LTE7XG4gICAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgICAvLyBGdWNrdXAgLSB2ZXJ5IHNtYWxsIGFuZCBicm9rZW4gc2VxdWVuY2UsXG4gICAgLy8gcmV0dXJuIG1heCwgYmVjYXVzZSB3ZSBzaG91bGQgcmV0dXJuIHNvbWV0aGluZyBhbnl3YXkuXG4gICAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gICAgLy8gSWYgd2UgY2FtZSB0byBzdGFydCBvZiBidWZmZXIgLSB0aGF0IG1lYW5zIHZ1ZmZlciBpcyB0b28gc21hbGwsXG4gICAgLy8gcmV0dXJuIG1heCB0b28uXG4gICAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgICByZXR1cm4gKHBvcyArIF91dGY4bGVuW2J1Zltwb3NdXSA+IG1heCkgPyBwb3MgOiBtYXg7XG59O1xuXG4vLyBjb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xudmFyIGJ1ZjJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgdmFyIHN0ciwgaSwgb3V0LCBjLCBjX2xlbjtcbiAgICB2YXIgbGVuID0gYnVmLmxlbmd0aDtcblxuICAgIC8vIFJlc2VydmUgbWF4IHBvc3NpYmxlIGxlbmd0aCAoMiB3b3JkcyBwZXIgY2hhcilcbiAgICAvLyBOQjogYnkgdW5rbm93biByZWFzb25zLCBBcnJheSBpcyBzaWduaWZpY2FudGx5IGZhc3RlciBmb3JcbiAgICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICAgIHZhciB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4qMik7XG5cbiAgICBmb3IgKG91dD0wLCBpPTA7IGk8bGVuOykge1xuICAgICAgICBjID0gYnVmW2krK107XG4gICAgICAgIC8vIHF1aWNrIHByb2Nlc3MgYXNjaWlcbiAgICAgICAgaWYgKGMgPCAweDgwKSB7IHV0ZjE2YnVmW291dCsrXSA9IGM7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAgICAgLy8gc2tpcCA1ICYgNiBieXRlIGNvZGVzXG4gICAgICAgIGlmIChjX2xlbiA+IDQpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBpICs9IGNfbGVuLTE7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgLy8gYXBwbHkgbWFzayBvbiBmaXJzdCBieXRlXG4gICAgICAgIGMgJj0gY19sZW4gPT09IDIgPyAweDFmIDogY19sZW4gPT09IDMgPyAweDBmIDogMHgwNztcbiAgICAgICAgLy8gam9pbiB0aGUgcmVzdFxuICAgICAgICB3aGlsZSAoY19sZW4gPiAxICYmIGkgPCBsZW4pIHtcbiAgICAgICAgICAgIGMgPSAoYyA8PCA2KSB8IChidWZbaSsrXSAmIDB4M2YpO1xuICAgICAgICAgICAgY19sZW4tLTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICAgICAgaWYgKGNfbGVuID4gMSkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSBjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2hyaW5rQnVmKHV0ZjE2YnVmLCBvdXQpXG4gICAgaWYgKHV0ZjE2YnVmLmxlbmd0aCAhPT0gb3V0KSB7XG4gICAgICAgIGlmKHV0ZjE2YnVmLnN1YmFycmF5KSB7XG4gICAgICAgICAgICB1dGYxNmJ1ZiA9IHV0ZjE2YnVmLnN1YmFycmF5KDAsIG91dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGYxNmJ1Zi5sZW5ndGggPSBvdXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB1dGYxNmJ1Zik7XG4gICAgcmV0dXJuIHV0aWxzLmFwcGx5RnJvbUNoYXJDb2RlKHV0ZjE2YnVmKTtcbn07XG5cblxuLy8gVGhhdCdzIGFsbCBmb3IgdGhlIHBha28gZnVuY3Rpb25zLlxuXG5cbi8qKlxuICogVHJhbnNmb3JtIGEgamF2YXNjcmlwdCBzdHJpbmcgaW50byBhbiBhcnJheSAodHlwZWQgaWYgcG9zc2libGUpIG9mIGJ5dGVzLFxuICogVVRGLTggZW5jb2RlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byBlbmNvZGVcbiAqIEByZXR1cm4ge0FycmF5fFVpbnQ4QXJyYXl8QnVmZmVyfSB0aGUgVVRGLTggZW5jb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydHMudXRmOGVuY29kZSA9IGZ1bmN0aW9uIHV0ZjhlbmNvZGUoc3RyKSB7XG4gICAgaWYgKHN1cHBvcnQubm9kZWJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gbm9kZWpzVXRpbHMubmV3QnVmZmVyRnJvbShzdHIsIFwidXRmLThcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZzJidWYoc3RyKTtcbn07XG5cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBieXRlcyBhcnJheSAob3IgYSByZXByZXNlbnRhdGlvbikgcmVwcmVzZW50aW5nIGFuIFVURi04IGVuY29kZWRcbiAqIHN0cmluZyBpbnRvIGEgamF2YXNjcmlwdCBzdHJpbmcuXG4gKiBAcGFyYW0ge0FycmF5fFVpbnQ4QXJyYXl8QnVmZmVyfSBidWYgdGhlIGRhdGEgZGUgZGVjb2RlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBkZWNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0cy51dGY4ZGVjb2RlID0gZnVuY3Rpb24gdXRmOGRlY29kZShidWYpIHtcbiAgICBpZiAoc3VwcG9ydC5ub2RlYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiB1dGlscy50cmFuc2Zvcm1UbyhcIm5vZGVidWZmZXJcIiwgYnVmKS50b1N0cmluZyhcInV0Zi04XCIpO1xuICAgIH1cblxuICAgIGJ1ZiA9IHV0aWxzLnRyYW5zZm9ybVRvKHN1cHBvcnQudWludDhhcnJheSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiLCBidWYpO1xuXG4gICAgcmV0dXJuIGJ1ZjJzdHJpbmcoYnVmKTtcbn07XG5cbi8qKlxuICogQSB3b3JrZXIgdG8gZGVjb2RlIHV0ZjggZW5jb2RlZCBiaW5hcnkgY2h1bmtzIGludG8gc3RyaW5nIGNodW5rcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBVdGY4RGVjb2RlV29ya2VyKCkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcInV0Zi04IGRlY29kZVwiKTtcbiAgICAvLyB0aGUgbGFzdCBieXRlcyBpZiBhIGNodW5rIGRpZG4ndCBlbmQgd2l0aCBhIGNvbXBsZXRlIGNvZGVwb2ludC5cbiAgICB0aGlzLmxlZnRPdmVyID0gbnVsbDtcbn1cbnV0aWxzLmluaGVyaXRzKFV0ZjhEZWNvZGVXb3JrZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuVXRmOERlY29kZVdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG5cbiAgICB2YXIgZGF0YSA9IHV0aWxzLnRyYW5zZm9ybVRvKHN1cHBvcnQudWludDhhcnJheSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiLCBjaHVuay5kYXRhKTtcblxuICAgIC8vIDFzdCBzdGVwLCByZS11c2Ugd2hhdCdzIGxlZnQgb2YgdGhlIHByZXZpb3VzIGNodW5rXG4gICAgaWYgKHRoaXMubGVmdE92ZXIgJiYgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpIHtcbiAgICAgICAgaWYoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNEYXRhID0gZGF0YTtcbiAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShwcmV2aW91c0RhdGEubGVuZ3RoICsgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpO1xuICAgICAgICAgICAgZGF0YS5zZXQodGhpcy5sZWZ0T3ZlciwgMCk7XG4gICAgICAgICAgICBkYXRhLnNldChwcmV2aW91c0RhdGEsIHRoaXMubGVmdE92ZXIubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLmxlZnRPdmVyLmNvbmNhdChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlZnRPdmVyID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEJvdW5kYXJ5ID0gdXRmOGJvcmRlcihkYXRhKTtcbiAgICB2YXIgdXNhYmxlRGF0YSA9IGRhdGE7XG4gICAgaWYgKG5leHRCb3VuZGFyeSAhPT0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICAgICAgdXNhYmxlRGF0YSA9IGRhdGEuc3ViYXJyYXkoMCwgbmV4dEJvdW5kYXJ5KTtcbiAgICAgICAgICAgIHRoaXMubGVmdE92ZXIgPSBkYXRhLnN1YmFycmF5KG5leHRCb3VuZGFyeSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXNhYmxlRGF0YSA9IGRhdGEuc2xpY2UoMCwgbmV4dEJvdW5kYXJ5KTtcbiAgICAgICAgICAgIHRoaXMubGVmdE92ZXIgPSBkYXRhLnNsaWNlKG5leHRCb3VuZGFyeSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IGV4cG9ydHMudXRmOGRlY29kZSh1c2FibGVEYXRhKSxcbiAgICAgICAgbWV0YSA6IGNodW5rLm1ldGFcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmZsdXNoXG4gKi9cblV0ZjhEZWNvZGVXb3JrZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKHRoaXMubGVmdE92ZXIgJiYgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiBleHBvcnRzLnV0ZjhkZWNvZGUodGhpcy5sZWZ0T3ZlciksXG4gICAgICAgICAgICBtZXRhIDoge31cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGVmdE92ZXIgPSBudWxsO1xuICAgIH1cbn07XG5leHBvcnRzLlV0ZjhEZWNvZGVXb3JrZXIgPSBVdGY4RGVjb2RlV29ya2VyO1xuXG4vKipcbiAqIEEgd29ya2VyIHRvIGVuZGNvZGUgc3RyaW5nIGNodW5rcyBpbnRvIHV0ZjggZW5jb2RlZCBiaW5hcnkgY2h1bmtzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFV0ZjhFbmNvZGVXb3JrZXIoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwidXRmLTggZW5jb2RlXCIpO1xufVxudXRpbHMuaW5oZXJpdHMoVXRmOEVuY29kZVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5VdGY4RW5jb2RlV29ya2VyLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICB0aGlzLnB1c2goe1xuICAgICAgICBkYXRhIDogZXhwb3J0cy51dGY4ZW5jb2RlKGNodW5rLmRhdGEpLFxuICAgICAgICBtZXRhIDogY2h1bmsubWV0YVxuICAgIH0pO1xufTtcbmV4cG9ydHMuVXRmOEVuY29kZVdvcmtlciA9IFV0ZjhFbmNvZGVXb3JrZXI7XG4iLCIvKiBnbG9iYWwgUHJvbWlzZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBsb2FkIHRoZSBnbG9iYWwgb2JqZWN0IGZpcnN0OlxuLy8gLSBpdCBzaG91bGQgYmUgYmV0dGVyIGludGVncmF0ZWQgaW4gdGhlIHN5c3RlbSAodW5oYW5kbGVkUmVqZWN0aW9uIGluIG5vZGUpXG4vLyAtIHRoZSBlbnZpcm9ubWVudCBtYXkgaGF2ZSBhIGN1c3RvbSBQcm9taXNlIGltcGxlbWVudGF0aW9uIChzZWUgem9uZS5qcylcbnZhciBFUzZQcm9taXNlID0gbnVsbDtcbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIEVTNlByb21pc2UgPSBQcm9taXNlO1xufSBlbHNlIHtcbiAgICBFUzZQcm9taXNlID0gcmVxdWlyZShcImxpZVwiKTtcbn1cblxuLyoqXG4gKiBMZXQgdGhlIHVzZXIgdXNlL2NoYW5nZSBzb21lIGltcGxlbWVudGF0aW9ucy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgUHJvbWlzZTogRVM2UHJvbWlzZVxufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuXG5mdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYodHlwZW9mIF9fZyA9PSAnbnVtYmVyJylfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhpcyBpcyBydW5uaW5nIGluIE5vZGVqcywgd2lsbCBiZSB1bmRlZmluZWQgaW4gYSBicm93c2VyLlxuICAgICAqIEluIGEgYnJvd3NlciwgYnJvd3NlcmlmeSB3b24ndCBpbmNsdWRlIHRoaXMgZmlsZSBhbmQgdGhlIHdob2xlIG1vZHVsZVxuICAgICAqIHdpbGwgYmUgcmVzb2x2ZWQgYW4gZW1wdHkgb2JqZWN0LlxuICAgICAqL1xuICAgIGlzTm9kZSA6IHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIsXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IG5vZGVqcyBCdWZmZXIgZnJvbSBhbiBleGlzdGluZyBjb250ZW50LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIHRoZSBkYXRhIHRvIHBhc3MgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBlbmNvZGluZyB0aGUgZW5jb2RpbmcgdG8gdXNlLlxuICAgICAqIEByZXR1cm4ge0J1ZmZlcn0gYSBuZXcgQnVmZmVyLlxuICAgICAqL1xuICAgIG5ld0J1ZmZlckZyb206IGZ1bmN0aW9uKGRhdGEsIGVuY29kaW5nKSB7XG4gICAgICAgIC8vIFhYWCBXZSBjYW4ndCB1c2UgYEJ1ZmZlci5mcm9tYCB3aGljaCBjb21lcyBmcm9tIGBVaW50OEFycmF5LmZyb21gXG4gICAgICAgIC8vIGluIG5vZGVqcyB2NCAoPCB2LjQuNSkuIEl0J3Mgbm90IHRoZSBleHBlY3RlZCBpbXBsZW1lbnRhdGlvbiAoYW5kXG4gICAgICAgIC8vIGhhcyBhIGRpZmZlcmVudCBzaWduYXR1cmUpLlxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy84MDUzXG4gICAgICAgIC8vIEEgY29uZGl0aW9uIG9uIG5vZGVqcycgdmVyc2lvbiB3b24ndCBzb2x2ZSB0aGUgaXNzdWUgYXMgd2UgZG9uJ3RcbiAgICAgICAgLy8gY29udHJvbCB0aGUgQnVmZmVyIHBvbHlmaWxscyB0aGF0IG1heSBvciBtYXkgbm90IGJlIHVzZWQuXG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyKGRhdGEsIGVuY29kaW5nKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBub2RlanMgQnVmZmVyIHdpdGggdGhlIHNwZWNpZmllZCBzaXplLlxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gc2l6ZSB0aGUgc2l6ZSBvZiB0aGUgYnVmZmVyLlxuICAgICAqIEByZXR1cm4ge0J1ZmZlcn0gYSBuZXcgQnVmZmVyLlxuICAgICAqL1xuICAgIGFsbG9jQnVmZmVyOiBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICBpZiAoQnVmZmVyLmFsbG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKHNpemUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoc2l6ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEZpbmQgb3V0IGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYiB0aGUgb2JqZWN0IHRvIHRlc3QuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgQnVmZmVyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNCdWZmZXIgOiBmdW5jdGlvbihiKXtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihiKTtcbiAgICB9LFxuXG4gICAgaXNTdHJlYW0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiZcbiAgICAgICAgICAgIHR5cGVvZiBvYmoub24gPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgdHlwZW9mIG9iai5wYXVzZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICB0eXBlb2Ygb2JqLnJlc3VtZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH1cbn07XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAoIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgbmV4dFRpY2s6IG5leHRUaWNrIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3Ncbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MsIGk7XG4gIHN3aXRjaCAobGVuKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XG4gICAgfSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xuICAgIH0pO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH0pO1xuICBkZWZhdWx0OlxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufVxuXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIGEgb2YgemlwIGZpbGUgaW4ganNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBKU1ppcCgpIHtcbiAgICAvLyBpZiB0aGlzIGNvbnN0cnVjdG9yIGlzwqB1c2VkIHdpdGhvdXTCoGBuZXdgLCBpdMKgYWRkcyBgbmV3YCBiZWZvcmXCoGl0c2VsZjpcbiAgICBpZighKHRoaXMgaW5zdGFuY2VvZiBKU1ppcCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKU1ppcCgpO1xuICAgIH1cblxuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNvbnN0cnVjdG9yIHdpdGggcGFyYW1ldGVycyBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKTtcbiAgICB9XG5cbiAgICAvLyBvYmplY3QgY29udGFpbmluZyB0aGUgZmlsZXMgOlxuICAgIC8vIHtcbiAgICAvLyAgIFwiZm9sZGVyL1wiIDogey4uLn0sXG4gICAgLy8gICBcImZvbGRlci9kYXRhLnR4dFwiIDogey4uLn1cbiAgICAvLyB9XG4gICAgdGhpcy5maWxlcyA9IHt9O1xuXG4gICAgdGhpcy5jb21tZW50ID0gbnVsbDtcblxuICAgIC8vIFdoZXJlIHdlIGFyZSBpbiB0aGUgaGllcmFyY2h5XG4gICAgdGhpcy5yb290ID0gXCJcIjtcbiAgICB0aGlzLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBuZXdPYmogPSBuZXcgSlNaaXAoKTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNbaV0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG5ld09ialtpXSA9IHRoaXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld09iajtcbiAgICB9O1xufVxuSlNaaXAucHJvdG90eXBlID0gcmVxdWlyZSgnLi9vYmplY3QnKTtcbkpTWmlwLnByb3RvdHlwZS5sb2FkQXN5bmMgPSByZXF1aXJlKCcuL2xvYWQnKTtcbkpTWmlwLnN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcbkpTWmlwLmRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG4vLyBUT0RPIGZpbmQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzIHZlcnNpb24sXG4vLyBhIHJlcXVpcmUoJ3BhY2thZ2UuanNvbicpLnZlcnNpb24gZG9lc24ndCB3b3JrIHdpdGggd2VicGFjaywgc2VlICMzMjdcbkpTWmlwLnZlcnNpb24gPSBcIjMuMS41XCI7XG5cbkpTWmlwLmxvYWRBc3luYyA9IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBKU1ppcCgpLmxvYWRBc3luYyhjb250ZW50LCBvcHRpb25zKTtcbn07XG5cbkpTWmlwLmV4dGVybmFsID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxcIik7XG5tb2R1bGUuZXhwb3J0cyA9IEpTWmlwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAyOiAgICAgICduZWVkIGRpY3Rpb25hcnknLCAgICAgLyogWl9ORUVEX0RJQ1QgICAgICAgMiAgKi9cbiAgMTogICAgICAnc3RyZWFtIGVuZCcsICAgICAgICAgIC8qIFpfU1RSRUFNX0VORCAgICAgIDEgICovXG4gIDA6ICAgICAgJycsICAgICAgICAgICAgICAgICAgICAvKiBaX09LICAgICAgICAgICAgICAwICAqL1xuICAnLTEnOiAgICdmaWxlIGVycm9yJywgICAgICAgICAgLyogWl9FUlJOTyAgICAgICAgICgtMSkgKi9cbiAgJy0yJzogICAnc3RyZWFtIGVycm9yJywgICAgICAgIC8qIFpfU1RSRUFNX0VSUk9SICAoLTIpICovXG4gICctMyc6ICAgJ2RhdGEgZXJyb3InLCAgICAgICAgICAvKiBaX0RBVEFfRVJST1IgICAgKC0zKSAqL1xuICAnLTQnOiAgICdpbnN1ZmZpY2llbnQgbWVtb3J5JywgLyogWl9NRU1fRVJST1IgICAgICgtNCkgKi9cbiAgJy01JzogICAnYnVmZmVyIGVycm9yJywgICAgICAgIC8qIFpfQlVGX0VSUk9SICAgICAoLTUpICovXG4gICctNic6ICAgJ2luY29tcGF0aWJsZSB2ZXJzaW9uJyAvKiBaX1ZFUlNJT05fRVJST1IgKC02KSAqL1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGNvbWUgZnJvbSBwYWtvLCBmcm9tIHBha28vbGliL3psaWIvY3JjMzIuanNcbiAqIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSwgc2VlIHBha28gaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvL1xuICovXG5cbi8vIFVzZSBvcmRpbmFyeSBhcnJheSwgc2luY2UgdW50eXBlZCBtYWtlcyBubyBib29zdCBoZXJlXG5mdW5jdGlvbiBtYWtlVGFibGUoKSB7XG4gICAgdmFyIGMsIHRhYmxlID0gW107XG5cbiAgICBmb3IodmFyIG4gPTA7IG4gPCAyNTY7IG4rKyl7XG4gICAgICAgIGMgPSBuO1xuICAgICAgICBmb3IodmFyIGsgPTA7IGsgPCA4OyBrKyspe1xuICAgICAgICAgICAgYyA9ICgoYyYxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFibGVbbl0gPSBjO1xuICAgIH1cblxuICAgIHJldHVybiB0YWJsZTtcbn1cblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbnZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpO1xuXG5cbmZ1bmN0aW9uIGNyYzMyKGNyYywgYnVmLCBsZW4sIHBvcykge1xuICAgIHZhciB0ID0gY3JjVGFibGUsIGVuZCA9IHBvcyArIGxlbjtcblxuICAgIGNyYyA9IGNyYyBeICgtMSk7XG5cbiAgICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKysgKSB7XG4gICAgICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdFsoY3JjIF4gYnVmW2ldKSAmIDB4RkZdO1xuICAgIH1cblxuICAgIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuXG4vLyBUaGF0J3MgYWxsIGZvciB0aGUgcGFrbyBmdW5jdGlvbnMuXG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgY3JjMzIgb2YgYSBzdHJpbmcuXG4gKiBUaGlzIGlzIGFsbW9zdCB0aGUgc2FtZSBhcyB0aGUgZnVuY3Rpb24gY3JjMzIsIGJ1dCBmb3Igc3RyaW5ncy4gVXNpbmcgdGhlXG4gKiBzYW1lIGZ1bmN0aW9uIGZvciB0aGUgdHdvIHVzZSBjYXNlcyBsZWFkcyB0byBob3JyaWJsZSBwZXJmb3JtYW5jZXMuXG4gKiBAcGFyYW0ge051bWJlcn0gY3JjIHRoZSBzdGFydGluZyB2YWx1ZSBvZiB0aGUgY3JjLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHVzZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW4gdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nLlxuICogQHBhcmFtIHtOdW1iZXJ9IHBvcyB0aGUgc3RhcnRpbmcgcG9zaXRpb24gZm9yIHRoZSBjcmMzMiBjb21wdXRhdGlvbi5cbiAqIEByZXR1cm4ge051bWJlcn0gdGhlIGNvbXB1dGVkIGNyYzMyLlxuICovXG5mdW5jdGlvbiBjcmMzMnN0cihjcmMsIHN0ciwgbGVuLCBwb3MpIHtcbiAgICB2YXIgdCA9IGNyY1RhYmxlLCBlbmQgPSBwb3MgKyBsZW47XG5cbiAgICBjcmMgPSBjcmMgXiAoLTEpO1xuXG4gICAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrICkge1xuICAgICAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIHN0ci5jaGFyQ29kZUF0KGkpKSAmIDB4RkZdO1xuICAgIH1cblxuICAgIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyYzMyd3JhcHBlcihpbnB1dCwgY3JjKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciBpc0FycmF5ID0gdXRpbHMuZ2V0VHlwZU9mKGlucHV0KSAhPT0gXCJzdHJpbmdcIjtcblxuICAgIGlmKGlzQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGNyYzMyKGNyY3wwLCBpbnB1dCwgaW5wdXQubGVuZ3RoLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY3JjMzJzdHIoY3JjfDAsIGlucHV0LCBpbnB1dC5sZW5ndGgsIDApO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBleHRlcm5hbCA9IHJlcXVpcmUoXCIuL2V4dGVybmFsXCIpO1xudmFyIERhdGFXb3JrZXIgPSByZXF1aXJlKCcuL3N0cmVhbS9EYXRhV29ya2VyJyk7XG52YXIgRGF0YUxlbmd0aFByb2JlID0gcmVxdWlyZSgnLi9zdHJlYW0vRGF0YUxlbmd0aFByb2JlJyk7XG52YXIgQ3JjMzJQcm9iZSA9IHJlcXVpcmUoJy4vc3RyZWFtL0NyYzMyUHJvYmUnKTtcbnZhciBEYXRhTGVuZ3RoUHJvYmUgPSByZXF1aXJlKCcuL3N0cmVhbS9EYXRhTGVuZ3RoUHJvYmUnKTtcblxuLyoqXG4gKiBSZXByZXNlbnQgYSBjb21wcmVzc2VkIG9iamVjdCwgd2l0aCBldmVyeXRoaW5nIG5lZWRlZCB0byBkZWNvbXByZXNzIGl0LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gY29tcHJlc3NlZFNpemUgdGhlIHNpemUgb2YgdGhlIGRhdGEgY29tcHJlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB1bmNvbXByZXNzZWRTaXplIHRoZSBzaXplIG9mIHRoZSBkYXRhIGFmdGVyIGRlY29tcHJlc3Npb24uXG4gKiBAcGFyYW0ge251bWJlcn0gY3JjMzIgdGhlIGNyYzMyIG9mIHRoZSBkZWNvbXByZXNzZWQgZmlsZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wcmVzc2lvbiB0aGUgdHlwZSBvZiBjb21wcmVzc2lvbiwgc2VlIGxpYi9jb21wcmVzc2lvbnMuanMuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gZGF0YSB0aGUgY29tcHJlc3NlZCBkYXRhLlxuICovXG5mdW5jdGlvbiBDb21wcmVzc2VkT2JqZWN0KGNvbXByZXNzZWRTaXplLCB1bmNvbXByZXNzZWRTaXplLCBjcmMzMiwgY29tcHJlc3Npb24sIGRhdGEpIHtcbiAgICB0aGlzLmNvbXByZXNzZWRTaXplID0gY29tcHJlc3NlZFNpemU7XG4gICAgdGhpcy51bmNvbXByZXNzZWRTaXplID0gdW5jb21wcmVzc2VkU2l6ZTtcbiAgICB0aGlzLmNyYzMyID0gY3JjMzI7XG4gICAgdGhpcy5jb21wcmVzc2lvbiA9IGNvbXByZXNzaW9uO1xuICAgIHRoaXMuY29tcHJlc3NlZENvbnRlbnQgPSBkYXRhO1xufVxuXG5Db21wcmVzc2VkT2JqZWN0LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB3b3JrZXIgdG8gZ2V0IHRoZSB1bmNvbXByZXNzZWQgY29udGVudC5cbiAgICAgKiBAcmV0dXJuIHtHZW5lcmljV29ya2VyfSB0aGUgd29ya2VyLlxuICAgICAqL1xuICAgIGdldENvbnRlbnRXb3JrZXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3b3JrZXIgPSBuZXcgRGF0YVdvcmtlcihleHRlcm5hbC5Qcm9taXNlLnJlc29sdmUodGhpcy5jb21wcmVzc2VkQ29udGVudCkpXG4gICAgICAgIC5waXBlKHRoaXMuY29tcHJlc3Npb24udW5jb21wcmVzc1dvcmtlcigpKVxuICAgICAgICAucGlwZShuZXcgRGF0YUxlbmd0aFByb2JlKFwiZGF0YV9sZW5ndGhcIikpO1xuXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgd29ya2VyLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuc3RyZWFtSW5mb1snZGF0YV9sZW5ndGgnXSAhPT0gdGhhdC51bmNvbXByZXNzZWRTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVnIDogdW5jb21wcmVzc2VkIGRhdGEgc2l6ZSBtaXNtYXRjaFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB3b3JrZXI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB3b3JrZXIgdG8gZ2V0IHRoZSBjb21wcmVzc2VkIGNvbnRlbnQuXG4gICAgICogQHJldHVybiB7R2VuZXJpY1dvcmtlcn0gdGhlIHdvcmtlci5cbiAgICAgKi9cbiAgICBnZXRDb21wcmVzc2VkV29ya2VyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGFXb3JrZXIoZXh0ZXJuYWwuUHJvbWlzZS5yZXNvbHZlKHRoaXMuY29tcHJlc3NlZENvbnRlbnQpKVxuICAgICAgICAud2l0aFN0cmVhbUluZm8oXCJjb21wcmVzc2VkU2l6ZVwiLCB0aGlzLmNvbXByZXNzZWRTaXplKVxuICAgICAgICAud2l0aFN0cmVhbUluZm8oXCJ1bmNvbXByZXNzZWRTaXplXCIsIHRoaXMudW5jb21wcmVzc2VkU2l6ZSlcbiAgICAgICAgLndpdGhTdHJlYW1JbmZvKFwiY3JjMzJcIiwgdGhpcy5jcmMzMilcbiAgICAgICAgLndpdGhTdHJlYW1JbmZvKFwiY29tcHJlc3Npb25cIiwgdGhpcy5jb21wcmVzc2lvbilcbiAgICAgICAgO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ2hhaW4gdGhlIGdpdmVuIHdvcmtlciB3aXRoIG90aGVyIHdvcmtlcnMgdG8gY29tcHJlc3MgdGhlIGNvbnRlbnQgd2l0aCB0aGVcbiAqIGdpdmVuIGNvbXByZXNpb24uXG4gKiBAcGFyYW0ge0dlbmVyaWNXb3JrZXJ9IHVuY29tcHJlc3NlZFdvcmtlciB0aGUgd29ya2VyIHRvIHBpcGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29tcHJlc3Npb24gdGhlIGNvbXByZXNzaW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb21wcmVzc2lvbk9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gY29tcHJlc3NpbmcuXG4gKiBAcmV0dXJuIHtHZW5lcmljV29ya2VyfSB0aGUgbmV3IHdvcmtlciBjb21wcmVzc2luZyB0aGUgY29udGVudC5cbiAqL1xuQ29tcHJlc3NlZE9iamVjdC5jcmVhdGVXb3JrZXJGcm9tID0gZnVuY3Rpb24gKHVuY29tcHJlc3NlZFdvcmtlciwgY29tcHJlc3Npb24sIGNvbXByZXNzaW9uT3B0aW9ucykge1xuICAgIHJldHVybiB1bmNvbXByZXNzZWRXb3JrZXJcbiAgICAucGlwZShuZXcgQ3JjMzJQcm9iZSgpKVxuICAgIC5waXBlKG5ldyBEYXRhTGVuZ3RoUHJvYmUoXCJ1bmNvbXByZXNzZWRTaXplXCIpKVxuICAgIC5waXBlKGNvbXByZXNzaW9uLmNvbXByZXNzV29ya2VyKGNvbXByZXNzaW9uT3B0aW9ucykpXG4gICAgLnBpcGUobmV3IERhdGFMZW5ndGhQcm9iZShcImNvbXByZXNzZWRTaXplXCIpKVxuICAgIC53aXRoU3RyZWFtSW5mbyhcImNvbXByZXNzaW9uXCIsIGNvbXByZXNzaW9uKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcHJlc3NlZE9iamVjdDtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qIDxyZXBsYWNlbWVudD4gKi9cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcG5hLm5leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgd3JpdGFibGVId20gPSBvcHRpb25zLndyaXRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmICh3cml0YWJsZUh3bSB8fCB3cml0YWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHdyaXRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTtcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIGlmICghcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHtcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB9XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHBuYS5uZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG4gICAgcG5hLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tO1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcG5hLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwbmEubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfVxuICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGNvcmtSZXE7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLmVuZCgpO1xuICBjYihlcnIpO1xufTsiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEFycmF5UmVhZGVyID0gcmVxdWlyZSgnLi9BcnJheVJlYWRlcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gVWludDhBcnJheVJlYWRlcihkYXRhKSB7XG4gICAgQXJyYXlSZWFkZXIuY2FsbCh0aGlzLCBkYXRhKTtcbn1cbnV0aWxzLmluaGVyaXRzKFVpbnQ4QXJyYXlSZWFkZXIsIEFycmF5UmVhZGVyKTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLnJlYWREYXRhXG4gKi9cblVpbnQ4QXJyYXlSZWFkZXIucHJvdG90eXBlLnJlYWREYXRhID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHRoaXMuY2hlY2tPZmZzZXQoc2l6ZSk7XG4gICAgaWYoc2l6ZSA9PT0gMCkge1xuICAgICAgICAvLyBpbiBJRTEwLCB3aGVuIHVzaW5nIHN1YmFycmF5KGlkeCwgaWR4KSwgd2UgZ2V0IHRoZSBhcnJheSBbMHgwMF0gaW5zdGVhZCBvZiBbXS5cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5kYXRhLnN1YmFycmF5KHRoaXMuemVybyArIHRoaXMuaW5kZXgsIHRoaXMuemVybyArIHRoaXMuaW5kZXggKyBzaXplKTtcbiAgICB0aGlzLmluZGV4ICs9IHNpemU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFVpbnQ4QXJyYXlSZWFkZXI7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5mdW5jdGlvbiBEYXRhUmVhZGVyKGRhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhOyAvLyB0eXBlIDogc2VlIGltcGxlbWVudGF0aW9uXG4gICAgdGhpcy5sZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB0aGlzLnplcm8gPSAwO1xufVxuRGF0YVJlYWRlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCB0aGUgb2Zmc2V0IHdpbGwgbm90IGdvIHRvbyBmYXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9mZnNldCB0aGUgYWRkaXRpb25hbCBvZmZzZXQgdG8gY2hlY2suXG4gICAgICogQHRocm93cyB7RXJyb3J9IGFuIEVycm9yIGlmIHRoZSBvZmZzZXQgaXMgb3V0IG9mIGJvdW5kcy5cbiAgICAgKi9cbiAgICBjaGVja09mZnNldDogZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tJbmRleCh0aGlzLmluZGV4ICsgb2Zmc2V0KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgdGhlIHNwZWNpZmllZCBpbmRleCB3aWxsIG5vdCBiZSB0b28gZmFyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdJbmRleCB0aGUgaW5kZXggdG8gY2hlY2suXG4gICAgICogQHRocm93cyB7RXJyb3J9IGFuIEVycm9yIGlmIHRoZSBpbmRleCBpcyBvdXQgb2YgYm91bmRzLlxuICAgICAqL1xuICAgIGNoZWNrSW5kZXg6IGZ1bmN0aW9uKG5ld0luZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA8IHRoaXMuemVybyArIG5ld0luZGV4IHx8IG5ld0luZGV4IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5kIG9mIGRhdGEgcmVhY2hlZCAoZGF0YSBsZW5ndGggPSBcIiArIHRoaXMubGVuZ3RoICsgXCIsIGFza2VkIGluZGV4ID0gXCIgKyAobmV3SW5kZXgpICsgXCIpLiBDb3JydXB0ZWQgemlwID9cIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0aGUgaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld0luZGV4IFRoZSBuZXcgaW5kZXguXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBuZXcgaW5kZXggaXMgb3V0IG9mIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIHNldEluZGV4OiBmdW5jdGlvbihuZXdJbmRleCkge1xuICAgICAgICB0aGlzLmNoZWNrSW5kZXgobmV3SW5kZXgpO1xuICAgICAgICB0aGlzLmluZGV4ID0gbmV3SW5kZXg7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTa2lwIHRoZSBuZXh0IG4gYnl0ZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gdGhlIG51bWJlciBvZiBieXRlcyB0byBza2lwLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgbmV3IGluZGV4IGlzIG91dCBvZiB0aGUgZGF0YS5cbiAgICAgKi9cbiAgICBza2lwOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHRoaXMuc2V0SW5kZXgodGhpcy5pbmRleCArIG4pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBieXRlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGkgdGhlIGluZGV4IHRvIHVzZS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IGEgYnl0ZS5cbiAgICAgKi9cbiAgICBieXRlQXQ6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgLy8gc2VlIGltcGxlbWVudGF0aW9uc1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IG51bWJlciB3aXRoIGEgZ2l2ZW4gYnl0ZSBzaXplLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBjb3JyZXNwb25kaW5nIG51bWJlci5cbiAgICAgKi9cbiAgICByZWFkSW50OiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAwLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgdGhpcy5jaGVja09mZnNldChzaXplKTtcbiAgICAgICAgZm9yIChpID0gdGhpcy5pbmRleCArIHNpemUgLSAxOyBpID49IHRoaXMuaW5kZXg7IGktLSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCA8PCA4KSArIHRoaXMuYnl0ZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5kZXggKz0gc2l6ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmV4dCBzdHJpbmcgd2l0aCBhIGdpdmVuIGJ5dGUgc2l6ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgY29ycmVzcG9uZGluZyBzdHJpbmcuXG4gICAgICovXG4gICAgcmVhZFN0cmluZzogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICByZXR1cm4gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgdGhpcy5yZWFkRGF0YShzaXplKSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgcmF3IGRhdGEgd2l0aG91dCBjb252ZXJzaW9uLCA8c2l6ZT4gYnl0ZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIHJhdyBkYXRhLCBpbXBsZW1lbnRhdGlvbiBzcGVjaWZpYy5cbiAgICAgKi9cbiAgICByZWFkRGF0YTogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICAvLyBzZWUgaW1wbGVtZW50YXRpb25zXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBsYXN0IG9jY3VyZW5jZSBvZiBhIHppcCBzaWduYXR1cmUgKDQgYnl0ZXMpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaWcgdGhlIHNpZ25hdHVyZSB0byBmaW5kLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIGluZGV4IG9mIHRoZSBsYXN0IG9jY3VyZW5jZSwgLTEgaWYgbm90IGZvdW5kLlxuICAgICAqL1xuICAgIGxhc3RJbmRleE9mU2lnbmF0dXJlOiBmdW5jdGlvbihzaWcpIHtcbiAgICAgICAgLy8gc2VlIGltcGxlbWVudGF0aW9uc1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgc2lnbmF0dXJlICg0IGJ5dGVzKSBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiBhbmQgY29tcGFyZSBpdCB3aXRoIHNpZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2lnIHRoZSBleHBlY3RlZCBzaWduYXR1cmVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBzaWduYXR1cmUgbWF0Y2hlcywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHJlYWRBbmRDaGVja1NpZ25hdHVyZTogZnVuY3Rpb24oc2lnKSB7XG4gICAgICAgIC8vIHNlZSBpbXBsZW1lbnRhdGlvbnNcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmV4dCBkYXRlLlxuICAgICAqIEByZXR1cm4ge0RhdGV9IHRoZSBkYXRlLlxuICAgICAqL1xuICAgIHJlYWREYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRvc3RpbWUgPSB0aGlzLnJlYWRJbnQoNCk7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyhcbiAgICAgICAgKChkb3N0aW1lID4+IDI1KSAmIDB4N2YpICsgMTk4MCwgLy8geWVhclxuICAgICAgICAoKGRvc3RpbWUgPj4gMjEpICYgMHgwZikgLSAxLCAvLyBtb250aFxuICAgICAgICAoZG9zdGltZSA+PiAxNikgJiAweDFmLCAvLyBkYXlcbiAgICAgICAgKGRvc3RpbWUgPj4gMTEpICYgMHgxZiwgLy8gaG91clxuICAgICAgICAoZG9zdGltZSA+PiA1KSAmIDB4M2YsIC8vIG1pbnV0ZVxuICAgICAgICAoZG9zdGltZSAmIDB4MWYpIDw8IDEpKTsgLy8gc2Vjb25kXG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gRGF0YVJlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBEYXRhUmVhZGVyID0gcmVxdWlyZSgnLi9EYXRhUmVhZGVyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5mdW5jdGlvbiBBcnJheVJlYWRlcihkYXRhKSB7XG4gICAgRGF0YVJlYWRlci5jYWxsKHRoaXMsIGRhdGEpO1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG5cdFx0ZGF0YVtpXSA9IGRhdGFbaV0gJiAweEZGO1xuXHR9XG59XG51dGlscy5pbmhlcml0cyhBcnJheVJlYWRlciwgRGF0YVJlYWRlcik7XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5ieXRlQXRcbiAqL1xuQXJyYXlSZWFkZXIucHJvdG90eXBlLmJ5dGVBdCA9IGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhW3RoaXMuemVybyArIGldO1xufTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLmxhc3RJbmRleE9mU2lnbmF0dXJlXG4gKi9cbkFycmF5UmVhZGVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZlNpZ25hdHVyZSA9IGZ1bmN0aW9uKHNpZykge1xuICAgIHZhciBzaWcwID0gc2lnLmNoYXJDb2RlQXQoMCksXG4gICAgICAgIHNpZzEgPSBzaWcuY2hhckNvZGVBdCgxKSxcbiAgICAgICAgc2lnMiA9IHNpZy5jaGFyQ29kZUF0KDIpLFxuICAgICAgICBzaWczID0gc2lnLmNoYXJDb2RlQXQoMyk7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gNDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVtpXSA9PT0gc2lnMCAmJiB0aGlzLmRhdGFbaSArIDFdID09PSBzaWcxICYmIHRoaXMuZGF0YVtpICsgMl0gPT09IHNpZzIgJiYgdGhpcy5kYXRhW2kgKyAzXSA9PT0gc2lnMykge1xuICAgICAgICAgICAgcmV0dXJuIGkgLSB0aGlzLnplcm87XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIucmVhZEFuZENoZWNrU2lnbmF0dXJlXG4gKi9cbkFycmF5UmVhZGVyLnByb3RvdHlwZS5yZWFkQW5kQ2hlY2tTaWduYXR1cmUgPSBmdW5jdGlvbiAoc2lnKSB7XG4gICAgdmFyIHNpZzAgPSBzaWcuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgc2lnMSA9IHNpZy5jaGFyQ29kZUF0KDEpLFxuICAgICAgICBzaWcyID0gc2lnLmNoYXJDb2RlQXQoMiksXG4gICAgICAgIHNpZzMgPSBzaWcuY2hhckNvZGVBdCgzKSxcbiAgICAgICAgZGF0YSA9IHRoaXMucmVhZERhdGEoNCk7XG4gICAgcmV0dXJuIHNpZzAgPT09IGRhdGFbMF0gJiYgc2lnMSA9PT0gZGF0YVsxXSAmJiBzaWcyID09PSBkYXRhWzJdICYmIHNpZzMgPT09IGRhdGFbM107XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIucmVhZERhdGFcbiAqL1xuQXJyYXlSZWFkZXIucHJvdG90eXBlLnJlYWREYXRhID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHRoaXMuY2hlY2tPZmZzZXQoc2l6ZSk7XG4gICAgaWYoc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy56ZXJvICsgdGhpcy5pbmRleCwgdGhpcy56ZXJvICsgdGhpcy5pbmRleCArIHNpemUpO1xuICAgIHRoaXMuaW5kZXggKz0gc2l6ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXlSZWFkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoJy4uL3N1cHBvcnQnKTtcbnZhciBBcnJheVJlYWRlciA9IHJlcXVpcmUoJy4vQXJyYXlSZWFkZXInKTtcbnZhciBTdHJpbmdSZWFkZXIgPSByZXF1aXJlKCcuL1N0cmluZ1JlYWRlcicpO1xudmFyIE5vZGVCdWZmZXJSZWFkZXIgPSByZXF1aXJlKCcuL05vZGVCdWZmZXJSZWFkZXInKTtcbnZhciBVaW50OEFycmF5UmVhZGVyID0gcmVxdWlyZSgnLi9VaW50OEFycmF5UmVhZGVyJyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgcmVhZGVyIGFkYXB0ZWQgdG8gdGhlIGRhdGEuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gZGF0YSB0aGUgZGF0YSB0byByZWFkLlxuICogQHJldHVybiB7RGF0YVJlYWRlcn0gdGhlIGRhdGEgcmVhZGVyLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHR5cGUgPSB1dGlscy5nZXRUeXBlT2YoZGF0YSk7XG4gICAgdXRpbHMuY2hlY2tTdXBwb3J0KHR5cGUpO1xuICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiICYmICFzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdSZWFkZXIoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcIm5vZGVidWZmZXJcIikge1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVCdWZmZXJSZWFkZXIoZGF0YSk7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5UmVhZGVyKHV0aWxzLnRyYW5zZm9ybVRvKFwidWludDhhcnJheVwiLCBkYXRhKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXJyYXlSZWFkZXIodXRpbHMudHJhbnNmb3JtVG8oXCJhcnJheVwiLCBkYXRhKSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuZXhwb3J0cy5MT0NBTF9GSUxFX0hFQURFUiA9IFwiUEtcXHgwM1xceDA0XCI7XG5leHBvcnRzLkNFTlRSQUxfRklMRV9IRUFERVIgPSBcIlBLXFx4MDFcXHgwMlwiO1xuZXhwb3J0cy5DRU5UUkFMX0RJUkVDVE9SWV9FTkQgPSBcIlBLXFx4MDVcXHgwNlwiO1xuZXhwb3J0cy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9MT0NBVE9SID0gXCJQS1xceDA2XFx4MDdcIjtcbmV4cG9ydHMuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfRU5EID0gXCJQS1xceDA2XFx4MDZcIjtcbmV4cG9ydHMuREFUQV9ERVNDUklQVE9SID0gXCJQS1xceDA3XFx4MDhcIjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4gIFpfTk9fRkxVU0g6ICAgICAgICAgMCxcbiAgWl9QQVJUSUFMX0ZMVVNIOiAgICAxLFxuICBaX1NZTkNfRkxVU0g6ICAgICAgIDIsXG4gIFpfRlVMTF9GTFVTSDogICAgICAgMyxcbiAgWl9GSU5JU0g6ICAgICAgICAgICA0LFxuICBaX0JMT0NLOiAgICAgICAgICAgIDUsXG4gIFpfVFJFRVM6ICAgICAgICAgICAgNixcblxuICAvKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICAqL1xuICBaX09LOiAgICAgICAgICAgICAgIDAsXG4gIFpfU1RSRUFNX0VORDogICAgICAgMSxcbiAgWl9ORUVEX0RJQ1Q6ICAgICAgICAyLFxuICBaX0VSUk5POiAgICAgICAgICAgLTEsXG4gIFpfU1RSRUFNX0VSUk9SOiAgICAtMixcbiAgWl9EQVRBX0VSUk9SOiAgICAgIC0zLFxuICAvL1pfTUVNX0VSUk9SOiAgICAgLTQsXG4gIFpfQlVGX0VSUk9SOiAgICAgICAtNSxcbiAgLy9aX1ZFUlNJT05fRVJST1I6IC02LFxuXG4gIC8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuICBaX05PX0NPTVBSRVNTSU9OOiAgICAgICAgIDAsXG4gIFpfQkVTVF9TUEVFRDogICAgICAgICAgICAgMSxcbiAgWl9CRVNUX0NPTVBSRVNTSU9OOiAgICAgICA5LFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT046ICAgLTEsXG5cblxuICBaX0ZJTFRFUkVEOiAgICAgICAgICAgICAgIDEsXG4gIFpfSFVGRk1BTl9PTkxZOiAgICAgICAgICAgMixcbiAgWl9STEU6ICAgICAgICAgICAgICAgICAgICAzLFxuICBaX0ZJWEVEOiAgICAgICAgICAgICAgICAgIDQsXG4gIFpfREVGQVVMVF9TVFJBVEVHWTogICAgICAgMCxcblxuICAvKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4gIFpfQklOQVJZOiAgICAgICAgICAgICAgICAgMCxcbiAgWl9URVhUOiAgICAgICAgICAgICAgICAgICAxLFxuICAvL1pfQVNDSUk6ICAgICAgICAgICAgICAgIDEsIC8vID0gWl9URVhUIChkZXByZWNhdGVkKVxuICBaX1VOS05PV046ICAgICAgICAgICAgICAgIDIsXG5cbiAgLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG4gIFpfREVGTEFURUQ6ICAgICAgICAgICAgICAgOFxuICAvL1pfTlVMTDogICAgICAgICAgICAgICAgIG51bGwgLy8gVXNlIC0xIG9yIG51bGwgaW5saW5lLCBkZXBlbmRpbmcgb24gdmFyIHR5cGVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gWlN0cmVhbSgpIHtcbiAgLyogbmV4dCBpbnB1dCBieXRlICovXG4gIHRoaXMuaW5wdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9pbiA9IDA7XG4gIC8qIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUgYXQgaW5wdXQgKi9cbiAgdGhpcy5hdmFpbF9pbiA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBpbnB1dCBieXRlcyByZWFkIHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX2luID0gMDtcbiAgLyogbmV4dCBvdXRwdXQgYnl0ZSBzaG91bGQgYmUgcHV0IHRoZXJlICovXG4gIHRoaXMub3V0cHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfb3V0ID0gMDtcbiAgLyogcmVtYWluaW5nIGZyZWUgc3BhY2UgYXQgb3V0cHV0ICovXG4gIHRoaXMuYXZhaWxfb3V0ID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGJ5dGVzIG91dHB1dCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9vdXQgPSAwO1xuICAvKiBsYXN0IGVycm9yIG1lc3NhZ2UsIE5VTEwgaWYgbm8gZXJyb3IgKi9cbiAgdGhpcy5tc2cgPSAnJy8qWl9OVUxMKi87XG4gIC8qIG5vdCB2aXNpYmxlIGJ5IGFwcGxpY2F0aW9ucyAqL1xuICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgLyogYmVzdCBndWVzcyBhYm91dCB0aGUgZGF0YSB0eXBlOiBiaW5hcnkgb3IgdGV4dCAqL1xuICB0aGlzLmRhdGFfdHlwZSA9IDIvKlpfVU5LTk9XTiovO1xuICAvKiBhZGxlcjMyIHZhbHVlIG9mIHRoZSB1bmNvbXByZXNzZWQgZGF0YSAqL1xuICB0aGlzLmFkbGVyID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBaU3RyZWFtO1xuIiwiLy8gU3RyaW5nIGVuY29kZS9kZWNvZGUgaGVscGVyc1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuLy8gUXVpY2sgY2hlY2sgaWYgd2UgY2FuIHVzZSBmYXN0IGFycmF5IHRvIGJpbiBzdHJpbmcgY29udmVyc2lvblxuLy9cbi8vIC0gYXBwbHkoQXJyYXkpIGNhbiBmYWlsIG9uIEFuZHJvaWQgMi4yXG4vLyAtIGFwcGx5KFVpbnQ4QXJyYXkpIGNhbiBmYWlsIG9uIGlPUyA1LjEgU2FmYXJpXG4vL1xudmFyIFNUUl9BUFBMWV9PSyA9IHRydWU7XG52YXIgU1RSX0FQUExZX1VJQV9PSyA9IHRydWU7XG5cbnRyeSB7IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgWyAwIF0pOyB9IGNhdGNoIChfXykgeyBTVFJfQVBQTFlfT0sgPSBmYWxzZTsgfVxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9VSUFfT0sgPSBmYWxzZTsgfVxuXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxudmFyIF91dGY4bGVuID0gbmV3IHV0aWxzLkJ1ZjgoMjU2KTtcbmZvciAodmFyIHEgPSAwOyBxIDwgMjU2OyBxKyspIHtcbiAgX3V0ZjhsZW5bcV0gPSAocSA+PSAyNTIgPyA2IDogcSA+PSAyNDggPyA1IDogcSA+PSAyNDAgPyA0IDogcSA+PSAyMjQgPyAzIDogcSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdID0gX3V0ZjhsZW5bMjU0XSA9IDE7IC8vIEludmFsaWQgc2VxdWVuY2Ugc3RhcnRcblxuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYsIGMsIGMyLCBtX3BvcywgaSwgc3RyX2xlbiA9IHN0ci5sZW5ndGgsIGJ1Zl9sZW4gPSAwO1xuXG4gIC8vIGNvdW50IGJpbmFyeSBzaXplXG4gIGZvciAobV9wb3MgPSAwOyBtX3BvcyA8IHN0cl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGJ1Zl9sZW4gKz0gYyA8IDB4ODAgPyAxIDogYyA8IDB4ODAwID8gMiA6IGMgPCAweDEwMDAwID8gMyA6IDQ7XG4gIH1cblxuICAvLyBhbGxvY2F0ZSBidWZmZXJcbiAgYnVmID0gbmV3IHV0aWxzLkJ1ZjgoYnVmX2xlbik7XG5cbiAgLy8gY29udmVydFxuICBmb3IgKGkgPSAwLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIC8qIG9uZSBieXRlICovXG4gICAgICBidWZbaSsrXSA9IGM7XG4gICAgfSBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIC8qIHR3byBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEMwIHwgKGMgPj4+IDYpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAvKiB0aHJlZSBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEUwIHwgKGMgPj4+IDEyKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBmb3VyIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4ZjAgfCAoYyA+Pj4gMTgpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDEyICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmO1xufTtcblxuLy8gSGVscGVyICh1c2VkIGluIDIgcGxhY2VzKVxuZnVuY3Rpb24gYnVmMmJpbnN0cmluZyhidWYsIGxlbikge1xuICAvLyB1c2UgZmFsbGJhY2sgZm9yIGJpZyBhcnJheXMgdG8gYXZvaWQgc3RhY2sgb3ZlcmZsb3dcbiAgaWYgKGxlbiA8IDY1NTM3KSB7XG4gICAgaWYgKChidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX1VJQV9PSykgfHwgKCFidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX09LKSkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdXRpbHMuc2hyaW5rQnVmKGJ1ZiwgbGVuKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8vIENvbnZlcnQgYnl0ZSBhcnJheSB0byBiaW5hcnkgc3RyaW5nXG5leHBvcnRzLmJ1ZjJiaW5zdHJpbmcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHJldHVybiBidWYyYmluc3RyaW5nKGJ1ZiwgYnVmLmxlbmd0aCk7XG59O1xuXG5cbi8vIENvbnZlcnQgYmluYXJ5IHN0cmluZyAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLmJpbnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYgPSBuZXcgdXRpbHMuQnVmOChzdHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1ZltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBidWY7XG59O1xuXG5cbi8vIGNvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG5leHBvcnRzLmJ1ZjJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmLCBtYXgpIHtcbiAgdmFyIGksIG91dCwgYywgY19sZW47XG4gIHZhciBsZW4gPSBtYXggfHwgYnVmLmxlbmd0aDtcblxuICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gIC8vIE5COiBieSB1bmtub3duIHJlYXNvbnMsIEFycmF5IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIGZvclxuICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICB2YXIgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuICogMik7XG5cbiAgZm9yIChvdXQgPSAwLCBpID0gMDsgaSA8IGxlbjspIHtcbiAgICBjID0gYnVmW2krK107XG4gICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaVxuICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAvLyBza2lwIDUgJiA2IGJ5dGUgY29kZXNcbiAgICBpZiAoY19sZW4gPiA0KSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgaSArPSBjX2xlbiAtIDE7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBhcHBseSBtYXNrIG9uIGZpcnN0IGJ5dGVcbiAgICBjICY9IGNfbGVuID09PSAyID8gMHgxZiA6IGNfbGVuID09PSAzID8gMHgwZiA6IDB4MDc7XG4gICAgLy8gam9pbiB0aGUgcmVzdFxuICAgIHdoaWxlIChjX2xlbiA+IDEgJiYgaSA8IGxlbikge1xuICAgICAgYyA9IChjIDw8IDYpIHwgKGJ1ZltpKytdICYgMHgzZik7XG4gICAgICBjX2xlbi0tO1xuICAgIH1cblxuICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICBpZiAoY19sZW4gPiAxKSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgY29udGludWU7IH1cblxuICAgIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYyYmluc3RyaW5nKHV0ZjE2YnVmLCBvdXQpO1xufTtcblxuXG4vLyBDYWxjdWxhdGUgbWF4IHBvc3NpYmxlIHBvc2l0aW9uIGluIHV0ZjggYnVmZmVyLFxuLy8gdGhhdCB3aWxsIG5vdCBicmVhayBzZXF1ZW5jZS4gSWYgdGhhdCdzIG5vdCBwb3NzaWJsZVxuLy8gLSAodmVyeSBzbWFsbCBsaW1pdHMpIHJldHVybiBtYXggc2l6ZSBhcyBpcy5cbi8vXG4vLyBidWZbXSAtIHV0ZjggYnl0ZXMgYXJyYXlcbi8vIG1heCAgIC0gbGVuZ3RoIGxpbWl0IChtYW5kYXRvcnkpO1xuZXhwb3J0cy51dGY4Ym9yZGVyID0gZnVuY3Rpb24gKGJ1ZiwgbWF4KSB7XG4gIHZhciBwb3M7XG5cbiAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmRcbiAgcG9zID0gbWF4IC0gMTtcbiAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgLy8gVmVyeSBzbWFsbCBhbmQgYnJva2VuIHNlcXVlbmNlLFxuICAvLyByZXR1cm4gbWF4LCBiZWNhdXNlIHdlIHNob3VsZCByZXR1cm4gc29tZXRoaW5nIGFueXdheS5cbiAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIC8vIElmIHdlIGNhbWUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gdGhhdCBtZWFucyBidWZmZXIgaXMgdG9vIHNtYWxsLFxuICAvLyByZXR1cm4gbWF4IHRvby5cbiAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgcmV0dXJuIChwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXgpID8gcG9zIDogbWF4O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogd2UgY2FuJ3QgZ2V0IHNpZ25pZmljYW50IHNwZWVkIGJvb3N0IGhlcmUuXG4vLyBTbyB3cml0ZSBjb2RlIHRvIG1pbmltaXplIHNpemUgLSBubyBwcmVnZW5lcmF0ZWQgdGFibGVzXG4vLyBhbmQgYXJyYXkgdG9vbHMgZGVwZW5kZW5jaWVzLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFVzZSBvcmRpbmFyeSBhcnJheSwgc2luY2UgdW50eXBlZCBtYWtlcyBubyBib29zdCBoZXJlXG5mdW5jdGlvbiBtYWtlVGFibGUoKSB7XG4gIHZhciBjLCB0YWJsZSA9IFtdO1xuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgMjU2OyBuKyspIHtcbiAgICBjID0gbjtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IDg7IGsrKykge1xuICAgICAgYyA9ICgoYyAmIDEpID8gKDB4RURCODgzMjAgXiAoYyA+Pj4gMSkpIDogKGMgPj4+IDEpKTtcbiAgICB9XG4gICAgdGFibGVbbl0gPSBjO1xuICB9XG5cbiAgcmV0dXJuIHRhYmxlO1xufVxuXG4vLyBDcmVhdGUgdGFibGUgb24gbG9hZC4gSnVzdCAyNTUgc2lnbmVkIGxvbmdzLiBOb3QgYSBwcm9ibGVtLlxudmFyIGNyY1RhYmxlID0gbWFrZVRhYmxlKCk7XG5cblxuZnVuY3Rpb24gY3JjMzIoY3JjLCBidWYsIGxlbiwgcG9zKSB7XG4gIHZhciB0ID0gY3JjVGFibGUsXG4gICAgICBlbmQgPSBwb3MgKyBsZW47XG5cbiAgY3JjIF49IC0xO1xuXG4gIGZvciAodmFyIGkgPSBwb3M7IGkgPCBlbmQ7IGkrKykge1xuICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdFsoY3JjIF4gYnVmW2ldKSAmIDB4RkZdO1xuICB9XG5cbiAgcmV0dXJuIChjcmMgXiAoLTEpKTsgLy8gPj4+IDA7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBjcmMzMjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogYWRsZXIzMiB0YWtlcyAxMiUgZm9yIGxldmVsIDAgYW5kIDIlIGZvciBsZXZlbCA2LlxuLy8gSXQgaXNuJ3Qgd29ydGggaXQgdG8gbWFrZSBhZGRpdGlvbmFsIG9wdGltaXphdGlvbnMgYXMgaW4gb3JpZ2luYWwuXG4vLyBTbWFsbCBzaXplIGlzIHByZWZlcmFibGUuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gYWRsZXIzMihhZGxlciwgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgczEgPSAoYWRsZXIgJiAweGZmZmYpIHwwLFxuICAgICAgczIgPSAoKGFkbGVyID4+PiAxNikgJiAweGZmZmYpIHwwLFxuICAgICAgbiA9IDA7XG5cbiAgd2hpbGUgKGxlbiAhPT0gMCkge1xuICAgIC8vIFNldCBsaW1pdCB+IHR3aWNlIGxlc3MgdGhhbiA1NTUyLCB0byBrZWVwXG4gICAgLy8gczIgaW4gMzEtYml0cywgYmVjYXVzZSB3ZSBmb3JjZSBzaWduZWQgaW50cy5cbiAgICAvLyBpbiBvdGhlciBjYXNlICU9IHdpbGwgZmFpbC5cbiAgICBuID0gbGVuID4gMjAwMCA/IDIwMDAgOiBsZW47XG4gICAgbGVuIC09IG47XG5cbiAgICBkbyB7XG4gICAgICBzMSA9IChzMSArIGJ1Zltwb3MrK10pIHwwO1xuICAgICAgczIgPSAoczIgKyBzMSkgfDA7XG4gICAgfSB3aGlsZSAoLS1uKTtcblxuICAgIHMxICU9IDY1NTIxO1xuICAgIHMyICU9IDY1NTIxO1xuICB9XG5cbiAgcmV0dXJuIChzMSB8IChzMiA8PCAxNikpIHwwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKFwiLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiKTtcblxuZXhwb3J0cy5TVE9SRSA9IHtcbiAgICBtYWdpYzogXCJcXHgwMFxceDAwXCIsXG4gICAgY29tcHJlc3NXb3JrZXIgOiBmdW5jdGlvbiAoY29tcHJlc3Npb25PcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2VuZXJpY1dvcmtlcihcIlNUT1JFIGNvbXByZXNzaW9uXCIpO1xuICAgIH0sXG4gICAgdW5jb21wcmVzc1dvcmtlciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljV29ya2VyKFwiU1RPUkUgZGVjb21wcmVzc2lvblwiKTtcbiAgICB9XG59O1xuZXhwb3J0cy5ERUZMQVRFID0gcmVxdWlyZSgnLi9mbGF0ZScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vR2VuZXJpY1dvcmtlcicpO1xudmFyIGNyYzMyID0gcmVxdWlyZSgnLi4vY3JjMzInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQSB3b3JrZXIgd2hpY2ggY2FsY3VsYXRlIHRoZSBjcmMzMiBvZiB0aGUgZGF0YSBmbG93aW5nIHRocm91Z2guXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ3JjMzJQcm9iZSgpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJDcmMzMlByb2JlXCIpO1xuICAgIHRoaXMud2l0aFN0cmVhbUluZm8oXCJjcmMzMlwiLCAwKTtcbn1cbnV0aWxzLmluaGVyaXRzKENyYzMyUHJvYmUsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuQ3JjMzJQcm9iZS5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5zdHJlYW1JbmZvLmNyYzMyID0gY3JjMzIoY2h1bmsuZGF0YSwgdGhpcy5zdHJlYW1JbmZvLmNyYzMyIHx8IDApO1xuICAgIHRoaXMucHVzaChjaHVuayk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBDcmMzMlByb2JlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL0dlbmVyaWNXb3JrZXInKTtcblxuLyoqXG4gKiBBIHdvcmtlciB3aGljaCBjYWxjdWxhdGUgdGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgZGF0YSBmbG93aW5nIHRocm91Z2guXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZSB0aGUgbmFtZSB1c2VkIHRvIGV4cG9zZSB0aGUgbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIERhdGFMZW5ndGhQcm9iZShwcm9wTmFtZSkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcIkRhdGFMZW5ndGhQcm9iZSBmb3IgXCIgKyBwcm9wTmFtZSk7XG4gICAgdGhpcy5wcm9wTmFtZSA9IHByb3BOYW1lO1xuICAgIHRoaXMud2l0aFN0cmVhbUluZm8ocHJvcE5hbWUsIDApO1xufVxudXRpbHMuaW5oZXJpdHMoRGF0YUxlbmd0aFByb2JlLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHJvY2Vzc0NodW5rXG4gKi9cbkRhdGFMZW5ndGhQcm9iZS5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgaWYoY2h1bmspIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuc3RyZWFtSW5mb1t0aGlzLnByb3BOYW1lXSB8fCAwO1xuICAgICAgICB0aGlzLnN0cmVhbUluZm9bdGhpcy5wcm9wTmFtZV0gPSBsZW5ndGggKyBjaHVuay5kYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rLmNhbGwodGhpcywgY2h1bmspO1xufTtcbm1vZHVsZS5leHBvcnRzID0gRGF0YUxlbmd0aFByb2JlO1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vR2VuZXJpY1dvcmtlcicpO1xuXG4vLyB0aGUgc2l6ZSBvZiB0aGUgZ2VuZXJhdGVkIGNodW5rc1xuLy8gVE9ETyBleHBvc2UgdGhpcyBhcyBhIHB1YmxpYyB2YXJpYWJsZVxudmFyIERFRkFVTFRfQkxPQ0tfU0laRSA9IDE2ICogMTAyNDtcblxuLyoqXG4gKiBBIHdvcmtlciB0aGF0IHJlYWRzIGEgY29udGVudCBhbmQgZW1pdHMgY2h1bmtzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1Byb21pc2V9IGRhdGFQIHRoZSBwcm9taXNlIG9mIHRoZSBkYXRhIHRvIHNwbGl0XG4gKi9cbmZ1bmN0aW9uIERhdGFXb3JrZXIoZGF0YVApIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJEYXRhV29ya2VyXCIpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmRhdGFJc1JlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgdGhpcy5tYXggPSAwO1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgdGhpcy50eXBlID0gXCJcIjtcblxuICAgIHRoaXMuX3RpY2tTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAgIGRhdGFQLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgc2VsZi5kYXRhSXNSZWFkeSA9IHRydWU7XG4gICAgICAgIHNlbGYuZGF0YSA9IGRhdGE7XG4gICAgICAgIHNlbGYubWF4ID0gZGF0YSAmJiBkYXRhLmxlbmd0aCB8fCAwO1xuICAgICAgICBzZWxmLnR5cGUgPSB1dGlscy5nZXRUeXBlT2YoZGF0YSk7XG4gICAgICAgIGlmKCFzZWxmLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICBzZWxmLl90aWNrQW5kUmVwZWF0KCk7XG4gICAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBzZWxmLmVycm9yKGUpO1xuICAgIH0pO1xufVxuXG51dGlscy5pbmhlcml0cyhEYXRhV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuY2xlYW5VcFxuICovXG5EYXRhV29ya2VyLnByb3RvdHlwZS5jbGVhblVwID0gZnVuY3Rpb24gKCkge1xuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLmNsZWFuVXAuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucmVzdW1lXG4gKi9cbkRhdGFXb3JrZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucmVzdW1lLmNhbGwodGhpcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fdGlja1NjaGVkdWxlZCAmJiB0aGlzLmRhdGFJc1JlYWR5KSB7XG4gICAgICAgIHRoaXMuX3RpY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICB1dGlscy5kZWxheSh0aGlzLl90aWNrQW5kUmVwZWF0LCBbXSwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBUcmlnZ2VyIGEgdGljayBhIHNjaGVkdWxlIGFuIG90aGVyIGNhbGwgdG8gdGhpcyBmdW5jdGlvbi5cbiAqL1xuRGF0YVdvcmtlci5wcm90b3R5cGUuX3RpY2tBbmRSZXBlYXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl90aWNrU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgaWYodGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl90aWNrKCk7XG4gICAgaWYoIXRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICB1dGlscy5kZWxheSh0aGlzLl90aWNrQW5kUmVwZWF0LCBbXSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3RpY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVhZCBhbmQgcHVzaCBhIGNodW5rLlxuICovXG5EYXRhV29ya2VyLnByb3RvdHlwZS5fdGljayA9IGZ1bmN0aW9uKCkge1xuXG4gICAgaWYodGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzaXplID0gREVGQVVMVF9CTE9DS19TSVpFO1xuICAgIHZhciBkYXRhID0gbnVsbCwgbmV4dEluZGV4ID0gTWF0aC5taW4odGhpcy5tYXgsIHRoaXMuaW5kZXggKyBzaXplKTtcbiAgICBpZiAodGhpcy5pbmRleCA+PSB0aGlzLm1heCkge1xuICAgICAgICAvLyBFT0ZcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGEuc3Vic3RyaW5nKHRoaXMuaW5kZXgsIG5leHRJbmRleCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ1aW50OGFycmF5XCI6XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YS5zdWJhcnJheSh0aGlzLmluZGV4LCBuZXh0SW5kZXgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgIGNhc2UgXCJub2RlYnVmZmVyXCI6XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLmluZGV4LCBuZXh0SW5kZXgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogZGF0YSxcbiAgICAgICAgICAgIG1ldGEgOiB7XG4gICAgICAgICAgICAgICAgcGVyY2VudCA6IHRoaXMubWF4ID8gdGhpcy5pbmRleCAvIHRoaXMubWF4ICogMTAwIDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFXb3JrZXI7XG4iLCIndXNlIHN0cmljdCc7XG5leHBvcnRzLmJhc2U2NCA9IGZhbHNlO1xuZXhwb3J0cy5iaW5hcnkgPSBmYWxzZTtcbmV4cG9ydHMuZGlyID0gZmFsc2U7XG5leHBvcnRzLmNyZWF0ZUZvbGRlcnMgPSB0cnVlO1xuZXhwb3J0cy5kYXRlID0gbnVsbDtcbmV4cG9ydHMuY29tcHJlc3Npb24gPSBudWxsO1xuZXhwb3J0cy5jb21wcmVzc2lvbk9wdGlvbnMgPSBudWxsO1xuZXhwb3J0cy5jb21tZW50ID0gbnVsbDtcbmV4cG9ydHMudW5peFBlcm1pc3Npb25zID0gbnVsbDtcbmV4cG9ydHMuZG9zUGVybWlzc2lvbnMgPSBudWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIENvbnZlcnRXb3JrZXIgPSByZXF1aXJlKCcuL0NvbnZlcnRXb3JrZXInKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi9HZW5lcmljV29ya2VyJyk7XG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnLi4vYmFzZTY0Jyk7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoXCIuLi9zdXBwb3J0XCIpO1xudmFyIGV4dGVybmFsID0gcmVxdWlyZShcIi4uL2V4dGVybmFsXCIpO1xuXG52YXIgTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlciA9IG51bGw7XG5pZiAoc3VwcG9ydC5ub2Rlc3RyZWFtKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlciA9IHJlcXVpcmUoJy4uL25vZGVqcy9Ob2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyJyk7XG4gICAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIEFwcGx5IHRoZSBmaW5hbCB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgZGF0YS4gSWYgdGhlIHVzZXIgd2FudHMgYSBCbG9iIGZvclxuICogZXhhbXBsZSwgaXQncyBlYXNpZXIgdG8gd29yayB3aXRoIGFuIFU4aW50QXJyYXkgYW5kIGZpbmFsbHkgZG8gdGhlXG4gKiBBcnJheUJ1ZmZlci9CbG9iIGNvbnZlcnNpb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgbmFtZSBvZiB0aGUgZmluYWwgdHlwZVxuICogQHBhcmFtIHtTdHJpbmd8VWludDhBcnJheXxCdWZmZXJ9IGNvbnRlbnQgdGhlIGNvbnRlbnQgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZVR5cGUgdGhlIG1pbWUgdHlwZSBvZiB0aGUgY29udGVudCwgaWYgYXBwbGljYWJsZS5cbiAqIEByZXR1cm4ge1N0cmluZ3xVaW50OEFycmF5fEFycmF5QnVmZmVyfEJ1ZmZlcnxCbG9ifSB0aGUgY29udGVudCBpbiB0aGUgcmlnaHQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1aaXBPdXRwdXQodHlwZSwgY29udGVudCwgbWltZVR5cGUpIHtcbiAgICBzd2l0Y2godHlwZSkge1xuICAgICAgICBjYXNlIFwiYmxvYlwiIDpcbiAgICAgICAgICAgIHJldHVybiB1dGlscy5uZXdCbG9iKHV0aWxzLnRyYW5zZm9ybVRvKFwiYXJyYXlidWZmZXJcIiwgY29udGVudCksIG1pbWVUeXBlKTtcbiAgICAgICAgY2FzZSBcImJhc2U2NFwiIDpcbiAgICAgICAgICAgIHJldHVybiBiYXNlNjQuZW5jb2RlKGNvbnRlbnQpO1xuICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgIHJldHVybiB1dGlscy50cmFuc2Zvcm1Ubyh0eXBlLCBjb250ZW50KTtcbiAgICB9XG59XG5cbi8qKlxuICogQ29uY2F0ZW5hdGUgYW4gYXJyYXkgb2YgZGF0YSBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIHRoZSBkYXRhIGluIHRoZSBnaXZlbiBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGFBcnJheSB0aGUgYXJyYXkgY29udGFpbmluZyB0aGUgZGF0YSBjaHVua3MgdG8gY29uY2F0ZW5hdGVcbiAqIEByZXR1cm4ge1N0cmluZ3xVaW50OEFycmF5fEJ1ZmZlcn0gdGhlIGNvbmNhdGVuYXRlZCBkYXRhXG4gKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBhc2tlZCB0eXBlIGlzIHVuc3VwcG9ydGVkXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdCAodHlwZSwgZGF0YUFycmF5KSB7XG4gICAgdmFyIGksIGluZGV4ID0gMCwgcmVzID0gbnVsbCwgdG90YWxMZW5ndGggPSAwO1xuICAgIGZvcihpID0gMDsgaSA8IGRhdGFBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b3RhbExlbmd0aCArPSBkYXRhQXJyYXlbaV0ubGVuZ3RoO1xuICAgIH1cbiAgICBzd2l0Y2godHlwZSkge1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gZGF0YUFycmF5LmpvaW4oXCJcIik7XG4gICAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgZGF0YUFycmF5KTtcbiAgICAgICAgY2FzZSBcInVpbnQ4YXJyYXlcIjpcbiAgICAgICAgICAgIHJlcyA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IGRhdGFBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlcy5zZXQoZGF0YUFycmF5W2ldLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gZGF0YUFycmF5W2ldLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIGNhc2UgXCJub2RlYnVmZmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChkYXRhQXJyYXkpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29uY2F0IDogdW5zdXBwb3J0ZWQgdHlwZSAnXCIgICsgdHlwZSArIFwiJ1wiKTtcbiAgICB9XG59XG5cbi8qKlxuICogTGlzdGVuIGEgU3RyZWFtSGVscGVyLCBhY2N1bXVsYXRlIGl0cyBjb250ZW50IGFuZCBjb25jYXRlbmF0ZSBpdCBpbnRvIGFcbiAqIGNvbXBsZXRlIGJsb2NrLlxuICogQHBhcmFtIHtTdHJlYW1IZWxwZXJ9IGhlbHBlciB0aGUgaGVscGVyIHRvIHVzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZUNhbGxiYWNrIGEgY2FsbGJhY2sgY2FsbGVkIG9uIGVhY2ggdXBkYXRlLiBDYWxsZWRcbiAqIHdpdGggb25lIGFyZyA6XG4gKiAtIHRoZSBtZXRhZGF0YSBsaW5rZWQgdG8gdGhlIHVwZGF0ZSByZWNlaXZlZC5cbiAqIEByZXR1cm4gUHJvbWlzZSB0aGUgcHJvbWlzZSBmb3IgdGhlIGFjY3VtdWxhdGlvbi5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZShoZWxwZXIsIHVwZGF0ZUNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG5ldyBleHRlcm5hbC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgICB2YXIgZGF0YUFycmF5ID0gW107XG4gICAgICAgIHZhciBjaHVua1R5cGUgPSBoZWxwZXIuX2ludGVybmFsVHlwZSxcbiAgICAgICAgICAgIHJlc3VsdFR5cGUgPSBoZWxwZXIuX291dHB1dFR5cGUsXG4gICAgICAgICAgICBtaW1lVHlwZSA9IGhlbHBlci5fbWltZVR5cGU7XG4gICAgICAgIGhlbHBlclxuICAgICAgICAub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSwgbWV0YSkge1xuICAgICAgICAgICAgZGF0YUFycmF5LnB1c2goZGF0YSk7XG4gICAgICAgICAgICBpZih1cGRhdGVDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUNhbGxiYWNrKG1ldGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBkYXRhQXJyYXkgPSBbXTtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ2VuZCcsIGZ1bmN0aW9uICgpe1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJhbnNmb3JtWmlwT3V0cHV0KHJlc3VsdFR5cGUsIGNvbmNhdChjaHVua1R5cGUsIGRhdGFBcnJheSksIG1pbWVUeXBlKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YUFycmF5ID0gW107XG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN1bWUoKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBBbiBoZWxwZXIgdG8gZWFzaWx5IHVzZSB3b3JrZXJzIG91dHNpZGUgb2YgSlNaaXAuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7V29ya2VyfSB3b3JrZXIgdGhlIHdvcmtlciB0byB3cmFwXG4gKiBAcGFyYW0ge1N0cmluZ30gb3V0cHV0VHlwZSB0aGUgdHlwZSBvZiBkYXRhIGV4cGVjdGVkIGJ5IHRoZSB1c2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lVHlwZSB0aGUgbWltZSB0eXBlIG9mIHRoZSBjb250ZW50LCBpZiBhcHBsaWNhYmxlLlxuICovXG5mdW5jdGlvbiBTdHJlYW1IZWxwZXIod29ya2VyLCBvdXRwdXRUeXBlLCBtaW1lVHlwZSkge1xuICAgIHZhciBpbnRlcm5hbFR5cGUgPSBvdXRwdXRUeXBlO1xuICAgIHN3aXRjaChvdXRwdXRUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJibG9iXCI6XG4gICAgICAgIGNhc2UgXCJhcnJheWJ1ZmZlclwiOlxuICAgICAgICAgICAgaW50ZXJuYWxUeXBlID0gXCJ1aW50OGFycmF5XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYmFzZTY0XCI6XG4gICAgICAgICAgICBpbnRlcm5hbFR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICAvLyB0aGUgdHlwZSB1c2VkIGludGVybmFsbHlcbiAgICAgICAgdGhpcy5faW50ZXJuYWxUeXBlID0gaW50ZXJuYWxUeXBlO1xuICAgICAgICAvLyB0aGUgdHlwZSB1c2VkIHRvIG91dHB1dCByZXN1bHRzXG4gICAgICAgIHRoaXMuX291dHB1dFR5cGUgPSBvdXRwdXRUeXBlO1xuICAgICAgICAvLyB0aGUgbWltZSB0eXBlXG4gICAgICAgIHRoaXMuX21pbWVUeXBlID0gbWltZVR5cGU7XG4gICAgICAgIHV0aWxzLmNoZWNrU3VwcG9ydChpbnRlcm5hbFR5cGUpO1xuICAgICAgICB0aGlzLl93b3JrZXIgPSB3b3JrZXIucGlwZShuZXcgQ29udmVydFdvcmtlcihpbnRlcm5hbFR5cGUpKTtcbiAgICAgICAgLy8gdGhlIGxhc3Qgd29ya2VycyBjYW4gYmUgcmV3aXJlZCB3aXRob3V0IGlzc3VlcyBidXQgd2UgbmVlZCB0b1xuICAgICAgICAvLyBwcmV2ZW50IGFueSB1cGRhdGVzIG9uIHByZXZpb3VzIHdvcmtlcnMuXG4gICAgICAgIHdvcmtlci5sb2NrKCk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHRoaXMuX3dvcmtlciA9IG5ldyBHZW5lcmljV29ya2VyKFwiZXJyb3JcIik7XG4gICAgICAgIHRoaXMuX3dvcmtlci5lcnJvcihlKTtcbiAgICB9XG59XG5cblN0cmVhbUhlbHBlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogTGlzdGVuIGEgU3RyZWFtSGVscGVyLCBhY2N1bXVsYXRlIGl0cyBjb250ZW50IGFuZCBjb25jYXRlbmF0ZSBpdCBpbnRvIGFcbiAgICAgKiBjb21wbGV0ZSBibG9jay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVDYiB0aGUgdXBkYXRlIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm4gUHJvbWlzZSB0aGUgcHJvbWlzZSBmb3IgdGhlIGFjY3VtdWxhdGlvbi5cbiAgICAgKi9cbiAgICBhY2N1bXVsYXRlIDogZnVuY3Rpb24gKHVwZGF0ZUNiKSB7XG4gICAgICAgIHJldHVybiBhY2N1bXVsYXRlKHRoaXMsIHVwZGF0ZUNiKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFkZCBhIGxpc3RlbmVyIG9uIGFuIGV2ZW50IHRyaWdnZXJlZCBvbiBhIHN0cmVhbS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZ0IHRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIHRoZSBsaXN0ZW5lclxuICAgICAqIEByZXR1cm4ge1N0cmVhbUhlbHBlcn0gdGhlIGN1cnJlbnQgaGVscGVyLlxuICAgICAqL1xuICAgIG9uIDogZnVuY3Rpb24gKGV2dCwgZm4pIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGlmKGV2dCA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtlci5vbihldnQsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoc2VsZiwgY2h1bmsuZGF0YSwgY2h1bmsubWV0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtlci5vbihldnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB1dGlscy5kZWxheShmbiwgYXJndW1lbnRzLCBzZWxmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVzdW1lIHRoZSBmbG93IG9mIGNodW5rcy5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW1IZWxwZXJ9IHRoZSBjdXJyZW50IGhlbHBlci5cbiAgICAgKi9cbiAgICByZXN1bWUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxzLmRlbGF5KHRoaXMuX3dvcmtlci5yZXN1bWUsIFtdLCB0aGlzLl93b3JrZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFBhdXNlIHRoZSBmbG93IG9mIGNodW5rcy5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW1IZWxwZXJ9IHRoZSBjdXJyZW50IGhlbHBlci5cbiAgICAgKi9cbiAgICBwYXVzZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fd29ya2VyLnBhdXNlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbm9kZWpzIHN0cmVhbSBmb3IgdGhpcyBoZWxwZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlQ2IgdGhlIHVwZGF0ZSBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJuIHtOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyfSB0aGUgbm9kZWpzIHN0cmVhbS5cbiAgICAgKi9cbiAgICB0b05vZGVqc1N0cmVhbSA6IGZ1bmN0aW9uICh1cGRhdGVDYikge1xuICAgICAgICB1dGlscy5jaGVja1N1cHBvcnQoXCJub2Rlc3RyZWFtXCIpO1xuICAgICAgICBpZiAodGhpcy5fb3V0cHV0VHlwZSAhPT0gXCJub2RlYnVmZmVyXCIpIHtcbiAgICAgICAgICAgIC8vIGFuIG9iamVjdCBzdHJlYW0gY29udGFpbmluZyBibG9iL2FycmF5YnVmZmVyL3VpbnQ4YXJyYXkvc3RyaW5nXG4gICAgICAgICAgICAvLyBpcyBzdHJhbmdlIGFuZCBJIGRvbid0IGtub3cgaWYgaXQgd291bGQgYmUgdXNlZnVsLlxuICAgICAgICAgICAgLy8gSSB5b3UgZmluZCB0aGlzIGNvbW1lbnQgYW5kIGhhdmUgYSBnb29kIHVzZWNhc2UsIHBsZWFzZSBvcGVuIGFcbiAgICAgICAgICAgIC8vIGJ1ZyByZXBvcnQgIVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuX291dHB1dFR5cGUgKyBcIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgbWV0aG9kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyKHRoaXMsIHtcbiAgICAgICAgICAgIG9iamVjdE1vZGUgOiB0aGlzLl9vdXRwdXRUeXBlICE9PSBcIm5vZGVidWZmZXJcIlxuICAgICAgICB9LCB1cGRhdGVDYik7XG4gICAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbUhlbHBlcjtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudFxuICAvLyBpbiBvbGQgSUUgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCdcbiAgLCBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTsiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59OyIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzIuMy4wJ307XG5pZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCIndXNlIHN0cmljdCc7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xuLy8gcHJpdmF0ZSBwcm9wZXJ0eVxudmFyIF9rZXlTdHIgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG5cblxuLy8gcHVibGljIG1ldGhvZCBmb3IgZW5jb2RpbmdcbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgdmFyIGNocjEsIGNocjIsIGNocjMsIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gICAgdmFyIGkgPSAwLCBsZW4gPSBpbnB1dC5sZW5ndGgsIHJlbWFpbmluZ0J5dGVzID0gbGVuO1xuXG4gICAgdmFyIGlzQXJyYXkgPSB1dGlscy5nZXRUeXBlT2YoaW5wdXQpICE9PSBcInN0cmluZ1wiO1xuICAgIHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHJlbWFpbmluZ0J5dGVzID0gbGVuIC0gaTtcblxuICAgICAgICBpZiAoIWlzQXJyYXkpIHtcbiAgICAgICAgICAgIGNocjEgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgICAgICBjaHIyID0gaSA8IGxlbiA/IGlucHV0LmNoYXJDb2RlQXQoaSsrKSA6IDA7XG4gICAgICAgICAgICBjaHIzID0gaSA8IGxlbiA/IGlucHV0LmNoYXJDb2RlQXQoaSsrKSA6IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIxID0gaW5wdXRbaSsrXTtcbiAgICAgICAgICAgIGNocjIgPSBpIDwgbGVuID8gaW5wdXRbaSsrXSA6IDA7XG4gICAgICAgICAgICBjaHIzID0gaSA8IGxlbiA/IGlucHV0W2krK10gOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5jMSA9IGNocjEgPj4gMjtcbiAgICAgICAgZW5jMiA9ICgoY2hyMSAmIDMpIDw8IDQpIHwgKGNocjIgPj4gNCk7XG4gICAgICAgIGVuYzMgPSByZW1haW5pbmdCeXRlcyA+IDEgPyAoKChjaHIyICYgMTUpIDw8IDIpIHwgKGNocjMgPj4gNikpIDogNjQ7XG4gICAgICAgIGVuYzQgPSByZW1haW5pbmdCeXRlcyA+IDIgPyAoY2hyMyAmIDYzKSA6IDY0O1xuXG4gICAgICAgIG91dHB1dC5wdXNoKF9rZXlTdHIuY2hhckF0KGVuYzEpICsgX2tleVN0ci5jaGFyQXQoZW5jMikgKyBfa2V5U3RyLmNoYXJBdChlbmMzKSArIF9rZXlTdHIuY2hhckF0KGVuYzQpKTtcblxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQuam9pbihcIlwiKTtcbn07XG5cbi8vIHB1YmxpYyBtZXRob2QgZm9yIGRlY29kaW5nXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgdmFyIGNocjEsIGNocjIsIGNocjM7XG4gICAgdmFyIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gICAgdmFyIGkgPSAwLCByZXN1bHRJbmRleCA9IDA7XG5cbiAgICB2YXIgZGF0YVVybFByZWZpeCA9IFwiZGF0YTpcIjtcblxuICAgIGlmIChpbnB1dC5zdWJzdHIoMCwgZGF0YVVybFByZWZpeC5sZW5ndGgpID09PSBkYXRhVXJsUHJlZml4KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBjb21tb24gZXJyb3I6IHBlb3BsZSBnaXZlIGEgZGF0YSB1cmxcbiAgICAgICAgLy8gKGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUi4uLikgd2l0aCBhIHtiYXNlNjQ6IHRydWV9IGFuZFxuICAgICAgICAvLyB3b25kZXJzIHdoeSB0aGluZ3MgZG9uJ3Qgd29yay5cbiAgICAgICAgLy8gV2UgY2FuIGRldGVjdCB0aGF0IHRoZSBzdHJpbmcgaW5wdXQgbG9va3MgbGlrZSBhIGRhdGEgdXJsIGJ1dCB3ZVxuICAgICAgICAvLyAqY2FuJ3QqIGJlIHN1cmUgaXQgaXMgb25lOiByZW1vdmluZyBldmVyeXRoaW5nIHVwIHRvIHRoZSBjb21tYSB3b3VsZFxuICAgICAgICAvLyBiZSB0b28gZGFuZ2Vyb3VzLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2U2NCBpbnB1dCwgaXQgbG9va3MgbGlrZSBhIGRhdGEgdXJsLlwiKTtcbiAgICB9XG5cbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLCBcIlwiKTtcblxuICAgIHZhciB0b3RhbExlbmd0aCA9IGlucHV0Lmxlbmd0aCAqIDMgLyA0O1xuICAgIGlmKGlucHV0LmNoYXJBdChpbnB1dC5sZW5ndGggLSAxKSA9PT0gX2tleVN0ci5jaGFyQXQoNjQpKSB7XG4gICAgICAgIHRvdGFsTGVuZ3RoLS07XG4gICAgfVxuICAgIGlmKGlucHV0LmNoYXJBdChpbnB1dC5sZW5ndGggLSAyKSA9PT0gX2tleVN0ci5jaGFyQXQoNjQpKSB7XG4gICAgICAgIHRvdGFsTGVuZ3RoLS07XG4gICAgfVxuICAgIGlmICh0b3RhbExlbmd0aCAlIDEgIT09IDApIHtcbiAgICAgICAgLy8gdG90YWxMZW5ndGggaXMgbm90IGFuIGludGVnZXIsIHRoZSBsZW5ndGggZG9lcyBub3QgbWF0Y2ggYSB2YWxpZFxuICAgICAgICAvLyBiYXNlNjQgY29udGVudC4gVGhhdCBjYW4gaGFwcGVuIGlmOlxuICAgICAgICAvLyAtIHRoZSBpbnB1dCBpcyBub3QgYSBiYXNlNjQgY29udGVudFxuICAgICAgICAvLyAtIHRoZSBpbnB1dCBpcyAqYWxtb3N0KiBhIGJhc2U2NCBjb250ZW50LCB3aXRoIGEgZXh0cmEgY2hhcnMgYXQgdGhlXG4gICAgICAgIC8vICAgYmVnaW5uaW5nIG9yIGF0IHRoZSBlbmRcbiAgICAgICAgLy8gLSB0aGUgaW5wdXQgdXNlcyBhIGJhc2U2NCB2YXJpYW50IChiYXNlNjR1cmwgZm9yIGV4YW1wbGUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGlucHV0LCBiYWQgY29udGVudCBsZW5ndGguXCIpO1xuICAgIH1cbiAgICB2YXIgb3V0cHV0O1xuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGh8MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ID0gbmV3IEFycmF5KHRvdGFsTGVuZ3RofDApO1xuICAgIH1cblxuICAgIHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKSB7XG5cbiAgICAgICAgZW5jMSA9IF9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzIgPSBfa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICAgICAgICBlbmMzID0gX2tleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jNCA9IF9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG5cbiAgICAgICAgY2hyMSA9IChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCk7XG4gICAgICAgIGNocjIgPSAoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKTtcbiAgICAgICAgY2hyMyA9ICgoZW5jMyAmIDMpIDw8IDYpIHwgZW5jNDtcblxuICAgICAgICBvdXRwdXRbcmVzdWx0SW5kZXgrK10gPSBjaHIxO1xuXG4gICAgICAgIGlmIChlbmMzICE9PSA2NCkge1xuICAgICAgICAgICAgb3V0cHV0W3Jlc3VsdEluZGV4KytdID0gY2hyMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jNCAhPT0gNjQpIHtcbiAgICAgICAgICAgIG91dHB1dFtyZXN1bHRJbmRleCsrXSA9IGNocjM7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYikge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSBjYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTtcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2IoZXJyMik7XG4gICAgX3RoaXMyLmVtaXQoJ2Nsb3NlJyk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XG4gIHZhciByZXRyaWVkO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuICd1dGY4JztcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xuICByZXR1cm4gbmVuYyB8fCBlbmM7XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy5cbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XG4gIHZhciBuYjtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcbiAgICAgIG5iID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcbiAgICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcbn1cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciByO1xuICB2YXIgaTtcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XG4gIHJldHVybiByIHx8ICcnO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcblxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59O1xuXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXG4vLyBjb250aW51YXRpb24gYnl0ZS4gSWYgYW4gaW52YWxpZCBieXRlIGlzIGRldGVjdGVkLCAtMiBpcyByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcbiAgcmV0dXJuIGJ5dGUgPj4gNiA9PT0gMHgwMiA/IC0xIDogLTI7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIGEgc2luZ2xlIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoJ1xcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcbi8vIGxvb3AuXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XG4gICAgcmV0dXJuICdcXHVmZmZkJztcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgfVxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcbiAgICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBhZGRlZCB3aGVuIGVuZGluZyBvbiBhIHBhcnRpYWxcbi8vIGNoYXJhY3Rlci5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iLCIndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyICYmICghdGhpcy5fd3JpdGFibGVTdGF0ZSB8fCAhdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCBfdGhpcywgZXJyKTtcbiAgICAgIGlmIChfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCcpO1xudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcblxuICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciByZWFkYWJsZUh3bSA9IG9wdGlvbnMucmVhZGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHJlYWRhYmxlSHdtIHx8IHJlYWRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gcmVhZGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIGNiKGVycik7XG59O1xuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gICAgaWYgKGVyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIHBuYS5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcG5hLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0geyBoYXNVbnBpcGVkOiBmYWxzZSB9O1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcG5hLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfVxuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IGZyb21MaXN0UGFydGlhbChuLCBzdGF0ZS5idWZmZXIsIHN0YXRlLmRlY29kZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gRXh0cmFjdHMgb25seSBlbm91Z2ggYnVmZmVyZWQgZGF0YSB0byBzYXRpc2Z5IHRoZSBhbW91bnQgcmVxdWVzdGVkLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdFBhcnRpYWwobiwgbGlzdCwgaGFzU3RyaW5ncykge1xuICB2YXIgcmV0O1xuICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzXG4gICAgcmV0ID0gbGlzdC5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTtcbiAgfSBlbHNlIGlmIChuID09PSBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBmaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyXG4gICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YVxuLy8gY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSB7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHZhciByZXQgPSBwLmRhdGE7XG4gIG4gLT0gcmV0Lmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEgY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KSB7XG4gIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHAuZGF0YS5jb3B5KHJldCk7XG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn0iLCIvKlxuICogVGhpcyBmaWxlIGlzIHVzZWQgYnkgbW9kdWxlIGJ1bmRsZXJzIChicm93c2VyaWZ5L3dlYnBhY2svZXRjKSB3aGVuXG4gKiBpbmNsdWRpbmcgYSBzdHJlYW0gaW1wbGVtZW50YXRpb24uIFdlIHVzZSBcInJlYWRhYmxlLXN0cmVhbVwiIHRvIGdldCBhXG4gKiBjb25zaXN0ZW50IGJlaGF2aW9yIGJldHdlZW4gbm9kZWpzIHZlcnNpb25zIGJ1dCBidW5kbGVycyBvZnRlbiBoYXZlIGEgc2hpbVxuICogZm9yIFwic3RyZWFtXCIuIFVzaW5nIHRoaXMgc2hpbSBncmVhdGx5IGltcHJvdmUgdGhlIGNvbXBhdGliaWxpdHkgYW5kIGdyZWF0bHlcbiAqIHJlZHVjZSB0aGUgZmluYWwgc2l6ZSBvZiB0aGUgYnVuZGxlIChvbmx5IG9uZSBzdHJlYW0gaW1wbGVtZW50YXRpb24sIG5vdFxuICogdHdvKS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvKiBGaWxlU2F2ZXIuanNcbiAqIEEgc2F2ZUFzKCkgRmlsZVNhdmVyIGltcGxlbWVudGF0aW9uLlxuICogMS4zLjJcbiAqIDIwMTYtMDYtMTYgMTg6MjU6MTlcbiAqXG4gKiBCeSBFbGkgR3JleSwgaHR0cDovL2VsaWdyZXkuY29tXG4gKiBMaWNlbnNlOiBNSVRcbiAqICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGlncmV5L0ZpbGVTYXZlci5qcy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kXG4gKi9cblxuLypnbG9iYWwgc2VsZiAqL1xuLypqc2xpbnQgYml0d2lzZTogdHJ1ZSwgaW5kZW50OiA0LCBsYXhicmVhazogdHJ1ZSwgbGF4Y29tbWE6IHRydWUsIHNtYXJ0dGFiczogdHJ1ZSwgcGx1c3BsdXM6IHRydWUgKi9cblxuLyohIEBzb3VyY2UgaHR0cDovL3B1cmwuZWxpZ3JleS5jb20vZ2l0aHViL0ZpbGVTYXZlci5qcy9ibG9iL21hc3Rlci9GaWxlU2F2ZXIuanMgKi9cblxudmFyIHNhdmVBcyA9IHNhdmVBcyB8fCAoZnVuY3Rpb24odmlldykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0Ly8gSUUgPDEwIGlzIGV4cGxpY2l0bHkgdW5zdXBwb3J0ZWRcblx0aWYgKHR5cGVvZiB2aWV3ID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgL01TSUUgWzEtOV1cXC4vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcblx0XHRyZXR1cm47XG5cdH1cblx0dmFyXG5cdFx0ICBkb2MgPSB2aWV3LmRvY3VtZW50XG5cdFx0ICAvLyBvbmx5IGdldCBVUkwgd2hlbiBuZWNlc3NhcnkgaW4gY2FzZSBCbG9iLmpzIGhhc24ndCBvdmVycmlkZGVuIGl0IHlldFxuXHRcdCwgZ2V0X1VSTCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHZpZXcuVVJMIHx8IHZpZXcud2Via2l0VVJMIHx8IHZpZXc7XG5cdFx0fVxuXHRcdCwgc2F2ZV9saW5rID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIiwgXCJhXCIpXG5cdFx0LCBjYW5fdXNlX3NhdmVfbGluayA9IFwiZG93bmxvYWRcIiBpbiBzYXZlX2xpbmtcblx0XHQsIGNsaWNrID0gZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0dmFyIGV2ZW50ID0gbmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiKTtcblx0XHRcdG5vZGUuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdFx0fVxuXHRcdCwgaXNfc2FmYXJpID0gL2NvbnN0cnVjdG9yL2kudGVzdCh2aWV3LkhUTUxFbGVtZW50KSB8fCB2aWV3LnNhZmFyaVxuXHRcdCwgaXNfY2hyb21lX2lvcyA9L0NyaU9TXFwvW1xcZF0rLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG5cdFx0LCB0aHJvd19vdXRzaWRlID0gZnVuY3Rpb24oZXgpIHtcblx0XHRcdCh2aWV3LnNldEltbWVkaWF0ZSB8fCB2aWV3LnNldFRpbWVvdXQpKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aHJvdyBleDtcblx0XHRcdH0sIDApO1xuXHRcdH1cblx0XHQsIGZvcmNlX3NhdmVhYmxlX3R5cGUgPSBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiXG5cdFx0Ly8gdGhlIEJsb2IgQVBJIGlzIGZ1bmRhbWVudGFsbHkgYnJva2VuIGFzIHRoZXJlIGlzIG5vIFwiZG93bmxvYWRmaW5pc2hlZFwiIGV2ZW50IHRvIHN1YnNjcmliZSB0b1xuXHRcdCwgYXJiaXRyYXJ5X3Jldm9rZV90aW1lb3V0ID0gMTAwMCAqIDQwIC8vIGluIG1zXG5cdFx0LCByZXZva2UgPSBmdW5jdGlvbihmaWxlKSB7XG5cdFx0XHR2YXIgcmV2b2tlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIGZpbGUgPT09IFwic3RyaW5nXCIpIHsgLy8gZmlsZSBpcyBhbiBvYmplY3QgVVJMXG5cdFx0XHRcdFx0Z2V0X1VSTCgpLnJldm9rZU9iamVjdFVSTChmaWxlKTtcblx0XHRcdFx0fSBlbHNlIHsgLy8gZmlsZSBpcyBhIEZpbGVcblx0XHRcdFx0XHRmaWxlLnJlbW92ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0c2V0VGltZW91dChyZXZva2VyLCBhcmJpdHJhcnlfcmV2b2tlX3RpbWVvdXQpO1xuXHRcdH1cblx0XHQsIGRpc3BhdGNoID0gZnVuY3Rpb24oZmlsZXNhdmVyLCBldmVudF90eXBlcywgZXZlbnQpIHtcblx0XHRcdGV2ZW50X3R5cGVzID0gW10uY29uY2F0KGV2ZW50X3R5cGVzKTtcblx0XHRcdHZhciBpID0gZXZlbnRfdHlwZXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHR2YXIgbGlzdGVuZXIgPSBmaWxlc2F2ZXJbXCJvblwiICsgZXZlbnRfdHlwZXNbaV1dO1xuXHRcdFx0XHRpZiAodHlwZW9mIGxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0bGlzdGVuZXIuY2FsbChmaWxlc2F2ZXIsIGV2ZW50IHx8IGZpbGVzYXZlcik7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXgpIHtcblx0XHRcdFx0XHRcdHRocm93X291dHNpZGUoZXgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHQsIGF1dG9fYm9tID0gZnVuY3Rpb24oYmxvYikge1xuXHRcdFx0Ly8gcHJlcGVuZCBCT00gZm9yIFVURi04IFhNTCBhbmQgdGV4dC8qIHR5cGVzIChpbmNsdWRpbmcgSFRNTClcblx0XHRcdC8vIG5vdGU6IHlvdXIgYnJvd3NlciB3aWxsIGF1dG9tYXRpY2FsbHkgY29udmVydCBVVEYtMTYgVStGRUZGIHRvIEVGIEJCIEJGXG5cdFx0XHRpZiAoL15cXHMqKD86dGV4dFxcL1xcUyp8YXBwbGljYXRpb25cXC94bWx8XFxTKlxcL1xcUypcXCt4bWwpXFxzKjsuKmNoYXJzZXRcXHMqPVxccyp1dGYtOC9pLnRlc3QoYmxvYi50eXBlKSkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IEJsb2IoW1N0cmluZy5mcm9tQ2hhckNvZGUoMHhGRUZGKSwgYmxvYl0sIHt0eXBlOiBibG9iLnR5cGV9KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBibG9iO1xuXHRcdH1cblx0XHQsIEZpbGVTYXZlciA9IGZ1bmN0aW9uKGJsb2IsIG5hbWUsIG5vX2F1dG9fYm9tKSB7XG5cdFx0XHRpZiAoIW5vX2F1dG9fYm9tKSB7XG5cdFx0XHRcdGJsb2IgPSBhdXRvX2JvbShibG9iKTtcblx0XHRcdH1cblx0XHRcdC8vIEZpcnN0IHRyeSBhLmRvd25sb2FkLCB0aGVuIHdlYiBmaWxlc3lzdGVtLCB0aGVuIG9iamVjdCBVUkxzXG5cdFx0XHR2YXJcblx0XHRcdFx0ICBmaWxlc2F2ZXIgPSB0aGlzXG5cdFx0XHRcdCwgdHlwZSA9IGJsb2IudHlwZVxuXHRcdFx0XHQsIGZvcmNlID0gdHlwZSA9PT0gZm9yY2Vfc2F2ZWFibGVfdHlwZVxuXHRcdFx0XHQsIG9iamVjdF91cmxcblx0XHRcdFx0LCBkaXNwYXRjaF9hbGwgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkaXNwYXRjaChmaWxlc2F2ZXIsIFwid3JpdGVzdGFydCBwcm9ncmVzcyB3cml0ZSB3cml0ZWVuZFwiLnNwbGl0KFwiIFwiKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gb24gYW55IGZpbGVzeXMgZXJyb3JzIHJldmVydCB0byBzYXZpbmcgd2l0aCBvYmplY3QgVVJMc1xuXHRcdFx0XHQsIGZzX2Vycm9yID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKChpc19jaHJvbWVfaW9zIHx8IChmb3JjZSAmJiBpc19zYWZhcmkpKSAmJiB2aWV3LkZpbGVSZWFkZXIpIHtcblx0XHRcdFx0XHRcdC8vIFNhZmFyaSBkb2Vzbid0IGFsbG93IGRvd25sb2FkaW5nIG9mIGJsb2IgdXJsc1xuXHRcdFx0XHRcdFx0dmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdFx0XHRcdFx0XHRyZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB1cmwgPSBpc19jaHJvbWVfaW9zID8gcmVhZGVyLnJlc3VsdCA6IHJlYWRlci5yZXN1bHQucmVwbGFjZSgvXmRhdGE6W147XSo7LywgJ2RhdGE6YXR0YWNobWVudC9maWxlOycpO1xuXHRcdFx0XHRcdFx0XHR2YXIgcG9wdXAgPSB2aWV3Lm9wZW4odXJsLCAnX2JsYW5rJyk7XG5cdFx0XHRcdFx0XHRcdGlmKCFwb3B1cCkgdmlldy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuXHRcdFx0XHRcdFx0XHR1cmw9dW5kZWZpbmVkOyAvLyByZWxlYXNlIHJlZmVyZW5jZSBiZWZvcmUgZGlzcGF0Y2hpbmdcblx0XHRcdFx0XHRcdFx0ZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuRE9ORTtcblx0XHRcdFx0XHRcdFx0ZGlzcGF0Y2hfYWxsKCk7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0cmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG5cdFx0XHRcdFx0XHRmaWxlc2F2ZXIucmVhZHlTdGF0ZSA9IGZpbGVzYXZlci5JTklUO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBkb24ndCBjcmVhdGUgbW9yZSBvYmplY3QgVVJMcyB0aGFuIG5lZWRlZFxuXHRcdFx0XHRcdGlmICghb2JqZWN0X3VybCkge1xuXHRcdFx0XHRcdFx0b2JqZWN0X3VybCA9IGdldF9VUkwoKS5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChmb3JjZSkge1xuXHRcdFx0XHRcdFx0dmlldy5sb2NhdGlvbi5ocmVmID0gb2JqZWN0X3VybDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIG9wZW5lZCA9IHZpZXcub3BlbihvYmplY3RfdXJsLCBcIl9ibGFua1wiKTtcblx0XHRcdFx0XHRcdGlmICghb3BlbmVkKSB7XG5cdFx0XHRcdFx0XHRcdC8vIEFwcGxlIGRvZXMgbm90IGFsbG93IHdpbmRvdy5vcGVuLCBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvc2FmYXJpL2RvY3VtZW50YXRpb24vVG9vbHMvQ29uY2VwdHVhbC9TYWZhcmlFeHRlbnNpb25HdWlkZS9Xb3JraW5nd2l0aFdpbmRvd3NhbmRUYWJzL1dvcmtpbmd3aXRoV2luZG93c2FuZFRhYnMuaHRtbFxuXHRcdFx0XHRcdFx0XHR2aWV3LmxvY2F0aW9uLmhyZWYgPSBvYmplY3RfdXJsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmaWxlc2F2ZXIucmVhZHlTdGF0ZSA9IGZpbGVzYXZlci5ET05FO1xuXHRcdFx0XHRcdGRpc3BhdGNoX2FsbCgpO1xuXHRcdFx0XHRcdHJldm9rZShvYmplY3RfdXJsKTtcblx0XHRcdFx0fVxuXHRcdFx0O1xuXHRcdFx0ZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuSU5JVDtcblxuXHRcdFx0aWYgKGNhbl91c2Vfc2F2ZV9saW5rKSB7XG5cdFx0XHRcdG9iamVjdF91cmwgPSBnZXRfVVJMKCkuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHNhdmVfbGluay5ocmVmID0gb2JqZWN0X3VybDtcblx0XHRcdFx0XHRzYXZlX2xpbmsuZG93bmxvYWQgPSBuYW1lO1xuXHRcdFx0XHRcdGNsaWNrKHNhdmVfbGluayk7XG5cdFx0XHRcdFx0ZGlzcGF0Y2hfYWxsKCk7XG5cdFx0XHRcdFx0cmV2b2tlKG9iamVjdF91cmwpO1xuXHRcdFx0XHRcdGZpbGVzYXZlci5yZWFkeVN0YXRlID0gZmlsZXNhdmVyLkRPTkU7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGZzX2Vycm9yKCk7XG5cdFx0fVxuXHRcdCwgRlNfcHJvdG8gPSBGaWxlU2F2ZXIucHJvdG90eXBlXG5cdFx0LCBzYXZlQXMgPSBmdW5jdGlvbihibG9iLCBuYW1lLCBub19hdXRvX2JvbSkge1xuXHRcdFx0cmV0dXJuIG5ldyBGaWxlU2F2ZXIoYmxvYiwgbmFtZSB8fCBibG9iLm5hbWUgfHwgXCJkb3dubG9hZFwiLCBub19hdXRvX2JvbSk7XG5cdFx0fVxuXHQ7XG5cdC8vIElFIDEwKyAobmF0aXZlIHNhdmVBcylcblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oYmxvYiwgbmFtZSwgbm9fYXV0b19ib20pIHtcblx0XHRcdG5hbWUgPSBuYW1lIHx8IGJsb2IubmFtZSB8fCBcImRvd25sb2FkXCI7XG5cblx0XHRcdGlmICghbm9fYXV0b19ib20pIHtcblx0XHRcdFx0YmxvYiA9IGF1dG9fYm9tKGJsb2IpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKGJsb2IsIG5hbWUpO1xuXHRcdH07XG5cdH1cblxuXHRGU19wcm90by5hYm9ydCA9IGZ1bmN0aW9uKCl7fTtcblx0RlNfcHJvdG8ucmVhZHlTdGF0ZSA9IEZTX3Byb3RvLklOSVQgPSAwO1xuXHRGU19wcm90by5XUklUSU5HID0gMTtcblx0RlNfcHJvdG8uRE9ORSA9IDI7XG5cblx0RlNfcHJvdG8uZXJyb3IgPVxuXHRGU19wcm90by5vbndyaXRlc3RhcnQgPVxuXHRGU19wcm90by5vbnByb2dyZXNzID1cblx0RlNfcHJvdG8ub253cml0ZSA9XG5cdEZTX3Byb3RvLm9uYWJvcnQgPVxuXHRGU19wcm90by5vbmVycm9yID1cblx0RlNfcHJvdG8ub253cml0ZWVuZCA9XG5cdFx0bnVsbDtcblxuXHRyZXR1cm4gc2F2ZUFzO1xufShcblx0ICAgdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZlxuXHR8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvd1xuXHR8fCB0aGlzLmNvbnRlbnRcbikpO1xuLy8gYHNlbGZgIGlzIHVuZGVmaW5lZCBpbiBGaXJlZm94IGZvciBBbmRyb2lkIGNvbnRlbnQgc2NyaXB0IGNvbnRleHRcbi8vIHdoaWxlIGB0aGlzYCBpcyBuc0lDb250ZW50RnJhbWVNZXNzYWdlTWFuYWdlclxuLy8gd2l0aCBhbiBhdHRyaWJ1dGUgYGNvbnRlbnRgIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIHdpbmRvd1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cy5zYXZlQXMgPSBzYXZlQXM7XG59IGVsc2UgaWYgKCh0eXBlb2YgZGVmaW5lICE9PSBcInVuZGVmaW5lZFwiICYmIGRlZmluZSAhPT0gbnVsbCkgJiYgKGRlZmluZS5hbWQgIT09IG51bGwpKSB7XG4gIGRlZmluZShcIkZpbGVTYXZlci5qc1wiLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2F2ZUFzO1xuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEpTWmlwVXRpbHMgPSB7fTtcbi8vIGp1c3QgdXNlIHRoZSByZXNwb25zZVRleHQgd2l0aCB4aHIxLCByZXNwb25zZSB3aXRoIHhocjIuXG4vLyBUaGUgdHJhbnNmb3JtYXRpb24gZG9lc24ndCB0aHJvdyBhd2F5IGhpZ2gtb3JkZXIgYnl0ZSAod2l0aCByZXNwb25zZVRleHQpXG4vLyBiZWNhdXNlIEpTWmlwIGhhbmRsZXMgdGhhdCBjYXNlLiBJZiBub3QgdXNlZCB3aXRoIEpTWmlwLCB5b3UgbWF5IG5lZWQgdG9cbi8vIGRvIGl0LCBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvRW4vVXNpbmdfWE1MSHR0cFJlcXVlc3QjSGFuZGxpbmdfYmluYXJ5X2RhdGFcbkpTWmlwVXRpbHMuX2dldEJpbmFyeUZyb21YSFIgPSBmdW5jdGlvbiAoeGhyKSB7XG4gICAgLy8gZm9yIHhoci5yZXNwb25zZVRleHQsIHRoZSAweEZGIG1hc2sgaXMgYXBwbGllZCBieSBKU1ppcFxuICAgIHJldHVybiB4aHIucmVzcG9uc2UgfHwgeGhyLnJlc3BvbnNlVGV4dDtcbn07XG5cbi8vIHRha2VuIGZyb20galF1ZXJ5XG5mdW5jdGlvbiBjcmVhdGVTdGFuZGFyZFhIUigpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuICAgIH0gY2F0Y2goIGUgKSB7fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVBY3RpdmVYSFIoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxIVFRQXCIpO1xuICAgIH0gY2F0Y2goIGUgKSB7fVxufVxuXG4vLyBDcmVhdGUgdGhlIHJlcXVlc3Qgb2JqZWN0XG52YXIgY3JlYXRlWEhSID0gd2luZG93LkFjdGl2ZVhPYmplY3QgP1xuICAgIC8qIE1pY3Jvc29mdCBmYWlsZWQgdG8gcHJvcGVybHlcbiAgICAgKiBpbXBsZW1lbnQgdGhlIFhNTEh0dHBSZXF1ZXN0IGluIElFNyAoY2FuJ3QgcmVxdWVzdCBsb2NhbCBmaWxlcyksXG4gICAgICogc28gd2UgdXNlIHRoZSBBY3RpdmVYT2JqZWN0IHdoZW4gaXQgaXMgYXZhaWxhYmxlXG4gICAgICogQWRkaXRpb25hbGx5IFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBpbiBJRTcvSUU4IHNvXG4gICAgICogd2UgbmVlZCBhIGZhbGxiYWNrLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjcmVhdGVTdGFuZGFyZFhIUigpIHx8IGNyZWF0ZUFjdGl2ZVhIUigpO1xufSA6XG4gICAgLy8gRm9yIGFsbCBvdGhlciBicm93c2VycywgdXNlIHRoZSBzdGFuZGFyZCBYTUxIdHRwUmVxdWVzdCBvYmplY3RcbiAgICBjcmVhdGVTdGFuZGFyZFhIUjtcblxuXG5cbkpTWmlwVXRpbHMuZ2V0QmluYXJ5Q29udGVudCA9IGZ1bmN0aW9uKHBhdGgsIGNhbGxiYWNrKSB7XG4gICAgLypcbiAgICAgKiBIZXJlIGlzIHRoZSB0cmlja3kgcGFydCA6IGdldHRpbmcgdGhlIGRhdGEuXG4gICAgICogSW4gZmlyZWZveC9jaHJvbWUvb3BlcmEvLi4uIHNldHRpbmcgdGhlIG1pbWVUeXBlIHRvICd0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkJ1xuICAgICAqIGlzIGVub3VnaCwgdGhlIHJlc3VsdCBpcyBpbiB0aGUgc3RhbmRhcmQgeGhyLnJlc3BvbnNlVGV4dC5cbiAgICAgKiBjZiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9Fbi9YTUxIdHRwUmVxdWVzdC9Vc2luZ19YTUxIdHRwUmVxdWVzdCNSZWNlaXZpbmdfYmluYXJ5X2RhdGFfaW5fb2xkZXJfYnJvd3NlcnNcbiAgICAgKiBJbiBJRSA8PSA5LCB3ZSBtdXN0IHVzZSAodGhlIElFIG9ubHkpIGF0dHJpYnV0ZSByZXNwb25zZUJvZHlcbiAgICAgKiAoZm9yIGJpbmFyeSBkYXRhLCBpdHMgY29udGVudCBpcyBkaWZmZXJlbnQgZnJvbSByZXNwb25zZVRleHQpLlxuICAgICAqIEluIElFIDEwLCB0aGUgJ2NoYXJzZXQ9eC11c2VyLWRlZmluZWQnIHRyaWNrIGRvZXNuJ3Qgd29yaywgb25seSB0aGVcbiAgICAgKiByZXNwb25zZVR5cGUgd2lsbCB3b3JrIDpcbiAgICAgKiBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg2NzM1NjklMjh2PXZzLjg1JTI5LmFzcHgjQmluYXJ5X09iamVjdF91cGxvYWRfYW5kX2Rvd25sb2FkXG4gICAgICpcbiAgICAgKiBJJ2QgbGlrZSB0byB1c2UgalF1ZXJ5IHRvIGF2b2lkIHRoaXMgWEhSIG1hZG5lc3MsIGJ1dCBpdCBkb2Vzbid0IHN1cHBvcnRcbiAgICAgKiB0aGUgcmVzcG9uc2VUeXBlIGF0dHJpYnV0ZSA6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzExNDYxXG4gICAgICovXG4gICAgdHJ5IHtcblxuICAgICAgICB2YXIgeGhyID0gY3JlYXRlWEhSKCk7XG5cbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHBhdGgsIHRydWUpO1xuXG4gICAgICAgIC8vIHJlY2VudCBicm93c2Vyc1xuICAgICAgICBpZiAoXCJyZXNwb25zZVR5cGVcIiBpbiB4aHIpIHtcbiAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvbGRlciBicm93c2VyXG4gICAgICAgIGlmKHhoci5vdmVycmlkZU1pbWVUeXBlKSB7XG4gICAgICAgICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZShcInRleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICB2YXIgZmlsZSwgZXJyO1xuICAgICAgICAgICAgLy8gdXNlIGB4aHJgIGFuZCBub3QgYHRoaXNgLi4uIHRoYW5rcyBJRVxuICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCB8fCB4aHIuc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBlcnIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZSA9IEpTWmlwVXRpbHMuX2dldEJpbmFyeUZyb21YSFIoeGhyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBmaWxlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoXCJBamF4IGVycm9yIGZvciBcIiArIHBhdGggKyBcIiA6IFwiICsgdGhpcy5zdGF0dXMgKyBcIiBcIiArIHRoaXMuc3RhdHVzVGV4dCksIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB4aHIuc2VuZCgpO1xuXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoZSksIG51bGwpO1xuICAgIH1cbn07XG5cbi8vIGV4cG9ydFxubW9kdWxlLmV4cG9ydHMgPSBKU1ppcFV0aWxzO1xuXG4vLyBlbmZvcmNpbmcgU3R1aydzIGNvZGluZyBzdHlsZVxuLy8gdmltOiBzZXQgc2hpZnR3aWR0aD00IHNvZnR0YWJzdG9wPTQ6XG4iLCJpbXBvcnQge19nbG9iYWxQcmVsb2FkLCBfaW5zdHJ1Y3Rpb25zVG9QcmVsb2FkLCBfdGltZW91dFByZWxvYWQsIF93YWl0V2hpbGVQcmVsb2FkaW5nTWVzc2FnZSwgX2NoZWNrUHJlbG9hZH0gZnJvbSBcIi4vcHJlbG9hZC9wcmVsb2FkLmpzXCI7XG5cbi8vIEFsbCB0aGUgaW1hZ2UgYW5kIGF1ZGlvIGZpbGVzXG52YXIgX3ByZWxvYWRlZEZpbGVzID0ge307XG5cbmRlZmluZV9pYmV4X2NvbnRyb2xsZXIoe1xuICAgIG5hbWU6IFwiUGVubkNvbnRyb2xsZXJcIixcbiAgICBqcXVlcnlXaWRnZXQ6IHsgICAgXG4gICAgICAgIF9pbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBfdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIF90LmNzc1ByZWZpeCA9IF90Lm9wdGlvbnMuX2Nzc1ByZWZpeDtcbiAgICAgICAgICAgIF90LnV0aWxzID0gX3Qub3B0aW9ucy5fdXRpbHM7XG4gICAgICAgICAgICBfdC5maW5pc2hlZENhbGxiYWNrID0gX3Qub3B0aW9ucy5fZmluaXNoZWRDYWxsYmFjaztcblxuICAgICAgICAgICAgLy8gID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgLy8gICAgICBFWENFUFRJT05BTCBDQVNFOiBDVVNUT00gQ09OVFJPTExFUlxuICAgICAgICAgICAgLy8gID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgaWYgKF90Lm9wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJjdXN0b21cIikgJiYgX3Qub3B0aW9ucy5jdXN0b20gaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgICAgICAgICAgICByZXR1cm4gX3Qub3B0aW9ucy5jdXN0b20oX3QpO1xuXG4gICAgICAgICAgICBfdC5pbnN0cnVjdGlvbnMgPSBfdC5vcHRpb25zLmluc3RydWN0aW9ucztcbiAgICAgICAgICAgIF90LmlkID0gX3Qub3B0aW9ucy5pZDtcblxuICAgICAgICAgICAgX3QudG9TYXZlID0gW107XG4gICAgICAgICAgICBfdC50b1J1bkJlZm9yZUZpbmlzaCA9IFtdO1xuXG4gICAgICAgICAgICBfdC50aW1lcnMgPSBbXTtcblxuICAgICAgICAgICAgLy8gID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgLy8gICAgICBJTlRFUk5BTCBGVU5DVElPTlNcbiAgICAgICAgICAgIC8vICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgICAgICAgICAgLy8gQWRkcyBhIHBhcmFtZXRlci9saW5lIHRvIHRoZSBsaXN0IG9mIHRoaW5ncyB0byBzYXZlXG4gICAgICAgICAgICBfdC5zYXZlID0gZnVuY3Rpb24ocGFyYW1ldGVyLCB2YWx1ZSwgdGltZSwgY29tbWVudCl7XG4gICAgICAgICAgICAgICAgX3QudG9TYXZlLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgW1wiUGFyYW1ldGVyXCIsIHBhcmFtZXRlcl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbXCJWYWx1ZVwiLCB2YWx1ZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbXCJUaW1lXCIsIHRpbWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgW1wiQ29tbWVudFwiLCBjb21tZW50ID8gY29tbWVudCA6IFwiTlVMTFwiXVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEFkZHMgYSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBiZWZvcmUgZmluaXNoZWRDYWxsQmFja1xuICAgICAgICAgICAgX3QuY2FsbGJhY2tCZWZvcmVGaW5pc2ggPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgICAgICAgX3QudG9SdW5CZWZvcmVGaW5pc2gucHVzaChmdW5jKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIENhbGxlZCB3aGVuIGNvbnRyb2xsZXIgZW5kc1xuICAgICAgICAgICAgLy8gUnVucyBmaW5pc2hlZENhbGxiYWNrXG4gICAgICAgICAgICBfdC5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBmIGluIF90LnRvUnVuQmVmb3JlRmluaXNoKXtcbiAgICAgICAgICAgICAgICAgICAgX3QudG9SdW5CZWZvcmVGaW5pc2hbZl0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmUtYXBwZW5kaW5nIHByZWxvYWRlZCByZXNvdXJjZXMgdG8gdGhlIEhUTUwgbm9kZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGYgaW4gX3ByZWxvYWRlZEZpbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX3ByZWxvYWRlZEZpbGVzW2ZdLnBhcmVudCgpLmlzKFwiaHRtbFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3ByZWxvYWRlZEZpbGVzW2ZdLmNzcyhcImRpc3BsYXlcIixcIm5vbmVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcHJlbG9hZGVkRmlsZXNbZl0uYXBwZW5kVG8oJChcImh0bWxcIikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhpZGUgYWxsIGlmcmFtZXNcbiAgICAgICAgICAgICAgICAkKFwiaWZyYW1lXCIpLmNzcyhcImRpc3BsYXlcIixcIm5vbmVcIik7XG4gICAgICAgICAgICAgICAgLy8gU3RvcCBwbGF5aW5nIGFsbCBhdWRpb3NcbiAgICAgICAgICAgICAgICAkKFwiYXVkaW9cIikuZWFjaChmdW5jdGlvbigpeyBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBFbmQgYWxsIHRpbWVyc1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHQgaW4gdGhpcy50aW1lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyc1t0XSk7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyc1t0XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNhdmUgdGltZVxuICAgICAgICAgICAgICAgIF90LnNhdmUoXCJQYWdlXCIsIFwiRW5kXCIsIERhdGUubm93KCksIFwiTlVMTFwiKTtcbiAgICAgICAgICAgICAgICAvLyBOZXh0IHRyaWFsXG4gICAgICAgICAgICAgICAgX3QuZmluaXNoZWRDYWxsYmFjayhfdC50b1NhdmUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuICAgICAgICAgICAgLy8gUFJFTE9BRElORyBQQVJUIDFcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBBZGRzIGFuIGluc3RydWN0aW9uIHRoYXQgbXVzdCBiZSBwcmVsb2FkZWQgYmVmb3JlIHRoZSBzZXF1ZW5jZSBzdGFydHNcbiAgICAgICAgICAgIF90LmFkZFRvUHJlbG9hZCA9IGZ1bmN0aW9uKGluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSByZXNvdXJjZSBpZiBkZWZpbmVkIGFuZCBvbmx5IGlmIG5vdCBhbHJlYWR5IHByZWxvYWRlZFxuICAgICAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbiAmJiBfaW5zdHJ1Y3Rpb25zVG9QcmVsb2FkLmluZGV4T2YoaW5zdHJ1Y3Rpb24pPj0wKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX3QudG9QcmVsb2FkKVxuICAgICAgICAgICAgICAgICAgICAgICAgX3QudG9QcmVsb2FkID0gW107XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgcmVzb3VyY2Ugb25seSBpZiBub3QgYWxyZWFkeSBsaXN0ZWQgKHNldmVyYWwgaW5zdHJ1Y3Rpb25zIG1heSBzaGFyZSB0aGUgc2FtZSBvcmlnaW4pXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdC50b1ByZWxvYWQuaW5kZXhPZihpbnN0cnVjdGlvbikgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdC50b1ByZWxvYWQucHVzaChpbnN0cnVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRlbmQgX3NldFJlc291cmNlIChjYWxsZWQgYWZ0ZXIgcHJlbG9hZGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLl9zZXRSZXNvdXJjZSA9IGluc3RydWN0aW9uLmV4dGVuZChcIl9zZXRSZXNvdXJjZVwiLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZW50cnkgKHNldCBpbmRleCBoZXJlLCBhcyBpdCBtYXkgaGF2ZSBjaGFuZ2VkIGJ5IHRoZSB0aW1lIGNhbGxiYWNrIGlzIGNhbGxlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBfdC50b1ByZWxvYWQuaW5kZXhPZihpbnN0cnVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90LnRvUHJlbG9hZC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG5vIG1vcmUgZmlsZSB0byBwcmVsb2FkLCBydW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3QudG9QcmVsb2FkLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXCIjd2FpdFdoaWxlUHJlbG9hZGluZ1wiKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Quc2F2ZShcIlByZWxvYWRcIiwgXCJDb21wbGV0ZVwiLCBEYXRlLm5vdygpLCBcIk5VTExcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3QuaW5zdHJ1Y3Rpb25zWzBdLmhhc0JlZW5SdW4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdC5pbnN0cnVjdGlvbnNbMF0ucnVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgaW5zdHJ1Y3Rpb24gcmVxdWlyZXMgYSBwcmVsb2FkZWQgcmVzb3VyY2VcbiAgICAgICAgICAgIGlmICghX2dsb2JhbFByZWxvYWQgJiYgQ3RybHIubGlzdFt0aGlzLmlkXS5oYXNPd25Qcm9wZXJ0eShcInByZWxvYWRpbmdJbnN0cnVjdGlvbnNcIikpIHtcbiAgICAgICAgICAgICAgICAvLyBHbyB0aHJvdWdoIGVhY2ggcmVzb3VyY2UgdGhhdCBuZXh0J3Mgb3JpZ2luIGhhcyB0byBwcmVsb2FkXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSBpbiBDdHJsci5saXN0W3RoaXMuaWRdLnByZWxvYWRpbmdJbnN0cnVjdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCByZXNvdXJjZVxuICAgICAgICAgICAgICAgICAgICBfdC5hZGRUb1ByZWxvYWQoQ3RybHIubGlzdFt0aGlzLmlkXS5wcmVsb2FkaW5nSW5zdHJ1Y3Rpb25zW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFxuICAgICAgICAgICAgLy8gRU5EIE9GIFBSRUxPQURJTkcgUEFSVCAxXG4gICAgICAgICAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cblxuICAgICAgICAgICAgLy8gTWFrZSBpdCBzbyB0aGF0IGVhY2ggaW5zdHJ1Y3Rpb24gcnVucyBuZXh0IG9uZVxuICAgICAgICAgICAgbGV0IHByZXZpb3VzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBpbiBfdC5pbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IF90Lmluc3RydWN0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAvLyBJZiBub3QgYW4gaW5zdHJ1Y3Rpb24sIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgaWYgKCEobmV4dCBpbnN0YW5jZW9mIEluc3RydWN0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgLy8gR2l2ZSBhIHBhcmVudCBlbGVtZW50XG4gICAgICAgICAgICAgICAgbmV4dC5wYXJlbnRFbGVtZW50ID0gX3QuZWxlbWVudDtcbiAgICAgICAgICAgICAgICAvLyBSdW4gbmV4dCBpbnN0cnVjdGlvbiB3aGVuIHByZXZpb3VzIGlzIGRvbmVcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXMgaW5zdGFuY2VvZiBJbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91cy5kb25lID0gcHJldmlvdXMuZXh0ZW5kKFwiZG9uZVwiLCBmdW5jdGlvbigpeyBuZXh0LnJ1bigpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5mb3JtIG9mIHByZXZpb3VzIGluc3RydWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIG5leHQucHJldmlvdXNJbnN0cnVjdGlvbiA9IHByZXZpb3VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2aW91cyA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3cgcHJldmlvdXMgaXMgdGhlIGxhc3QgaW5zdHJ1Y3Rpb25cbiAgICAgICAgICAgIHByZXZpb3VzLmRvbmUgPSBwcmV2aW91cy5leHRlbmQoXCJkb25lXCIsIGZ1bmN0aW9uKCl7IF90LmVuZCgpOyB9KTtcblxuICAgICAgICAgICAgLy8gUmVjb3JkIHJ1bm5pbmcgb2YgZmlyc3QgaW5zdHJ1Y3Rpb25cbiAgICAgICAgICAgIF90Lmluc3RydWN0aW9uc1swXS5ydW4gPSBfdC5pbnN0cnVjdGlvbnNbMF0uZXh0ZW5kKFwicnVuXCIsIGZ1bmN0aW9uKCl7IFxuICAgICAgICAgICAgICAgIF90LnNhdmUoXCJQYWdlXCIsIFwiUnVuRmlyc3RJbnN0cnVjdGlvblwiLCBEYXRlLm5vdygpLCBcIk5VTExcIik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGxvY2FsIHZhcmlhYmxlcyAoc2VlIEZ1bmNJbnN0cilcbiAgICAgICAgICAgIF90LnZhcmlhYmxlcyA9IHt9O1xuXG4gICAgICAgICAgICAvLyBJbmZvcm0gdGhhdCB0aGUgY3VycmVudCBjb250cm9sbGVyIGlzIHRoaXMgb25lXG4gICAgICAgICAgICAvL19zZXRDdHJscihfdCk7XG4gICAgICAgICAgICBDdHJsci5ydW5uaW5nID0gX3Q7XG5cbiAgICAgICAgICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbiAgICAgICAgICAgIC8vIFBSRUxPQURJTkcgUEFSVCAyXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gSWYgQUxMIHJlc291cmNlcyBzaG91bGQgYmUgcHJlbG9hZGVkIGF0IG9uY2UgKGFuZCBpZiB0aGVyZSBhcmUgcmVzb3VyY2VzIHRvIHByZWxvYWQgdG8gc3RhcnQgd2l0aClcbiAgICAgICAgICAgIGlmIChfZ2xvYmFsUHJlbG9hZCAmJiBfaW5zdHJ1Y3Rpb25zVG9QcmVsb2FkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBlYWNoIG9mIHRoZW1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpIGluIF9pbnN0cnVjdGlvbnNUb1ByZWxvYWQpXG4gICAgICAgICAgICAgICAgICAgIF90LmFkZFRvUHJlbG9hZChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGFueXRoaW5nIHRvIHByZWxvYWRcbiAgICAgICAgICAgIGlmIChfdC50b1ByZWxvYWQpIHtcbiAgICAgICAgICAgICAgICAvLyBTYXZlIHByZWxvYWRpbmcgdGltZVxuICAgICAgICAgICAgICAgIF90LnNhdmUoXCJQcmVsb2FkXCIsIFwiU3RhcnRcIiwgRGF0ZS5ub3coKSwgXCJOVUxMXCIpO1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhIHByZWxvYWRpbmcgbWVzc2FnZVxuICAgICAgICAgICAgICAgIF90LmVsZW1lbnQuYXBwZW5kKCQoXCI8ZGl2IGlkPSd3YWl0V2hpbGVQcmVsb2FkaW5nJz5cIikuaHRtbChfd2FpdFdoaWxlUHJlbG9hZGluZ01lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAvLyBBZGRpbmcgYSB0aW1lb3V0IGluIGNhc2UgcHJlbG9hZGluZyBmYWlsc1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWJvcnQgaWYgZmlyc3QgaW5zdHJ1Y3Rpb24gaGFzIGJlZW4gcnVuIGluIHRoZSBtZWFudGltZSAoZS5nLiBwcmVsb2FkaW5nJ3MgZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90Lmluc3RydWN0aW9uc1swXS5oYXNCZWVuUnVuKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFib3J0O1xuICAgICAgICAgICAgICAgICAgICAkKFwiI3dhaXRXaGlsZVByZWxvYWRpbmdcIikucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIF90LnNhdmUoXCJQcmVsb2FkXCIsIFwiVGltZW91dFwiLCBEYXRlLm5vdygpLCBcIk5VTExcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX3QuaW5zdHJ1Y3Rpb25zWzBdLmhhc0JlZW5SdW4pXG4gICAgICAgICAgICAgICAgICAgICAgICBfdC5pbnN0cnVjdGlvbnNbMF0ucnVuKCk7XG4gICAgICAgICAgICAgICAgfSwgX3RpbWVvdXRQcmVsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBFTkQgT0YgUFJFTE9BRElORyBQQVJUIDJcbiAgICAgICAgICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbiAgICAgICAgICAgIC8vIEVsc2UsIHJ1biB0aGUgZmlyc3QgaW5zdHJ1Y3Rpb24gYWxyZWFkeSFcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBfdC5pbnN0cnVjdGlvbnNbMF0ucnVuKCk7XG5cbiAgICAgICAgICAgIC8vIFNhdmUgdGltZSBvZiBjcmVhdGlvblxuICAgICAgICAgICAgX3Quc2F2ZShcIlBhZ2VcIiwgXCJDcmVhdGlvblwiLCBEYXRlLm5vdygpLCBcIk5VTExcIik7XG5cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIG9ibGlnYXRvcnk6IFtdLFxuICAgICAgICBjb3VudHNGb3JQcm9ncmVzc0JhcjogdHJ1ZSxcbiAgICAgICAgaHRtbERlc2NyaXB0aW9uOiBudWxsXG4gICAgfVxufSk7XG5cblxuLy8gR2V0IGFueSBjaGFuZ2UgdG8gdGhlIHJ1bm5pbmcgb3JkZXIgKHN0b2NrZWQgaW4gY29udHJvbGxlci5qcylcbmltcG9ydCB7IGdldENoYW5nZVJ1bm5pbmdPcmRlciB9IGZyb20gXCIuL2NvbnRyb2xsZXIuanNcIjtcblxuLy8gQXBwbHkgYW55IGNoYW5nZSB0byB0aGUgcnVubmluZyBvcmRlclxud2luZG93Lm1vZGlmeVJ1bm5pbmdPcmRlciA9IGZ1bmN0aW9uIChybykge1xuICAgIGNvbnNvbGUubG9nKFwiUnVubmluZyBtb2RpZnlSdW5uaW5nT3JkZXJcIik7XG4gICAgbGV0IGZ1bmN0aW9uc1J1bm5pbmdPcmRlciA9IGdldENoYW5nZVJ1bm5pbmdPcmRlcigpO1xuICAgIGNvbnNvbGUubG9nKFwiTm93IGdvaW5nIHRocm91Z2guLi5cIik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdW5jdGlvbnNSdW5uaW5nT3JkZXIubGVuZ3RoOyBpKyspe1xuICAgICAgICBjb25zb2xlLmxvZyhcIk1vZGlmeWluZyBydW5uaW5nIG9yZGVyIHdpdGggYSBmdW5jdGlvblwiKTtcbiAgICAgICAgcm8gPSBmdW5jdGlvbnNSdW5uaW5nT3JkZXJbaV0ocm8pO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZyhcIk5ldyBydW5uaW5nIG9yZGVyOlwiLCBybyk7XG4gICAgcmV0dXJuIHJvO1xufSIsIi8qKlxuICogalF1ZXJ5LWNzdiAoalF1ZXJ5IFBsdWdpbilcbiAqXG4gKiBUaGlzIGRvY3VtZW50IGlzIGxpY2Vuc2VkIGFzIGZyZWUgc29mdHdhcmUgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZVxuICogTUlUIExpY2Vuc2U6IGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gKlxuICogQWNrbm93bGVkZ2VtZW50czpcbiAqIFRoZSBvcmlnaW5hbCBkZXNpZ24gYW5kIGluZmx1ZW5jZSB0byBpbXBsZW1lbnQgdGhpcyBsaWJyYXJ5IGFzIGEganF1ZXJ5XG4gKiBwbHVnaW4gaXMgaW5mbHVlbmNlZCBieSBqcXVlcnktanNvbiAoaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2pxdWVyeS1qc29uLykuXG4gKiBJZiB5b3UncmUgbG9va2luZyB0byB1c2UgbmF0aXZlIEpTT04uU3RyaW5naWZ5IGJ1dCB3YW50IGFkZGl0aW9uYWwgYmFja3dhcmRzXG4gKiBjb21wYXRpYmlsaXR5IGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgaXQsIEkgaGlnaGx5IHJlY29tbWVuZCB5b3VcbiAqIGNoZWNrIGl0IG91dC5cbiAqXG4gKiBBIHNwZWNpYWwgdGhhbmtzIGdvZXMgb3V0IHRvIHJ3a0BhY20ub3JnIGZvciBwcm92aWRpbmcgYSBsb3Qgb2YgdmFsdWFibGVcbiAqIGZlZWRiYWNrIHRvIHRoZSBwcm9qZWN0IGluY2x1ZGluZyB0aGUgY29yZSBmb3IgdGhlIG5ldyBGU01cbiAqIChGaW5pdGUgU3RhdGUgTWFjaGluZSkgcGFyc2Vycy4gSWYgeW91J3JlIGxvb2tpbmcgZm9yIGEgc3RhYmxlIFRTViBwYXJzZXJcbiAqIGJlIHN1cmUgdG8gdGFrZSBhIGxvb2sgYXQganF1ZXJ5LXRzdiAoaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2pxdWVyeS10c3YvKS5cblxuICogRm9yIGxlZ2FsIHB1cnBvc2VzIEknbGwgaW5jbHVkZSB0aGUgXCJOTyBXQVJSQU5UWSBFWFBSRVNTRUQgT1IgSU1QTElFRC5cbiAqIFVTRSBBVCBZT1VSIE9XTiBSSVNLLlwiLiBXaGljaCwgaW4gJ2xheW1hbidzIHRlcm1zJyBtZWFucywgYnkgdXNpbmcgdGhpc1xuICogbGlicmFyeSB5b3UgYXJlIGFjY2VwdGluZyByZXNwb25zaWJpbGl0eSBpZiBpdCBicmVha3MgeW91ciBjb2RlLlxuICpcbiAqIExlZ2FsIGphcmdvbiBhc2lkZSwgSSB3aWxsIGRvIG15IGJlc3QgdG8gcHJvdmlkZSBhIHVzZWZ1bCBhbmQgc3RhYmxlIGNvcmVcbiAqIHRoYXQgY2FuIGVmZmVjdGl2ZWx5IGJlIGJ1aWx0IG9uLlxuICpcbiAqIENvcHlyaWdodGVkIDIwMTIgYnkgRXZhbiBQbGFpY2UuXG4gKi9cblxuUmVnRXhwLmVzY2FwZSA9IGZ1bmN0aW9uIChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciAkO1xuXG4gIC8vIHRvIGtlZXAgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgaWYgKHR5cGVvZiBqUXVlcnkgIT09ICd1bmRlZmluZWQnICYmIGpRdWVyeSkge1xuICAgICQgPSBqUXVlcnk7XG4gIH0gZWxzZSB7XG4gICAgJCA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIGpRdWVyeS5jc3YuZGVmYXVsdHNcbiAgICogRW5jYXBzdWxhdGVzIHRoZSBtZXRob2QgcGFyYW1hdGVyIGRlZmF1bHRzIGZvciB0aGUgQ1NWIHBsdWdpbiBtb2R1bGUuXG4gICAqL1xuXG4gICQuY3N2ID0ge1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICBzZXBhcmF0b3I6ICcsJyxcbiAgICAgIGRlbGltaXRlcjogJ1wiJyxcbiAgICAgIGhlYWRlcnM6IHRydWVcbiAgICB9LFxuXG4gICAgaG9va3M6IHtcbiAgICAgIGNhc3RUb1NjYWxhcjogZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSkge1xuICAgICAgICB2YXIgaGFzRG90ID0gL1xcLi87XG4gICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGhhc0RvdC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW50ZWdlciA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpc05hTihpbnRlZ2VyKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbnRlZ2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwYXJzZXJzOiB7XG4gICAgICBwYXJzZTogZnVuY3Rpb24gKGNzdiwgb3B0aW9ucykge1xuICAgICAgICAvLyBjYWNoZSBzZXR0aW5nc1xuICAgICAgICB2YXIgc2VwYXJhdG9yID0gb3B0aW9ucy5zZXBhcmF0b3I7XG4gICAgICAgIHZhciBkZWxpbWl0ZXIgPSBvcHRpb25zLmRlbGltaXRlcjtcblxuICAgICAgICAvLyBzZXQgaW5pdGlhbCBzdGF0ZSBpZiBpdCdzIG1pc3NpbmdcbiAgICAgICAgaWYgKCFvcHRpb25zLnN0YXRlLnJvd051bSkge1xuICAgICAgICAgIG9wdGlvbnMuc3RhdGUucm93TnVtID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnMuc3RhdGUuY29sTnVtKSB7XG4gICAgICAgICAgb3B0aW9ucy5zdGF0ZS5jb2xOdW0gPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgaW5pdGlhbCBzdGF0ZVxuICAgICAgICB2YXIgZGF0YSA9IFtdO1xuICAgICAgICB2YXIgZW50cnkgPSBbXTtcbiAgICAgICAgdmFyIHN0YXRlID0gMDtcbiAgICAgICAgdmFyIHZhbHVlID0gJyc7XG4gICAgICAgIHZhciBleGl0ID0gZmFsc2U7XG5cbiAgICAgICAgZnVuY3Rpb24gZW5kT2ZFbnRyeSAoKSB7XG4gICAgICAgICAgLy8gcmVzZXQgdGhlIHN0YXRlXG4gICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgIHZhbHVlID0gJyc7XG5cbiAgICAgICAgICAvLyBpZiAnc3RhcnQnIGhhc24ndCBiZWVuIG1ldCwgZG9uJ3Qgb3V0cHV0XG4gICAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnQgJiYgb3B0aW9ucy5zdGF0ZS5yb3dOdW0gPCBvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgZ2xvYmFsIHN0YXRlXG4gICAgICAgICAgICBlbnRyeSA9IFtdO1xuICAgICAgICAgICAgb3B0aW9ucy5zdGF0ZS5yb3dOdW0rKztcbiAgICAgICAgICAgIG9wdGlvbnMuc3RhdGUuY29sTnVtID0gMTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5vblBhcnNlRW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gb25QYXJzZUVudHJ5IGhvb2sgbm90IHNldFxuICAgICAgICAgICAgZGF0YS5wdXNoKGVudHJ5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhvb2tWYWwgPSBvcHRpb25zLm9uUGFyc2VFbnRyeShlbnRyeSwgb3B0aW9ucy5zdGF0ZSk7IC8vIG9uUGFyc2VFbnRyeSBIb29rXG4gICAgICAgICAgICAvLyBmYWxzZSBza2lwcyB0aGUgcm93LCBjb25maWd1cmFibGUgdGhyb3VnaCBhIGhvb2tcbiAgICAgICAgICAgIGlmIChob29rVmFsICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBkYXRhLnB1c2goaG9va1ZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdlbnRyeTonICsgZW50cnkpO1xuXG4gICAgICAgICAgLy8gY2xlYW51cFxuICAgICAgICAgIGVudHJ5ID0gW107XG5cbiAgICAgICAgICAvLyBpZiAnZW5kJyBpcyBtZXQsIHN0b3AgcGFyc2luZ1xuICAgICAgICAgIGlmIChvcHRpb25zLmVuZCAmJiBvcHRpb25zLnN0YXRlLnJvd051bSA+PSBvcHRpb25zLmVuZCkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdXBkYXRlIGdsb2JhbCBzdGF0ZVxuICAgICAgICAgIG9wdGlvbnMuc3RhdGUucm93TnVtKys7XG4gICAgICAgICAgb3B0aW9ucy5zdGF0ZS5jb2xOdW0gPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZW5kT2ZWYWx1ZSAoKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMub25QYXJzZVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIG9uUGFyc2VWYWx1ZSBob29rIG5vdCBzZXRcbiAgICAgICAgICAgIGVudHJ5LnB1c2godmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaG9vayA9IG9wdGlvbnMub25QYXJzZVZhbHVlKHZhbHVlLCBvcHRpb25zLnN0YXRlKTsgLy8gb25QYXJzZVZhbHVlIEhvb2tcbiAgICAgICAgICAgIC8vIGZhbHNlIHNraXBzIHRoZSByb3csIGNvbmZpZ3VyYWJsZSB0aHJvdWdoIGEgaG9va1xuICAgICAgICAgICAgaWYgKGhvb2sgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGVudHJ5LnB1c2goaG9vayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd2YWx1ZTonICsgdmFsdWUpO1xuICAgICAgICAgIC8vIHJlc2V0IHRoZSBzdGF0ZVxuICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgIC8vIHVwZGF0ZSBnbG9iYWwgc3RhdGVcbiAgICAgICAgICBvcHRpb25zLnN0YXRlLmNvbE51bSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZXNjYXBlIHJlZ2V4LXNwZWNpZmljIGNvbnRyb2wgY2hhcnNcbiAgICAgICAgdmFyIGVzY1NlcGFyYXRvciA9IFJlZ0V4cC5lc2NhcGUoc2VwYXJhdG9yKTtcbiAgICAgICAgdmFyIGVzY0RlbGltaXRlciA9IFJlZ0V4cC5lc2NhcGUoZGVsaW1pdGVyKTtcblxuICAgICAgICAvLyBjb21waWxlIHRoZSByZWdFeCBzdHIgdXNpbmcgdGhlIGN1c3RvbSBkZWxpbWl0ZXIvc2VwYXJhdG9yXG4gICAgICAgIHZhciBtYXRjaCA9IC8oRHxTfFxcclxcbnxcXG58XFxyfFteRFNcXHJcXG5dKykvO1xuICAgICAgICB2YXIgbWF0Y2hTcmMgPSBtYXRjaC5zb3VyY2U7XG4gICAgICAgIG1hdGNoU3JjID0gbWF0Y2hTcmMucmVwbGFjZSgvUy9nLCBlc2NTZXBhcmF0b3IpO1xuICAgICAgICBtYXRjaFNyYyA9IG1hdGNoU3JjLnJlcGxhY2UoL0QvZywgZXNjRGVsaW1pdGVyKTtcbiAgICAgICAgbWF0Y2ggPSBuZXcgUmVnRXhwKG1hdGNoU3JjLCAnZ20nKTtcblxuICAgICAgICAvLyBwdXQgb24geW91ciBmYW5jeSBwYW50cy4uLlxuICAgICAgICAvLyBwcm9jZXNzIGNvbnRyb2wgY2hhcnMgaW5kaXZpZHVhbGx5LCB1c2UgbG9vay1haGVhZCBvbiBub24tY29udHJvbCBjaGFyc1xuICAgICAgICBjc3YucmVwbGFjZShtYXRjaCwgZnVuY3Rpb24gKG0wKSB7XG4gICAgICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgLy8gdGhlIHN0YXJ0IG9mIGEgdmFsdWVcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgLy8gbnVsbCBsYXN0IHZhbHVlXG4gICAgICAgICAgICAgIGlmIChtMCA9PT0gc2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gJyc7XG4gICAgICAgICAgICAgICAgZW5kT2ZWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIG9wZW5pbmcgZGVsaW1pdGVyXG4gICAgICAgICAgICAgIGlmIChtMCA9PT0gZGVsaW1pdGVyKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIG51bGwgbGFzdCB2YWx1ZVxuICAgICAgICAgICAgICBpZiAoL14oXFxyXFxufFxcbnxcXHIpJC8udGVzdChtMCkpIHtcbiAgICAgICAgICAgICAgICBlbmRPZlZhbHVlKCk7XG4gICAgICAgICAgICAgICAgZW5kT2ZFbnRyeSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIHVuLWRlbGltaXRlZCB2YWx1ZVxuICAgICAgICAgICAgICB2YWx1ZSArPSBtMDtcbiAgICAgICAgICAgICAgc3RhdGUgPSAzO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgLy8gZGVsaW1pdGVkIGlucHV0XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIC8vIHNlY29uZCBkZWxpbWl0ZXI/IGNoZWNrIGZ1cnRoZXJcbiAgICAgICAgICAgICAgaWYgKG0wID09PSBkZWxpbWl0ZXIpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gZGVsaW1pdGVkIGRhdGFcbiAgICAgICAgICAgICAgdmFsdWUgKz0gbTA7XG4gICAgICAgICAgICAgIHN0YXRlID0gMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIC8vIGRlbGltaXRlciBmb3VuZCBpbiBkZWxpbWl0ZWQgaW5wdXRcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgLy8gZXNjYXBlZCBkZWxpbWl0ZXI/XG4gICAgICAgICAgICAgIGlmIChtMCA9PT0gZGVsaW1pdGVyKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gbTA7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIG51bGwgdmFsdWVcbiAgICAgICAgICAgICAgaWYgKG0wID09PSBzZXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBlbmRPZlZhbHVlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gZW5kIG9mIGVudHJ5XG4gICAgICAgICAgICAgIGlmICgvXihcXHJcXG58XFxufFxccikkLy50ZXN0KG0wKSkge1xuICAgICAgICAgICAgICAgIGVuZE9mVmFsdWUoKTtcbiAgICAgICAgICAgICAgICBlbmRPZkVudHJ5KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gYnJva2VuIHBhc2VyP1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NTVkRhdGFFcnJvcjogSWxsZWdhbCBTdGF0ZSBbUm93OicgKyBvcHRpb25zLnN0YXRlLnJvd051bSArICddW0NvbDonICsgb3B0aW9ucy5zdGF0ZS5jb2xOdW0gKyAnXScpO1xuXG4gICAgICAgICAgICAvLyB1bi1kZWxpbWl0ZWQgaW5wdXRcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgLy8gbnVsbCBsYXN0IHZhbHVlXG4gICAgICAgICAgICAgIGlmIChtMCA9PT0gc2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgZW5kT2ZWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGVuZCBvZiBlbnRyeVxuICAgICAgICAgICAgICBpZiAoL14oXFxyXFxufFxcbnxcXHIpJC8udGVzdChtMCkpIHtcbiAgICAgICAgICAgICAgICBlbmRPZlZhbHVlKCk7XG4gICAgICAgICAgICAgICAgZW5kT2ZFbnRyeSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtMCA9PT0gZGVsaW1pdGVyKSB7XG4gICAgICAgICAgICAgIC8vIG5vbi1jb21wbGlhbnQgZGF0YVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ1NWRGF0YUVycm9yOiBJbGxlZ2FsIFF1b3RlIFtSb3c6JyArIG9wdGlvbnMuc3RhdGUucm93TnVtICsgJ11bQ29sOicgKyBvcHRpb25zLnN0YXRlLmNvbE51bSArICddJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gYnJva2VuIHBhcnNlcj9cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDU1ZEYXRhRXJyb3I6IElsbGVnYWwgRGF0YSBbUm93OicgKyBvcHRpb25zLnN0YXRlLnJvd051bSArICddW0NvbDonICsgb3B0aW9ucy5zdGF0ZS5jb2xOdW0gKyAnXScpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gc2hlbmFuaWdhbnNcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDU1ZEYXRhRXJyb3I6IFVua25vd24gU3RhdGUgW1JvdzonICsgb3B0aW9ucy5zdGF0ZS5yb3dOdW0gKyAnXVtDb2w6JyArIG9wdGlvbnMuc3RhdGUuY29sTnVtICsgJ10nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ3ZhbDonICsgbTAgKyAnIHN0YXRlOicgKyBzdGF0ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHN1Ym1pdCB0aGUgbGFzdCBlbnRyeVxuICAgICAgICAvLyBpZ25vcmUgbnVsbCBsYXN0IGxpbmVcbiAgICAgICAgaWYgKGVudHJ5Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIGVuZE9mVmFsdWUoKTtcbiAgICAgICAgICBlbmRPZkVudHJ5KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIGEgY3N2LXNwZWNpZmljIGxpbmUgc3BsaXR0ZXJcbiAgICAgIHNwbGl0TGluZXM6IGZ1bmN0aW9uIChjc3YsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFjc3YpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgLy8gY2FjaGUgc2V0dGluZ3NcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9IG9wdGlvbnMuc2VwYXJhdG9yIHx8ICQuY3N2LmRlZmF1bHRzLnNlcGFyYXRvcjtcbiAgICAgICAgdmFyIGRlbGltaXRlciA9IG9wdGlvbnMuZGVsaW1pdGVyIHx8ICQuY3N2LmRlZmF1bHRzLmRlbGltaXRlcjtcblxuICAgICAgICAvLyBzZXQgaW5pdGlhbCBzdGF0ZSBpZiBpdCdzIG1pc3NpbmdcbiAgICAgICAgb3B0aW9ucy5zdGF0ZSA9IG9wdGlvbnMuc3RhdGUgfHwge307XG4gICAgICAgIGlmICghb3B0aW9ucy5zdGF0ZS5yb3dOdW0pIHtcbiAgICAgICAgICBvcHRpb25zLnN0YXRlLnJvd051bSA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhciBpbml0aWFsIHN0YXRlXG4gICAgICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgICAgIHZhciBzdGF0ZSA9IDA7XG4gICAgICAgIHZhciBlbnRyeSA9ICcnO1xuICAgICAgICB2YXIgZXhpdCA9IGZhbHNlO1xuXG4gICAgICAgIGZ1bmN0aW9uIGVuZE9mTGluZSAoKSB7XG4gICAgICAgICAgLy8gcmVzZXQgdGhlIHN0YXRlXG4gICAgICAgICAgc3RhdGUgPSAwO1xuXG4gICAgICAgICAgLy8gaWYgJ3N0YXJ0JyBoYXNuJ3QgYmVlbiBtZXQsIGRvbid0IG91dHB1dFxuICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0ICYmIG9wdGlvbnMuc3RhdGUucm93TnVtIDwgb3B0aW9ucy5zdGFydCkge1xuICAgICAgICAgICAgLy8gdXBkYXRlIGdsb2JhbCBzdGF0ZVxuICAgICAgICAgICAgZW50cnkgPSAnJztcbiAgICAgICAgICAgIG9wdGlvbnMuc3RhdGUucm93TnVtKys7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMub25QYXJzZUVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIG9uUGFyc2VFbnRyeSBob29rIG5vdCBzZXRcbiAgICAgICAgICAgIGVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBob29rVmFsID0gb3B0aW9ucy5vblBhcnNlRW50cnkoZW50cnksIG9wdGlvbnMuc3RhdGUpOyAvLyBvblBhcnNlRW50cnkgSG9va1xuICAgICAgICAgICAgLy8gZmFsc2Ugc2tpcHMgdGhlIHJvdywgY29uZmlndXJhYmxlIHRocm91Z2ggYSBob29rXG4gICAgICAgICAgICBpZiAoaG9va1ZhbCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgZW50cmllcy5wdXNoKGhvb2tWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGNsZWFudXBcbiAgICAgICAgICBlbnRyeSA9ICcnO1xuXG4gICAgICAgICAgLy8gaWYgJ2VuZCcgaXMgbWV0LCBzdG9wIHBhcnNpbmdcbiAgICAgICAgICBpZiAob3B0aW9ucy5lbmQgJiYgb3B0aW9ucy5zdGF0ZS5yb3dOdW0gPj0gb3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHVwZGF0ZSBnbG9iYWwgc3RhdGVcbiAgICAgICAgICBvcHRpb25zLnN0YXRlLnJvd051bSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZXNjYXBlIHJlZ2V4LXNwZWNpZmljIGNvbnRyb2wgY2hhcnNcbiAgICAgICAgdmFyIGVzY1NlcGFyYXRvciA9IFJlZ0V4cC5lc2NhcGUoc2VwYXJhdG9yKTtcbiAgICAgICAgdmFyIGVzY0RlbGltaXRlciA9IFJlZ0V4cC5lc2NhcGUoZGVsaW1pdGVyKTtcblxuICAgICAgICAvLyBjb21waWxlIHRoZSByZWdFeCBzdHIgdXNpbmcgdGhlIGN1c3RvbSBkZWxpbWl0ZXIvc2VwYXJhdG9yXG4gICAgICAgIHZhciBtYXRjaCA9IC8oRHxTfFxcbnxcXHJ8W15EU1xcclxcbl0rKS87XG4gICAgICAgIHZhciBtYXRjaFNyYyA9IG1hdGNoLnNvdXJjZTtcbiAgICAgICAgbWF0Y2hTcmMgPSBtYXRjaFNyYy5yZXBsYWNlKC9TL2csIGVzY1NlcGFyYXRvcik7XG4gICAgICAgIG1hdGNoU3JjID0gbWF0Y2hTcmMucmVwbGFjZSgvRC9nLCBlc2NEZWxpbWl0ZXIpO1xuICAgICAgICBtYXRjaCA9IG5ldyBSZWdFeHAobWF0Y2hTcmMsICdnbScpO1xuXG4gICAgICAgIC8vIHB1dCBvbiB5b3VyIGZhbmN5IHBhbnRzLi4uXG4gICAgICAgIC8vIHByb2Nlc3MgY29udHJvbCBjaGFycyBpbmRpdmlkdWFsbHksIHVzZSBsb29rLWFoZWFkIG9uIG5vbi1jb250cm9sIGNoYXJzXG4gICAgICAgIGNzdi5yZXBsYWNlKG1hdGNoLCBmdW5jdGlvbiAobTApIHtcbiAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgICAgICAvLyB0aGUgc3RhcnQgb2YgYSB2YWx1ZS9lbnRyeVxuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAvLyBudWxsIHZhbHVlXG4gICAgICAgICAgICAgIGlmIChtMCA9PT0gc2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgZW50cnkgKz0gbTA7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIG9wZW5pbmcgZGVsaW1pdGVyXG4gICAgICAgICAgICAgIGlmIChtMCA9PT0gZGVsaW1pdGVyKSB7XG4gICAgICAgICAgICAgICAgZW50cnkgKz0gbTA7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGVuZCBvZiBsaW5lXG4gICAgICAgICAgICAgIGlmIChtMCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICBlbmRPZkxpbmUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBwaGFudG9tIGNhcnJpYWdlIHJldHVyblxuICAgICAgICAgICAgICBpZiAoL15cXHIkLy50ZXN0KG0wKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIHVuLWRlbGltaXQgdmFsdWVcbiAgICAgICAgICAgICAgZW50cnkgKz0gbTA7XG4gICAgICAgICAgICAgIHN0YXRlID0gMztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIC8vIGRlbGltaXRlZCBpbnB1dFxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAvLyBzZWNvbmQgZGVsaW1pdGVyPyBjaGVjayBmdXJ0aGVyXG4gICAgICAgICAgICAgIGlmIChtMCA9PT0gZGVsaW1pdGVyKSB7XG4gICAgICAgICAgICAgICAgZW50cnkgKz0gbTA7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGRlbGltaXRlZCBkYXRhXG4gICAgICAgICAgICAgIGVudHJ5ICs9IG0wO1xuICAgICAgICAgICAgICBzdGF0ZSA9IDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAvLyBkZWxpbWl0ZXIgZm91bmQgaW4gZGVsaW1pdGVkIGlucHV0XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIC8vIGVzY2FwZWQgZGVsaW1pdGVyP1xuICAgICAgICAgICAgICB2YXIgcHJldkNoYXIgPSBlbnRyeS5zdWJzdHIoZW50cnkubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgIGlmIChtMCA9PT0gZGVsaW1pdGVyICYmIHByZXZDaGFyID09PSBkZWxpbWl0ZXIpIHtcbiAgICAgICAgICAgICAgICBlbnRyeSArPSBtMDtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gZW5kIG9mIHZhbHVlXG4gICAgICAgICAgICAgIGlmIChtMCA9PT0gc2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgZW50cnkgKz0gbTA7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGVuZCBvZiBsaW5lXG4gICAgICAgICAgICAgIGlmIChtMCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICBlbmRPZkxpbmUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBwaGFudG9tIGNhcnJpYWdlIHJldHVyblxuICAgICAgICAgICAgICBpZiAobTAgPT09ICdcXHInKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gYnJva2VuIHBhc2VyP1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NTVkRhdGFFcnJvcjogSWxsZWdhbCBzdGF0ZSBbUm93OicgKyBvcHRpb25zLnN0YXRlLnJvd051bSArICddJyk7XG5cbiAgICAgICAgICAgIC8vIHVuLWRlbGltaXRlZCBpbnB1dFxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAvLyBudWxsIHZhbHVlXG4gICAgICAgICAgICAgIGlmIChtMCA9PT0gc2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgZW50cnkgKz0gbTA7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGVuZCBvZiBsaW5lXG4gICAgICAgICAgICAgIGlmIChtMCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICBlbmRPZkxpbmUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBwaGFudG9tIGNhcnJpYWdlIHJldHVyblxuICAgICAgICAgICAgICBpZiAobTAgPT09ICdcXHInKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gbm9uLWNvbXBsaWFudCBkYXRhXG4gICAgICAgICAgICAgIGlmIChtMCA9PT0gZGVsaW1pdGVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDU1ZEYXRhRXJyb3I6IElsbGVnYWwgcXVvdGUgW1JvdzonICsgb3B0aW9ucy5zdGF0ZS5yb3dOdW0gKyAnXScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBwYXJzZXI/XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ1NWRGF0YUVycm9yOiBJbGxlZ2FsIHN0YXRlIFtSb3c6JyArIG9wdGlvbnMuc3RhdGUucm93TnVtICsgJ10nKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIHNoZW5hbmlnYW5zXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ1NWRGF0YUVycm9yOiBVbmtub3duIHN0YXRlIFtSb3c6JyArIG9wdGlvbnMuc3RhdGUucm93TnVtICsgJ10nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ3ZhbDonICsgbTAgKyAnIHN0YXRlOicgKyBzdGF0ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHN1Ym1pdCB0aGUgbGFzdCBlbnRyeVxuICAgICAgICAvLyBpZ25vcmUgbnVsbCBsYXN0IGxpbmVcbiAgICAgICAgaWYgKGVudHJ5ICE9PSAnJykge1xuICAgICAgICAgIGVuZE9mTGluZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgICB9LFxuXG4gICAgICAvLyBhIGNzdiBlbnRyeSBwYXJzZXJcbiAgICAgIHBhcnNlRW50cnk6IGZ1bmN0aW9uIChjc3YsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gY2FjaGUgc2V0dGluZ3NcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9IG9wdGlvbnMuc2VwYXJhdG9yO1xuICAgICAgICB2YXIgZGVsaW1pdGVyID0gb3B0aW9ucy5kZWxpbWl0ZXI7XG5cbiAgICAgICAgLy8gc2V0IGluaXRpYWwgc3RhdGUgaWYgaXQncyBtaXNzaW5nXG4gICAgICAgIGlmICghb3B0aW9ucy5zdGF0ZS5yb3dOdW0pIHtcbiAgICAgICAgICBvcHRpb25zLnN0YXRlLnJvd051bSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLnN0YXRlLmNvbE51bSkge1xuICAgICAgICAgIG9wdGlvbnMuc3RhdGUuY29sTnVtID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIGluaXRpYWwgc3RhdGVcbiAgICAgICAgdmFyIGVudHJ5ID0gW107XG4gICAgICAgIHZhciBzdGF0ZSA9IDA7XG4gICAgICAgIHZhciB2YWx1ZSA9ICcnO1xuXG4gICAgICAgIGZ1bmN0aW9uIGVuZE9mVmFsdWUgKCkge1xuICAgICAgICAgIGlmIChvcHRpb25zLm9uUGFyc2VWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBvblBhcnNlVmFsdWUgaG9vayBub3Qgc2V0XG4gICAgICAgICAgICBlbnRyeS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhvb2sgPSBvcHRpb25zLm9uUGFyc2VWYWx1ZSh2YWx1ZSwgb3B0aW9ucy5zdGF0ZSk7IC8vIG9uUGFyc2VWYWx1ZSBIb29rXG4gICAgICAgICAgICAvLyBmYWxzZSBza2lwcyB0aGUgdmFsdWUsIGNvbmZpZ3VyYWJsZSB0aHJvdWdoIGEgaG9va1xuICAgICAgICAgICAgaWYgKGhvb2sgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGVudHJ5LnB1c2goaG9vayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHJlc2V0IHRoZSBzdGF0ZVxuICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgIC8vIHVwZGF0ZSBnbG9iYWwgc3RhdGVcbiAgICAgICAgICBvcHRpb25zLnN0YXRlLmNvbE51bSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2tlZCBmb3IgYSBjYWNoZWQgcmVnRXggZmlyc3RcbiAgICAgICAgaWYgKCFvcHRpb25zLm1hdGNoKSB7XG4gICAgICAgICAgLy8gZXNjYXBlIHJlZ2V4LXNwZWNpZmljIGNvbnRyb2wgY2hhcnNcbiAgICAgICAgICB2YXIgZXNjU2VwYXJhdG9yID0gUmVnRXhwLmVzY2FwZShzZXBhcmF0b3IpO1xuICAgICAgICAgIHZhciBlc2NEZWxpbWl0ZXIgPSBSZWdFeHAuZXNjYXBlKGRlbGltaXRlcik7XG5cbiAgICAgICAgICAvLyBjb21waWxlIHRoZSByZWdFeCBzdHIgdXNpbmcgdGhlIGN1c3RvbSBkZWxpbWl0ZXIvc2VwYXJhdG9yXG4gICAgICAgICAgdmFyIG1hdGNoID0gLyhEfFN8XFxufFxccnxbXkRTXFxyXFxuXSspLztcbiAgICAgICAgICB2YXIgbWF0Y2hTcmMgPSBtYXRjaC5zb3VyY2U7XG4gICAgICAgICAgbWF0Y2hTcmMgPSBtYXRjaFNyYy5yZXBsYWNlKC9TL2csIGVzY1NlcGFyYXRvcik7XG4gICAgICAgICAgbWF0Y2hTcmMgPSBtYXRjaFNyYy5yZXBsYWNlKC9EL2csIGVzY0RlbGltaXRlcik7XG4gICAgICAgICAgb3B0aW9ucy5tYXRjaCA9IG5ldyBSZWdFeHAobWF0Y2hTcmMsICdnbScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHV0IG9uIHlvdXIgZmFuY3kgcGFudHMuLi5cbiAgICAgICAgLy8gcHJvY2VzcyBjb250cm9sIGNoYXJzIGluZGl2aWR1YWxseSwgdXNlIGxvb2stYWhlYWQgb24gbm9uLWNvbnRyb2wgY2hhcnNcbiAgICAgICAgY3N2LnJlcGxhY2Uob3B0aW9ucy5tYXRjaCwgZnVuY3Rpb24gKG0wKSB7XG4gICAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgLy8gdGhlIHN0YXJ0IG9mIGEgdmFsdWVcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgLy8gbnVsbCBsYXN0IHZhbHVlXG4gICAgICAgICAgICAgIGlmIChtMCA9PT0gc2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gJyc7XG4gICAgICAgICAgICAgICAgZW5kT2ZWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIG9wZW5pbmcgZGVsaW1pdGVyXG4gICAgICAgICAgICAgIGlmIChtMCA9PT0gZGVsaW1pdGVyKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIHNraXAgdW4tZGVsaW1pdGVkIG5ldy1saW5lc1xuICAgICAgICAgICAgICBpZiAobTAgPT09ICdcXG4nIHx8IG0wID09PSAnXFxyJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIHVuLWRlbGltaXRlZCB2YWx1ZVxuICAgICAgICAgICAgICB2YWx1ZSArPSBtMDtcbiAgICAgICAgICAgICAgc3RhdGUgPSAzO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgLy8gZGVsaW1pdGVkIGlucHV0XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIC8vIHNlY29uZCBkZWxpbWl0ZXI/IGNoZWNrIGZ1cnRoZXJcbiAgICAgICAgICAgICAgaWYgKG0wID09PSBkZWxpbWl0ZXIpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gZGVsaW1pdGVkIGRhdGFcbiAgICAgICAgICAgICAgdmFsdWUgKz0gbTA7XG4gICAgICAgICAgICAgIHN0YXRlID0gMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIC8vIGRlbGltaXRlciBmb3VuZCBpbiBkZWxpbWl0ZWQgaW5wdXRcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgLy8gZXNjYXBlZCBkZWxpbWl0ZXI/XG4gICAgICAgICAgICAgIGlmIChtMCA9PT0gZGVsaW1pdGVyKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gbTA7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIG51bGwgdmFsdWVcbiAgICAgICAgICAgICAgaWYgKG0wID09PSBzZXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBlbmRPZlZhbHVlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gc2tpcCB1bi1kZWxpbWl0ZWQgbmV3LWxpbmVzXG4gICAgICAgICAgICAgIGlmIChtMCA9PT0gJ1xcbicgfHwgbTAgPT09ICdcXHInKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gYnJva2VuIHBhc2VyP1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NTVkRhdGFFcnJvcjogSWxsZWdhbCBTdGF0ZSBbUm93OicgKyBvcHRpb25zLnN0YXRlLnJvd051bSArICddW0NvbDonICsgb3B0aW9ucy5zdGF0ZS5jb2xOdW0gKyAnXScpO1xuXG4gICAgICAgICAgICAvLyB1bi1kZWxpbWl0ZWQgaW5wdXRcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgLy8gbnVsbCBsYXN0IHZhbHVlXG4gICAgICAgICAgICAgIGlmIChtMCA9PT0gc2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgZW5kT2ZWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIHNraXAgdW4tZGVsaW1pdGVkIG5ldy1saW5lc1xuICAgICAgICAgICAgICBpZiAobTAgPT09ICdcXG4nIHx8IG0wID09PSAnXFxyJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIG5vbi1jb21wbGlhbnQgZGF0YVxuICAgICAgICAgICAgICBpZiAobTAgPT09IGRlbGltaXRlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ1NWRGF0YUVycm9yOiBJbGxlZ2FsIFF1b3RlIFtSb3c6JyArIG9wdGlvbnMuc3RhdGUucm93TnVtICsgJ11bQ29sOicgKyBvcHRpb25zLnN0YXRlLmNvbE51bSArICddJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gYnJva2VuIHBhcnNlcj9cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDU1ZEYXRhRXJyb3I6IElsbGVnYWwgRGF0YSBbUm93OicgKyBvcHRpb25zLnN0YXRlLnJvd051bSArICddW0NvbDonICsgb3B0aW9ucy5zdGF0ZS5jb2xOdW0gKyAnXScpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gc2hlbmFuaWdhbnNcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDU1ZEYXRhRXJyb3I6IFVua25vd24gU3RhdGUgW1JvdzonICsgb3B0aW9ucy5zdGF0ZS5yb3dOdW0gKyAnXVtDb2w6JyArIG9wdGlvbnMuc3RhdGUuY29sTnVtICsgJ10nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ3ZhbDonICsgbTAgKyAnIHN0YXRlOicgKyBzdGF0ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHN1Ym1pdCB0aGUgbGFzdCB2YWx1ZVxuICAgICAgICBlbmRPZlZhbHVlKCk7XG5cbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBoZWxwZXJzOiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogJC5jc3YuaGVscGVycy5jb2xsZWN0UHJvcGVydHlOYW1lcyhvYmplY3RzQXJyYXkpXG4gICAgICAgKiBDb2xsZWN0cyBhbGwgdW5pcXVlIHByb3BlcnR5IG5hbWVzIGZyb20gYWxsIHBhc3NlZCBvYmplY3RzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IG9iamVjdHMgT2JqZWN0cyB0byBjb2xsZWN0IHByb3BlcnRpZXMgZnJvbS5cbiAgICAgICAqXG4gICAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIChhcnJheSB3aWxsIGJlIGVtcHR5LFxuICAgICAgICogaWYgb2JqZWN0cyBoYXZlIG5vIG93biBwcm9wZXJ0aWVzKS5cbiAgICAgICAqL1xuICAgICAgY29sbGVjdFByb3BlcnR5TmFtZXM6IGZ1bmN0aW9uIChvYmplY3RzKSB7XG4gICAgICAgIHZhciBvID0gW107XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IFtdO1xuICAgICAgICB2YXIgcHJvcHMgPSBbXTtcbiAgICAgICAgZm9yIChvIGluIG9iamVjdHMpIHtcbiAgICAgICAgICBmb3IgKHByb3BOYW1lIGluIG9iamVjdHNbb10pIHtcbiAgICAgICAgICAgIGlmICgob2JqZWN0c1tvXS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpICYmXG4gICAgICAgICAgICAgICAgKHByb3BzLmluZGV4T2YocHJvcE5hbWUpIDwgMCkgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIG9iamVjdHNbb11bcHJvcE5hbWVdICE9PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgICBwcm9wcy5wdXNoKHByb3BOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BzO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiAkLmNzdi50b0FycmF5KGNzdilcbiAgICAgKiBDb252ZXJ0cyBhIENTViBlbnRyeSBzdHJpbmcgdG8gYSBqYXZhc2NyaXB0IGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gY3N2IFRoZSBzdHJpbmcgY29udGFpbmluZyB0aGUgQ1NWIGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyB1c2VyLWRlZmluZWQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge0NoYXJhY3Rlcn0gW3NlcGFyYXRvcl0gQW4gb3ZlcnJpZGUgZm9yIHRoZSBzZXBhcmF0b3IgY2hhcmFjdGVyLiBEZWZhdWx0cyB0byBhIGNvbW1hKCwpLlxuICAgICAqIEBwYXJhbSB7Q2hhcmFjdGVyfSBbZGVsaW1pdGVyXSBBbiBvdmVycmlkZSBmb3IgdGhlIGRlbGltaXRlciBjaGFyYWN0ZXIuIERlZmF1bHRzIHRvIGEgZG91YmxlLXF1b3RlKFwiKS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGRlYWxzIHdpdGggc2ltcGxlIENTViBzdHJpbmdzIG9ubHkuIEl0J3MgdXNlZnVsIGlmIHlvdSBvbmx5XG4gICAgICogbmVlZCB0byBwYXJzZSBhIHNpbmdsZSBlbnRyeS4gSWYgeW91IG5lZWQgdG8gcGFyc2UgbW9yZSB0aGFuIG9uZSBsaW5lLFxuICAgICAqIHVzZSAkLmNzdjJBcnJheSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIHRvQXJyYXk6IGZ1bmN0aW9uIChjc3YsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICBvcHRpb25zID0gKG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMgOiB7fSk7XG4gICAgICB2YXIgY29uZmlnID0ge307XG4gICAgICBjb25maWcuY2FsbGJhY2sgPSAoKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIChjYWxsYmFjaykgPT09ICdmdW5jdGlvbicpID8gY2FsbGJhY2sgOiBmYWxzZSk7XG4gICAgICBjb25maWcuc2VwYXJhdG9yID0gJ3NlcGFyYXRvcicgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc2VwYXJhdG9yIDogJC5jc3YuZGVmYXVsdHMuc2VwYXJhdG9yO1xuICAgICAgY29uZmlnLmRlbGltaXRlciA9ICdkZWxpbWl0ZXInIGluIG9wdGlvbnMgPyBvcHRpb25zLmRlbGltaXRlciA6ICQuY3N2LmRlZmF1bHRzLmRlbGltaXRlcjtcbiAgICAgIHZhciBzdGF0ZSA9IChvcHRpb25zLnN0YXRlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0YXRlIDoge30pO1xuXG4gICAgICAvLyBzZXR1cFxuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgZGVsaW1pdGVyOiBjb25maWcuZGVsaW1pdGVyLFxuICAgICAgICBzZXBhcmF0b3I6IGNvbmZpZy5zZXBhcmF0b3IsXG4gICAgICAgIG9uUGFyc2VFbnRyeTogb3B0aW9ucy5vblBhcnNlRW50cnksXG4gICAgICAgIG9uUGFyc2VWYWx1ZTogb3B0aW9ucy5vblBhcnNlVmFsdWUsXG4gICAgICAgIHN0YXRlOiBzdGF0ZVxuICAgICAgfTtcblxuICAgICAgdmFyIGVudHJ5ID0gJC5jc3YucGFyc2Vycy5wYXJzZUVudHJ5KGNzdiwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIHB1c2ggdGhlIHZhbHVlIHRvIGEgY2FsbGJhY2sgaWYgb25lIGlzIGRlZmluZWRcbiAgICAgIGlmICghY29uZmlnLmNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbmZpZy5jYWxsYmFjaygnJywgZW50cnkpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiAkLmNzdi50b0FycmF5cyhjc3YpXG4gICAgICogQ29udmVydHMgYSBDU1Ygc3RyaW5nIHRvIGEgamF2YXNjcmlwdCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjc3YgVGhlIHN0cmluZyBjb250YWluaW5nIHRoZSByYXcgQ1NWIGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyB1c2VyLWRlZmluZWQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge0NoYXJhY3Rlcn0gW3NlcGFyYXRvcl0gQW4gb3ZlcnJpZGUgZm9yIHRoZSBzZXBhcmF0b3IgY2hhcmFjdGVyLiBEZWZhdWx0cyB0byBhIGNvbW1hKCwpLlxuICAgICAqIEBwYXJhbSB7Q2hhcmFjdGVyfSBbZGVsaW1pdGVyXSBBbiBvdmVycmlkZSBmb3IgdGhlIGRlbGltaXRlciBjaGFyYWN0ZXIuIERlZmF1bHRzIHRvIGEgZG91YmxlLXF1b3RlKFwiKS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGRlYWxzIHdpdGggbXVsdGktbGluZSBDU1YuIFRoZSBicmVha2Rvd24gaXMgc2ltcGxlLiBUaGUgZmlyc3RcbiAgICAgKiBkaW1lbnNpb24gb2YgdGhlIGFycmF5IHJlcHJlc2VudHMgdGhlIGxpbmUgKG9yIGVudHJ5L3Jvdykgd2hpbGUgdGhlIHNlY29uZFxuICAgICAqIGRpbWVuc2lvbiBjb250YWlucyB0aGUgdmFsdWVzIChvciB2YWx1ZXMvY29sdW1ucykuXG4gICAgICovXG4gICAgdG9BcnJheXM6IGZ1bmN0aW9uIChjc3YsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICBvcHRpb25zID0gKG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMgOiB7fSk7XG4gICAgICB2YXIgY29uZmlnID0ge307XG4gICAgICBjb25maWcuY2FsbGJhY2sgPSAoKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIChjYWxsYmFjaykgPT09ICdmdW5jdGlvbicpID8gY2FsbGJhY2sgOiBmYWxzZSk7XG4gICAgICBjb25maWcuc2VwYXJhdG9yID0gJ3NlcGFyYXRvcicgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc2VwYXJhdG9yIDogJC5jc3YuZGVmYXVsdHMuc2VwYXJhdG9yO1xuICAgICAgY29uZmlnLmRlbGltaXRlciA9ICdkZWxpbWl0ZXInIGluIG9wdGlvbnMgPyBvcHRpb25zLmRlbGltaXRlciA6ICQuY3N2LmRlZmF1bHRzLmRlbGltaXRlcjtcblxuICAgICAgLy8gc2V0dXBcbiAgICAgIHZhciBkYXRhID0gW107XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBkZWxpbWl0ZXI6IGNvbmZpZy5kZWxpbWl0ZXIsXG4gICAgICAgIHNlcGFyYXRvcjogY29uZmlnLnNlcGFyYXRvcixcbiAgICAgICAgb25QcmVQYXJzZTogb3B0aW9ucy5vblByZVBhcnNlLFxuICAgICAgICBvblBhcnNlRW50cnk6IG9wdGlvbnMub25QYXJzZUVudHJ5LFxuICAgICAgICBvblBhcnNlVmFsdWU6IG9wdGlvbnMub25QYXJzZVZhbHVlLFxuICAgICAgICBvblBvc3RQYXJzZTogb3B0aW9ucy5vblBvc3RQYXJzZSxcbiAgICAgICAgc3RhcnQ6IG9wdGlvbnMuc3RhcnQsXG4gICAgICAgIGVuZDogb3B0aW9ucy5lbmQsXG4gICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgcm93TnVtOiAxLFxuICAgICAgICAgIGNvbE51bTogMVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBvblByZVBhcnNlIGhvb2tcbiAgICAgIGlmIChvcHRpb25zLm9uUHJlUGFyc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLm9uUHJlUGFyc2UoY3N2LCBvcHRpb25zLnN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgLy8gcGFyc2UgdGhlIGRhdGFcbiAgICAgIGRhdGEgPSAkLmNzdi5wYXJzZXJzLnBhcnNlKGNzdiwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIG9uUG9zdFBhcnNlIGhvb2tcbiAgICAgIGlmIChvcHRpb25zLm9uUG9zdFBhcnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5vblBvc3RQYXJzZShkYXRhLCBvcHRpb25zLnN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgLy8gcHVzaCB0aGUgdmFsdWUgdG8gYSBjYWxsYmFjayBpZiBvbmUgaXMgZGVmaW5lZFxuICAgICAgaWYgKCFjb25maWcuY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25maWcuY2FsbGJhY2soJycsIGRhdGEpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiAkLmNzdi50b09iamVjdHMoY3N2KVxuICAgICAqIENvbnZlcnRzIGEgQ1NWIHN0cmluZyB0byBhIGphdmFzY3JpcHQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjc3YgVGhlIHN0cmluZyBjb250YWluaW5nIHRoZSByYXcgQ1NWIGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyB1c2VyLWRlZmluZWQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge0NoYXJhY3Rlcn0gW3NlcGFyYXRvcl0gQW4gb3ZlcnJpZGUgZm9yIHRoZSBzZXBhcmF0b3IgY2hhcmFjdGVyLiBEZWZhdWx0cyB0byBhIGNvbW1hKCwpLlxuICAgICAqIEBwYXJhbSB7Q2hhcmFjdGVyfSBbZGVsaW1pdGVyXSBBbiBvdmVycmlkZSBmb3IgdGhlIGRlbGltaXRlciBjaGFyYWN0ZXIuIERlZmF1bHRzIHRvIGEgZG91YmxlLXF1b3RlKFwiKS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtoZWFkZXJzXSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGF0YSBjb250YWlucyBhIGhlYWRlciBsaW5lLiBEZWZhdWx0cyB0byB0cnVlLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZGVhbHMgd2l0aCBtdWx0aS1saW5lIENTViBzdHJpbmdzLiBXaGVyZSB0aGUgaGVhZGVycyBsaW5lIGlzXG4gICAgICogdXNlZCBhcyB0aGUga2V5IGZvciBlYWNoIHZhbHVlIHBlciBlbnRyeS5cbiAgICAgKi9cbiAgICB0b09iamVjdHM6IGZ1bmN0aW9uIChjc3YsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICBvcHRpb25zID0gKG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMgOiB7fSk7XG4gICAgICB2YXIgY29uZmlnID0ge307XG4gICAgICBjb25maWcuY2FsbGJhY2sgPSAoKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIChjYWxsYmFjaykgPT09ICdmdW5jdGlvbicpID8gY2FsbGJhY2sgOiBmYWxzZSk7XG4gICAgICBjb25maWcuc2VwYXJhdG9yID0gJ3NlcGFyYXRvcicgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc2VwYXJhdG9yIDogJC5jc3YuZGVmYXVsdHMuc2VwYXJhdG9yO1xuICAgICAgY29uZmlnLmRlbGltaXRlciA9ICdkZWxpbWl0ZXInIGluIG9wdGlvbnMgPyBvcHRpb25zLmRlbGltaXRlciA6ICQuY3N2LmRlZmF1bHRzLmRlbGltaXRlcjtcbiAgICAgIGNvbmZpZy5oZWFkZXJzID0gJ2hlYWRlcnMnIGluIG9wdGlvbnMgPyBvcHRpb25zLmhlYWRlcnMgOiAkLmNzdi5kZWZhdWx0cy5oZWFkZXJzO1xuICAgICAgb3B0aW9ucy5zdGFydCA9ICdzdGFydCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhcnQgOiAxO1xuXG4gICAgICAvLyBhY2NvdW50IGZvciBoZWFkZXJzXG4gICAgICBpZiAoY29uZmlnLmhlYWRlcnMpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCsrO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZW5kICYmIGNvbmZpZy5oZWFkZXJzKSB7XG4gICAgICAgIG9wdGlvbnMuZW5kKys7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldHVwXG4gICAgICB2YXIgbGluZXMgPSBbXTtcbiAgICAgIHZhciBkYXRhID0gW107XG5cbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIGRlbGltaXRlcjogY29uZmlnLmRlbGltaXRlcixcbiAgICAgICAgc2VwYXJhdG9yOiBjb25maWcuc2VwYXJhdG9yLFxuICAgICAgICBvblByZVBhcnNlOiBvcHRpb25zLm9uUHJlUGFyc2UsXG4gICAgICAgIG9uUGFyc2VFbnRyeTogb3B0aW9ucy5vblBhcnNlRW50cnksXG4gICAgICAgIG9uUGFyc2VWYWx1ZTogb3B0aW9ucy5vblBhcnNlVmFsdWUsXG4gICAgICAgIG9uUG9zdFBhcnNlOiBvcHRpb25zLm9uUG9zdFBhcnNlLFxuICAgICAgICBzdGFydDogb3B0aW9ucy5zdGFydCxcbiAgICAgICAgZW5kOiBvcHRpb25zLmVuZCxcbiAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICByb3dOdW06IDEsXG4gICAgICAgICAgY29sTnVtOiAxXG4gICAgICAgIH0sXG4gICAgICAgIG1hdGNoOiBmYWxzZSxcbiAgICAgICAgdHJhbnNmb3JtOiBvcHRpb25zLnRyYW5zZm9ybVxuICAgICAgfTtcblxuICAgICAgLy8gZmV0Y2ggdGhlIGhlYWRlcnNcbiAgICAgIHZhciBoZWFkZXJPcHRpb25zID0ge1xuICAgICAgICBkZWxpbWl0ZXI6IGNvbmZpZy5kZWxpbWl0ZXIsXG4gICAgICAgIHNlcGFyYXRvcjogY29uZmlnLnNlcGFyYXRvcixcbiAgICAgICAgc3RhcnQ6IDEsXG4gICAgICAgIGVuZDogMSxcbiAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICByb3dOdW06IDEsXG4gICAgICAgICAgY29sTnVtOiAxXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIG9uUHJlUGFyc2UgaG9va1xuICAgICAgaWYgKG9wdGlvbnMub25QcmVQYXJzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMub25QcmVQYXJzZShjc3YsIG9wdGlvbnMuc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBwYXJzZSB0aGUgY3N2XG4gICAgICB2YXIgaGVhZGVyTGluZSA9ICQuY3N2LnBhcnNlcnMuc3BsaXRMaW5lcyhjc3YsIGhlYWRlck9wdGlvbnMpO1xuICAgICAgdmFyIGhlYWRlcnMgPSAkLmNzdi50b0FycmF5KGhlYWRlckxpbmVbMF0sIG9wdGlvbnMpO1xuXG4gICAgICAvLyBmZXRjaCB0aGUgZGF0YVxuICAgICAgbGluZXMgPSAkLmNzdi5wYXJzZXJzLnNwbGl0TGluZXMoY3N2LCBvcHRpb25zKTtcblxuICAgICAgLy8gcmVzZXQgdGhlIHN0YXRlIGZvciByZS11c2VcbiAgICAgIG9wdGlvbnMuc3RhdGUuY29sTnVtID0gMTtcbiAgICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAgIG9wdGlvbnMuc3RhdGUucm93TnVtID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuc3RhdGUucm93TnVtID0gMTtcbiAgICAgIH1cblxuICAgICAgLy8gY29udmVydCBkYXRhIHRvIG9iamVjdHNcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgZW50cnkgPSAkLmNzdi50b0FycmF5KGxpbmVzW2ldLCBvcHRpb25zKTtcbiAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGhlYWRlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBvYmplY3RbaGVhZGVyc1tqXV0gPSBlbnRyeVtqXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy50cmFuc2Zvcm0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRhdGEucHVzaChvcHRpb25zLnRyYW5zZm9ybS5jYWxsKHVuZGVmaW5lZCwgb2JqZWN0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YS5wdXNoKG9iamVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgcm93IHN0YXRlXG4gICAgICAgIG9wdGlvbnMuc3RhdGUucm93TnVtKys7XG4gICAgICB9XG5cbiAgICAgIC8vIG9uUG9zdFBhcnNlIGhvb2tcbiAgICAgIGlmIChvcHRpb25zLm9uUG9zdFBhcnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5vblBvc3RQYXJzZShkYXRhLCBvcHRpb25zLnN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgLy8gcHVzaCB0aGUgdmFsdWUgdG8gYSBjYWxsYmFjayBpZiBvbmUgaXMgZGVmaW5lZFxuICAgICAgaWYgKCFjb25maWcuY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25maWcuY2FsbGJhY2soJycsIGRhdGEpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqICQuY3N2LmZyb21BcnJheXMoYXJyYXlzKVxuICAgICogQ29udmVydHMgYSBqYXZhc2NyaXB0IGFycmF5IHRvIGEgQ1NWIFN0cmluZy5cbiAgICAqXG4gICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheXMgQW4gYXJyYXkgY29udGFpbmluZyBhbiBhcnJheSBvZiBDU1YgZW50cmllcy5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdXNlci1kZWZpbmVkIG9wdGlvbnMuXG4gICAgKiBAcGFyYW0ge0NoYXJhY3Rlcn0gW3NlcGFyYXRvcl0gQW4gb3ZlcnJpZGUgZm9yIHRoZSBzZXBhcmF0b3IgY2hhcmFjdGVyLiBEZWZhdWx0cyB0byBhIGNvbW1hKCwpLlxuICAgICogQHBhcmFtIHtDaGFyYWN0ZXJ9IFtkZWxpbWl0ZXJdIEFuIG92ZXJyaWRlIGZvciB0aGUgZGVsaW1pdGVyIGNoYXJhY3Rlci4gRGVmYXVsdHMgdG8gYSBkb3VibGUtcXVvdGUoXCIpLlxuICAgICpcbiAgICAqIFRoaXMgbWV0aG9kIGdlbmVyYXRlcyBhIENTViBmaWxlIGZyb20gYW4gYXJyYXkgb2YgYXJyYXlzIChyZXByZXNlbnRpbmcgZW50cmllcykuXG4gICAgKi9cbiAgICBmcm9tQXJyYXlzOiBmdW5jdGlvbiAoYXJyYXlzLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgb3B0aW9ucyA9IChvcHRpb25zICE9PSB1bmRlZmluZWQgPyBvcHRpb25zIDoge30pO1xuICAgICAgdmFyIGNvbmZpZyA9IHt9O1xuICAgICAgY29uZmlnLmNhbGxiYWNrID0gKChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiAoY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSA/IGNhbGxiYWNrIDogZmFsc2UpO1xuICAgICAgY29uZmlnLnNlcGFyYXRvciA9ICdzZXBhcmF0b3InIGluIG9wdGlvbnMgPyBvcHRpb25zLnNlcGFyYXRvciA6ICQuY3N2LmRlZmF1bHRzLnNlcGFyYXRvcjtcbiAgICAgIGNvbmZpZy5kZWxpbWl0ZXIgPSAnZGVsaW1pdGVyJyBpbiBvcHRpb25zID8gb3B0aW9ucy5kZWxpbWl0ZXIgOiAkLmNzdi5kZWZhdWx0cy5kZWxpbWl0ZXI7XG5cbiAgICAgIHZhciBvdXRwdXQgPSAnJztcbiAgICAgIHZhciBsaW5lO1xuICAgICAgdmFyIGxpbmVWYWx1ZXM7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBqO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpbmUgPSBhcnJheXNbaV07XG4gICAgICAgIGxpbmVWYWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxpbmUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgc3RyVmFsdWUgPSAobGluZVtqXSA9PT0gdW5kZWZpbmVkIHx8IGxpbmVbal0gPT09IG51bGwpID8gJycgOiBsaW5lW2pdLnRvU3RyaW5nKCk7XG4gICAgICAgICAgaWYgKHN0clZhbHVlLmluZGV4T2YoY29uZmlnLmRlbGltaXRlcikgPiAtMSkge1xuICAgICAgICAgICAgc3RyVmFsdWUgPSBzdHJWYWx1ZS5yZXBsYWNlKG5ldyBSZWdFeHAoY29uZmlnLmRlbGltaXRlciwgJ2cnKSwgY29uZmlnLmRlbGltaXRlciArIGNvbmZpZy5kZWxpbWl0ZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBlc2NNYXRjaGVyID0gJ1xcbnxcXHJ8U3xEJztcbiAgICAgICAgICBlc2NNYXRjaGVyID0gZXNjTWF0Y2hlci5yZXBsYWNlKCdTJywgY29uZmlnLnNlcGFyYXRvcik7XG4gICAgICAgICAgZXNjTWF0Y2hlciA9IGVzY01hdGNoZXIucmVwbGFjZSgnRCcsIGNvbmZpZy5kZWxpbWl0ZXIpO1xuXG4gICAgICAgICAgaWYgKHN0clZhbHVlLnNlYXJjaChlc2NNYXRjaGVyKSA+IC0xKSB7XG4gICAgICAgICAgICBzdHJWYWx1ZSA9IGNvbmZpZy5kZWxpbWl0ZXIgKyBzdHJWYWx1ZSArIGNvbmZpZy5kZWxpbWl0ZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxpbmVWYWx1ZXMucHVzaChzdHJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0ICs9IGxpbmVWYWx1ZXMuam9pbihjb25maWcuc2VwYXJhdG9yKSArICdcXG4nO1xuICAgICAgfVxuXG4gICAgICAvLyBwdXNoIHRoZSB2YWx1ZSB0byBhIGNhbGxiYWNrIGlmIG9uZSBpcyBkZWZpbmVkXG4gICAgICBpZiAoIWNvbmZpZy5jYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uZmlnLmNhbGxiYWNrKCcnLCBvdXRwdXQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiAkLmNzdi5mcm9tT2JqZWN0cyhvYmplY3RzKVxuICAgICAqIENvbnZlcnRzIGEgamF2YXNjcmlwdCBkaWN0aW9uYXJ5IHRvIGEgQ1NWIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RzIEFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyB0aGUgZGF0YS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIHVzZXItZGVmaW5lZCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7Q2hhcmFjdGVyfSBbc2VwYXJhdG9yXSBBbiBvdmVycmlkZSBmb3IgdGhlIHNlcGFyYXRvciBjaGFyYWN0ZXIuIERlZmF1bHRzIHRvIGEgY29tbWEoLCkuXG4gICAgICogQHBhcmFtIHtDaGFyYWN0ZXJ9IFtkZWxpbWl0ZXJdIEFuIG92ZXJyaWRlIGZvciB0aGUgZGVsaW1pdGVyIGNoYXJhY3Rlci4gRGVmYXVsdHMgdG8gYSBkb3VibGUtcXVvdGUoXCIpLlxuICAgICAqIEBwYXJhbSB7Q2hhcmFjdGVyfSBbc29ydE9yZGVyXSBTb3J0IG9yZGVyIG9mIGNvbHVtbnMgKG5hbWVkIGFmdGVyXG4gICAgICogICBvYmplY3QgcHJvcGVydGllcykuIFVzZSAnYWxwaGEnIGZvciBhbHBoYWJldGljLiBEZWZhdWx0IGlzICdkZWNsYXJlJyxcbiAgICAgKiAgIHdoaWNoIG1lYW5zLCB0aGF0IHByb3BlcnRpZXMgd2lsbCBfcHJvYmFibHlfIGFwcGVhciBpbiBvcmRlciB0aGV5IHdlcmVcbiAgICAgKiAgIGRlY2xhcmVkIGZvciB0aGUgb2JqZWN0LiBCdXQgd2l0aG91dCBhbnkgZ3VhcmFudGVlLlxuICAgICAqIEBwYXJhbSB7Q2hhcmFjdGVyIG9yIEFycmF5fSBbbWFudWFsT3JkZXJdIE1hbnVhbGx5IG9yZGVyIGNvbHVtbnMuIE1heSBiZVxuICAgICAqIGEgc3RyaW4gaW4gYSBzYW1lIGNzdiBmb3JtYXQgYXMgYW4gb3V0cHV0IG9yIGFuIGFycmF5IG9mIGhlYWRlciBuYW1lc1xuICAgICAqIChhcnJheSBpdGVtcyB3b24ndCBiZSBwYXJzZWQpLiBBbGwgdGhlIHByb3BlcnRpZXMsIG5vdCBwcmVzZW50IGluXG4gICAgICogYG1hbnVhbE9yZGVyYCB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBlbmQgaW4gYWNjb3JkYW5jZSB3aXRoIGBzb3J0T3JkZXJgXG4gICAgICogb3B0aW9uLiBTbyB0aGUgYG1hbnVhbE9yZGVyYCBhbHdheXMgdGFrZXMgcHJlZmVyZW5jZSwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGdlbmVyYXRlcyBhIENTViBmaWxlIGZyb20gYW4gYXJyYXkgb2Ygb2JqZWN0cyAobmFtZTp2YWx1ZSBwYWlycykuXG4gICAgICogSXQgc3RhcnRzIGJ5IGRldGVjdGluZyB0aGUgaGVhZGVycyBhbmQgYWRkaW5nIHRoZW0gYXMgdGhlIGZpcnN0IGxpbmUgb2ZcbiAgICAgKiB0aGUgQ1NWIGZpbGUsIGZvbGxvd2VkIGJ5IGEgc3RydWN0dXJlZCBkdW1wIG9mIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIGZyb21PYmplY3RzOiBmdW5jdGlvbiAob2JqZWN0cywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgIG9wdGlvbnMgPSAob3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucyA6IHt9KTtcbiAgICAgIHZhciBjb25maWcgPSB7fTtcbiAgICAgIGNvbmZpZy5jYWxsYmFjayA9ICgoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgKGNhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykgPyBjYWxsYmFjayA6IGZhbHNlKTtcbiAgICAgIGNvbmZpZy5zZXBhcmF0b3IgPSAnc2VwYXJhdG9yJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zZXBhcmF0b3IgOiAkLmNzdi5kZWZhdWx0cy5zZXBhcmF0b3I7XG4gICAgICBjb25maWcuZGVsaW1pdGVyID0gJ2RlbGltaXRlcicgaW4gb3B0aW9ucyA/IG9wdGlvbnMuZGVsaW1pdGVyIDogJC5jc3YuZGVmYXVsdHMuZGVsaW1pdGVyO1xuICAgICAgY29uZmlnLmhlYWRlcnMgPSAnaGVhZGVycycgaW4gb3B0aW9ucyA/IG9wdGlvbnMuaGVhZGVycyA6ICQuY3N2LmRlZmF1bHRzLmhlYWRlcnM7XG4gICAgICBjb25maWcuc29ydE9yZGVyID0gJ3NvcnRPcmRlcicgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc29ydE9yZGVyIDogJ2RlY2xhcmUnO1xuICAgICAgY29uZmlnLm1hbnVhbE9yZGVyID0gJ21hbnVhbE9yZGVyJyBpbiBvcHRpb25zID8gb3B0aW9ucy5tYW51YWxPcmRlciA6IFtdO1xuICAgICAgY29uZmlnLnRyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy5tYW51YWxPcmRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uZmlnLm1hbnVhbE9yZGVyID0gJC5jc3YudG9BcnJheShjb25maWcubWFudWFsT3JkZXIsIGNvbmZpZyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcudHJhbnNmb3JtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG9yaWdPYmplY3RzID0gb2JqZWN0cztcbiAgICAgICAgb2JqZWN0cyA9IFtdO1xuXG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3JpZ09iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvYmplY3RzLnB1c2goY29uZmlnLnRyYW5zZm9ybS5jYWxsKHVuZGVmaW5lZCwgb3JpZ09iamVjdHNbaV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcHJvcHMgPSAkLmNzdi5oZWxwZXJzLmNvbGxlY3RQcm9wZXJ0eU5hbWVzKG9iamVjdHMpO1xuXG4gICAgICBpZiAoY29uZmlnLnNvcnRPcmRlciA9PT0gJ2FscGhhJykge1xuICAgICAgICBwcm9wcy5zb3J0KCk7XG4gICAgICB9IC8vIGVsc2Uge30gLSBub3RoaW5nIHRvIGRvIGZvciAnZGVjbGFyZScgb3JkZXJcblxuICAgICAgaWYgKGNvbmZpZy5tYW51YWxPcmRlci5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBwcm9wc01hbnVhbCA9IFtdLmNvbmNhdChjb25maWcubWFudWFsT3JkZXIpO1xuICAgICAgICBsZXQgcDtcbiAgICAgICAgZm9yIChwID0gMDsgcCA8IHByb3BzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgaWYgKHByb3BzTWFudWFsLmluZGV4T2YocHJvcHNbcF0pIDwgMCkge1xuICAgICAgICAgICAgcHJvcHNNYW51YWwucHVzaChwcm9wc1twXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByb3BzID0gcHJvcHNNYW51YWw7XG4gICAgICB9XG5cbiAgICAgIHZhciBvLCBwLCBsaW5lLCBvdXRwdXQsIHByb3BOYW1lO1xuICAgICAgaWYgKGNvbmZpZy5oZWFkZXJzKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKHByb3BzKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChvID0gMDsgbyA8IG9iamVjdHMubGVuZ3RoOyBvKyspIHtcbiAgICAgICAgbGluZSA9IFtdO1xuICAgICAgICBmb3IgKHAgPSAwOyBwIDwgcHJvcHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICBwcm9wTmFtZSA9IHByb3BzW3BdO1xuICAgICAgICAgIGlmIChwcm9wTmFtZSBpbiBvYmplY3RzW29dICYmIHR5cGVvZiBvYmplY3RzW29dW3Byb3BOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbGluZS5wdXNoKG9iamVjdHNbb11bcHJvcE5hbWVdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGluZS5wdXNoKCcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnB1c2gobGluZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHB1c2ggdGhlIHZhbHVlIHRvIGEgY2FsbGJhY2sgaWYgb25lIGlzIGRlZmluZWRcbiAgICAgIHJldHVybiAkLmNzdi5mcm9tQXJyYXlzKG91dHB1dCwgb3B0aW9ucywgY29uZmlnLmNhbGxiYWNrKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gTWFpbnRlbmFuY2UgY29kZSB0byBtYWludGFpbiBiYWNrd2FyZC1jb21wYXRpYmlsaXR5XG4gIC8vIFdpbGwgYmUgcmVtb3ZlZCBpbiByZWxlYXNlIDEuMFxuICAkLmNzdkVudHJ5MkFycmF5ID0gJC5jc3YudG9BcnJheTtcbiAgJC5jc3YyQXJyYXkgPSAkLmNzdi50b0FycmF5cztcbiAgJC5jc3YyRGljdGlvbmFyeSA9ICQuY3N2LnRvT2JqZWN0cztcblxuICAvLyBDb21tb25KUyBtb2R1bGUgaXMgZGVmaW5lZFxuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9ICQuY3N2O1xuICB9XG59KS5jYWxsKHRoaXMpO1xuIiwiLy9pbXBvcnQge19sb2FkalF1ZXJ5Q1NWfSBmcm9tIFwiLi9qUXVlcnlDU1YuanNcIjtcbmltcG9ydCBcImpxdWVyeS1jc3ZcIjtcblxuLy8gVGhlIFRBQkxFIGNsYXNzIGNvbnRhaW5zIGFuIDJ4MiBBcnJheS1PYmplY3QgYW5kIGRlZmluZXMgSXRlbSwgR3JvdXAgYW5kIExhYmVsXG5jbGFzcyBUYWJsZSB7XG4gICAgY29uc3RydWN0b3IodGFibGUpIHtcbiAgICAgICAgaWYgKCEodGFibGUgaW5zdGFuY2VvZiBBcnJheSkgfHwgdGFibGUubGVuZ3RoIDwgMiB8fCBPYmplY3Qua2V5cyh0YWJsZVswXSkubGVuZ3RoIDwgMilcbiAgICAgICAgICAgIHJldHVybiBBYm9ydDtcbiAgICAgICAgdGhpcy50YWJsZSA9IHRhYmxlO1xuICAgICAgICBmb3IgKGxldCBjb2wgaW4gdGFibGVbMF0pIHtcbiAgICAgICAgICAgIGlmIChjb2wubWF0Y2goL15pdGVtJC9pKSlcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW0gPSBjb2w7XG4gICAgICAgICAgICBpZiAoY29sLm1hdGNoKC9eZ3JvdXAkL2kpKVxuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAgPSBjb2w7XG4gICAgICAgICAgICBpZiAoY29sLm1hdGNoKC9ebGFiZWwkL2kpKVxuICAgICAgICAgICAgICAgIHRoaXMubGFiZWwgPSBjb2w7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0SXRlbShjb2wpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRhYmxlWzBdLmhhc093blByb3BlcnR5KGNvbCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3Igd2hlbiBzZXR0aW5nIHRhYmxlJ3MgaXRlbSBjb2x1bW46IG5vIGNvbHVtbiBmb3VuZCB3aXRoIHRoZSBuYW1lIFwiK2NvbCk7XG4gICAgICAgICAgICByZXR1cm4gQWJvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pdGVtID0gY29sO1xuICAgIH1cbiAgICBzZXRHcm91cChjb2wpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRhYmxlWzBdLmhhc093blByb3BlcnR5KGNvbCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3Igd2hlbiBzZXR0aW5nIHRhYmxlJ3MgaXRlbSBjb2x1bW46IG5vIGNvbHVtbiBmb3VuZCB3aXRoIHRoZSBuYW1lIFwiK2NvbCk7XG4gICAgICAgICAgICByZXR1cm4gQWJvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncm91cCA9IGNvbDtcbiAgICB9XG4gICAgc2V0TGFiZWwoY29sKSB7XG4gICAgICAgIGlmICghdGhpcy50YWJsZVswXS5oYXNPd25Qcm9wZXJ0eShjb2wpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yIHdoZW4gc2V0dGluZyB0YWJsZSdzIGl0ZW0gY29sdW1uOiBubyBjb2x1bW4gZm91bmQgd2l0aCB0aGUgbmFtZSBcIitjb2wpO1xuICAgICAgICAgICAgcmV0dXJuIEFib3J0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFiZWwgPSBjb2w7XG4gICAgfVxufVxuXG4vLyBUaGUgbWFpbiBmdW5jdGlvblxuLy8gUGVubkNvbnRyb2xsZXIuRmVlZEl0ZW1zKFwidGFibGUuY3N2XCIsICAgICAgICAvLyBPcHRpb25hbCwgb3IgcmVmZXJlbmNlIHRvIGEgVGFibGUgb2JqZWN0XG4vLyAgICAgKHJvdykgPT4gUGVubkNvbnRyb2xsZXIoICAgICAgICAgICAgICAgICAvLyBPciAoKSA9PiBbXCJNZXNzYWdlXCIsIHsuLi59LCBcIlBlbm5Db250cm9sbGVyXCIsIFBlbm5Db250cm9sbGVyKC4uLildXG4vLyAgICAgICAgIHAocm93LnRleHQpXG4vLyAgICAgICAgICxcbi8vICAgICAgICAgcChyb3cuaW1hZ2UpXG4vLyAgICAgICAgICxcbi8vICAgICAgICAgcC5rZXkoXCJGSlwiKVxuLy8gICAgICkgICAgXG5QZW5uQ29udHJvbGxlci5GZWVkSXRlbXMgPSBmdW5jdGlvbiAocGFyYW0xLCBwYXJhbTIpIHtcbiAgICAvLyBMb29rcyBmb3IgYSBDU1YgZmlsZSBkZWZpbmluZyBhIGRhdGFzb3VyY2UgaW4gY2h1bmtfaW5jbHVkZXNcbiAgICBmdW5jdGlvbiBfc21hcnRUYWJsZURldGVjdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gX2NoZWNrVGFibGUodGFibGUpe1xuICAgICAgICAgICAgLy8gTG9hZCB0aGUgalF1ZXJ5LUNTViBwbHVnaW5cbiAgICAgICAgICAgIC8vIGlmICghJC5jc3YpXG4gICAgICAgICAgICAvLyAgICAgX2xvYWRqUXVlcnlDU1YoKTtcbiAgICAgICAgICAgIHRhYmxlID0gJC5jc3YudG9PYmplY3RzKHRhYmxlKTtcbiAgICAgICAgICAgIC8vIENoZWNraW5nIHRoYXQgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBjb2x1bW5cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh0YWJsZVswXSkubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFibGU7XG4gICAgICAgICAgICAvLyBJZiBpdCBkaWRuJ3Qgd29yayB3aXRoIGNvbW1hIGFzIHRoZSBkZWZhdWx0IHNlcGFyYXRvciwgdHJ5IHdpdGggdGFiXG4gICAgICAgICAgICB0YWJsZSA9ICQuY3N2LnRvT2JqZWN0cyhDSFVOS1NfRElDVFtlbnRyeV0sIHtzZXBhcmF0b3I6IFwiXFx0XCJ9KTtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh0YWJsZVswXSkubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFibGU7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIGRlZmF1bHQgdGFibGUgd2FzIGRlZmluZWRcbiAgICAgICAgaWYgKFBlbm5Db250cm9sbGVyLmhhc093blByb3BlcnR5KFwiZGVmYXVsdFRhYmxlXCIpKSB7XG4gICAgICAgICAgICBsZXQgdGFibGUgPSBfY2hlY2tUYWJsZShQZW5uQ29udHJvbGxlci5kZWZhdWx0VGFibGUpO1xuICAgICAgICAgICAgaWYgKHRhYmxlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBObyBkZWZhdWx0IHRhYmxlLCBsb29rIHVwIENIVU5LU19ESUNUXG4gICAgICAgIGZvciAobGV0IGVudHJ5IGluIENIVU5LU19ESUNUKSB7XG4gICAgICAgICAgICBpZiAoZW50cnkubWF0Y2goL1xcLihodG1sP3xtcDMpJC9pKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCB0YWJsZSA9IF9jaGVja1RhYmxlKENIVU5LU19ESUNUW2VudHJ5XSk7XG4gICAgICAgICAgICBpZiAodGFibGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlO1xuICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm90aGluZyB3b3JrZWQsIHJldHVybiBBYm9ydFxuICAgICAgICByZXR1cm4gQWJvcnQ7XG4gICAgfSAgICAgICAgXG4gICAgLy8gVGhpcyBpcyB0aGUgZnVuY3Rpb24gdGhhdCBhY3R1YWxseSBjcmVhdGVzIHRoZSBsaXN0IG9mIGl0ZW1zXG4gICAgZnVuY3Rpb24gX2dldEl0ZW1zRnJvbSh0YWJsZSwgcGVubmZ1bmMpIHtcbiAgICAgICAgLy8gQnVpbGRpbmcgdGhlIGl0ZW1zXG4gICAgICAgIGxldCBpdGVtcyA9IFtdO1xuICAgICAgICBsZXQgZ3JvdXBzID0ge307XG4gICAgICAgIC8vIEdvaW5nIHRocm91Z2ggdGhlIHRhYmxlXG4gICAgICAgIGZvciAobGV0IHJvdyBpbiB0YWJsZS50YWJsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRpbmcgZWFjaCBpdGVtJ3MgY29udGVudCBieSBjYWxsaW5nIGZ1bmMgb24gZWFjaCByb3dcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gcGVubmZ1bmModGFibGUudGFibGVbcm93XSk7XG4gICAgICAgICAgICAvLyBUaGUgUGVubkNvbnRyb2xsZXIgZnVuY3Rpb24gcmV0dXJucyBhbiBvYmplY3QgdG8gYmUgcGFzc2VkIGFsb25nIHdpdGggXCJQZW5uQ29udHJvbGxlclwiXG4gICAgICAgICAgICBpZiAoIShjb250ZW50IGluc3RhbmNlb2YgQXJyYXkpKVxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbXCJQZW5uQ29udHJvbGxlclwiLCBjb250ZW50XTtcbiAgICAgICAgICAgIC8vIENyZWF0aW5nIHRoZSBpdGVtIGl0c2VsZlxuICAgICAgICAgICAgbGV0IGl0ZW0gPSBbXCJJdGVtLVwiK3Jvd107XG4gICAgICAgICAgICBmb3IgKGxldCBjIGluIGNvbnRlbnQpXG4gICAgICAgICAgICAgICAgaXRlbS5wdXNoKGNvbnRlbnRbY10pO1xuICAgICAgICAgICAgLy8gSWYgYSBsYWJlbCBjb2x1bW4gd2FzIGRlZmluZWRcbiAgICAgICAgICAgIGlmICh0YWJsZS5sYWJlbCAmJiB0YWJsZS50YWJsZVtyb3ddLmhhc093blByb3BlcnR5KHRhYmxlLmxhYmVsKSlcbiAgICAgICAgICAgICAgICBpdGVtWzBdID0gdGFibGUudGFibGVbcm93XVt0YWJsZS5sYWJlbF07XG4gICAgICAgICAgICAvLyBFbHNlLCBpZiBhbiBpdGVtIGNvbHVtbiB3YXMgZGVmaW5lZFxuICAgICAgICAgICAgZWxzZSBpZiAodGFibGUuaXRlbSAmJiB0YWJsZS50YWJsZVtyb3ddLmhhc093blByb3BlcnR5KHRhYmxlLml0ZW0pKVxuICAgICAgICAgICAgICAgIGl0ZW1bMF0gPSBcIkl0ZW0tXCIrdGFibGUudGFibGVbcm93XVt0YWJsZS5pdGVtXTtcbiAgICAgICAgICAgIC8vIEVsc2VcbiAgICAgICAgICAgIC8vIElmIGdyb3VwIGRlc2lnblxuICAgICAgICAgICAgaWYgKHRhYmxlLml0ZW0gJiYgdGFibGUuZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAvLyAgZ3JvdXBzID0ge1xuICAgICAgICAgICAgICAgIC8vICAgICAgaXRlbTE6IHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICBncm91cDE6IFsgXCJOYW1lXCIsIFwiQ29udHJvbGxlclwiLCBPcHRpb25zLCAuLi4gXSwgIFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgIGdyb3VwMjogWyBcIk5hbWVcIiwgXCJDb250cm9sbGVyXCIsIE9wdGlvbnMsIC4uLiBdXG4gICAgICAgICAgICAgICAgLy8gICAgICB9LFxuICAgICAgICAgICAgICAgIC8vICAgICAgaXRlbTI6IHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICBncm91cDE6IFsgXCJOYW1lXCIsIFwiQ29udHJvbGxlclwiLCBPcHRpb25zLCAuLi4gXSwgIFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgIGdyb3VwMjogWyBcIk5hbWVcIiwgXCJDb250cm9sbGVyXCIsIE9wdGlvbnMsIC4uLiBdXG4gICAgICAgICAgICAgICAgLy8gICAgICB9LFxuICAgICAgICAgICAgICAgIC8vICAgICAgLi4uXG4gICAgICAgICAgICAgICAgLy8gIH1cbiAgICAgICAgICAgICAgICBsZXQgaXRlbUlEID0gdGFibGUudGFibGVbcm93XVt0YWJsZS5pdGVtXSwgZ3JvdXBJRCA9IHRhYmxlLnRhYmxlW3Jvd11bdGFibGUuZ3JvdXBdO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXRlbSBpcyBub3QgbGlzdGVkIHlldCwgYWRkIGl0XG4gICAgICAgICAgICAgICAgaWYgKCFncm91cHMuaGFzT3duUHJvcGVydHkoaXRlbUlEKSkgZ3JvdXBzW2l0ZW1JRF0gPSB7fTtcbiAgICAgICAgICAgICAgICAvLyBBZGRpbmcgdGhlIGl0ZW1cbiAgICAgICAgICAgICAgICBncm91cHNbaXRlbUlEXVtncm91cElEXSA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBObyBncm91cDogZGlyZWN0bHkgYWRkIHRoZSBpdGVtXG4gICAgICAgICAgICBlbHNlIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgZ3JvdXAgZGVzaWduXG4gICAgICAgIGlmICh0YWJsZS5pdGVtICYmIHRhYmxlLmdyb3VwKSB7XG4gICAgICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBncm91cHNcbiAgICAgICAgICAgIGxldCBncm91cExpc3QgPSBPYmplY3Qua2V5cyhncm91cHNbT2JqZWN0LmtleXMoZ3JvdXBzKVswXV0pO1xuICAgICAgICAgICAgLy8gR28gdGhyb3VnaCBlYWNoIGl0ZW0gaW4gZ3JvdXBzXG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtSUQgaW4gZ3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgLy8gR28gdGhyb3VnaCBlYWNoIGdyb3VwIHZlcnNpb24gb2YgdGhlIGl0ZW1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBncm91cElEIGluIGdyb3VwTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlcmUgaXMgYSB2ZXJzaW9uIG9mIHRoaXMgaXRlbSBmb3IgdGhpcyBncm91cFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWdyb3Vwc1tpdGVtSURdLmhhc093blByb3BlcnR5KGdyb3VwTGlzdFtncm91cElEXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3I6IGl0ZW0gXCIraXRlbUlEK1wiIGhhcyBubyBlbnRyeSBmb3IgZ3JvdXAgXCIrZ3JvdXBMaXN0W2dyb3VwSURdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBBYm9ydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHNwZWNpZmljIGVudHJ5XG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gZ3JvdXBzW2l0ZW1JRF1bZ3JvdXBMaXN0W2dyb3VwSURdXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVuYW1lIHRoZSBsYWJlbCB0byBhZGQgJ2l0ZW1JRCcgYXMgdGhlIGxhdGluLXNxdWFyZSBJRFxuICAgICAgICAgICAgICAgICAgICBpdGVtWzBdID0gW2l0ZW1bMF0sIGl0ZW1JRF07XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBpdCB0byB0aGUgZmluYWwgaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ3ljbGUgdGhyb3VnaCBncm91cExpc3QgZm9yIG5leHQgaXRlbSwgZW5zdXJpbmcgbGF0aW4tc3F1YXJlIGhhY2tcbiAgICAgICAgICAgICAgICBncm91cExpc3QudW5zaGlmdChncm91cExpc3QucG9wKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG4gICAgLy8gTm8gdGFibGUgc3BlY2lmaWVkLCB0cnkgdG8gYXV0b21hdGljYWxseSBkZXRlY3RcbiAgICBpZiAocGFyYW0xIGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgcGFyYW0yID09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGFibGUgPSBfc21hcnRUYWJsZURldGVjdGlvbigpO1xuICAgICAgICBpZiAodGFibGUgPT0gQWJvcnQpXG4gICAgICAgICAgICByZXR1cm4gQWJvcnQ7XG4gICAgICAgIHRhYmxlID0gbmV3IFRhYmxlKHRhYmxlKTtcbiAgICAgICAgaWYgKCEod2luZG93Lml0ZW1zIGluc3RhbmNlb2YgQXJyYXkpKVxuICAgICAgICAgICAgd2luZG93Lml0ZW1zID0gW107XG4gICAgICAgIHdpbmRvdy5pdGVtcyA9IHdpbmRvdy5pdGVtcy5jb25jYXQoX2dldEl0ZW1zRnJvbSh0YWJsZSwgcGFyYW0xKSk7XG4gICAgICAgIC8vcmV0dXJuIF9nZXRJdGVtc0Zyb20odGFibGUsIHBhcmFtMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mKHBhcmFtMSkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiBBYm9ydDtcbiAgICAgICAgLy8gZWxzZSBpZiAocGFyYW0xIGluc3RhbmNlb2YgUGVubkNvbnRyb2xsZXIuVGFibGUpXG4gICAgfVxufTsiLCJpbXBvcnQge19hdXRvUHJlbG9hZFZpZGVvc30gZnJvbSBcIi4uL3ByZWxvYWQvcHJlbG9hZC5qc1wiO1xuLy9pbXBvcnQge011dGF0aW9uT2JzZXJ2ZXJ9IGZyb20gXCIuLi9jb250cm9sbGVyLmpzXCI7XG5jb25zdCBNdXRhdGlvbk9ic2VydmVyID1cbiAgICB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciB8fCB3aW5kb3cuV2ViS2l0TXV0YXRpb25PYnNlcnZlciB8fCB3aW5kb3cuTW96TXV0YXRpb25PYnNlcnZlcjtcblxuLy8gWW91dHViZSB2aWRlb3MgdG8gbG9hZFxudmFyIF95b3V0dWJlVmlkZW9zID0ge307XG5cblxuLy8gTG9hZCB0aGUgWW91dHViZSBBUEkgKHNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS95b3V0dWJlL2lmcmFtZV9hcGlfcmVmZXJlbmNlKVxuLy8gV2lsbCBiZSBleGVjdXRlZCB3aGVuIGpRdWVyeSBpcyByZWFkeVxuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKXtcbiAgICB2YXIgdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cbiAgICB0YWcuc3JjID0gXCJodHRwczovL3d3dy55b3V0dWJlLmNvbS9pZnJhbWVfYXBpXCI7XG4gICAgdmFyIGZpcnN0U2NyaXB0VGFnID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuICAgIGZpcnN0U2NyaXB0VGFnLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRhZywgZmlyc3RTY3JpcHRUYWcpO1xuXG4gICAgLy8gMy4gVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGFuIDxpZnJhbWU+IChhbmQgWW91VHViZSBwbGF5ZXIpXG4gICAgLy8gICAgYWZ0ZXIgdGhlIEFQSSBjb2RlIGRvd25sb2Fkcy5cbiAgICB2YXIgcGxheWVyO1xuICAgIHdpbmRvdy5vbllvdVR1YmVJZnJhbWVBUElSZWFkeSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGZvciAobGV0IHkgaW4gX3lvdXR1YmVWaWRlb3MpIHtcbiAgICAgICAgICAgIF95b3V0dWJlVmlkZW9zW3ldLmNhbGwoKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5cbi8vIEFkZHMgYSBZb3V0dWJlIHZpZGVvXG4vLyBEb25lIGltbWVkaWF0ZWx5XG5jbGFzcyBZVEluc3RyIGV4dGVuZHMgSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGNvZGUpIHtcbiAgICAgICAgc3VwZXIoY29kZSwgXCJ5b3V0dWJlXCIpO1xuICAgICAgICBpZiAoY29kZSAhPSBBYm9ydCl7XG4gICAgICAgICAgICBsZXQgdGkgPSB0aGlzO1xuICAgICAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGEgcGxheWVyIHRocm91Z2ggdGhlIFlUIEFQSVxuICAgICAgICAgICAgbGV0IGNyZWF0ZVBsYXllciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRpLm9yaWdpbi5wbGF5ZXIgPSBuZXcgWVQuUGxheWVyKGNvZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW9JZDogY29kZSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnb25SZWFkeSc6IGZ1bmN0aW9uKGV2ZW50KXsgdGkub3JpZ2luLl9yZWFkeShldmVudCk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAnb25TdGF0ZUNoYW5nZSc6IGZ1bmN0aW9uKGV2ZW50KXsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEgPT0gWVQuUGxheWVyU3RhdGUuRU5ERUQpIHRpLm9yaWdpbi5fZW5kZWQoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmRhdGEgPT0gWVQuUGxheWVyU3RhdGUuQlVGRkVSSU5HKSB0aS5vcmlnaW4uX2J1ZmZlcmluZyhldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQuZGF0YSA9PSBZVC5QbGF5ZXJTdGF0ZS5QTEFZSU5HKSB0aS5vcmlnaW4uX3BsYXlpbmcoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmRhdGEgPT0gWVQuUGxheWVyU3RhdGUuQ1VFRCkgdGkub3JpZ2luLl9jYW5QbGF5KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudC5kYXRhID09IFlULlBsYXllclN0YXRlLlBBVVNFRCkgdGkub3JpZ2luLl9wYXVzZWQoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gSUZSQU1FXG4gICAgICAgICAgICAvLyBOb3QgbG9hZGVkIGF0IGZpcnN0XG4gICAgICAgICAgICB0aGlzLmlmcmFtZUxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gQ3JlYXRpbmcgdGhlIGlmcmFtZSBlbGVtZW50IChUT0RPOiBjaGVjayBwcmVsb2FkZWQgZmlsZXMsIG5vIG5lZWQgdG8gcmVjcmVhdGUgZWFjaCB0aW1lKVxuICAgICAgICAgICAgdGhpcy5pZnJhbWUgPSAkKFwiPGlmcmFtZT5cIik7XG4gICAgICAgICAgICB0aGlzLmlmcmFtZS5hdHRyKHtzcmM6IFwiaHR0cHM6Ly93d3cueW91dHViZS1ub2Nvb2tpZS5jb20vZW1iZWQvXCIrY29kZStcIj9lbmFibGVqc2FwaT0xXCIsIGlkOiBjb2RlLCBmcmFtZWJvcmRlcjogMH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYmluZChcImxvYWRcIiwgZnVuY3Rpb24oKXsgdGkub3JpZ2luLmlmcmFtZUxvYWRlZCA9IHRydWU7IH0pOyAvLyBTaWduYWwgbG9hZGluZ1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBmcmFtZSB0byBodG1sIChpbnZpc2libGUpXG4gICAgICAgICAgICAkKFwiaHRtbFwiKS5hcHBlbmQodGhpcy5pZnJhbWUuY3NzKHtkaXNwbGF5OiBcIm5vbmVcIiwgcG9zaXRpb246IFwiYWJzb2x1dGVcIn0pKTtcbiAgICAgICAgICAgIC8vIFRoZSBpbnN0cnVjdGlvbidzIGVsZW1lbnQgaXMgYSBESVYsIGJlY2F1c2UgaWZyYW1lIG5lZWRzIHRvIGJlIGdsb2JhbCAoYXBwZW5kaW5nIGl0IHdvdWxkIFJFQ1JFQVRFIGl0KVxuICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50KCQoXCI8ZGl2PlwiKSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgcGxheWVyIGhhcyBub3QgYWxyZWFkeSBiZWVuIGNyZWF0ZWRcbiAgICAgICAgICAgIGlmICghX3lvdXR1YmVWaWRlb3MuaGFzT3duUHJvcGVydHkoY29kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBwbGF5ZXIgdG8gYmUgY3JlYXRlZCB3aGVuIHRoZSBZVCBBUEkgaXMgcmVhZHkgKHNlZSBhYm92ZSBpbiBQUkVMT0FERVIgRU5HSU5FKVxuICAgICAgICAgICAgICAgIF95b3V0dWJlVmlkZW9zW2NvZGVdID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGlmcmFtZSBpcyBub3QgcmVhZHkgeWV0LCB3YWl0IGJlZm9yZSBjcmVhdGluZyB0aGUgcGxheWVyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGkub3JpZ2luLmlmcmFtZUxvYWRlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpLm9yaWdpbi5pZnJhbWUuYmluZChcImxvYWRcIiwgY3JlYXRlUGxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgaXMgcmVhZHksIGNyZWF0ZSB0aGUgcGxheWVyIGFscmVhZHlcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlUGxheWVyKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFZpc3VhbCBpbmZvcm1hdGlvblxuICAgICAgICAgICAgdGhpcy52aXN1YWwgPSB7XG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gQXV0b3BsYXkgYnkgZGVmYXVsdFxuICAgICAgICAgICAgdGhpcy5hdXRvUGxheSA9IHRydWU7XG4gICAgICAgICAgICAvLyBBc3luY2hyb25vdXMgY29tbWFuZHM6IG5lZWQgdG8ga2VlcCB0cmFja1xuICAgICAgICAgICAgdGhpcy5jb21tYW5kc1F1ZXVlID0gW107XG4gICAgICAgICAgICAvLyBOb3QgcGxheWVkIHlldFxuICAgICAgICAgICAgdGhpcy5oYXNQbGF5ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIENhbGxpbmcgYWRkVG9QcmVsb2FkIGltbWVkaWF0ZWx5IGlmIHNldHRpbmdzIHNheSBzbyBcbiAgICAgICAgICAgIGlmIChfYXV0b1ByZWxvYWRWaWRlb3MpXG4gICAgICAgICAgICAgICAgdGhpcy5vcmlnaW4uX2FkZFRvUHJlbG9hZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFBSSVZBVEUgJiBJTlRSSU5TSUMgTUVUSE9EU1xuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICBydW4oKSB7XG4gICAgICAgIGlmIChzdXBlci5ydW4oKSA9PSBBYm9ydClcbiAgICAgICAgICAgIHJldHVybiBBYm9ydDtcbiAgICAgICAgbGV0IHRpID0gdGhpcy5vcmlnaW47XG4gICAgICAgIC8vIEJpbmQgYW55IG11dGF0aW9uIHRvIHRoZSBkaXYgZWxlbWVudCB0byB0aGUgaWZyYW1lXG4gICAgICAgIGxldCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKG11dGF0aW9ucykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgZWxlbWVudCBpcyBpbiB0aGUgRE9NIGFuZCB2aXNpYmxlXG4gICAgICAgICAgICBpZiAoJC5jb250YWlucyhkb2N1bWVudC5ib2R5LCB0aS5lbGVtZW50WzBdKSAmJiB0aS5lbGVtZW50WzBdLm9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgICAgIGxldCB3ID0gdGkuZWxlbWVudC53aWR0aCgpLCBoID0gdGkuZWxlbWVudC5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICBpZiAodyAhPSB0aS52aXN1YWwud2lkdGggfHwgaCAhPSB0aS52aXN1YWwuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRpLmlmcmFtZS5jc3Moe3dpZHRoOiB3LCBoZWlnaHQ6IGgsIGRpc3BsYXk6IFwiYmxvY2tcIn0pO1xuICAgICAgICAgICAgICAgICAgICB0aS52aXN1YWwud2lkdGggPSB3O1xuICAgICAgICAgICAgICAgICAgICB0aS52aXN1YWwuaGVpZ2h0ID0gaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG8gPSB0aS5lbGVtZW50Lm9mZnNldCgpLCB4ID0gby5sZWZ0LCB5ID0gby50b3A7XG4gICAgICAgICAgICAgICAgaWYgKHggIT0gdGkudmlzdWFsLmxlZnQgfHwgeSAhPSB0aS52aXN1YWwudG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpLmlmcmFtZS5jc3Moe2xlZnQ6IHgsIHRvcDogeSwgZGlzcGxheTogXCJibG9ja1wifSk7XG4gICAgICAgICAgICAgICAgICAgIHRpLnZpc3VhbC5sZWZ0ID0geDtcbiAgICAgICAgICAgICAgICAgICAgdGkudmlzdWFsLnRvcCA9IHk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBMaXN0ZW4gdG8gYW55IG1vZGlmaWNhdGlvbiB0aGF0IG1pZ2h0IGFmZmVjdCB0aGUgZGlzcGxheSBvZiB0aGUgZGl2XG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuYm9keSwgeyBjaGlsZExpc3QgOiB0cnVlLCBhdHRyaWJ1dGVzIDogdHJ1ZSwgc3VidHJlZSA6IHRydWUgfSk7XG4gICAgICAgIC8vIEFkZCB0aGUgZGl2IGVsZW1lbnQgdG8gdGhlIGRvY3VtZW50IChhbnkgbXV0YXRpb24gaXMgbGlzdGVuZWQpXG4gICAgICAgIHRoaXMuX2FkZEVsZW1lbnQodGhpcy5wYXJlbnRFbGVtZW50KTtcbiAgICAgICAgLy8gSWYgcGxheWVyIGV4aXN0cywgc3RhcnQgcGxheWJhY2tcbiAgICAgICAgaWYgKHRpLm9yaWdpbi5wbGF5ZXIgJiYgdGkub3JpZ2luLmF1dG9QbGF5KVxuICAgICAgICAgICAgdGkuX3BsYXkoKTtcbiAgICAgICAgLy8gU3RvcCBwbGF5aW5nIHRoZSB2aWRlbyB3aGVuIHRoZSB0cmlhbCBpcyBvdmVyXG4gICAgICAgIEN0cmxyLnJ1bm5pbmcuY2FsbGJhY2tCZWZvcmVGaW5pc2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRpLl9mb3JjZVBhdXNlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEZvcmNlIHBsYXlpbmcgYmVjYXVzZSBwbGF5VmlkZW8gc29tZXRpbWVzIHNpbXBseSBoYXMgbm8gZWZmZWN0IGF0IGFsbFxuICAgIF9mb3JjZVBsYXkoKSB7XG4gICAgICAgIGxldCB0aSA9IHRoaXMub3JpZ2luLCBpID0gMCwgaXZsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmICh0aS5wbGF5ZXIuZ2V0UGxheWVyU3RhdGUoKSA9PSBZVC5QbGF5ZXJTdGF0ZS5QTEFZSU5HIHx8IGkgPj0gNTAwMClcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGl2bCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGkucGxheWVyLnBsYXlWaWRlbygpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9LCAxKTtcbiAgICB9XG5cbiAgICAvLyBGb3JjZSBwYXVzZSBiZWNhdXNlIHBhdXNlVmlkZW8gc29tZXRpbWVzIHNpbXBseSBoYXMgbm8gZWZmZWN0IGF0IGFsbFxuICAgIF9mb3JjZVBhdXNlKCkge1xuICAgICAgICBsZXQgdGkgPSB0aGlzLm9yaWdpbiwgaSA9IDAsIGl2bCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiAodGkucGxheWVyLmdldFBsYXllclN0YXRlKCkgPT0gWVQuUGxheWVyU3RhdGUuUEFVU0VEIHx8IHRpLnBsYXllci5nZXRQbGF5ZXJTdGF0ZSgpID09IFlULlBsYXllclN0YXRlLkVOREVEIHx8IGkgPj0gNTAwMClcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGl2bCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGkucGxheWVyLnBhdXNlVmlkZW8oKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfSwgMSk7XG4gICAgfVxuXG4gICAgX3BsYXkoKSB7XG4gICAgICAgIGlmICghdGhpcy5vcmlnaW4ucGxheWVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLm9yaWdpbi5jb21tYW5kc1F1ZXVlLnB1c2goXCJwbGF5XCIpO1xuICAgICAgICAvLyBGb3JjZSBwbGF5aW5nIGJlY2F1c2UgaXQgc29tZXRpbWVzIHNpbXBseSBoYXMgbm8gZWZmZWN0IGF0IGFsbFxuICAgICAgICB0aGlzLl9mb3JjZVBsYXkoKTtcbiAgICB9XG5cbiAgICBfcGF1c2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5vcmlnaW4ucGxheWVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLm9yaWdpbi5jb21tYW5kc1F1ZXVlLnB1c2goXCJwYXVzZVwiKTtcbiAgICAgICAgdGhpcy5fZm9yY2VQYXVzZSgpO1xuICAgIH1cblxuICAgIF9wYXVzZWQoZXZlbnQpIHtcbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnRseSBwZW5kaW5nIGNvbW1hbmQgaXMgUEFVU0UsIHJlbW92ZSBpdFxuICAgICAgICBpZiAodGhpcy5vcmlnaW4uY29tbWFuZHNRdWV1ZS5pbmRleE9mKFwicGF1c2VcIikgPT0gMClcbiAgICAgICAgICAgIHRoaXMub3JpZ2luLmNvbW1hbmRzUXVldWUuc3BsaWNlKDAsIDEpO1xuICAgICAgICAvLyBJZiB0aGUgbmV4dCBwZW5kaW5nIGNvbW1hbmQgaXMgUExBWSwgcGxheSB0aGUgdmlkZW9cbiAgICAgICAgaWYgKHRoaXMub3JpZ2luLmNvbW1hbmRzUXVldWUubGVuZ3RoID4gMCAmJiB0aGlzLm9yaWdpbi5jb21tYW5kc1F1ZXVlWzBdID09IFwicGxheVwiKVxuICAgICAgICAgICAgdGhpcy5fZm9yY2VQbGF5KCk7XG4gICAgfVxuXG4gICAgX3BsYXlpbmcoZXZlbnQpIHtcbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnRseSBwZW5kaW5nIGNvbW1hbmQgaXMgUExBWSwgcmVtb3ZlIGl0XG4gICAgICAgIGlmICh0aGlzLm9yaWdpbi5jb21tYW5kc1F1ZXVlLmluZGV4T2YoXCJwbGF5XCIpID09IDApXG4gICAgICAgICAgICB0aGlzLm9yaWdpbi5jb21tYW5kc1F1ZXVlLnNwbGljZSgwLCAxKTtcbiAgICAgICAgLy8gSWYgdGhlIG5leHQgcGVuZGluZyBjb21tYW5kIGlzIFBBVVNFLCBwYXVzZSB0aGUgdmlkZW9cbiAgICAgICAgaWYgKHRoaXMub3JpZ2luLmNvbW1hbmRzUXVldWUubGVuZ3RoID4gMCAmJiB0aGlzLm9yaWdpbi5jb21tYW5kc1F1ZXVlWzBdID09IFwicGF1c2VcIilcbiAgICAgICAgICAgIHRoaXMub3JpZ2luLnBsYXllci5wYXVzZVZpZGVvKCk7XG5cbiAgICAgICAgLy8gSWYgbm90IGxvYWRlZCB5ZXQsIGNoYW5nZSB0aGF0OiBpdCdzIG5vdyBwbGF5aW5nXG4gICAgICAgIGlmICghdGhpcy5vcmlnaW4ubG9hZGVkKSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbi5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgLy8gU2lnbmFsIHRoYXQgaXQgY2FuIHBsYXlcbiAgICAgICAgICAgIGlmICh0aGlzLm9yaWdpbi5idWZmZXJpbmcgJiYgIXRoaXMub3JpZ2luLmNhblBsYXkpXG4gICAgICAgICAgICAgICAgdGhpcy5vcmlnaW4uX2NhblBsYXkoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpZ25hbCBpdCdzIG5vIGxvbmdlciBidWZmZXJpbmdcbiAgICAgICAgaWYgKHRoaXMub3JpZ2luLmJ1ZmZlcmluZylcbiAgICAgICAgICAgIHRoaXMub3JpZ2luLmJ1ZmZlcmluZyA9IGZhbHNlO1xuICAgICAgICAvLyBJZiBvcmlnaW4gaGFzIGJlZW4gcnVuIGJ1dCBpcyBub3QgZG9uZSB5ZXQsIGNoYW5nZSB0aGF0XG4gICAgICAgIGlmICh0aGlzLm9yaWdpbi5oYXNCZWVuUnVuICYmICF0aGlzLm9yaWdpbi5pc0RvbmUpXG4gICAgICAgICAgICB0aGlzLm9yaWdpbi5kb25lKCk7XG4gICAgfVxuXG4gICAgX2J1ZmZlcmluZyhldmVudCkge1xuICAgICAgICAvLyBTaWduYWwgaXQncyBidWZmZXJpbmdcbiAgICAgICAgaWYgKCF0aGlzLm9yaWdpbi5idWZmZXJpbmcpXG4gICAgICAgICAgICB0aGlzLm9yaWdpbi5idWZmZXJpbmcgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIFRyaWdnZXJlZCB3aGVuIHRoZSB2aWRlbyBoYXMgZmlyc3Qgc3RhcnRlZCBwbGF5aW5nXG4gICAgX2NhblBsYXkoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9yaWdpbi5jYW5QbGF5KSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbi5jYW5QbGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIExpc3RpbmcgdGhlIFlUIHZpZGVvIGFzIHByZWxvYWRlZFxuICAgICAgICAgICAgdGhpcy5vcmlnaW4uX3NldFJlc291cmNlKHRoaXMuaWZyYW1lKTtcbiAgICAgICAgICAgIC8vIElmIHZpZGVvIG5vdCBwbGF5ZWQgeWV0LCBwbGF5IGl0XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNCZWVuUnVuICYmIGV2ZW50LnRhcmdldC5nZXRQbGF5ZXJTdGF0ZSgpICE9IFlULlBsYXllclN0YXRlLlBMQVlJTkcpXG4gICAgICAgICAgICAgICAgdGhpcy5fcGxheSgpO1xuICAgICAgICAgICAgLy8gSWYgdmlkZW8gYWxyZWFkeSBwbGF5aW5nIGJ1dCBub3QgcnVuIHlldCwgcGF1c2VcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmhhc0JlZW5SdW4gJiYgZXZlbnQudGFyZ2V0LmdldFBsYXllclN0YXRlKCkgPT0gWVQuUGxheWVyU3RhdGUuUExBWUlORylcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXVzZSgpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBfZW5kZWQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5oYXNQbGF5ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIF9yZWFkeShldmVudCkge1xuICAgICAgICAvLyBTdGFydGluZyB0byBwbGF5LCB0byBzdGFydCBidWZmZXJpbmdcbiAgICAgICAgdGhpcy5fcGxheSgpOyAgICAgICAgICAgIFxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBNRVRIT0RTIFRIQVQgUkVUVVJOIE5FVyBJTlNUUlVDVElPTlNcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyBSZXR1cm5zIGFuIGluc3RydWN0aW9uIHRvIHdhaXQgZm9yIHRoZSBlbmQgb2YgdGhlIHZpZGVvXG4gICAgLy8gRG9uZSB3aGVuIHRoZSB2aWRlbyBoYXMgYmVlbiBlbnRpcmVseSBwbGF5ZWRcbiAgICB3YWl0KCkge1xuICAgICAgICBpZiAodGhpcy5vcmlnaW4uaGFzUGxheWVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV3TWV0YShmdW5jdGlvbigpeyB0aGlzLmRvbmUoKTsgfSk7XG4gICAgICAgIGxldCBpbnN0ciA9IHRoaXMubmV3TWV0YSgpO1xuICAgICAgICB0aGlzLm9yaWdpbi5fZW5kZWQgPSB0aGlzLm9yaWdpbi5leHRlbmQoXCJfZW5kZWRcIiwgZnVuY3Rpb24oKXsgaW5zdHIuZG9uZSgpOyB9KTtcbiAgICAgICAgcmV0dXJuIGluc3RyO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYW4gaW5zdHJ1Y3Rpb24gdG8gcGF1c2UgdGhlIHZpZGVvXG4gICAgLy8gRG9uZSBpbW1lZGlhdGVseVxuICAgIHBhdXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdNZXRhKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLl9wYXVzZSgpO1xuICAgICAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYW4gaW5zdHJ1Y3Rpb24gdG8gcGxheSB0aGUgdmlkZW9cbiAgICAvLyBEb25lIGltbWVkaWF0ZWx5XG4gICAgcGxheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV3TWV0YShmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5fcGxheSgpO1xuICAgICAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYW4gaW5zdHJ1Y3Rpb24gdG8gcHJlbG9hZCB0aGUgdmlkZW9cbiAgICAvLyBEb25lIGltbWVkaWF0ZWx5XG4gICAgcHJlbG9hZCgpIHtcbiAgICAgICAgdGhpcy5vcmlnaW4uX2FkZFRvUHJlbG9hZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdNZXRhKGZ1bmN0aW9uKCl7IHRoaXMuZG9uZSgpOyB9KTtcbiAgICB9XG59XG5cblBlbm5Db250cm9sbGVyLmluc3RydWN0aW9uLnl0ID0gZnVuY3Rpb24oY29kZSl7IHJldHVybiBuZXcgWVRJbnN0cihjb2RlKTsgfTsiLCIvKiBnbG9iYWxzIF9fd2VicGFja19hbWRfb3B0aW9uc19fICovXHJcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX2FtZF9vcHRpb25zX187XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblx0dGhyb3cgbmV3IEVycm9yKFwiZGVmaW5lIGNhbm5vdCBiZSB1c2VkIGluZGlyZWN0XCIpO1xyXG59O1xyXG4iLCIvLyBOT1RFKFMpXG4vLyAgY2hhbmdlIGZvciB0d28tYnV0dG9uIGludGVyZmFjZTogKHN0b3ApcmVjb3JkICYgcGxheS9zdG9wXG4vLyAgYWRkIGFuIGljb24gKHBvc2l0aW9uOmFic29sdXRlKSB0aGF0IHNpZ25hbHMgd2hlbiByZWNvcmRlciBpcyBhY3RpdmU/XG4vLyAgc2hvdWxkIHNhdmUgZXZlcnkgcmVjb3JkaW5nIGF0dGVtcHQ/XG5cbmltcG9ydCAqIGFzIEpTWmlwIGZyb20gJ2pzemlwJztcbmltcG9ydCB7IGNoYW5nZVJ1bm5pbmdPcmRlciB9IGZyb20gXCIuLi9jb250cm9sbGVyLmpzXCI7XG5pbXBvcnQgeyBzYXZlQXMgfSBmcm9tICdmaWxlLXNhdmVyJztcblxuLy8gVGhpcyBhcnJheSBjb250YWlucyBhbGwgdGhlIHNhbXBsZXMgcmVjb3JkZWQgc28gZmFyXG52YXIgYXVkaW9TdHJlYW1zID0gW107XG4vLyBUaGUgVVJMIHRvIHRoZSBQSFAgZmlsZSB0aGF0IHNhdmVzIHRoZSBhcmNoaXZlXG52YXIgdXBsb2FkVVJMID0gXCJcIjtcbi8vIFRoZSByZWNvcmRpbmcgb2JqZWN0XG52YXIgbWVkaWFSZWNvcmRlcjtcbi8vIFdoZXRoZXIgUGVubkNvbnRyb2xsZXIuSW5pdGlhdGVSZWNvcmRlciBoYXMgYmVlbiBjYWxsZWRcbnZhciBpbml0aWF0ZWQgPSBmYWxzZTtcbi8vIFRoZSB6aXAgZmlsZVxudmFyIHppcEZpbGU7XG4vLyBUaGUgdm9pY2UgaW5zdHJ1Y3Rpb24gY3VycmVudGx5IGFjdGl2ZVxudmFyIGN1cnJlbnRWb2ljZUluc3RydWN0aW9uO1xuXG5cbi8vIFRoZSBwZXJtaXNzaW9uIG1lc3NhZ2UgZGlzcGxheWVkIHdoZW4gdGhlIHVzZXIgaXMgYXNrZWQgZm9yIGFjY2VzcyB0byB0aGUgcmVjb3JkaW5nIGRldmljZVxudmFyIHBlcm1pc3Npb25NZXNzYWdlID0gXCJUaGlzIGV4cGVyaW1lbnQgY29sbGVjdHMgdm9pY2UgcmVjb3JkaW5ncyBmcm9tIGl0cyBwYXJ0aWNpcGFudHMuIFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJZb3VyIGJyb3dzZXIgc2hvdWxkIG5vdyBiZSBhc2tpbmcgZm9yIHlvdXIgcGVybWlzc2lvbiB0byB1c2UgeW91ciByZWNvcmRpbmcgZGV2aWNlIChpZiBhcHBsaWNhYmxlKS4gXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkJ5IGdpdmluZyB5b3UgYXV0aG9yaXphdGlvbiB0byByZWNvcmQgYW5kIGJ5IHBhcnRpY2lwYXRpbmcgaW4gdGhpcyBleHBlcmltZW50LCBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgIFwieW91IGFyZSBnaXZpbmcgcGVybWlzc2lvbiB0byB0aGUgZGVzaWduZXIocykgb2YgdGhpcyBleHBlcmltZW50IHRvIGFub255bW91c2x5IGNvbGxlY3QgXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRoZSB2b2ljZSAgc2FtcGxlcyByZWNvcmRlZCBkdXJpbmcgdGhpcyBleHBlcmltZW50LiBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiVGhlIG91dHB1dCBhdWRpbyBmaWxlcyB3aWxsIGJlIHVwbG9hZGVkIHRvIGFuZCBob3N0ZWQgb24gYSBzZXJ2ZXIgZGVzaWduYXRlZCBieSB0aGUgZXhwZXJpbWVudGVyKHMpLiBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXCJZb3Ugd2lsbCBiZSBnaXZlbiB0aGUgb3B0aW9uIHRvIGRvd25sb2FkIGEgY29weSBvZiB0aGUgYXJjaGl2ZSBvZiB5b3VyIGF1ZGlvIHJlY29yZGluZ3MgYmVmb3JlIGl0IGlzIHVwbG9hZGVkLlwiO1xuXG4vLyBUaGlzIGZ1bmN0aW9uIGRlZmluZXMgYSBjb250cm9sbGVyIHRoYXQgaW5pdGF0ZXMgdGhlIHJlY29yZGluZyBkZXZpY2Vcbi8vIEl0IGFza3MgdGhlIHVzZXIgdGhlaXIgcGVybWlzc2lvbiB0byB1c2UgdGhlaXIgcmVjb3JkaW5nIGRldmljZSB0byByZWNvcmQgdGhlaXIgdm9pY2Vcbi8vIGFuZCB0aGVuIHVwbG9hZCBpdCBmb3IgcmVzZWFyY2ggcHVycG9zZXNcbi8vIFRoZSBjb250cm9sbGVyIHNob3VsZCBiZSBwbGFjZWQgYmVmb3JlIGFueSByZWNvcmRpbmcgaXMgZG9uZSBpbiB0aGUgcnVubmluZyBvcmRlclxuZnVuY3Rpb24gaW5pdGlhdGVSZWNvcmRlcihjb250cm9sbGVyKXtcblxuICAgIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyl7XG4gICAgICAgIGNvbnRyb2xsZXIuZWxlbWVudC5hcHBlbmQoJChcIjxwPlNvcnJ5LCB5b3UgY2Fubm90IGNvbXBsZXRlIHRoaXMgZXhwZXJpbWVudCBiZWNhdXNlIHlvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHZvaWNlIHJlY29yZGluZy48L3A+XCIpKTtcbiAgICAgICAgcmV0dXJuIEFib3J0O1xuICAgIH1cbiAgICBcbiAgICBsZXQgbWVzc2FnZSA9IGRnZXQoY29udHJvbGxlci5vcHRpb25zLCBcInBlcm1pc3Npb25NZXNzYWdlXCIsIHBlcm1pc3Npb25NZXNzYWdlKTtcblxuICAgIGNvbnRyb2xsZXIuZWxlbWVudC5hcHBlbmQoJChcIjxwPlwiK21lc3NhZ2UrXCI8L3A+XCIpKTtcblxuICAgIHZhciBjb25zdHJhaW50cyA9IHsgYXVkaW86IHRydWUgfTtcbiAgICB2YXIgY2h1bmtzID0gW107XG4gICAgXG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpXG4gICAgLnRoZW4oZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgXG4gICAgICAgIG1lZGlhUmVjb3JkZXIgPSBuZXcgTWVkaWFSZWNvcmRlcihzdHJlYW0pO1xuICAgIFxuICAgICAgICBtZWRpYVJlY29yZGVyLm9uc3RvcCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZGF0YSBhdmFpbGFibGUgYWZ0ZXIgTWVkaWFSZWNvcmRlci5zdG9wKCkgY2FsbGVkLlwiKTtcblxuICAgICAgICAgICAgY3VycmVudFZvaWNlSW5zdHJ1Y3Rpb24uZmlsZW5hbWUgPSAnbXNyLScgKyAobmV3IERhdGUpLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvOnxcXC4vZywgJy0nKSArICcub2dnJztcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRmlsZW5hbWU6XCIsIGN1cnJlbnRWb2ljZUluc3RydWN0aW9uLmZpbGVuYW1lKTtcbiAgICAgICAgICAgIGN1cnJlbnRWb2ljZUluc3RydWN0aW9uLmJsb2IgPSBuZXcgQmxvYihjaHVua3MsIHsgJ3R5cGUnIDogJ2F1ZGlvL29nZzsgY29kZWNzPW9wdXMnIH0pO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJCbG9iOlwiLCBjdXJyZW50Vm9pY2VJbnN0cnVjdGlvbi5ibG9iKTtcbiAgICAgICAgICAgIGN1cnJlbnRWb2ljZUluc3RydWN0aW9uLmF1ZGlvUGxheWVyLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoY3VycmVudFZvaWNlSW5zdHJ1Y3Rpb24uYmxvYik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInNyYzpcIiwgY3VycmVudFZvaWNlSW5zdHJ1Y3Rpb24uYXVkaW9QbGF5ZXIuc3JjKTtcblxuICAgICAgICAgICAgY2h1bmtzID0gW107XG4gICAgICAgICAgICBjdXJyZW50Vm9pY2VJbnN0cnVjdGlvbiA9IG51bGw7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicmVjb3JkZXIgc3RvcHBlZFwiKTtcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgbWVkaWFSZWNvcmRlci5vbmRhdGFhdmFpbGFibGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBjaHVua3MucHVzaChlLmRhdGEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGxldCBhdXRob3JpemF0aW9uTWVzc2FnZSA9IFwiQnkgY2xpY2tpbmcgdGhpcyBsaW5rIEkgdW5kZXJzdGFuZCB0aGF0IEkgZ3JhbnQgdGhpcyBleHBlcmltZW50J3Mgc2NyaXB0IGFjY2VzcyBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidG8gbXkgcmVjb3JkaW5nIGRldmljZSBmb3IgdGhlIHB1cnBvc2Ugb2YgdXBsb2FkaW5nIHZvaWNlIHJlY29yZGluZ3MgXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRvIHRoZSBzZXJ2ZXIgZGVzaWduYXRlZCBieSB0aGUgZXhwZXJpbWVudGVyKHMpLlwiO1xuXG4gICAgICAgIC8vIEFkZCBhdXRob3JpemF0aW9uL1wiY29udGludWVcIiBsaW5rIG5vdyB0aGF0IHRoZSBwYXJ0aWNpcGFudCBoYXMgZ3JhbnRlZCBhY2Nlc3MgdG8gdGhlIHJlY29yZGluZyBkZXZpY2VcbiAgICAgICAgY29udHJvbGxlci5lbGVtZW50LmFwcGVuZChcbiAgICAgICAgICAgICQoXCI8YT5cIithdXRob3JpemF0aW9uTWVzc2FnZStcIjwvYT5cIilcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJNZXNzYWdlLWNvbnRpbnVlLWxpbmtcIilcbiAgICAgICAgICAgICAgICAuY2xpY2soY29udHJvbGxlci5maW5pc2hlZENhbGxiYWNrKVxuICAgICAgICApO1xuXG4gICAgfSlcbiAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZWxlbWVudC5hcHBlbmQoJChcIjxwPlRoZSBmb2xsb3dpbmcgZXJyb3Igb2NjdXJyZWQ6IFwiICsgZXJyICsgXCI8L3A+XCIpKTtcbiAgICAgICAgcmV0dXJuIEFib3J0O1xuICAgIH0pXG59XG5cblxuLy8gRGVmaW5lcyBhIGNvbnRyb2xsZXIgdGhhdCB1cGxvYWRzIHRoZSBhcmNoaXZlIGNvbnRhaW5pbmcgdGhlIGF1ZGlvIHJlY29yZGluZ3Ncbi8vIEl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBhZGRlZCBiZWZvcmUgX19TZW5kUmVzdWx0c19fIGlmIGl0IGlzIG5vdCBtYW51YWxseSBhZGRlZCB0byBpdGVtc1xuLy8gSXQgYXNrcyB0aGUgcGFydGljaXBhbnQgZm9yIHRoZWlyIGV4cHJlc3MgcGVybWlzc2lvbiB0byBzZW5kIHRoZSBhcmNoaXZlIG9uIHRoZSBzZXJ2ZXJzXG4vLyBhbmQgZ2l2ZXMgdGhlbSB0aGUgb3B0aW9uIHRvIGRvd25sb2FkIGEgY29weSBvZiB0aGUgYXJjaGl2ZVxuZnVuY3Rpb24gdXBsb2FkUmVjb3JkaW5ncyhjb250cm9sbGVyKSB7XG5cbiAgICBjb250cm9sbGVyLmVsZW1lbnQuYXBwZW5kKCQoXCI8cD5QbGVhc2Ugd2FpdCB3aGlsZSB0aGUgYXJjaGl2ZSBpcyBiZWluZyB1cGxvYWRlZCB0byB0aGUgc2VydmVyLi4uPC9wPlwiKSk7XG5cbiAgICB2YXIgemlwID0gbmV3IEpTWmlwKCk7ICAgLy8gQ3JlYXRlIHRoZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSB6aXAgZmlsZVxuXG4gICAgZm9yIChsZXQgcyBpbiBhdWRpb1N0cmVhbXMpIHtcbiAgICAgICAgdmFyIGZpbGUgPSBhdWRpb1N0cmVhbXNbc107XG4gICAgICAgIHppcC5maWxlKGZpbGUubmFtZSwgZmlsZS5kYXRhKTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnR2VuZXJhdGluZyBjb21wcmVzc2VkIGFyY2hpdmUuLi4nKTtcbiAgICB6aXAuZ2VuZXJhdGVBc3luYyh7XG4gICAgICAgIGNvbXByZXNzaW9uOiAnREVGTEFURScsXG4gICAgICAgIHR5cGU6ICdibG9iJ1xuICAgIH0pLnRoZW4oZnVuY3Rpb24oemMpIHsgLy8gRnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIGdlbmVyYXRpb24gaXMgY29tcGxldGVcbiAgICAgICAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gdG8gZG93bmxvYWQgdGhlIGFyY2hpdmVcbiAgICAgICAgUGVubkNvbnRyb2xsZXIuZG93bmxvYWRWb2ljZVJlY29yZGluZ3NBcmNoaXZlID0gZnVuY3Rpb24oKXsgc2F2ZUFzKHpjLCBcIlZvaWNlUmVjb3JkaW5nc0FyY2hpdmUuemlwXCIpOyB9O1xuICAgICAgICBjb25zb2xlLmxvZygnQ29tcHJlc3Npb24gY29tcGxldGUhJyk7XG4gICAgICAgIHZhciBmaWxlTmFtZSA9ICdtc3ItJyArIChuZXcgRGF0ZSkudG9JU09TdHJpbmcoKS5yZXBsYWNlKC86fFxcLi9nLCAnLScpICsgJy56aXAnO1xuICAgICAgICAvLyBDcmVhdGUgZmlsZSBvYmplY3QgdG8gdXBsb2FkXG4gICAgICAgIHZhciBmaWxlT2JqID0gbmV3IEZpbGUoW3pjXSwgZmlsZU5hbWUpO1xuICAgICAgICBjb25zb2xlLmxvZygnRmlsZSBvYmplY3QgY3JlYXRlZDonLCBmaWxlT2JqKTtcbiAgICAgICAgdmFyIGZkID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgIGZkLmFwcGVuZCgnZmlsZU5hbWUnLCBmaWxlTmFtZSk7XG4gICAgICAgIGZkLmFwcGVuZCgnZmlsZScsIGZpbGVPYmopO1xuICAgICAgICBmZC5hcHBlbmQoJ21pbWVUeXBlJywgJ2FwcGxpY2F0aW9uL3ppcCcpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlVwbG9hZCBVUkw6XCIsIHVwbG9hZFVSTCk7XG4gICAgICAgIC8vIFVzaW5nIFhNTEh0dHBSZXF1ZXN0IHJhdGhlciB0aGFuIGpRdWVyeSdzIEFqYXggKG15c3RlcmlvdXMgQ09SUyBwcm9ibGVtcyB3aXRoIGpRdWVyeSAxLjgpXG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgeGhyLm9wZW4oJ1BPU1QnLCB1cGxvYWRVUkwsIHRydWUpO1xuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIDQgbWVhbnMgZmluaXNoZWQgYW5kIHJlc3BvbnNlIHJlYWR5XG4gICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09IDQpe1xuICAgICAgICAgICAgLy8gMjAwIG1lYW5zIHN1Y2Nlc3NcbiAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09IDIwMCAmJiAheGhyLnJlc3BvbnNlVGV4dC5tYXRjaCgvcHJvYmxlbXxlcnJvci9pKSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQWpheCBwb3N0IHdhcyBzdWNjZXNzZnVsLiAnLCB4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5maW5pc2hlZENhbGxiYWNrKFtbW1wiVm9pY2VSZWNvcmRpbmdzRmlsZW5hbWVcIiwgZmlsZU5hbWVdLCBbXCJVcGxvYWRTdGF0dXNcIiwgXCJTdWNjZXNzXCJdXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRWxzZSwgZXJyb3JcbiAgICAgICAgICAgIGVsc2UgeyBcbiAgICAgICAgICAgICAgYWxlcnQoXCJUaGVyZSB3YXMgYW4gZXJyb3IgdXBsb2FkaW5nIHRoZSByZWNvcmRpbmdzIChcIit4aHIucmVzcG9uc2VUZXh0K1wiKS5cIik7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBamF4IHBvc3QgZmFpbGVkLiAoJyt4aHIuc3RhdHVzKycpJywgeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZmluaXNoZWRDYWxsYmFjayhbW1tcIlZvaWNlUmVjb3JkaW5nc0ZpbGVuYW1lXCIsIGZpbGVOYW1lXSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIlVwbG9hZFN0YXR1c1wiLCBcIkZhaWxlZFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiRXJyb3IgVGV4dFwiLCB4aHIucmVzcG9uc2VUZXh0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiU3RhdHVzXCIsIHhoci5zdGF0dXNdXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gXG4gICAgICAgIH07XG4gICAgICAgIHhoci5zZW5kKGZkKTtcbiAgICB9KTtcbn1cblxuXG4vLyBBZGRpbmcgdGhlIHVwbG9hZCBzdGVwIGlmIG5vdCBhbHJlYWR5IHRoZXJlXG5jaGFuZ2VSdW5uaW5nT3JkZXIoZnVuY3Rpb24gKHJvKSB7XG4gICAgLy8gSWYgUGVubkNvbnRyb2xsZXIuSW5pdGlhdGVSZWNvcmRlciBoYXMgbm90IGJlZW4gY2FsbGVkLCBsZWF2ZSBydW5uaW5nIG9yZGVyIGFzIGlzXG4gICAgaWYgKCFpbml0aWF0ZWQpXG4gICAgICAgIHJldHVybiBybztcbiAgICBsZXQgbWFudWFsVXBsb2FkID0gZmFsc2U7XG4gICAgbGV0IHNlbmRSZXN1bHRzSUQgPSBbLTEsLTFdO1xuICAgIC8vIEdvIHRocm91Z2ggZWFjaCBlbGVtZW50IG9mIGVhY2ggaXRlbSBpbiB0aGUgcnVubmluZyBvcmRlclxuICAgIGZvciAobGV0IGl0ZW0gPSAwOyBpdGVtIDwgcm8ubGVuZ3RoOyArK2l0ZW0pIHtcbiAgICAgICAgZm9yIChsZXQgZWxlbWVudCA9IDA7IGVsZW1lbnQgPCByb1tpdGVtXS5sZW5ndGg7ICsrZWxlbWVudCkge1xuICAgICAgICAgICAgLy8gSWYgY3VycmVudCBlbGVtZW50IGlzICd1cGxvYWRSZWNvcmRpbmdzJyB0aGVuIHVwbG9hZCBpcyBtYW51YWxcbiAgICAgICAgICAgIGlmIChyb1tpdGVtXVtlbGVtZW50XS5jb250cm9sbGVyID09IFwiUGVubkNvbnRyb2xsZXJcIikge1xuICAgICAgICAgICAgICAgIGlmIChyb1tpdGVtXVtlbGVtZW50XS5vcHRpb25zLmhhc093blByb3BlcnR5KFwiY3VzdG9tXCIpICYmIHJvW2l0ZW1dW2VsZW1lbnRdLm9wdGlvbnMuY3VzdG9tID09IHVwbG9hZFJlY29yZGluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFudWFsVXBsb2FkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbmRSZXN1bHRzSURbMF0+PTApXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGVydChcIldBUk5JTkc6IHVwbG9hZCBvZiB2b2ljZSBhcmNoaXZlIHNldCBBRlRFUiBzZW5kaW5nIG9mIHJlc3VsdHM7IGNoZWNrIHRoZSAnaXRlbXMnIGFuZCAnc2h1ZmZsZVNlcXVlbmNlJyB2YXJpYWJsZXMuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGN1cnJlbnQgZWxlbWVudCBpcyBmaXJzdCBlbmNvdW50ZXJlZCAnX19TZW5kUmVzdWx0c19fJyAoYW5kIG1hbnVhbFVwbG9hZCBub3QgZGV0ZWN0ZWQgc28gZmFyKVxuICAgICAgICAgICAgZWxzZSBpZiAocm9baXRlbV1bZWxlbWVudF0uY29udHJvbGxlciA9PSBcIl9fU2VuZFJlc3VsdHNfX1wiICYmIHNlbmRSZXN1bHRzSURbMF08MCAmJiAhbWFudWFsVXBsb2FkKVxuICAgICAgICAgICAgICAgIHNlbmRSZXN1bHRzSUQgPSBbaXRlbSwgZWxlbWVudF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgbm8gbWFudWFsIHVwbG9hZCBkZXRlY3RlZCwgdGhlbiBhZGQgdGhlIHVwbG9hZCBjb250cm9sbGVyIGJlZm9yZSBfX1NlbmRSZXN1bHRzX19cbiAgICBpZiAoIW1hbnVhbFVwbG9hZCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIk5vIG1hbnVhbCB1cGxvYWRcIik7XG4gICAgICAgIGxldCB1cGxvYWRFbGVtZW50ID0gbmV3IER5bmFtaWNFbGVtZW50KFwiUGVubkNvbnRyb2xsZXJcIiwge2N1c3RvbTogdXBsb2FkUmVjb3JkaW5nc30pO1xuICAgICAgICAvLyBJZiBfX1NlbmRSZXN1bHRzX18gd2FzIGFkZGVkIG1hbnVhbGx5LCBhZGQgdXBsb2FkIGNvbnRyb2xsZXIgYmVmb3JlIGl0XG4gICAgICAgIGlmIChzZW5kUmVzdWx0c0lEWzBdPj0wKVxuICAgICAgICAgICAgcm9bc2VuZFJlc3VsdHNJRFswXV0uc3BsaWNlKHNlbmRSZXN1bHRzSURbMV0sIDAsIHVwbG9hZEVsZW1lbnQpO1xuICAgICAgICAvLyBFbHNlLCBqdXN0IGFkZCB1cGxvYWRFbGVtZW50IGF0IHRoZSBlbmRcbiAgICAgICAgZWxzZSBcbiAgICAgICAgICAgIHJvLnB1c2goW3VwbG9hZEVsZW1lbnRdKTtcbiAgICB9XG4gICAgY29uc29sZS5sb2coXCJSZXR1cm5pbmcgcm8gZnJvbSB2b2ljZTpcIiwgcm8pO1xuICAgIHJldHVybiBybztcbn0pO1xuXG5cblxuLy8gSW5pdGlhdGVSZWNvcmRlciBNVVNUIGJlIG1hbnVhbGx5IGFkZGVkIHRvIGl0ZW1zIGFuZCBzcGVjaWZ5IGEgVVJMIHRvIGEgUEhQIGZpbGUgZm9yIHVwbG9hZGluZyB0aGUgYXJjaGl2ZVxuUGVubkNvbnRyb2xsZXIuSW5pdGlhdGVSZWNvcmRlciA9IGZ1bmN0aW9uKHNhdmVVUkwsIG1lc3NhZ2UpIHtcbiAgICBpZiAoIXR5cGVvZih1cmwpPT1cInN0cmluZ1wiIHx8ICFzYXZlVVJMLm1hdGNoKC9eaHR0cC4rL2kpKVxuICAgICAgICByZXR1cm4gY29uc29sZS5sb2coXCJFUlJPUjogc2F2ZSBVUkwgaXMgaW5jb3JyZWN0XCIsIHNhdmVVUkwpO1xuICAgIHVwbG9hZFVSTCA9IHNhdmVVUkw7XG4gICAgaW5pdGlhdGVkID0gdHJ1ZTtcbiAgICByZXR1cm4ge2N1c3RvbTogaW5pdGlhdGVSZWNvcmRlciwgcGVybWlzc2lvbk1lc3NhZ2U6IG1lc3NhZ2V9O1xufTtcblxuXG4vLyBIYW5kbGVyIGdlbmVyYXRpbmcgYSBIVE1MIGJ1dHRvbiB0byBkb3dubG9hZCB0aGUgemlwIGFyY2hpdmUgY29udGFpbmluZyB0aGUgdm9pY2UgcmVjb3JkaW5nc1xuUGVubkNvbnRyb2xsZXIuRG93bmxvYWRWb2ljZUJ1dHRvbiA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgcmV0dXJuIFwiPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIG9uY2xpY2s9XFxcIlwiK1xuICAgICAgICAgICBcImlmIChQZW5uQ29udHJvbGxlci5oYXNPd25Qcm9wZXJ0eSgnZG93bmxvYWRWb2ljZVJlY29yZGluZ3NBcmNoaXZlJykpXCIrXG4gICAgICAgICAgIFwiICBQZW5uQ29udHJvbGxlci5kb3dubG9hZFZvaWNlUmVjb3JkaW5nc0FyY2hpdmUoKTtcIitcbiAgICAgICAgICAgXCIgIFwiK1xuICAgICAgICAgICBcImVsc2VcIitcbiAgICAgICAgICAgXCIgIGFsZXJ0KCdFUlJPUjogY291bGQgbm90IGZpbmQgYW4gYXJjaGl2ZSBmb3Igdm9pY2UgcmVjb3JkaW5ncycpO1wiK1xuICAgICAgICAgICBcIlxcXCI+XCIrdGV4dCtcIjwvYnV0dG9uPlwiO1xufTtcblxuXG4vLyBBZGRzIGFuIFZPSUNFIHRvIHRoZSBwYXJlbnQgZWxlbWVudFxuLy8gRG9uZSBpbW1lZGlhdGVseVxuY2xhc3MgVm9pY2VSZWNvcmRlckluc3RyIGV4dGVuZHMgSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGFyZykge1xuICAgICAgICBzdXBlcihhcmcsIFwidm9pY2VcIik7XG4gICAgICAgIGlmIChhcmcgIT0gQWJvcnQpIHtcblxuICAgICAgICAgICAgdGhpcy5yZWNvcmRpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgdGhpcy5hdWRpb1BsYXllciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhdWRpb1wiKTtcblxuICAgICAgICAgICAgbGV0IHJlY29yZGVyVUkgPSAkKFwiPHNwYW4+XCIpLmFkZENsYXNzKFwiUGVubkNvbnRyb2xsZXItVm9pY2VSZWNvcmRlclVJXCIpO1xuICAgICAgICAgICAgbGV0IHJlY29yZEJ1dHRvbiA9ICQoXCI8YnV0dG9uPlwiKS5hZGRDbGFzcyhcIlBlbm5Db250cm9sbGVyLVZvaWNlUmVjb3JkZXJSZWNvcmRcIik7XG4gICAgICAgICAgICBsZXQgcmVjb3JkU3RhdHVzID0gJChcIjxkaXY+XCIpLmFkZENsYXNzKFwiUGVubkNvbnRyb2xsZXItVm9pY2VSZWNvcmRlclN0YXR1c1wiKTtcbiAgICAgICAgICAgIGxldCBwbGF5QnV0dG9uID0gJChcIjxidXR0b24+XCIpLmFkZENsYXNzKFwiUGVubkNvbnRyb2xsZXItVm9pY2VSZWNvcmRlclBsYXlcIik7XG4gICAgICAgICAgICBsZXQgcGxheUlubmVyID0gJChcIjxkaXY+XCIpO1xuICAgICAgICAgICAgbGV0IHN0b3BCdXR0b24gPSAkKFwiPGJ1dHRvbj5cIikuYWRkQ2xhc3MoXCJQZW5uQ29udHJvbGxlci1Wb2ljZVJlY29yZGVyU3RvcFwiKTtcbiAgICAgICAgICAgIGxldCBzdG9wSW5uZXIgPSAkKFwiPGRpdj5cIik7XG5cbiAgICAgICAgICAgIC8vIENTU1xuICAgICAgICAgICAgJChbcmVjb3JkQnV0dG9uLCBwbGF5QnV0dG9uLCBzdG9wQnV0dG9uXSkuZWFjaChmdW5jdGlvbigpeyB0aGlzLmNzcyh7d2lkdGg6IFwiMjVweFwiLCBoZWlnaHQ6IFwiMjVweFwiLCBwb3NpdGlvbjogXCJyZWxhdGl2ZVwifSk7IH0pO1xuICAgICAgICAgICAgJChbcGxheUlubmVyLCBzdG9wSW5uZXIsIHJlY29yZFN0YXR1c10pLmVhY2goZnVuY3Rpb24oKXsgdGhpcy5jc3Moe3Bvc2l0aW9uOiBcImFic29sdXRlXCIsIGxlZnQ6IFwiMnB4XCIsIHRvcDogXCI0cHhcIiwgd2lkdGg6IFwiMTVweFwiLCBoZWlnaHQ6IFwiMTVweFwifSk7IH0pO1xuICAgICAgICAgICAgcmVjb3JkQnV0dG9uLmNzcyh7J2JhY2tncm91bmQtY29sb3InOiBcInJlZFwiLCAnYm9yZGVyLXJhZGl1cyc6IFwiNTAlXCIsIFwibWFyZ2luLXJpZ2h0XCI6IFwiMTBweFwifSk7XG4gICAgICAgICAgICByZWNvcmRTdGF0dXMuY3NzKHsnYmFja2dyb3VuZC1jb2xvcic6IFwiYnJvd25cIiwgJ2JvcmRlci1yYWRpdXMnOiBcIjUwJVwiLCBsZWZ0OiBcIjZweFwiLCB0b3A6IFwiNnB4XCIsIHdpZHRoOiBcIjEwcHhcIiwgaGVpZ2h0OiBcIjEwcHhcIiB9KTtcbiAgICAgICAgICAgIHBsYXlJbm5lci5jc3Moe1xuICAgICAgICAgICAgICAgIHdpZHRoOiAwLCBoZWlnaHQ6IDAsICdiYWNrZ3JvdW5kLWNvbG9yJzogXCJ0cmFuc3BhcmVudFwiLCBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgICAgICdib3JkZXItdG9wJzogXCI3LjVweCBzb2xpZCB0cmFuc3BhcmVudFwiLCAnYm9yZGVyLWJvdHRvbSc6IFwiNy41cHggc29saWQgdHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgICAgICAnYm9yZGVyLXJpZ2h0JzogXCIwcHggc29saWQgdHJhbnNwYXJlbnRcIiwgJ2JvcmRlci1sZWZ0JzogXCIxNXB4IHNvbGlkIGdyZWVuXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RvcElubmVyLmNzcyh7ICdiYWNrZ3JvdW5kLWNvbG9yJzogXCJicm93blwiIH0pO1xuXG4gICAgICAgICAgICBsZXQgc2hvd1BsYXkgPSBmdW5jdGlvbihlbmFibGVkKXtcbiAgICAgICAgICAgICAgICBwbGF5QnV0dG9uLmNzcyhcImRpc3BsYXlcIiwgXCJpbmxpbmUtYmxvY2tcIik7XG4gICAgICAgICAgICAgICAgc3RvcEJ1dHRvbi5jc3MoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoZW5hYmxlZCl7XG4gICAgICAgICAgICAgICAgICAgIHBsYXlJbm5lci5jc3MoJ2JvcmRlci1sZWZ0JywgXCIxNXB4IHNvbGlkIGdyZWVuXCIpO1xuICAgICAgICAgICAgICAgICAgICBwbGF5QnV0dG9uLmF0dHIoXCJkaXNhYmxlZFwiLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwbGF5SW5uZXIuY3NzKCdib3JkZXItbGVmdCcsIFwiMTVweCBzb2xpZCBncmF5XCIpO1xuICAgICAgICAgICAgICAgICAgICBwbGF5QnV0dG9uLmF0dHIoXCJkaXNhYmxlZFwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHNob3dTdG9wID0gZnVuY3Rpb24oZW5hYmxlZCl7XG4gICAgICAgICAgICAgICAgc3RvcEJ1dHRvbi5jc3MoXCJkaXNwbGF5XCIsIFwiaW5saW5lLWJsb2NrXCIpO1xuICAgICAgICAgICAgICAgIHBsYXlCdXR0b24uY3NzKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG4gICAgICAgICAgICAgICAgaWYgKGVuYWJsZWQpe1xuICAgICAgICAgICAgICAgICAgICBzdG9wSW5uZXIuY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJywgXCJicm93blwiKTtcbiAgICAgICAgICAgICAgICAgICAgc3RvcEJ1dHRvbi5hdHRyKFwiZGlzYWJsZWRcIiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcElubmVyLmNzcygnYmFja2dyb3VuZC1jb2xvcicsIFwiZ3JheVwiKTtcbiAgICAgICAgICAgICAgICAgICAgc3RvcEJ1dHRvbi5hdHRyKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc2hvd1BsYXkoZmFsc2UpO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGVyc1xuICAgICAgICAgICAgbGV0IHRpID0gdGhpcztcbiAgICAgICAgICAgIGxldCBzdGF0dXNJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgICAgICByZWNvcmRCdXR0b24uY2xpY2soZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBpZiAodGkucmVjb3JkaW5nKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpLmF1ZGlvUGxheWVyLmN1cnJlbnRUaW1lPjApe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGkuYXVkaW9QbGF5ZXIucGF1c2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpLmF1ZGlvUGxheWVyLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dQbGF5KGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aS5yZWNvcmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChzdGF0dXNJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZFN0YXR1cy5jc3MoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsXCJicm93blwiKTtcbiAgICAgICAgICAgICAgICAgICAgc2hvd1BsYXkodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRpLl9zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmRTdGF0dXMuY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcImxpZ2h0Z3JlZW5cIik7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c0ludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmRTdGF0dXMuY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiKSA9PSBcInJnYigyNTUsIDI1NSwgMjU1KVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZFN0YXR1cy5jc3MoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwibGlnaHRncmVlblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRTdGF0dXMuY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcIndoaXRlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9LCA3NTApO1xuICAgICAgICAgICAgICAgICAgICBzaG93UGxheShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRpLnJlY29yZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRpLl9zdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGxheUJ1dHRvbi5jbGljayhmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHNob3dTdG9wKHRydWUpO1xuICAgICAgICAgICAgICAgIHRpLmF1ZGlvUGxheWVyLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgICAgICAgICB0aS5hdWRpb1BsYXllci5wbGF5KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0b3BCdXR0b24uY2xpY2soZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBpZiAodGkuYXVkaW9QbGF5ZXIuY3VycmVudFRpbWU+MCl7XG4gICAgICAgICAgICAgICAgICAgIHRpLmF1ZGlvUGxheWVyLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRpLmF1ZGlvUGxheWVyLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgc2hvd1BsYXkodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmF1ZGlvUGxheWVyLm9uZW5kZWQgPSBmdW5jdGlvbigpeyBzaG93UGxheSh0cnVlKTsgfTtcblxuICAgICAgICAgICAgcmVjb3JkZXJVSS5hcHBlbmQocmVjb3JkQnV0dG9uLmFwcGVuZChyZWNvcmRTdGF0dXMpKS5hcHBlbmQocGxheUJ1dHRvbi5hcHBlbmQocGxheUlubmVyKSkuYXBwZW5kKHN0b3BCdXR0b24uYXBwZW5kKHN0b3BJbm5lcikpO1xuXG4gICAgICAgICAgICAvLyBTZXQgZWxlbWVudCB0byBTUEFOICh3aWxsIGFwcGVuZCBhdWRpbyBsYXRlcilcbiAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudChyZWNvcmRlclVJKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQUklWQVRFICYgSU5UUklOU0lDIE1FVEhPRFNcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBydW4oKSB7XG4gICAgICAgIGlmIChzdXBlci5ydW4oKSA9PSBBYm9ydClcbiAgICAgICAgICAgIHJldHVybiBBYm9ydDtcbiAgICAgICAgXG4gICAgICAgIGlmICh0eXBlb2YobWVkaWFSZWNvcmRlcik9PVwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS5sb2coXCJFUlJPUjogcmVjb3JkZXIgbm90IGluaXRpYXRlZC4gXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJNYWtlIHN1cmUgeW91ciBpdGVtcyB2YXJpYWJsZSBjb250YWlucyBhbiBJbml0aWF0ZVJlY29yZGVyIGNvbnRyb2xsZXIuXCIpO1xuXG4gICAgICAgIGxldCB0aSA9IHRoaXM7XG4gICAgICAgIEN0cmxyLnJ1bm5pbmcuY2FsbGJhY2tCZWZvcmVGaW5pc2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmICh0aS5ibG9iKVxuICAgICAgICAgICAgICAgIGF1ZGlvU3RyZWFtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdGkuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHRpLmJsb2JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aS5TdGFydFJlY29yZGluZylcbiAgICAgICAgICAgICAgICBDdHJsci5ydW5uaW5nLnNhdmUoXCJWb2ljZVJlY29yZGVyXCIsIFwiU3RhcnRSZWNvcmRpbmdcIiwgdGkuU3RhcnRSZWNvcmRpbmcsIHRpLl9pZCk7XG4gICAgICAgICAgICBpZiAodGkuU3RvcFJlY29yZGluZylcbiAgICAgICAgICAgICAgICBDdHJsci5ydW5uaW5nLnNhdmUoXCJWb2ljZVJlY29yZGVyXCIsIFwiU3RvcFJlY29yZGluZ1wiLCB0aS5TdG9wUmVjb3JkaW5nLCB0aS5faWQpO1xuICAgICAgICAgICAgaWYgKHRpLmZpbGVuYW1lKVxuICAgICAgICAgICAgICAgIEN0cmxyLnJ1bm5pbmcuc2F2ZShcIlZvaWNlUmVjb3JkZXJcIiwgXCJGaWxlbmFtZVwiLCB0aS5maWxlbmFtZSwgdGkuX2lkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fYWRkRWxlbWVudCh0aGlzLnBhcmVudEVsZW1lbnQpO1xuXG4gICAgICAgIHRoaXMuZG9uZSgpO1xuICAgIH1cblxuICAgIF9zdGFydCgpIHtcbiAgICAgICAgdGhpcy5yZWNvcmRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLlN0YXJ0UmVjb3JkaW5nID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbWVkaWFSZWNvcmRlci5zdGFydCgpO1xuICAgIH1cblxuICAgIF9zdG9wKCkge1xuICAgICAgICB0aGlzLnJlY29yZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLlN0b3BSZWNvcmRpbmcgPSBEYXRlLm5vdygpO1xuICAgICAgICBjdXJyZW50Vm9pY2VJbnN0cnVjdGlvbiA9IHRoaXM7XG4gICAgICAgIG1lZGlhUmVjb3JkZXIuc3RvcCgpO1xuICAgIH1cbn1cblxuUGVubkNvbnRyb2xsZXIuaW5zdHJ1Y3Rpb24udm9pY2VSZWNvcmRlciA9IGZ1bmN0aW9uKCl7IHJldHVybiBuZXcgVm9pY2VSZWNvcmRlckluc3RyKCk7IH07IiwiLy8gaW1wb3J0IHtfc2V0Q3RybHJ9IGZyb20gXCIuLi9jb250cm9sbGVyLmpzXCI7XG5cbi8vIEFkZHMgYSB0aW1lclxuLy8gRG9uZSBpbW1lZGlhdGVseVxuY2xhc3MgVGltZXJJbnN0ciBleHRlbmRzIEluc3RydWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihkZWxheSwgY2FsbGJhY2spIHtcbiAgICAgICAgc3VwZXIoZGVsYXksIFwidGltZXJcIik7XG4gICAgICAgIGlmIChkZWxheSAhPSBBYm9ydCl7XG4gICAgICAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgICAgICAgICB0aGlzLnNldEVsZW1lbnQoJChcIjx0aW1lcj5cIikpO1xuICAgICAgICAgICAgdGhpcy5zdGVwID0gMTA7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICB0aGlzLmNsZWFyZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQUklWQVRFICYgSU5UUklOU0lDIE1FVEhPRFNcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBydW4oKSB7XG4gICAgICAgIGlmIChzdXBlci5ydW4oKSA9PSBBYm9ydClcbiAgICAgICAgICAgIHJldHVybiBBYm9ydDtcbiAgICAgICAgdGhpcy5sZWZ0ID0gdGhpcy5kZWxheTtcbiAgICAgICAgbGV0IHRpID0gdGhpcztcbiAgICAgICAgLyp0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRpLmxlZnQgLT0gdGkuc3RlcDtcbiAgICAgICAgICAgIGlmICh0aS5sZWZ0IDw9IDApe1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGkudGltZXIpO1xuICAgICAgICAgICAgICAgIHRpLmxlZnQgPSAwO1xuICAgICAgICAgICAgICAgIHRpLl9lbGFwc2VkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuc3RlcCk7Ki9cbiAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXsgdGkuX2VsYXBzZWQoKTsgfSwgdGhpcy5kZWxheSk7XG4gICAgICAgIC8vX3NldEN0cmxyKFwidGltZXJzXCIsIEN0cmxyLnJ1bm5pbmcudGltZXJzLmNvbmNhdChbdGhpcy50aW1lcl0pKTtcbiAgICAgICAgQ3RybHIucnVubmluZy50aW1lcnMucHVzaCh0aGlzLnRpbWVyKTtcbiAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgfVxuXG4gICAgLy8gQ2FsbGVkIHdoZW4gdGltZXIgaGFzIGVsYXBzZWRcbiAgICBfZWxhcHNlZCgpIHtcbiAgICAgICAgdGhpcy5jbGVhcmVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2soKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5jYWxsYmFjayBpbnN0YW5jZW9mIEluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrLnBhcmVudEVsZW1lbnQgPSBDdHJsci5ydW5uaW5nLmVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrLnJ1bigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIE1FVEhPRFMgUkVUVVJOSU5HIE5FVyBJTlNUUlVDVElPTlNcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyBSZXR1cm5zIGFuIGluc3RydWN0aW9uIHRoYXQgcHJlbWF0dXJlbHkgc3RvcHMgdGhlIHRpbWVyXG4gICAgLy8gRG9uZSBpbW1lZGlhdGVseVxuICAgIHN0b3AoZG9uZSkge1xuICAgICAgICBsZXQgdGkgPSB0aGlzLCBpbnN0ciA9IHRoaXMubmV3TWV0YShmdW5jdGlvbigpIHsgdGkuZG9uZSB9KTtcbiAgICAgICAgaW5zdHIucnVuID0gZnVuY3Rpb24oKXsgXG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRpLm9yaWdpbi50aW1lcik7XG4gICAgICAgICAgICAvLyBJZiBET05FIGlzIHRydWUsIHRoZSAob3JpZ2luKSB0aW1lciBpbnN0cnVjdGlvbiBpcyBjb25zaWRlcmVkIGRvbmUgdXBvbiBzdG9wcGluZ1xuICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgdGkub3JpZ2luLmRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdHI7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhbiBpbnN0cnVjdGlvbiBhZnRlciBzZXR0aW5nIHRoZSBvcmlnaW4ncyBzdGVwXG4gICAgLy8gRG9uZSBpbW1lZGlhdGVseVxuICAgIHN0ZXAodmFsdWUpIHtcbiAgICAgICAgLy8gKFJlKXNldCB0aGUgc3RlcFxuICAgICAgICB0aGlzLm9yaWdpbi5zdGVwID0gdmFsdWU7XG4gICAgICAgIC8vIFJldHVybiB0aGUgaW5zdHJ1Y3Rpb24gaXRzZWxmXG4gICAgICAgIHJldHVybiB0aGlzLm5ld01ldGEoZnVuY3Rpb24oKXsgdGhpcy5kb25lKCk7IH0pO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYW4gaW5zdHJ1Y3Rpb24gdG8gc2FpdCB1bnRpbCB0aGUgdGltZXIgaGFzIGVsYXBzZWRcbiAgICAvLyBEb25lIHdoZW4gdGhlIHRpbWVyIGhhcyBlbGFwc2VkXG4gICAgd2FpdChjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdNZXRhKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBsZXQgdGkgPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHRpbWVyQ2xlYXJlZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgdGkuZG9uZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNhbGxiYWNrIGluc3RhbmNlb2YgSW5zdHJ1Y3Rpb24gJiYgIWNhbGxiYWNrLmhhc0JlZW5SdW4pXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLnJ1bigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjbGVhcmVkKVxuICAgICAgICAgICAgICAgIHRpbWVyQ2xlYXJlZCgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luLl9lbGFwc2VkID0gdGhpcy5vcmlnaW4uZXh0ZW5kKFwiX2VsYXBzZWRcIiwgdGltZXJDbGVhcmVkKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5QZW5uQ29udHJvbGxlci5pbnN0cnVjdGlvbi50aW1lciA9IGZ1bmN0aW9uKGRlbGF5LCBjYWxsYmFjayl7IHJldHVybiBuZXcgVGltZXJJbnN0cihkZWxheSwgY2FsbGJhY2spOyB9OyIsIi8vIEFkZHMgYSBTUEFOIHRvIHRoZSBwYXJlbnQgZWxlbWVudFxuLy8gRG9uZSBpbW1lZGlhdGVseVxuY2xhc3MgVGV4dEluc3RyIGV4dGVuZHMgSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHRleHQpIHtcbiAgICAgICAgc3VwZXIodGV4dCwgXCJ0ZXh0XCIpO1xuICAgICAgICBpZiAodGV4dCAhPSBBYm9ydCkge1xuICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50KCQoXCI8c3Bhbj5cIikuaHRtbCh0ZXh0KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUFJJVkFURSAmIElOVFJJTlNJQyBNRVRIT0RTXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgcnVuKCkge1xuICAgICAgICBpZiAoc3VwZXIucnVuKCkgPT0gQWJvcnQpXG4gICAgICAgICAgICByZXR1cm4gQWJvcnQ7XG4gICAgICAgIHRoaXMuX2FkZEVsZW1lbnQodGhpcy5wYXJlbnRFbGVtZW50KTtcbiAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIE1FVEhPRFMgUkVUVVJOSU5HIE5FVyBJTlNUUlVDVElPTlNcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyBDaGFuZ2VzIHRoZSBjb250ZW50XG4gICAgLy8gRG9uZSBpbW1lZGlhdGVseVxuICAgIHRleHQodGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdNZXRhKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbi5jb250ZW50ID0gdGV4dDtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luLmVsZW1lbnQuaHRtbCh0ZXh0KTtcbiAgICAgICAgICAgIHRoaXMuZG9uZSgpO1xuICAgICAgICB9KVxuICAgIH1cbn1cblxuUGVubkNvbnRyb2xsZXIuaW5zdHJ1Y3Rpb24udGV4dCA9IGZ1bmN0aW9uKHRleHQpeyByZXR1cm4gbmV3IFRleHRJbnN0cih0ZXh0KTsgfTsiLCIvLyBHcm91cHMgaW5zdHJ1Y3Rpb24ncyBlbGVtZW50cyBpbiBhICdzZWxlY3QnIGZvcm1cbi8vIERvbmUgaW1tZWRpYXRlbHkgKCtXQUlUIG1ldGhvZDogdXBvbiBzZWxlY3Rpb24pXG5jbGFzcyBTZWxlY3Rvckluc3RyIGV4dGVuZHMgSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGFyZykge1xuICAgICAgICBzdXBlcihhcmcsIFwic2VsZWN0b3JcIik7XG4gICAgICAgIGlmIChhcmcgIT0gQWJvcnQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gYXJnO1xuICAgICAgICAgICAgdGhpcy5zaHVmZmxlZEluc3RydWN0aW9ucyA9IGFyZztcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNhbkNsaWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMua2V5TGlzdCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zaHVmZmxlZEtleUxpc3QgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbnN0cnVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrRnVuY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50KCQoXCI8ZGl2PlwiKS5hZGRDbGFzcyhcIlBlbm5Db250cm9sbGVyLVNlbGVjdG9yXCIpKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9ucyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFBSSVZBVEUgJiBJTlRSSU5TSUMgTUVUSE9EU1xuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIHJ1bigpIHtcbiAgICAgICAgaWYgKHN1cGVyLnJ1bigpID09IEFib3J0KVxuICAgICAgICAgICAgcmV0dXJuIEFib3J0O1xuICAgICAgICBsZXQgdGkgPSB0aGlzO1xuICAgICAgICAvLyBHbyB0aHJvdWdoIGVhY2ggaW5zdHJ1Y3Rpb25cbiAgICAgICAgZm9yIChsZXQgaSBpbiB0aGlzLmluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgbGV0IGluc3RydWN0aW9uID0gdGhpcy5pbnN0cnVjdGlvbnNbaV07XG4gICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24gaW5zdGFuY2VvZiBJbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIElmIGluc3RydWN0aW9uJ3Mgb3JpZ2luIGhhcyBub3QgYmVlbiBydW4sIHRoZW4gc2VsZWN0b3IgY3JlYXRlcyBpdDogc2hvdWxkIGJlIGl0cyBwYXJlbnRcbiAgICAgICAgICAgICAgICBpZiAoIWluc3RydWN0aW9uLm9yaWdpbi5oYXNCZWVuUnVuKVxuICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5vcmlnaW4ucGFyZW50RWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICAgICAgICAgICAgICAvLyBJZiBpbnN0cnVjdGlvbidzIG5vdCBiZWVuIHJ1biB5ZXQsIHJ1biBpdFxuICAgICAgICAgICAgICAgIGlmICghaW5zdHJ1Y3Rpb24uaGFzQmVlblJ1bilcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24ucnVuKCk7XG4gICAgICAgICAgICAgICAgLy8gQmluZCBjbGlja3NcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5vcmlnaW4uZWxlbWVudC5iaW5kKFwiY2xpY2tcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aS5jYW5DbGljaylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgLy8gU0VMRUNUIGlzIGEgbWV0aG9kIHRoYXQgcmV0dXJucyBhbiBpbnN0cnVjdGlvblxuICAgICAgICAgICAgICAgICAgICB0aS5fc2VsZWN0KGluc3RydWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV2FybmluZzogc2VsZWN0b3IncyBlbnRyeSAjXCIraStcIiBpcyBub3QgYSBwcm9wZXIgaW5zdHJ1Y3Rpb24uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEJpbmRpbmcgYSBrZXlkb3duIGV2ZW50XG4gICAgICAgIEN0cmxyLnJ1bm5pbmcuc2FmZUJpbmQoJChkb2N1bWVudCksIFwia2V5ZG93blwiLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgIC8vIFRyaWdnZXJpbmcgb25seSBpZiBrZXlzIHdlcmUgc3BlY2lmaWVkXG4gICAgICAgICAgICBpZiAoIXRpLmtleUxpc3QubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBBYm9ydDtcbiAgICAgICAgICAgIGZvciAobGV0IGsgaW4gdGkuc2h1ZmZsZWRLZXlMaXN0KXtcbiAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZih0aS5zaHVmZmxlZEtleUxpc3Rba10pPT1cIm51bWJlclwiICYmIHRpLnNodWZmbGVkS2V5TGlzdFtrXSA9PSBlLmtleUNvZGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICh0aS5zaHVmZmxlZEtleUxpc3Rba10gaW5zdGFuY2VvZiBBcnJheSAmJiB0aS5zaHVmZmxlZEtleUxpc3Rba10uaW5kZXhPZihlLmtleUNvZGUpPj0wKSlcbiAgICAgICAgICAgICAgICAgICAgdGkuX3NlbGVjdCh0aS5zaHVmZmxlZEluc3RydWN0aW9uc1trXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBZGQgdGhlIGRpdiB0byB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgX2FkZEVsZW1lbnQodGhpcy5wYXJlbnRFbGVtZW50KTtcbiAgICAgICAgLy8gRG9uZSBpbW1lZGlhdGVseVxuICAgICAgICB0aGlzLmRvbmUoKTtcbiAgICB9XG5cbiAgICAvLyBTZWxlY3RzIGFuIGluc3RydWN0aW9uXG4gICAgX3NlbGVjdChpbnN0cnVjdGlvbikge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZClcbiAgICAgICAgICAgIHJldHVybiBBYm9ydDtcbiAgICAgICAgbGV0IHRpID0gdGhpcy5vcmlnaW47XG4gICAgICAgIC8vIFNlbGVjdCBhbiBpbnN0cnVjdGlvblxuICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24gaW5zdGFuY2VvZiBJbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgdGkuc2VsZWN0ZWRFbGVtZW50ID0gaW5zdHJ1Y3Rpb24ub3JpZ2luLmVsZW1lbnQ7XG4gICAgICAgICAgICB0aS5zZWxlY3RlZEluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb24ub3JpZ2luO1xuICAgICAgICAgICAgLy8gQWRkIHRoZSAnc2VsZWN0ZWQnIGNsYXNzIHRvIHRoZSBlbGVtZW50XG4gICAgICAgICAgICBpbnN0cnVjdGlvbi5vcmlnaW4uZWxlbWVudC5hZGRDbGFzcyhcIlBlbm5Db250cm9sbGVyLXNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgLy8gR28gdGhyb3VnaCB0aGUgb3RoZXIgaW5zdHJ1Y3Rpb25zJyBlbGVtZW50cyBhbmQgcmVtb3ZlIHRoZSBjbGFzc1xuICAgICAgICAgICAgZm9yIChsZXQgaSBpbiB0aS5pbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBzZWxlY3RlZCBpbnN0cnVjdGlvbiwgaW5mb3JtIHRvIGJlIGFibGUgdG8gc2F2ZSBsYXRlclxuICAgICAgICAgICAgICAgIGlmICh0aS5pbnN0cnVjdGlvbnNbaV0ub3JpZ2luID09IGluc3RydWN0aW9uLm9yaWdpbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgaW5zdHJ1Y3Rpb24gaGFzIGFuIElELCBzYXZlIGl0XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5vcmlnaW4uX2lkKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGkuc2VsZWN0aW9ucy5wdXNoKFtpbnN0cnVjdGlvbi5vcmlnaW4uX2lkLCBEYXRlLm5vdygpXSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVsc2UsIHNhdmUgaXRzIGluZGV4IGluIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpLnNlbGVjdGlvbnMucHVzaChbaSwgRGF0ZS5ub3coKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiBub3QgdGhlIHNlbGVjdGVkIGluc3RydWN0aW9uLCBtYWtlIHN1cmUgaXQncyBub3QgdGFnZ2VkIGFzIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGkuaW5zdHJ1Y3Rpb25zW2ldLm9yaWdpbi5lbGVtZW50ICE9IGluc3RydWN0aW9uLmVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIHRpLmluc3RydWN0aW9uc1tpXS5vcmlnaW4uZWxlbWVudC5yZW1vdmVDbGFzcyhcIlBlbm5Db250cm9sbGVyLXNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpLmNhbGxiYWNrRnVuY3Rpb24gaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgICAgICAgICAgICB0aS5jYWxsYmFja0Z1bmN0aW9uKGluc3RydWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBDT05ESVRJT05BTCBGVU5DVElPTlNcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyBSZXR1cm5zIGEgY29uZGl0aW9uYWwgZnVuY3Rpb24gYXMgd2hldGhlciBhIChzcGVjaWZpYykgaW5zdHJ1dGlvbiBpcyBzZWxlY3RlZFxuICAgIHNlbGVjdGVkKGluc3RydWN0aW9uKSB7XG4gICAgICAgIGxldCBvID0gdGhpcy5vcmlnaW4sIGFyZyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAvLyBJZiBtb3JlIHRoYW4gb25lIGluc3RydWN0aW9uXG4gICAgICAgICAgICBpZiAoYXJnLmhhc093blByb3BlcnR5KFwiMVwiKSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGEgaW4gYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdbYV0gaW5zdGFuY2VvZiBJbnN0cnVjdGlvbiAmJiBhcmdbYV0ub3JpZ2luID09IG8uc2VsZWN0ZWRJbnN0cnVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnN0cnVjdGlvbiBpbnN0YW5jZW9mIEluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpbnN0cnVjdGlvbi5vcmlnaW4gPT0gby5zZWxlY3RlZEluc3RydWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gby5zZWxlY3RlZEluc3RydWN0aW9uO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIE1FVEhPRFMgUkVUVVJOSU5HIE5FVyBJTlNUUlVDVElPTlNcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyBSZXR1cm5zIGFuIGluc3RydWN0aW9uIHRvIHNlbGVjdCBhbiBpbnN0cnVjdGlvblxuICAgIC8vIERvbmUgaW1tZWRpYXRlbHlcbiAgICBzZWxlY3QoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV3TWV0YShmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5vcmlnaW4uX3NlbGVjdChpbnN0cnVjdGlvbik7XG4gICAgICAgICAgICB0aGlzLmRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhbiBpbnN0cnVjdGlvbiB0aGF0IHNldHMgd2hldGhlciBzZWxlY3RvciBpcyBjbGlja2FibGVcbiAgICAvLyBEb25lIGltbWVkaWF0ZWx5XG4gICAgY2xpY2thYmxlKGNhbkNsaWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld01ldGEoZnVuY3Rpb24oKXsgXG4gICAgICAgICAgICB0aGlzLm9yaWdpbi5jYW5DbGljayA9IGNhbkNsaWNrO1xuICAgICAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYW4gaW5zdHJ1Y3Rpb24gdG8gZXhlY3V0ZSBjYWxsYmFjayB1cG9uIHNlbGVjdGlvblxuICAgIC8vIERvbmUgaW1tZWRpYXRlbHlcbiAgICBjYWxsYmFjayhpbnN0ck9yRnVuYykge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdNZXRhKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbi5fc2VsZWN0ID0gdGhpcy5vcmlnaW4uZXh0ZW5kKFwiX3NlbGVjdFwiLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIGlmIChpbnN0ck9yRnVuYyBpbnN0YW5jZW9mIEluc3RydWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICBpbnN0ck9yRnVuYy5ydW4oKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpbnN0ck9yRnVuYyBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxuICAgICAgICAgICAgICAgICAgICBpbnN0ck9yRnVuYy5hcHBseShDdHJsci5ydW5uaW5nLnZhcmlhYmxlcywgW3RoaXMub3JpZ2luLnNlbGVjdGVkSW5zdHJ1Y3Rpb25dKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLy8gUmV0dXJucyBhbiBpbnN0cnVjdGlvbiB0aGF0IGFzc29jaWF0ZXMgaW5zdHJ1Y3Rpb25zIHdpdGgga2V5c1xuICAgIC8vIERvbmUgaW1tZWRpYXRlbHlcbiAgICBrZXlzKCkge1xuICAgICAgICBsZXQga2V5cyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIHRoaXMubmV3TWV0YShmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYgKGtleXMuaGFzT3duUHJvcGVydHkoXCIwXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihrZXlzWzBdKSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjYXNlU2Vuc2l0aXZlID0ga2V5cy5oYXNPd25Qcm9wZXJ0eShcIjFcIik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5c1swXS5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcmlnaW4uaW5zdHJ1Y3Rpb25zLmhhc093blByb3BlcnR5KGkpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FzZVNlbnNpdGl2ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcmlnaW4ua2V5TGlzdC5wdXNoKGtleXNbMF0uY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9yaWdpbi5rZXlMaXN0LnB1c2goW2tleXNbMF0udG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5c1swXS50b0xvd2VyQ2FzZSgpLmNoYXJDb2RlQXQoaSldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGtleXNbMF0pID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgayBpbiBrZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5c1trXTwwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV2FybmluZzogaW52YWxpZCBrZXkgY29kZSBmb3Igc2VsZWN0b3IgaW5zdHJ1Y3Rpb24gI1wiK2srXCIsIG5vdCBhdHRhY2hpbmcga2V5cyB0byBpdC5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcmlnaW4ua2V5TGlzdC5wdXNoKGtleXNba10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vcmlnaW4uc2h1ZmZsZWRLZXlMaXN0ID0gdGhpcy5vcmlnaW4ua2V5TGlzdDtcbiAgICAgICAgICAgIHRoaXMuZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIGFuIGluc3RydWN0aW9uIHRvIHNodWZmbGUgdGhlIHByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdHJ1Y3Rpb25zXG4gICAgLy8gRG9uZSBpbW1lZGlhdGVseVxuICAgIC8vIE5PVEU6IGlmIEtFWVMgaXMgY2FsbGVkIGJlZm9yZSwga2V5cyBhcmUgc2h1ZmZsZWQsIGlmIGNhbGxlZCBhZnRlciwgdGhleSBhcmUgbm90XG4gICAgc2h1ZmZsZShhcmcpIHtcbiAgICAgICAgbGV0IHRpID0gdGhpcy5vcmlnaW47XG4gICAgICAgIHJldHVybiB0aGlzLm5ld01ldGEoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGxldCBpbnN0cnVjdGlvbkluZGljZXMgPSBbXTtcbiAgICAgICAgICAgIC8vIElmIG5vIGFyZ3VtZW50LCBqdXN0IGFkZCBldmVyeSBpbnN0cnVjdGlvbidzIGluZGV4XG4gICAgICAgICAgICBpZiAodHlwZW9mKGFyZyk9PVwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpIGluIHRpLmluc3RydWN0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25JbmRpY2VzLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFbHNlLCBmaXJzdCBmZWVkIGluc3RydWN0aW9uSW5kaWNlc1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gR28gdGhyb3VnaCBlYWNoIGFyZ3VtZW50XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSBpbiBhcmd1bWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluc3RydWN0aW9uID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAvLyBOVU1CRVI6IGNoZWNrIHRoZXJlIGlzIGFuIGluc3RydWN0aW9uIGF0IGluZGV4XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YoaW5zdHJ1Y3Rpb24pPT1cIm51bWJlclwiICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgdGkuaW5zdHJ1Y3Rpb25zLmhhc093blByb3BlcnR5KGluc3RydWN0aW9uKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25JbmRpY2VzLmluZGV4T2YoaW5zdHJ1Y3Rpb24pPDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25JbmRpY2VzLnB1c2goaW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAvLyBJTlNUUlVDVElPTjogY2hlY2sgdGhhdCBpbnN0cnVjdGlvbiBpcyBjb250YWluZWRcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5zdHJ1Y3Rpb24gaW5zdGFuY2VvZiBJbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaTIgaW4gdGhpcy5vcmlnaW4uaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpLmluc3RydWN0aW9uc1tpMl0ub3JpZ2luPT1pbnN0cnVjdGlvbi5vcmlnaW4gJiYgaW5zdHJ1Y3Rpb25JbmRpY2VzLmluZGV4T2YoaTIpPDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uSW5kaWNlcy5wdXNoKGkyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB1bnNodWZmbGVkID0gW10uY29uY2F0KGluc3RydWN0aW9uSW5kaWNlcyk7XG4gICAgICAgICAgICAvLyBOb3csIHNodWZmbGUgdGhlIGluZGljZXNcbiAgICAgICAgICAgIGZpc2hlcllhdGVzKGluc3RydWN0aW9uSW5kaWNlcyk7XG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgbGlzdHNcbiAgICAgICAgICAgIHRpLnNodWZmbGVkSW5zdHJ1Y3Rpb25zID0gJC5leHRlbmQoe30sIHRpLmluc3RydWN0aW9ucyk7XG4gICAgICAgICAgICB0aS5zaHVmZmxlZEtleUxpc3QgPSBbXS5jb25jYXQodGkua2V5TGlzdCk7XG4gICAgICAgICAgICAvLyBHbyB0aHJvdWdoIGVhY2ggaW5kZXggbm93XG4gICAgICAgICAgICBmb3IgKGxldCBpIGluIGluc3RydWN0aW9uSW5kaWNlcykge1xuICAgICAgICAgICAgICAgIGxldCBvbGRJbmRleCA9IHVuc2h1ZmZsZWRbaV0sXG4gICAgICAgICAgICAgICAgICAgIG5ld0luZGV4ID0gaW5zdHJ1Y3Rpb25JbmRpY2VzW2ldLCBcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luID0gdGkuaW5zdHJ1Y3Rpb25zW25ld0luZGV4XS5vcmlnaW47XG4gICAgICAgICAgICAgICAgdGkuc2h1ZmZsZWRJbnN0cnVjdGlvbnNbb2xkSW5kZXhdID0gdGkuaW5zdHJ1Y3Rpb25zW25ld0luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAob2xkSW5kZXggPCB0aS5rZXlMaXN0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGkuc2h1ZmZsZWRLZXlMaXN0W29sZEluZGV4XSA9IHRpLmtleUxpc3RbbmV3SW5kZXhdO1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhIFNIVUZGTEUgdGFnIHdpdGggdGhlIHByb3BlciBpbmRleCBiZWZvcmUgZWFjaCBpbnN0cnVjdGlvblxuICAgICAgICAgICAgICAgIGxldCBzaHVmID0gJChcIjxzaHVmZmxlPlwiKS5hdHRyKFwiaWRcIiwgb2xkSW5kZXgpLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB0aS5pbnN0cnVjdGlvbnNbbmV3SW5kZXhdLm9yaWdpbi5lbGVtZW50LmNzcyhcInBvc2l0aW9uXCIpLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0aS5pbnN0cnVjdGlvbnNbbmV3SW5kZXhdLm9yaWdpbi5lbGVtZW50LmNzcyhcImxlZnRcIiksXG4gICAgICAgICAgICAgICAgICAgIHRvcDogdGkuaW5zdHJ1Y3Rpb25zW25ld0luZGV4XS5vcmlnaW4uZWxlbWVudC5jc3MoXCJ0b3BcIilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvcmlnaW4uZWxlbWVudC5iZWZvcmUoc2h1Zik7XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgLy8gR28gdGhyb3VnaCBlYWNoIHNodWZmbGUgdGFnXG4gICAgICAgICAgICAkKFwic2h1ZmZsZVwiKS5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gJCh0aGlzKS5hdHRyKCdpZCcpO1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgZWxlbWVudCBvZiB0aGUgSU5ERVgtdGggaW5zdHJ1Y3Rpb24gdGhlcmVcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmFmdGVyKHRpLmluc3RydWN0aW9uc1tpbmRleF0ub3JpZ2luLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIC8vIEFuZCB1cGRhdGUgcmVsZXZhbnQgQ1NTXG4gICAgICAgICAgICAgICAgdGkuaW5zdHJ1Y3Rpb25zW2luZGV4XS5vcmlnaW4uZWxlbWVudC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJCh0aGlzKS5jc3MoXCJwb3NpdGlvblwiKSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogJCh0aGlzKS5jc3MoXCJsZWZ0XCIpLFxuICAgICAgICAgICAgICAgICAgICB0b3A6ICQodGhpcykuY3NzKFwidG9wXCIpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLy8gQW5kIG5vdyByZW1vdmUgZXZlcnkgU0hVRkZMRSB0YWdcbiAgICAgICAgICAgICQoXCJzaHVmZmxlXCIpLnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYW4gaW5zdHJ1Y3Rpb24gdG8gZGlzYWJsZSB0aGUgc2VsZWN0b3IgcmlnaHQgYWZ0ZXIgZmlyc3Qgc2VsZWN0aW9uXG4gICAgLy8gRG9uZSBpbW1lZGlhdGVseVxuICAgIG9uY2UoKSB7XG4gICAgICAgIGxldCB0aSA9IHRoaXMub3JpZ2luO1xuICAgICAgICB0aS5fc2VsZWN0ID0gdGkuZXh0ZW5kKFwiX3NlbGVjdFwiLCBmdW5jdGlvbigpeyB0aS5lbmFibGVkID0gZmFsc2U7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdNZXRhKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhbiBpbnN0cnVjdGlvbiB0byBlbmFibGUvZGlzYWJsZSB0aGUgc2VsZWN0b3JcbiAgICAvLyBEb25lIGltbWVkaWF0ZWx5XG4gICAgZW5hYmxlKGFjdGl2ZSkge1xuICAgICAgICBpZiAodHlwZW9mKGFjdGl2ZSk9PVwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICBhY3RpdmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdNZXRhKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbi5lbmFibGVkID0gYWN0aXZlO1xuICAgICAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYW4gaW5zdHJ1Y3Rpb24gdG8gc2F2ZSB0aGUgc2VsZWN0aW9uKHMpXG4gICAgLy8gRG9uZSBpbW1lZGlhdGVseVxuICAgIHJlY29yZChwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld01ldGEoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGxldCBvID0gdGhpcy5vcmlnaW47XG4gICAgICAgICAgICBDdHJsci5ydW5uaW5nLmNhbGxiYWNrQmVmb3JlRmluaXNoKGZ1bmN0aW9uKCl7IFxuICAgICAgICAgICAgICAgIGlmICghby5zZWxlY3Rpb25zLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFib3J0O1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YocGFyYW1ldGVycykgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1ldGVycyA9PSBcImZpcnN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBDdHJsci5ydW5uaW5nLnNhdmUoXCJzZWxlY3Rpb25cIiwgby5zZWxlY3Rpb25zWzBdWzBdLCBvLnNlbGVjdGlvbnNbMF1bMV0sIFwiTlVMTFwiKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1ldGVycyA9PSBcImxhc3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIEN0cmxyLnJ1bm5pbmcuc2F2ZShcInNlbGVjdGlvblwiLCBvLnNlbGVjdGlvbnNbby5zZWxlY3Rpb25zLmxlbmd0aC0xXVswXSwgby5zZWxlY3Rpb25zW28uc2VsZWN0aW9ucy5sZW5ndGgtMV1bMV0sIFwiTlVMTFwiKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBzIGluIG8uc2VsZWN0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDdHJsci5ydW5uaW5nLnNhdmUoXCJzZWxlY3Rpb25cIiwgby5zZWxlY3Rpb25zW3NdWzBdLCBvLnNlbGVjdGlvbnNbc11bMV0sIFwiTlVMTFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcyBpbiBvLnNlbGVjdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ3RybHIucnVubmluZy5zYXZlKFwic2VsZWN0aW9uXCIsIG8uc2VsZWN0aW9uc1tzXVswXSwgby5zZWxlY3Rpb25zW3NdWzFdLCBcIk5VTExcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhbiBpbnN0cnVjdGlvbiB0byB3YWl0IGZvciBzb21ldGhpbmcgdG8gYmUgc2VsZWN0ZWRcbiAgICAvLyBEb25lIHVwb24gc2VsZWN0aW9uXG4gICAgd2FpdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV3TWV0YShmdW5jdGlvbigpeyBcbiAgICAgICAgICAgIGxldCB0aSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5vcmlnaW4uc2VsZWN0ZWQoKS5jYWxsKCkpXG4gICAgICAgICAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5vcmlnaW4uX3NlbGVjdCA9IHRoaXMub3JpZ2luLmV4dGVuZChcIl9zZWxlY3RcIiwgZnVuY3Rpb24oKXsgdGkuZG9uZSgpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5QZW5uQ29udHJvbGxlci5pbnN0cnVjdGlvbi5zZWxlY3RvciA9IGZ1bmN0aW9uKCl7IHJldHVybiBuZXcgU2VsZWN0b3JJbnN0cihhcmd1bWVudHMpOyB9OyIsIi8vIEFkZHMgc29tZXRoaW5nIHRvIHRoZSBsaXN0IG9mIHdoYXQgaXMgdG8gYmUgc2F2ZWRcbi8vIERvbmUgaW1tZWRpYXRlbHlcbmNsYXNzIFNhdmVJbnN0ciBleHRlbmRzIEluc3RydWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMsIFwic2F2ZVwiKTtcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMgIT0gQWJvcnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudCgkKFwiPHNhdmU+XCIpKTtcbiAgICAgICAgICAgIHRoaXMucGFyYW1ldGVyID0gcGFyYW1ldGVyc1swXTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBwYXJhbWV0ZXJzWzFdO1xuICAgICAgICAgICAgdGhpcy5jb21tZW50ID0gcGFyYW1ldGVyc1syXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQUklWQVRFICYgSU5UUklOU0lDIE1FVEhPRFNcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgcnVuKCkge1xuICAgICAgICBpZiAoc3VwZXIucnVuKCkgPT0gQWJvcnQpXG4gICAgICAgICAgICByZXR1cm4gQWJvcnQ7XG4gICAgICAgIEN0cmxyLnJ1bm5pbmcuc2F2ZSh0aGlzLnBhcmFtZXRlciwgdGhpcy52YWx1ZSwgRGF0ZS5ub3coKSwgdGhpcy5jb21tZW50KTtcbiAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgfVxufVxuXG5QZW5uQ29udHJvbGxlci5pbnN0cnVjdGlvbi5zYXZlID0gZnVuY3Rpb24oKXsgcmV0dXJuIG5ldyBTYXZlSW5zdHIoYXJndW1lbnRzKTsgfTsiLCIvLyBBZGRzIGEgcmFkaW8gc2NhbGUgdG8gdGhlIHBhcmVudCBlbGVtZW50XG4vLyBEb25lIGltbWVkaWF0ZWx5XG5jbGFzcyBSYWRpb0luc3RyIGV4dGVuZHMgSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGxhYmVsLCBsZW5ndGgpIHtcbiAgICAgICAgc3VwZXIoe2xhYmVsOiBsYWJlbCwgbGVuZ3RoOiBsZW5ndGh9LCBcInJhZGlvXCIpO1xuICAgICAgICBpZiAobGFiZWwgIT0gQWJvcnQpIHtcbiAgICAgICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMudGltZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudCgkKFwiPHNwYW4+XCIpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgdGkgPSB0aGlzLCBpbnB1dCA9ICQoXCI8aW5wdXQgdHlwZT0ncmFkaW8nPlwiKS5hdHRyKHtuYW1lOiBsYWJlbCwgdmFsdWU6IGl9KVxuICAgICAgICAgICAgICAgIGlucHV0LmNsaWNrKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIHRpLl9jbGlja2VkKCQodGhpcykuYXR0cihcInZhbHVlXCIpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aS5lbGVtZW50LmFwcGVuZChpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUFJJVkFURSAmIElOVFJJTlNJQyBNRVRIT0RTXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgcnVuKCkge1xuICAgICAgICBpZiAoc3VwZXIucnVuKCkgPT0gQWJvcnQpXG4gICAgICAgICAgICByZXR1cm4gQWJvcnQ7XG4gICAgICAgIHRoaXMuX2FkZEVsZW1lbnQodGhpcy5wYXJlbnRFbGVtZW50KTtcbiAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgV0hFTiBpbiBvcmlnaW4ncyBDTElDS0VEXG4gICAgX3doZW5Ub0luc2lzdCh0cnlUb1ZhbGlkYXRlKSB7XG4gICAgICAgIHRoaXMuX2NsaWNrZWQgPSB0aGlzLmV4dGVuZChcIl9jbGlja2VkXCIsIHRyeVRvVmFsaWRhdGUpO1xuICAgIH1cblxuICAgIC8vIENhbGxlZCB1cG9uIGFueSBjbGljayBvbiBhbiBpbnB1dFxuICAgIF9jbGlja2VkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB0aGlzLnRpbWVzLnB1c2goRGF0ZS5ub3coKSk7XG4gICAgfVxuXG4gICAgXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIE1FVEhPRFMgUkVUVVJOSU5HIENPTkRJVElPTkFMIEZVTkNUSU9OU1xuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIFJldHVybnMgYSBmdW5jdGlvbiBnaXZpbmcgc2VsZWN0ZWQgdmFsdWUvVFJVRS9UUlVFIHZhbHVlIGlmZiBleGlzdGVudC89IFZBTFVFUy9hbW9uZyBWQUxVRVNcbiAgICBzZWxlY3RlZCh2YWx1ZXMpIHtcbiAgICAgICAgbGV0IG8gPSB0aGlzLm9yaWdpbjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBsZXQgbGFzdHZhbHVlID0gby52YWx1ZXNbby52YWx1ZXMubGVuZ3RoLTFdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZih2YWx1ZXMpID09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhc3R2YWx1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZih2YWx1ZXMpID09IFwibnVtYmVyXCIgfHwgdHlwZW9mKHZhbHVlcykgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gKGxhc3R2YWx1ZSA9PSB2YWx1ZXMpO1xuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWVzIGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZXMuaW5kZXhPZihsYXN0dmFsdWUpID49IDAgfHwgdmFsdWVzLmluZGV4T2YocGFyc2VJbnQobGFzdHZhbHVlKSkgPj0gMCk7XG4gICAgICAgIH07XG4gICAgfVxuXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gTUVUSE9EUyBSRVRVUk5JTkcgTkVXIElOU1RSVUNUSU9OU1xuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIFJldHVybnMgYW4gaW5zdHJ1Y3Rpb24gdG8gd2FpdCBmb3IgYSBjbGljayAob24gKGEpIHNwZWNpZmljIHZhbHVlKHMpKVxuICAgIC8vIERvbmUgdXBvbiBjbGljayBtZWV0aW5nIHRoZSBzcGVjaWZpZWQgY29uZGl0aW9ucyAoaWYgYW55KVxuICAgIHdhaXQodmFsdWVzKSB7XG4gICAgICAgIGxldCBpbnN0ciA9IHRoaXMubmV3TWV0YSgpLCB0aSA9IHRoaXM7XG4gICAgICAgIHRoaXMub3JpZ2luLl9jbGlja2VkID0gdGhpcy5vcmlnaW4uZXh0ZW5kKFwiX2NsaWNrZWRcIiwgZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZXMgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSB2YWx1ZXMpXG4gICAgICAgICAgICAgICAgICAgIGluc3RyLmRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlcy5pbmRleE9mKHZhbHVlKSA+PSAwKVxuICAgICAgICAgICAgICAgICAgICBpbnN0ci5kb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaW5zdHIuZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGluc3RyO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYW4gaW5zdHJ1Y3Rpb24gdG8gc2F2ZSB0aGUgcGFyYW1ldGVyc1xuICAgIC8vIERvbmUgaW1tZWRpYXRlbHlcbiAgICByZWNvcmQocGFyYW1ldGVycywgY29tbWVudCkge1xuICAgICAgICBsZXQgbyA9IHRoaXMub3JpZ2luO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdNZXRhKGZ1bmN0aW9uKCl7IFxuICAgICAgICAgICAgLy8gVGVsbCBjb250cm9sbGVyIHRvIHNhdmUgdmFsdWUocykgYmVmb3JlIGNhbGxpbmcgZmluaXNoZWRDYWxsYmFja1xuICAgICAgICAgICAgQ3RybHIucnVubmluZy5jYWxsYmFja0JlZm9yZUZpbmlzaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSB0byBiZSBzYXZlZCBpbiBvbmx5IHRoZSBmaW5hbCB2YWx1ZSAoZGVmYXVsdClcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHBhcmFtZXRlcnMpICE9IFwic3RyaW5nXCIgfHwgcGFyYW1ldGVycyA9PSBcImxhc3RcIilcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgYSBmdW5jdGlvbiB0byBzYXZlIHRoZSB2YWx1ZSBhdCB0aGUgZW5kIG9mIHRoZSB0cmlhbFxuICAgICAgICAgICAgICAgICAgICBDdHJsci5ydW5uaW5nLnNhdmUoby5sYWJlbCwgby52YWx1ZXNbby52YWx1ZXMubGVuZ3RoLTFdLCBvLnRpbWVzW28udGltZXMubGVuZ3RoLTFdLCBjb21tZW50KTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgb25seSBzYXZpbmcgZmlyc3Qgc2VsZWN0ZWQgdmFsdWUsIGNhbGwgQ3RybHIucnVubmluZy5TQVZFIG9uIGZpcnN0IGNsaWNrXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzID09IFwiZmlyc3RcIiAmJiBvLnZhbHVlcy5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIEN0cmxyLnJ1bm5pbmcuc2F2ZShvLmxhYmVsLCBvLnZhbHVlc1swXSwgby50aW1lc1swXSwgY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGFsbCB2YWx1ZXMgYXJlIHRvIGJlIHNhdmVkLCBjYWxsIEN0cmxyLnJ1bm5pbmcuU0FWRSBvbiBldmVyeSBjbGlja1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbWV0ZXJzID09IFwiYWxsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG4gaW4gby52YWx1ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ3RybHIucnVubmluZy5zYXZlKG8ubGFiZWwsIG8udmFsdWVzW25dLCBvLnRpbWVzW25dLCBjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuUGVubkNvbnRyb2xsZXIuaW5zdHJ1Y3Rpb24ucmFkaW9CdXR0b25zID0gZnVuY3Rpb24obGFiZWwsIGxlbmd0aCl7IHJldHVybiBuZXcgUmFkaW9JbnN0cihsYWJlbCwgbGVuZ3RoKTsgfTsiLCIvLyBCaW5kcyBhIGtleXByZXNzIGV2ZW50IHRvIHRoZSBkb2N1bWVudFxuLy8gRG9uZSB1cG9uIGtleXByZXNzXG5jbGFzcyBLZXlJbnN0ciBleHRlbmRzIEluc3RydWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihrZXlzLCBjYXNlU2Vuc2l0aXZlKSB7XG4gICAgICAgIHN1cGVyKGtleXMsIFwia2V5XCIpO1xuICAgICAgICBpZiAoa2V5cyAhPSBBYm9ydCkge1xuICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50KCQoXCI8a2V5PlwiKSk7XG4gICAgICAgICAgICB0aGlzLmtleXMgPSBbXTtcbiAgICAgICAgICAgIC8vIENhbiBwYXNzIGEgbnVtYmVyICh1c2VmdWwgZm9yIHNwZWNpYWwga2V5cyBzdWNoIGFzIHNoaWZ0KVxuICAgICAgICAgICAgaWYgKHR5cGVvZihrZXlzKSA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIHRoaXMua2V5cy5wdXNoKGtleXMpO1xuICAgICAgICAgICAgLy8gT3IgYSBzdHJpbmcgb2YgY2hhcmFjdGVyc1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mKGtleXMpID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrIGluIGtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgY2FzZSBzZW5zaXRpdmUsIGFkZCB0aGUgZXhhY3QgY2hhcmNvZGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhc2VTZW5zaXRpdmUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtleXMucHVzaChrZXlzLmNoYXJDb2RlQXQoaykpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBub3QsIGFkZCBib3RoIGxvd2VyLSBhbmQgdXBwZXItY2FzZSBjaGFyY29kZXNcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdXBwZXJLZXlzID0ga2V5cy50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyS2V5cyA9IGtleXMudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2V5cy5wdXNoKGxvd2VyS2V5cy5jaGFyQ29kZUF0KGspKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2V5cy5wdXNoKHVwcGVyS2V5cy5jaGFyQ29kZUF0KGspKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQUklWQVRFICYgSU5UUklOU0lDIE1FVEhPRFNcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyBBZGRzIGtleSBwcmVzcyBldmVudFxuICAgIHJ1bigpIHtcbiAgICAgICAgaWYgKHN1cGVyLnJ1bigpID09IEFib3J0KVxuICAgICAgICAgICAgcmV0dXJuIEFib3J0O1xuICAgICAgICBsZXQgdGkgPSB0aGlzO1xuICAgICAgICBDdHJsci5ydW5uaW5nLnNhZmVCaW5kKCQoZG9jdW1lbnQpLFwia2V5ZG93blwiLGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgaWYgKHRpLmtleXMubGVuZ3RoPT0wIHx8IHRpLmtleXMuaW5kZXhPZihlLmtleUNvZGUpPj0wKVxuICAgICAgICAgICAgICAgIHRpLl9wcmVzc2VkKGUua2V5Q29kZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIFdIRU4gaW4gb3JpZ2luJ3MgUFJFU1NFRFxuICAgIF93aGVuVG9JbnNpc3QodHJ5VG9WYWxpZGF0ZSkge1xuICAgICAgICB0aGlzLm9yaWdpbi5fcHJlc3NlZCA9IHRoaXMub3JpZ2luLmV4dGVuZChcIl9wcmVzc2VkXCIsIHRyeVRvVmFsaWRhdGUpO1xuICAgIH1cblxuICAgIC8vIENhbGxlZCB3aGVuIHRoZSByaWdodCAob3IgYW55IGlmIHVuc3BlY2lmaWVkKSBrZXkgaXMgcHJlc3NlZFxuICAgIF9wcmVzc2VkKGtleSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNEb25lKSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbi5rZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGtleSk7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbi50aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luLmRvbmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBDT05ESVRJT05BTCBGVU5DVElPTlNcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdHJ1ZSBpZiB0aGUga2V5IHByZXNzZWQgbWF0Y2hlc1xuICAgIC8vIGZhbHNlIG90aGVyd2lzZVxuICAgIHByZXNzZWQoa2V5cykge1xuICAgICAgICBsZXQgdGkgPSB0aGlzLm9yaWdpbjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBsZXQga2V5ID0gdGkua2V5O1xuICAgICAgICAgICAgaWYgKCFrZXkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mKGtleXMpID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZ0V4cChrZXksJ2knKS50ZXN0KGtleXMpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mKGtleXMpID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXMgPT0ga2V5LmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleS5jaGFyQ29kZUF0KDApO1xuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIE1FVEhPRFMgUkVUVVJOSU5HIE5FVyBJTlNUUlVDVElPTlNcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyBSZXR1cm5zIGFuIGluc3RydWN0aW9uIHRvIHNhdmUgdGhlIGtleSB0aGF0IHdhcyBwcmVzc2VkXG4gICAgLy8gRG9uZSBpbW1lZGlhdGVseVxuICAgIHJlY29yZChjb21tZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld01ldGEoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGxldCB0aSA9IHRoaXM7XG4gICAgICAgICAgICBDdHJsci5ydW5uaW5nLmNhbGxiYWNrQmVmb3JlRmluaXNoKGZ1bmN0aW9uKCl7IFxuICAgICAgICAgICAgICAgIEN0cmxyLnJ1bm5pbmcuc2F2ZSgna2V5cHJlc3MnLCB0aS5vcmlnaW4ua2V5LCB0aS5vcmlnaW4udGltZSwgY29tbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cblBlbm5Db250cm9sbGVyLmluc3RydWN0aW9uLmtleSA9IGZ1bmN0aW9uKGtleXMpeyByZXR1cm4gbmV3IEtleUluc3RyKGtleXMpOyB9OyIsImltcG9ydCB7X2F1dG9QcmVsb2FkSW1hZ2VzfSBmcm9tIFwiLi4vcHJlbG9hZC9wcmVsb2FkLmpzXCI7XG5cbi8vIEFkZHMgYW4gSU1HIHRvIHRoZSBwYXJlbnQgZWxlbWVudFxuLy8gRG9uZSBpbW1lZGlhdGVseVxuY2xhc3MgSW1hZ2VJbnN0ciBleHRlbmRzIEluc3RydWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihpbWFnZSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihpbWFnZSwgXCJpbWFnZVwiKTtcbiAgICAgICAgaWYgKGltYWdlICE9IEFib3J0KSB7XG4gICAgICAgICAgICBsZXQgZGl2ID0gJChcIjxkaXY+XCIpLmNzcyhcImRpc3BsYXlcIiwgXCJpbmxpbmUtYmxvY2tcIik7XG4gICAgICAgICAgICBpZiAodHlwZW9mKHdpZHRoKSA9PSBcIm51bWJlclwiICYmIHR5cGVvZihoZWlnaHQpID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgZGl2LmNzcyh7d2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodH0pO1xuICAgICAgICAgICAgLy8gQSBzcGFuIHRvIHdoaWNoIHRoZSBpbWFnZSB3aWxsIGJlIGFwcGVuZGVkIHVwb24gcnVubmluZ1xuICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50KGRpdik7XG4gICAgICAgICAgICAvLyBUaGlzIGdldHMgaXRzIHZhbHVlIGluIF9zZXRSZXNvdXJjZVxuICAgICAgICAgICAgdGhpcy5pbWFnZSA9IG51bGw7XG4gICAgICAgICAgICAvLyBDYWxsaW5nIGFkZFRvUHJlbG9hZCBpbW1lZGlhdGVseSBpZiBzZXR0aW5ncyBzYXkgc28gXG4gICAgICAgICAgICBpZiAoX2F1dG9QcmVsb2FkSW1hZ2VzKVxuICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luLl9hZGRUb1ByZWxvYWQoKTtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luLmZldGNoUmVzb3VyY2UoaW1hZ2UsIFwiaW1hZ2VcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUFJJVkFURSAmIElOVFJJTlNJQyBNRVRIT0RTXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgcnVuKCkge1xuICAgICAgICBpZiAoc3VwZXIucnVuKCkgPT0gQWJvcnQpXG4gICAgICAgICAgICByZXR1cm4gQWJvcnQ7XG4gICAgICAgIC8vdGhpcy5lbGVtZW50LmFwcGVuZCh0aGlzLmltYWdlKTtcbiAgICAgICAgdGhpcy5fYWRkRWxlbWVudCh0aGlzLnBhcmVudEVsZW1lbnQpO1xuICAgICAgICB0aGlzLmRvbmUoKTtcbiAgICB9XG5cbiAgICBfc2V0UmVzb3VyY2UoaW1hZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMub3JpZ2luLmltYWdlKVxuICAgICAgICAgICAgcmV0dXJuIEFib3J0O1xuICAgICAgICBpZiAoc3VwZXIuX3NldFJlc291cmNlKGltYWdlKT09QWJvcnQpXG4gICAgICAgICAgICByZXR1cm4gQWJvcnQ7XG4gICAgICAgIHRoaXMub3JpZ2luLmltYWdlID0gaW1hZ2UuY2xvbmUoKTtcbiAgICAgICAgdGhpcy5vcmlnaW4uZWxlbWVudC5hcHBlbmQodGhpcy5vcmlnaW4uaW1hZ2UpO1xuICAgICAgICB0aGlzLm9yaWdpbi5pbWFnZS5jc3Moe3dpZHRoOiBcIjEwMCVcIiwgaGVpZ2h0OiBcIjEwMCVcIiwgZGlzcGxheTogXCJpbmhlcml0XCJ9KTtcbiAgICB9XG5cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBNRVRIT0RTIFJFVFVSTklORyBORVcgSU5TVFJVQ1RJT05TXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gUmV0dXJucyBhbiBpbnN0cnVjdGlvbiB0byBtb3ZlIHRoZSBpbWFnZSB0byBYLFlcbiAgICAvLyBEb25lIGltbWVkaWF0ZWx5XG4gICAgbW92ZSh4LHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV3TWV0YShmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5vcmlnaW4uZWxlbWVudC5jc3Moe2xlZnQ6IHgsIHRvcDogeSwgcG9zaXRpb246ICdhYnNvbHV0ZSd9KTtcbiAgICAgICAgICAgIHRoaXMuZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIGFuIGluc3RydWN0aW9uIHRoYXQgdGhlIGltYWdlIHNob3VsZCBiZSBwcmVsb2FkZWRcbiAgICAvLyBEb25lIGltbWVkaWF0ZWx5XG4gICAgcHJlbG9hZCgpIHtcbiAgICAgICAgdGhpcy5vcmlnaW4uX2FkZFRvUHJlbG9hZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdNZXRhKGZ1bmN0aW9uKCl7IHRoaXMuZG9uZSgpOyB9KTtcbiAgICB9XG59XG5cblBlbm5Db250cm9sbGVyLmluc3RydWN0aW9uLmltYWdlID0gZnVuY3Rpb24oaW1hZ2UsIHdpZHRoLCBoZWlnaHQpeyByZXR1cm4gbmV3IEltYWdlSW5zdHIoaW1hZ2UsIHdpZHRoLCBoZWlnaHQpOyB9OyIsIi8vIENvbmRpdGlvbmFsbHkgcnVucyBvbmUgb3IgYW5vdGhlciBpbnN0cnVjdGlvblxuLy8gRG9uZSB3aGVuIGV4ZWN1dGVkIGluc3RydWN0aW9uIGlzIGRvbmVcbmNsYXNzIElmSW5zdHIgZXh0ZW5kcyBJbnN0cnVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoY29uZGl0aW9uLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gICAgICAgIHN1cGVyKGFyZ3VtZW50cywgXCJpZlwiKTtcbiAgICAgICAgaWYgKGNvbmRpdGlvbiAhPSBBYm9ydCkge1xuICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50KCQoXCI8ZGl2PlwiKS5hZGRDbGFzcyhcIlBlbm5Db250cm9sbGVyLUNvbmRpdGlvblwiKSk7XG4gICAgICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgICAgIHRoaXMuc3VjY2VzcyA9IHN1Y2Nlc3M7XG4gICAgICAgICAgICB0aGlzLmZhaWx1cmUgPSBmYWlsdXJlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFBSSVZBVEUgJiBJTlRSSU5TSUMgTUVUSE9EU1xuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIHJ1bigpIHtcbiAgICAgICAgaWYgKHN1cGVyLnJ1bigpID09IEFib3J0KVxuICAgICAgICAgICAgcmV0dXJuIEFib3J0O1xuICAgICAgICBpZiAoIXRoaXMuc3VjY2VzcyBpbnN0YW5jZW9mIEluc3RydWN0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIEFib3J0O1xuICAgICAgICBpZiAoIXRoaXMuY29uZGl0aW9uIGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICAgICAgICByZXR1cm4gQWJvcnQ7XG4gICAgICAgIGxldCB0aSA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmNvbmRpdGlvbigpKSB7XG4gICAgICAgICAgICAvL3RoaXMuc3VjY2Vzcy5vcmlnaW4ucGFyZW50RWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuc3VjY2Vzcy5kb25lID0gdGhpcy5zdWNjZXNzLmV4dGVuZChcImRvbmVcIiwgZnVuY3Rpb24oKXsgdGkuZG9uZSgpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuc3VjY2Vzcy5ydW4oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmZhaWx1cmUgaW5zdGFuY2VvZiBJbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgLy90aGlzLmZhaWx1cmUub3JpZ2luLnBhcmVudEVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmZhaWx1cmUuZG9uZSA9IHRoaXMuZmFpbHVyZS5leHRlbmQoXCJkb25lXCIsIGZ1bmN0aW9uKCl7IHRpLmRvbmUoKTsgfSk7XG4gICAgICAgICAgICB0aGlzLmZhaWx1cmUucnVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRvbmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuUGVubkNvbnRyb2xsZXIuaW5zdHJ1Y3Rpb24uaWYgPSBmdW5jdGlvbihjb25kaXRpb24sIHN1Y2Nlc3MsIGZhaWx1cmUpeyByZXR1cm4gbmV3IElmSW5zdHIoY29uZGl0aW9uLCBzdWNjZXNzLCBmYWlsdXJlKTsgfTsiLCIvLyBFeGVjdXRlcyBhIGZ1bmN0aW9uXG4vLyBEb25lIGltbWVkaWF0ZWx5XG5jbGFzcyBGdW5jdGlvbkluc3RyIGV4dGVuZHMgSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGZ1bmMpIHtcbiAgICAgICAgc3VwZXIoZnVuYywgXCJmdW5jdGlvblwiKTtcbiAgICAgICAgaWYgKGZ1bmMgIT0gQWJvcnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudCgkKFwiPGZ1bmN0aW9uPlwiKSk7XG4gICAgICAgICAgICB0aGlzLmZ1bmMgPSBmdW5jO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFBSSVZBVEUgJiBJTlRSSU5TSUMgTUVUSE9EU1xuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICBydW4oKSB7XG4gICAgICAgIGlmIChzdXBlci5ydW4oKSA9PSBBYm9ydClcbiAgICAgICAgICAgIHJldHVybiBBYm9ydDtcbiAgICAgICAgdGhpcy5mdW5jLmFwcGx5KEN0cmxyLnJ1bm5pbmcudmFyaWFibGVzKTtcbiAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgfVxufVxuXG5QZW5uQ29udHJvbGxlci5pbnN0cnVjdGlvbi5mdW5jID0gZnVuY3Rpb24oZnVuYyl7IHJldHVybiBuZXcgRnVuY3Rpb25JbnN0cihmdW5jKTsgfTsiLCIvLyBBZGRzIGFuIGluc3RydWN0aW9uIHRvIGVuZCB0aGUgdHJpYWwgcHJlbWF0dXJlbHlcbi8vIERvbmUgaW1tZWRpYXRlbHlcbmNsYXNzIEVuZEluc3RyIGV4dGVuZHMgSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcImVuZFwiLCBcImVuZFwiKTtcbiAgICB9XG4gICAgcnVuKCkge1xuICAgICAgICBzdXBlci5ydW4oKTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUnVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgQ3RybHIucnVubmluZy5lbmQoKTtcbiAgICB9XG59XG5cblBlbm5Db250cm9sbGVyLmluc3RydWN0aW9uLmVuZCA9IGZ1bmN0aW9uKCl7IHJldHVybiBuZXcgRW5kSW5zdHIoKTsgfTsiLCIvLyBOT1RFOiBwYXNzaW5nIGFuIGluc3RydWN0aW9uJ3MgSUQgaW4gJ3ZhbGlkYXRpb24nIHBvaW50cyB0byB0aGUgaW5zdHJ1Y3Rpb24ncyBvcmlnaW5cbi8vICAgICAgdGhpcyBpcyBwcm9iYWJseSBub3Qgd2hhdCBpcyBpbnRlbmRlZCBpZiBDb21wbGV4IGNvbnRhaW5zIGEgd2FpdFxuLy8gICAgICA+IENyZWF0ZSBzZXBhcmF0ZSBpbnN0cnVjdGlvbnM/XG5cbi8vIE5PVEU6ICAgIG1heWJlICdSdW5JblBhcmFsbGVsJyB3b3VsZCBiZSBhIGdvb2QgbmFtZSBmb3IgdGhpcyBpbnN0cnVjdGlvbj9cbi8vICAgICAgPiBQZW5uQ29udHJvbGxlci5pbnN0cnVjdGlvbi5SdW5JblBhcmFsbGVsKFxuLy8gICAgICAgICAgICAgIFBlbm5Db250cm9sbGVyLmluc3RydWN0aW9uLmF1ZGlvKFwid2FmLm9nZ1wiKS8vLndhaXQoKVxuLy8gICAgICAgICAgICAgICxcbi8vICAgICAgICAgICAgICBQZW5uQ29udHJvbGxlci5pbnN0cnVjdGlvbi5rZXkoXCIgXCIpLy8ud2FpdCgpXG4vLyAgICAgICAgICApLndhaXQoXCJhbnlcIilcblxuLy8gUnVucyBhbGwgaW5zdHJ1Y3Rpb25zIHBhc3NlZCBhcyBhcmd1bWVudHNcbi8vIERvbmUgaW1tZWRpYXRlbHlcbmNsYXNzIENvbXBsZXhJbnN0ciBleHRlbmRzIEluc3RydWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihpbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoaW5zdHJ1Y3Rpb25zLCBcImNvbXBsZXhcIik7XG4gICAgICAgIGlmIChpbnN0cnVjdGlvbnMgIT0gQWJvcnQpIHtcbiAgICAgICAgICAgIHRoaXMudGFibGUgPSAkKFwiPHRhYmxlPlwiKS5hZGRDbGFzcyhcIlBlbm5Db250cm9sbGVyLUNvbXBsZXhcIik7XG4gICAgICAgICAgICAvLyBUaGUgaW5zdHJ1Y3Rpb25zIHN0aWxsIHRvIGJlIGRvbmUgKGluaXRpYWwgc3RhdGU6IGFsbCBvZiB0aGVtKVxuICAgICAgICAgICAgdGhpcy50b0JlRG9uZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50KHRoaXMudGFibGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFBSSVZBVEUgJiBJTlRSSU5TSUMgTUVUSE9EU1xuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIHJ1bigpIHtcbiAgICAgICAgaWYgKHN1cGVyLnJ1bigpID09IEFib3J0KVxuICAgICAgICAgICAgcmV0dXJuIEFib3J0O1xuICAgICAgICBsZXQgdGkgPSB0aGlzO1xuICAgICAgICAvLyBHbyB0aHJvdWdoIGVhY2ggaW5zdHJ1Y3Rpb24gYW5kIGFkZC9ydW4gdGhlbSBpZiBuZWVkZWRcbiAgICAgICAgbGV0IHRyID0gJChcIjx0cj5cIik7XG4gICAgICAgIGZvciAobGV0IGkgaW4gdGhpcy5jb250ZW50KSB7XG4gICAgICAgICAgICBsZXQgaW5zdHJ1Y3Rpb24gPSB0aS5jb250ZW50W2ldLFxuICAgICAgICAgICAgICAgIHRkID0gJChcIjx0ZD5cIik7XG4gICAgICAgICAgICBpZiAoIShpbnN0cnVjdGlvbiBpbnN0YW5jZW9mIEluc3RydWN0aW9uKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8vIElmIGluc3RydWN0aW9uIGFscmVhZHkgcnVuLCBkbyBub3RoaW5nIHdpdGggaXRcbiAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5oYXNCZWVuUnVuKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy8gSWYgbm90IHJ1biwgYWRkIGl0IHRvIGluc3RydWN0aW9ucyB0byBsaXN0ZW4gdG9cbiAgICAgICAgICAgIHRpLnRvQmVEb25lLnB1c2goaW5zdHJ1Y3Rpb24pOyAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFzc2lnbiBlYWNoIGluc3RydWN0aW9uIHRvIHRoZSBwcm9wZXIgcGFyZW50XG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRQYXJlbnRFbGVtZW50KGluc3RyKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgY29tcGxleCBpdHNlbGYsIGFkZCBkaXJlY3RseSB0byB0aGUgdGFibGVcbiAgICAgICAgICAgICAgICBpZiAoaW5zdHIgaW5zdGFuY2VvZiBDb21wbGV4SW5zdHIpXG4gICAgICAgICAgICAgICAgICAgIGluc3RyLnBhcmVudEVsZW1lbnQgPSB0aS50YWJsZTtcbiAgICAgICAgICAgICAgICAvLyBFbHNlLCBhZGQgdG8gdGhlIGN1cnJlbnQgVERcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGluc3RyLnBhcmVudEVsZW1lbnQgPSB0ZDtcbiAgICAgICAgICAgICAgICAvLyBJZiBpbnN0cnVjdGlvbiBoYXMgc291cmNlcywgbmF2aWdhdGVcbiAgICAgICAgICAgICAgICBpZiAoaW5zdHIudHlwZSA9PSBcIm1ldGFcIiAmJiAhaW5zdHIuc291cmNlLnBhcmVudEVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGFkZFBhcmVudEVsZW1lbnQoaW5zdHIuc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluaXRpYXRlIHBhcmVudCBhc3NpZ21lbnRcbiAgICAgICAgICAgIGFkZFBhcmVudEVsZW1lbnQoaW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgLy8gSWYgY29tcGxleCBpbnN0cnVjdGlvbiwgc2hvdWxkIHN0YXJ0IGEgbmV3IFRSXG4gICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24gaW5zdGFuY2VvZiBDb21wbGV4SW5zdHIpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgY3VycmVudCBUUiB0byB0aGUgdGFibGUgaWYgaXQgY29udGFpbnMgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBpZiAodHIuY2hpbGRyZW4oKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRpLnRhYmxlLmFwcGVuZCh0cik7XG4gICAgICAgICAgICAgICAgdHIgPSAkKFwiPHRyPlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIG5vdCBjb21wbGV4LCBzaW1wbHkgYWRkIGN1cnJlbnQgVEQgdG8gY3VycmVudCBUUlxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRyLmFwcGVuZCh0ZCk7XG4gICAgICAgICAgICAvLyBJbmZvcm0gQ29tcGxleEluc3RyIChjYWxsIEVYRUNVVEVEKSB3aGVuIHRoZSBpbnN0cnVjdGlvbiBpcyBkb25lXG4gICAgICAgICAgICBpbnN0cnVjdGlvbi5kb25lID0gaW5zdHJ1Y3Rpb24uZXh0ZW5kKFwiZG9uZVwiLCBmdW5jdGlvbigpeyB0aS5fZXhlY3V0ZWQoaW5zdHJ1Y3Rpb24pOyB9KTtcbiAgICAgICAgICAgIC8vIFJ1biB0aGUgaW5zdHJ1Y3Rpb25cbiAgICAgICAgICAgIGluc3RydWN0aW9uLnJ1bigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGN1cnJlbnQgVFIgaGFzIGNoaWxkcmVuLCBtYWtlIHN1cmUgdG8gYWRkIGl0IHRvIHRhYmxlXG4gICAgICAgIGlmICh0ci5jaGlsZHJlbigpLmxlbmd0aClcbiAgICAgICAgICAgIHRpLnRhYmxlLmFwcGVuZCh0cik7XG5cbiAgICAgICAgLy8gSWYgYWRkaW5nIENvbXBsZXggdG8gYSBUQUJMRSwgYWRkIGVhY2ggb2YgaXRzIFRSIHRvIGl0cyBwYXJlbnQgdGFibGVcbiAgICAgICAgaWYgKHRoaXMucGFyZW50RWxlbWVudCAmJiB0aGlzLnBhcmVudEVsZW1lbnQuaXMoXCJ0YWJsZVwiKSkge1xuICAgICAgICAgICAgdGhpcy50YWJsZS5maW5kKFwidHJcIikuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHRpLl9hZGRFbGVtZW50KHRpLnBhcmVudEVsZW1lbnQsICQodGhpcykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRWxzZSwgYWRkIHRoZSB0YWJsZSB0byBwYXJlbnQgZWxlbWVudFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnQuaXMoXCJ0YWJsZVwiKSlcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRFbGVtZW50KHRoaXMucGFyZW50RWxlbWVudCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkRWxlbWVudCh0aGlzLnBhcmVudEVsZW1lbnQsICQoXCI8dGFibGU+XCIpLmFwcGVuZCh0aGlzLmVsZW1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbmUoKTtcbiAgICB9XG5cbiAgICAvLyBDYWxsZWQgd2hlbiBhbiBpbnN0cnVjdGlvbiBpcyBkb25lXG4gICAgX2V4ZWN1dGVkKGluc3RydWN0aW9uKSB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMudG9CZURvbmUuaW5kZXhPZihpbnN0cnVjdGlvbik7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKVxuICAgICAgICAgICAgdGhpcy50b0JlRG9uZS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBpbnN0cnVjdGlvbiBsZWZ0IHRvIGJlIGRvbmUsIGNhbGwgZG9uZSBpZiBlbGVtZW50IGFscmVhZHkgYWRkZWRcbiAgICAgICAgaWYgKHRoaXMudG9CZURvbmUubGVuZ3RoIDwgMSAmJiAkLmNvbnRhaW5zKGRvY3VtZW50LmJvZHksIHRoaXMuZWxlbWVudFswXSkpXG4gICAgICAgICAgICB0aGlzLmRvbmUoKTtcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkaW5nIG5ld01ldGEsIGFzIG9yaWdpbmFsJ3MgY29udGVudCBwb3NlcyBwcm9ibGVtc1xuICAgIG5ld01ldGEoY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IGN0ID0gdGhpcy5vcmlnaW4uY29udGVudDtcbiAgICAgICAgdGhpcy5vcmlnaW4uY29udGVudCA9IG51bGw7XG4gICAgICAgIGxldCBydG4gPSBzdXBlci5uZXdNZXRhKGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5vcmlnaW4uY29udGVudCA9IGN0O1xuICAgICAgICByZXR1cm4gcnRuO1xuICAgIH1cblxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIE1FVEhPRFMgUkVUVVJOSU5HIE5FVyBJTlNUUlVDVElPTlNcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyBSZXR1cm5zIGFuIGluc3RydWN0aW9uIHNldHRpbmcgdGhlIHZhbGlkYXRpb24gbWV0aG9kXG4gICAgLy8gRG9uZSB3aGVuIGFsbCBPUiBhbnkgT1Igc3BlY2lmaWMgaW5zdHJ1Y3Rpb24ocykgZG9uZVxuICAgIHZhbGlkYXRpb24od2hpY2gpIHtcbiAgICAgICAgbGV0IGluc3RyID0gdGhpcy5uZXdNZXRhKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAvLyBWYWxpZGF0aW9uIGNvbmRpdGlvbnMgbWF5IGFscmVhZHkgaG9sZCB3aGVuIGluc3RydWN0aW9uIGlzIHJ1blxuICAgICAgICAgICAgaWYgICggXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luLnRvQmVEb25lLmxlbmd0aDwxIHx8XG4gICAgICAgICAgICAgICAgICAgICh3aGljaCA9PSBcImFueVwiICYmIHRoaXMub3JpZ2luLnRvQmVEb25lLmxlbmd0aCA8IE9iamVjdC5rZXlzKHRoaXMub3JpZ2luLmNvbnRlbnQpLmxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHR5cGVvZih3aGljaCkgPT0gXCJudW1iZXJcIiAmJiB3aGljaCBpbiB0aGlzLm9yaWdpbi5jb250ZW50ICYmIHRoaXMub3JpZ2luLmNvbnRlbnRbd2hpY2hdLmlzRG9uZSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDaGVjayB2YWxpZGF0aW9uIGNvbmRpdGlvbnMgd2hlbmV2ZXIgYW4gaW5zdHJ1Y3Rpb24gaXMgZG9uZVxuICAgICAgICB0aGlzLm9yaWdpbi5fZXhlY3V0ZWQgPSB0aGlzLm9yaWdpbi5leHRlbmQoXCJfZXhlY3V0ZWRcIiwgZnVuY3Rpb24oaW5zdHJ1Y3Rpb24pe1xuICAgICAgICAgICAgLy8gSWYgdmFsaWRhdGlvbiBjb25kaXRpb25zIG1ldCBiZWZvcmUsIHRoaXMgaW5zdHJ1Y3Rpb24ncyBhbHJlYWR5IGRvbmVcbiAgICAgICAgICAgIGlmIChpbnN0ci5pc0RvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEFib3J0O1xuICAgICAgICAgICAgLy8gSWYgJ2FueSwnIGluc3RydWN0aW9uIGlzIGRvbmUgYXMgc29vbiBhcyBvbmUgaW5zdHJ1Y3Rpb24gaXMgZG9uZVxuICAgICAgICAgICAgaWYgKHdoaWNoID09IFwiYW55XCIpXG4gICAgICAgICAgICAgICAgaW5zdHIuZG9uZSgpO1xuICAgICAgICAgICAgLy8gSWYgV0hJQ0ggaXMgYW4gaW5kZXgsIHRoZSBjb21wbGV4IGluc3RydWN0aW9uIGlzIGRvbmUgb25seSB3aGVuIHRoZSBpbmRleCd0aCBpbnN0cnVjdGlvbiBpcyBkb25lXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Yod2hpY2gpID09IFwibnVtYmVyXCIgJiYgd2hpY2ggaW4gdGhpcy5vcmlnaW4uY29udGVudCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0ci5vcmlnaW4uY29udGVudFt3aGljaF0gPT0gaW5zdHJ1Y3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0ci5kb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBXSElDSCBwb2ludHMgdG8gb25lIG9mIHRoZSBpbnN0cnVjdGlvbnMsIGNvbXBsZXggaXMgZG9uZSB3aGVuIHRoYXQgaW5zdHJ1Y3Rpb24gaXMgZG9uZVxuICAgICAgICAgICAgZWxzZSBpZiAod2hpY2ggaW5zdGFuY2VvZiBJbnN0cnVjdGlvbiAmJiB3aGljaCA9PSBpbnN0cnVjdGlvbilcbiAgICAgICAgICAgICAgICBpbnN0ci5kb25lKCk7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGFsbCBpbnN0cnVjdGlvbnMgaGF2ZSB0byBiZSBkb25lIGJlZm9yZSB0aGlzIG9uZSdzIGRvbmVcbiAgICAgICAgICAgIGVsc2UgaWYgKGluc3RyLm9yaWdpbi50b0JlRG9uZS5sZW5ndGg8MSlcbiAgICAgICAgICAgICAgICAgICAgaW5zdHIuZG9uZSgpO1xuICAgICAgIH0pO1xuICAgICAgIHJldHVybiBpbnN0cjtcbiAgICB9XG59XG5cblBlbm5Db250cm9sbGVyLmluc3RydWN0aW9uLnNlcXVlbmNlID0gZnVuY3Rpb24oKXsgcmV0dXJuIG5ldyBDb21wbGV4SW5zdHIoYXJndW1lbnRzKTsgfTsiLCIvLyBEZXRhY2hlcyBhbnkgcHJlY2VkaW5nIERPTSBlbGVtZW50XG4vLyBEb25lIGltbWVkaWF0ZWx5XG5jbGFzcyBDbGVhckluc3RyIGV4dGVuZHMgSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcImNsZWFyXCIsIFwiY2xlYXJcIik7XG4gICAgfVxuXG4gICAgcnVuKCkge1xuICAgICAgICBzdXBlci5ydW4oKTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUnVuID0gdHJ1ZTtcbiAgICAgICAgJChcIi5QZW5uQ29udHJvbGxlci1QZW5uQ29udHJvbGxlciBkaXZcIikuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuZG9uZSgpO1xuICAgIH1cbn1cblxuUGVubkNvbnRyb2xsZXIuaW5zdHJ1Y3Rpb24uY2xlYXIgPSBmdW5jdGlvbigpeyByZXR1cm4gbmV3IENsZWFySW5zdHIoKTsgfTsiLCIvLyBBZGRzIGEgQ2FudmFzIHdoZXJlIHlvdSBjYW4gcGxhY2UgbXVsdGlwbGUgaW5zdHJ1Y3Rpb25zXG4vLyBEb25lIGltbWVkaWF0ZWx5XG5jbGFzcyBDYW52YXNJbnN0ciBleHRlbmRzIEluc3RydWN0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih3LGgpIHtcbiAgICAgICAgc3VwZXIoe3dpZHRoOiB3LCBoZWlnaHQ6IGh9LCBcImNhbnZhc1wiKTtcbiAgICAgICAgaWYgKHcgIT0gQWJvcnQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YodykgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YoaCkgIT0gXCJudW1iZXJcIiB8fCB3IDwgMCB8fCBoIDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm4gQWJvcnQ7XG4gICAgICAgICAgICBsZXQgZWxlbWVudCA9ICQoXCI8ZGl2PlwiKS5jc3Moe3dpZHRoOiB3LCBoZWlnaHQ6IGgsIHBvc2l0aW9uOiBcInJlbGF0aXZlXCJ9KS5hZGRDbGFzcyhcIlBlbm5Db250cm9sbGVyLUNhbnZhc1wiKTtcbiAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0cyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFBSSVZBVEUgQU5EIElOU1RSSU5TSUMgTUVUSE9EU1xuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIHJ1bigpIHtcbiAgICAgICAgaWYgKHN1cGVyLnJ1bigpID09IEFib3J0KVxuICAgICAgICAgICAgcmV0dXJuIEFib3J0O1xuICAgICAgICBmb3IgKGxldCBvIGluIHRoaXMub2JqZWN0cykge1xuICAgICAgICAgICAgbGV0IG9iamVjdCA9IHRoaXMub2JqZWN0c1tvXSxcbiAgICAgICAgICAgICAgICBvcmlnaW4gPSBvYmplY3RbMF07XG4gICAgICAgICAgICBpZiAoIShvcmlnaW4gaW5zdGFuY2VvZiBJbnN0cnVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGVsZW1lbnQgI1wiK28rXCIgb2YgY2FudmFzIGlzIG5vdCBhIHByb3BlciBpbnN0cnVjdGlvbjsgaWdub3JpbmcgaXQuXCIpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgaW5zdHJ1Y3Rpb24gaGFzIG5vdCBiZWVuIHJ1biB5ZXQsIHJ1biBpdFxuICAgICAgICAgICAgaWYgKCFvcmlnaW4uaGFzQmVlblJ1bikge1xuICAgICAgICAgICAgICAgIG9yaWdpbi5ydW4oKTtcbiAgICAgICAgICAgICAgICBvcmlnaW4uZG9uZSA9IG9yaWdpbi5leHRlbmQoXCJkb25lXCIsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbi5lbGVtZW50LmNzcyh7cG9zaXRpb246IFwiYWJzb2x1dGVcIiwgbGVmdDogb2JqZWN0WzFdLCB0b3A6IG9iamVjdFsyXSwgXCJ6LWluZGV4XCI6IG9iamVjdFszXX0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FkZEVsZW1lbnQodGhpcy5wYXJlbnRFbGVtZW50KTtcbiAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgfVxuXG4gICAgLy8gQWRkcyBhbiBvYmplY3Qgb250byB0aGUgY2FudmFzIGF0IChYLFkpIG9uIHRoZSBaLWluZGV4IGxldmVsXG4gICAgX2FkZE9iamVjdChpbnN0cnVjdGlvbiwgeCwgeSwgeikge1xuICAgICAgICBpZiAodHlwZW9mKHgpICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mKHkpICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICByZXR1cm4gQWJvcnQ7XG4gICAgICAgIGlmICghKGluc3RydWN0aW9uIGluc3RhbmNlb2YgSW5zdHJ1Y3Rpb24pKVxuICAgICAgICAgICAgcmV0dXJuIEFib3J0O1xuICAgICAgICBsZXQgb3JpZ2luID0gaW5zdHJ1Y3Rpb24ub3JpZ2luO1xuICAgICAgICBsZXQgYWxyZWFkeUluID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IG8gaW4gdGhpcy5vcmlnaW4ub2JqZWN0cykge1xuICAgICAgICAgICAgbGV0IG9iamVjdCA9IHRoaXMub3JpZ2luLm9iamVjdHNbb107XG4gICAgICAgICAgICAvLyBJZiBpbnN0cnVjdGlvbiBhbHJlYWR5IGNvbnRhaW5lZCwgdXBkYXRlIHRoZSBwYXJhbWV0ZXJzXG4gICAgICAgICAgICBpZiAob2JqZWN0WzBdID09IG9yaWdpbikge1xuICAgICAgICAgICAgICAgIG9iamVjdFsxXSA9IHg7XG4gICAgICAgICAgICAgICAgb2JqZWN0WzJdID0geTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHopID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFszXSA9IHo7XG4gICAgICAgICAgICAgICAgYWxyZWFkeUluID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBpbnN0cnVjdGlvbiBpcyBuZXdseSBhZGRlZCwganVzdCBwdXNoIE9CSkVDVFNcbiAgICAgICAgaWYgKCFhbHJlYWR5SW4pXG4gICAgICAgICAgICB0aGlzLm9yaWdpbi5vYmplY3RzLnB1c2goW29yaWdpbiwgeCwgeSwgKHR5cGVvZih6KT09XCJudW1iZXJcIiA/IHogOiB0aGlzLm9yaWdpbi5vYmplY3RzLmxlbmd0aCldKTtcbiAgICAgICAgLy8gUmVkZWZpbmVkIHBhcmVudEVsZW1lbnQgaW4gYW55IGNhc2VcbiAgICAgICAgb3JpZ2luLnBhcmVudEVsZW1lbnQgPSB0aGlzLm9yaWdpbi5lbGVtZW50O1xuICAgICAgICAvLyBJZiBpbnN0cnVjdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJ1biBhbmQgaXMgYWxyZWFkeSBkb25lLCByZS1hcHBlbmQgaXRzIGVsZW1lbnRcbiAgICAgICAgaWYgKGluc3RydWN0aW9uLmhhc0JlZW5SdW4gJiYgaW5zdHJ1Y3Rpb24uaXNEb25lKSB7XG4gICAgICAgICAgICBvcmlnaW4uZWxlbWVudC5hcHBlbmRUbyh0aGlzLm9yaWdpbi5lbGVtZW50KTtcbiAgICAgICAgICAgIG9yaWdpbi5lbGVtZW50LmNzcyh7cG9zaXRpb246IFwiYWJzb2x1dGVcIiwgbGVmdDogeCwgdG9wOiB5LCBcInotaW5kZXhcIjogen0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGluc3RydWN0aW9uIGhhcyBub3QgYmVlbiBydW4geWV0LCBidXQgaWYgQ0FOVkFTIGhhcyBiZWVuIHJ1bjogcnVuIGluc3RydWN0aW9uXG4gICAgICAgIGVsc2UgaWYgKHRoaXMub3JpZ2luLmhhc0JlZW5SdW4pIHtcbiAgICAgICAgICAgIG9yaWdpbi5kb25lID0gb3JpZ2luLmV4dGVuZChcImRvbmVcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBvcmlnaW4uZWxlbWVudC5jc3Moe3Bvc2l0aW9uOiBcImFic29sdXRlXCIsIGxlZnQ6IHgsIHRvcDogeSwgXCJ6LWluZGV4XCI6IHp9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24ucnVuKCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBNRVRIT0RTIFJFVFVSTklORyBORVcgSU5TVFJVQ1RJT05TXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gUmV0dXJucyBhbiBpbnN0cnVjdGlvbiB0byBhZGQvdXBkYXRlIGFuIGluc3RydWN0aW9uIG9uIHRoZSBjYW52YXMgYXQgKFgsWSlcbiAgICAvLyBEb25lIGltbWVkaWF0ZWx5XG4gICAgcHV0KGluc3RydWN0aW9uLCB4LCB5LCB6KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld01ldGEoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luLl9hZGRPYmplY3QoaW5zdHJ1Y3Rpb24sIHgsIHksIHopO1xuICAgICAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuUGVubkNvbnRyb2xsZXIuaW5zdHJ1Y3Rpb24uY2FudmFzID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCl7IHJldHVybiBuZXcgQ2FudmFzSW5zdHIod2lkdGgsIGhlaWdodCk7IH07IiwiaW1wb3J0IHtfYXV0b1ByZWxvYWRBdWRpbywgX2luc3RydWN0aW9uc1RvUHJlbG9hZH0gZnJvbSBcIi4uL3ByZWxvYWQvcHJlbG9hZC5qc1wiO1xuXG4vLyBBZGRzIGFuIEFVRElPIHRvIHRoZSBwYXJlbnQgZWxlbWVudFxuLy8gRG9uZSBpbW1lZGlhdGVseVxuY2xhc3MgQXVkaW9JbnN0ciBleHRlbmRzIEluc3RydWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihmaWxlKSB7XG4gICAgICAgIHN1cGVyKGZpbGUsIFwiYXVkaW9cIik7XG4gICAgICAgIGlmIChmaWxlICE9IEFib3J0KSB7XG4gICAgICAgICAgICBpZiAoIWZpbGUubWF0Y2goL1xcLihvZ2d8d2F2fG1wMykkL2kpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFcnJvcjogXCIrZmlsZStcIiBpcyBub3QgYSB2YWxpZCBhdWRpbyBmaWxlLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQWJvcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBdXRvcGxheSBieSBkZWZhdWx0XG4gICAgICAgICAgICB0aGlzLmF1dG9QbGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIERvIG5vdCBzaG93IGNvbnRyb2xzIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFdpbGwgYmUgc2V0IHRvIHRydWUgd2hlbiBwbGF5YmFjayBlbmRzXG4gICAgICAgICAgICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBBIHJlY29yZCBvZiB0aGUgZGlmZmVyZW50IGV2ZW50cyAocGxheSwgcGF1c2UsIHN0b3AsIHNlZWspXG4gICAgICAgICAgICB0aGlzLmV2ZW50c1JlY29yZCA9IFtdO1xuICAgICAgICAgICAgLy8gV2hldGhlciB0byBzYXZlIHBsYXlzXG4gICAgICAgICAgICB0aGlzLnNhdmVQbGF5cyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gV2hldGhlciB0byBzYXZlIHBhdXNlc1xuICAgICAgICAgICAgdGhpcy5zYXZlUGF1c2VzID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBXaGV0aGVyIHRvIHNhdmUgZW5kc1xuICAgICAgICAgICAgdGhpcy5zYXZlRW5kcyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gV2hldGhlciB0byBzYXZlIHNlZWtzXG4gICAgICAgICAgICB0aGlzLnNhdmVTZWVrcyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gU2V0IGVsZW1lbnQgdG8gU1BBTiAod2lsbCBhcHBlbmQgYXVkaW8gbGF0ZXIpXG4gICAgICAgICAgICB0aGlzLnNldEVsZW1lbnQoJChcIjxzcGFuPlwiKSk7XG4gICAgICAgICAgICAvLyBDYWxsaW5nIGFkZFRvUHJlbG9hZCBpbW1lZGlhdGVseSBpZiBzZXR0aW5ncyBzYXkgc28gXG4gICAgICAgICAgICBpZiAoX2F1dG9QcmVsb2FkQXVkaW8pXG4gICAgICAgICAgICAgICAgdGhpcy5vcmlnaW4uX2FkZFRvUHJlbG9hZCgpO1xuICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIGZpbGVcbiAgICAgICAgICAgIHRoaXMub3JpZ2luLmZldGNoUmVzb3VyY2UoZmlsZSwgXCJhdWRpb1wiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQUklWQVRFICYgSU5UUklOU0lDIE1FVEhPRFNcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBydW4oKSB7XG4gICAgICAgIGlmIChzdXBlci5ydW4oKSA9PSBBYm9ydClcbiAgICAgICAgICAgIHJldHVybiBBYm9ydDtcbiAgICAgICAgaWYgKHRoaXMuYXVkaW8pIHtcbiAgICAgICAgICAgIC8vIEJpbmRpbmcgdGhlIHdoZW5FbmRlZCBtZXRob2QgKHVwb24gcnVubmluZyBiZWNhdXNlIG90aGVyd2lzZSBwb3RlbnRpYWwgcHJvYmxlbXMgd2l0aCBvdGhlciBpdGVtcycgaW5zdHJ1Y3Rpb25zKVxuICAgICAgICAgICAgbGV0IHRpID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMub3JpZ2luLmF1ZGlvLmJpbmQoJ2VuZGVkJywgZnVuY3Rpb24oKXsgdGkuX3doZW5FbmRlZCgpOyB9KTtcbiAgICAgICAgICAgIC8vIElmIGF1ZGlvIG5vdCBlbnRpcmVseSBwcmVsb2FkZWQgeWV0LCBzZW5kIGFuIGVycm9yIHNpZ25hbFxuICAgICAgICAgICAgaWYgKHRoaXMuYXVkaW8ucmVhZHlTdGF0ZSA8IDQgJiYgX2luc3RydWN0aW9uc1RvUHJlbG9hZC5pbmRleE9mKHRoaXMub3JpZ2luKT49MClcbiAgICAgICAgICAgICAgICBDdHJsci5ydW5uaW5nLnNhdmUoXCJFUlJPUl9QUkVMT0FESU5HX0FVRElPXCIsIHRoaXMuY29udGVudCwgRGF0ZS5ub3coKSwgXCJBdWRpbyB3YXMgbm90IGZ1bGx5IGxvYWRlZFwiKTtcbiAgICAgICAgICAgIC8vIFNob3cgY29udHJvbHNcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpby5hdHRyKCdjb250cm9scycsdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpby5jc3MoXCJkaXNwbGF5XCIsIFwiaW5oZXJpdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhpZGUgYXVkaW8gZWxlbWVudFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW8uY3NzKCdkaXNwbGF5Jywnbm9uZScpO1xuICAgICAgICAgICAgLy8gQWRkaW5nIGl0IHRvIHRoZSBlbGVtZW50XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kKHRoaXMuYXVkaW8pO1xuICAgICAgICAgICAgLy8gQWRkaW5nIHRoZSBlbGVtZW50IHRvIHRoZSBkb2N1bWVudFxuICAgICAgICAgICAgdGhpcy5fYWRkRWxlbWVudCh0aGlzLnBhcmVudEVsZW1lbnQpO1xuICAgICAgICAgICAgLy8gQXV0b3BsYXlcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9QbGF5KVxuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9bMF0ucGxheSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9uZSgpO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgQVVESU8gZWxlbWVudFxuICAgIF9zZXRSZXNvdXJjZShhdWRpbykge1xuICAgICAgICAvLyBBYm9ydCBpZiBvcmlnaW4ncyBhdWRpbydzIGFscmVhZHkgc2V0XG4gICAgICAgIGlmICh0aGlzLm9yaWdpbi5hdWRpbylcbiAgICAgICAgICAgIHJldHVybiBBYm9ydDtcbiAgICAgICAgaWYgKHN1cGVyLl9zZXRSZXNvdXJjZShhdWRpbyk9PUFib3J0KVxuICAgICAgICAgICAgcmV0dXJuIEFib3J0O1xuICAgICAgICBsZXQgdGkgPSB0aGlzLm9yaWdpbjtcbiAgICAgICAgdGhpcy5vcmlnaW4uYXVkaW8gPSBhdWRpbztcbiAgICAgICAgLy8gUmVjb3JkIHRoZSBkaWZmZXJlbnQgZXZlbnRzXG4gICAgICAgIGF1ZGlvLmJpbmQoXCJwbGF5XCIsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAvLyBTb21ldGltZXMgaXQgdGFrZXMgdGltZSBiZWZvcmUgdGhlIGF1ZGlvIHN0ZWFtIGFjdHVhbGx5IHN0YXJ0cyBwbGF5aW5nXG4gICAgICAgICAgICBsZXQgYWN0dWFsUGxheSA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBQQVVTRUQgYW5kIENVUlJFTlRJTUUgZXZlcnkgbWlsbGlzZWNvbmQ6IHRoZW4gaXQncyB0aW1lIHRvIHJlY29yZCFcbiAgICAgICAgICAgICAgICBpZiAoIWF1ZGlvWzBdLnBhdXNlZCAmJiBhdWRpb1swXS5jdXJyZW50VGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aS5ldmVudHNSZWNvcmQucHVzaChbXCJwbGF5XCIsIERhdGUubm93KCksIGF1ZGlvWzBdLmN1cnJlbnRUaW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoYWN0dWFsUGxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgIH0pLmJpbmQoXCJlbmRlZFwiLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGkuZXZlbnRzUmVjb3JkLnB1c2goW1wiZW5kXCIsIERhdGUubm93KCksIGF1ZGlvWzBdLmN1cnJlbnRUaW1lXSk7XG4gICAgICAgIH0pLmJpbmQoXCJwYXVzZVwiLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGkuZXZlbnRzUmVjb3JkLnB1c2goW1wicGF1c2VcIiwgRGF0ZS5ub3coKSwgYXVkaW9bMF0uY3VycmVudFRpbWVdKTtcbiAgICAgICAgfSkuYmluZChcInNlZWtlZFwiLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGkuZXZlbnRzUmVjb3JkLnB1c2goW1wic2Vla1wiLCBEYXRlLm5vdygpLCBhdWRpb1swXS5jdXJyZW50VGltZV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMub3JpZ2luLmhhc0JlZW5SdW4pIHtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luLmhhc0JlZW5SdW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luLnJ1bigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2FsbGVkIHdoZW4gdGhlIGF1ZGlvIGVuZHNcbiAgICBfd2hlbkVuZGVkKCkge1xuICAgICAgICB0aGlzLm9yaWdpbi5lbmRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIE1FVEhPRFMgUkVUVVJOSU5HIE5FVyBJTlNUUlVDVElPTlNcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyBSZXR1cm5zIGFuIGluc3RydWN0aW9uIHRvIHNob3cgdGhlIGF1ZGlvIChhbmQgaXRzIGNvbnRyb2xzKVxuICAgIC8vIERvbmUgaW1tZWRpYXRlbHlcbiAgICBzaG93KGRvU2hvdykge1xuICAgICAgICBpZiAodHlwZW9mKGRvU2hvdykgPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIGRvU2hvdyA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld01ldGEoZnVuY3Rpb24oKXsgXG4gICAgICAgICAgICB0aGlzLm9yaWdpbi5jb250cm9scyA9IGRvU2hvdztcbiAgICAgICAgICAgIHRoaXMuZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIGFuIGluc3RydWN0aW9uIHRoYXQgdXNlcnMgc2hvdWxkIGNsaWNrIHRvIHN0YXJ0IHBsYXlpbmcgdGhlIGF1ZGlvXG4gICAgLy8gRG9uZSBpbW1lZGlhdGVseVxuICAgIGNsaWNrVG9TdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV3TWV0YShmdW5jdGlvbigpeyBcbiAgICAgICAgICAgIC8vIE1ha2luZyBzdXJlIHRoZSBjb250cm9scyBhcmUgdmlzaWJsZVxuICAgICAgICAgICAgaWYgKCF0aGlzLm9yaWdpbi5jb250cm9scylcbiAgICAgICAgICAgICAgICB0aGlzLm9yaWdpbi5jb250cm9scyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbi5hdXRvID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFJldHVybnMgYW4gaW5zdHJ1Y3Rpb24gdG8gd2FpdFxuICAgIC8vIERvbmUgd2hlbiBvcmlnaW4ncyBlbGVtZW50IGhhcyBiZWVuIHBsYXllZFxuICAgIHdhaXQoKSB7XG4gICAgICAgIC8vIElmIHNvdW5kJ3MgYWxyZWFkeSBjb21wbGV0ZWx5IHBsYXllZCBiYWNrLCBkb25lIGltbWVkaWF0ZWx5XG4gICAgICAgIGlmICh0aGlzLm9yaWdpbi5lbmRlZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5ld01ldGEoZnVuY3Rpb24oKXsgdGhpcy5kb25lKCk7IH0pO1xuICAgICAgICAvLyBFbHNlLCBkb25lIHdoZW4gb3JpZ2luJ3MgcGxheWVkIGJhY2tcbiAgICAgICAgbGV0IGluc3RyID0gdGhpcy5uZXdNZXRhKCk7XG4gICAgICAgIHRoaXMub3JpZ2luLl93aGVuRW5kZWQgPSB0aGlzLm9yaWdpbi5leHRlbmQoXCJfd2hlbkVuZGVkXCIsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpbnN0ci5kb25lKCk7XG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBpbnN0cjtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIGFuIGluc3RydWN0aW9uIHRvIFNBVkUgdGhlIHBhcmFtZXRlcnNcbiAgICAvLyBEb25lIGltbWVkaWF0ZWx5XG4gICAgcmVjb3JkKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgbGV0IG8gPSB0aGlzLm9yaWdpbiwgXG4gICAgICAgICAgICBzYXZlRmN0ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQgPT0gXCJwbGF5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8uc2F2ZVBsYXlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFib3J0O1xuICAgICAgICAgICAgICAgICAgICBvLnNhdmVQbGF5cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50ID09IFwicGF1c2VcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoby5zYXZlUGF1c2VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFib3J0O1xuICAgICAgICAgICAgICAgICAgICBvLnNhdmVQYXVzZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudCA9PSBcImVuZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvLnNhdmVFbmRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFib3J0O1xuICAgICAgICAgICAgICAgICAgICBvLnNhdmVFbmRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQgPT0gXCJzZWVrXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8uc2F2ZVNlZWtzKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFib3J0O1xuICAgICAgICAgICAgICAgICAgICBvLnNhdmVTZWVrcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFib3J0O1xuICAgICAgICAgICAgICAgIC8vIEFkZGluZyBpdCB0byBkb25lLCBiZWNhdXNlIEN0cmxyLnJ1bm5pbmcgaXMgbm90IGRlZmluZWQgdXBvbiBjcmVhdGlvbiBvZiBpbnN0cnVjdGlvblxuICAgICAgICAgICAgICAgIG8uZG9uZSA9IG8uZXh0ZW5kKFwiZG9uZVwiLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICBDdHJsci5ydW5uaW5nLmNhbGxiYWNrQmVmb3JlRmluaXNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIGluIG8uZXZlbnRzUmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlY29yZCA9IG8uZXZlbnRzUmVjb3JkW3JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmRbMF0gPT0gZXZlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEN0cmxyLnJ1bm5pbmcuc2F2ZShvLmNvbnRlbnQsIHJlY29yZFswXSwgcmVjb3JkWzFdLCByZWNvcmRbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIC8vIEFyZ3VtZW50IGlzIGEgc3RyaW5nXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEgJiYgdHlwZW9mKHBhcmFtZXRlcnMpID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBzYXZlRmN0KHBhcmFtZXRlcnMpO1xuICAgICAgICAvLyBNdWx0aXBsZSBhcmd1bWVudHNcbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGEgPSAwOyBhIDwgYXJndW1lbnRzLmxlbmd0aDsgYSsrKVxuICAgICAgICAgICAgICAgIHNhdmVGY3QoYXJndW1lbnRzW2FdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBObyBhcmd1bWVudCAob3IgdW5pbnRlbGxpZ2libGUgYXJndW1lbnQpOiBzYXZlIGV2ZXJ5dGhpbmdcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzYXZlRmN0KFwicGxheVwiKTtcbiAgICAgICAgICAgIHNhdmVGY3QoXCJwYXVzZVwiKTtcbiAgICAgICAgICAgIHNhdmVGY3QoXCJlbmRcIik7XG4gICAgICAgICAgICBzYXZlRmN0KFwic2Vla1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXdNZXRhKGZ1bmN0aW9uKCl7IHRoaXMuZG9uZSgpOyB9KTtcbiAgICB9XG5cbiAgICBwcmVsb2FkKCkge1xuICAgICAgICB0aGlzLm9yaWdpbi5fYWRkVG9QcmVsb2FkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld01ldGEoZnVuY3Rpb24oKXsgdGhpcy5kb25lKCk7IH0pO1xuICAgIH1cbn1cblxuUGVubkNvbnRyb2xsZXIuaW5zdHJ1Y3Rpb24uYXVkaW8gPSBmdW5jdGlvbihhdWRpbyl7IHJldHVybiBuZXcgQXVkaW9JbnN0cihhdWRpbyk7IH07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlYWRlckZvciA9IHJlcXVpcmUoJy4vcmVhZGVyL3JlYWRlckZvcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIENvbXByZXNzZWRPYmplY3QgPSByZXF1aXJlKCcuL2NvbXByZXNzZWRPYmplY3QnKTtcbnZhciBjcmMzMmZuID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIHV0ZjggPSByZXF1aXJlKCcuL3V0ZjgnKTtcbnZhciBjb21wcmVzc2lvbnMgPSByZXF1aXJlKCcuL2NvbXByZXNzaW9ucycpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcblxudmFyIE1BREVfQllfRE9TID0gMHgwMDtcbnZhciBNQURFX0JZX1VOSVggPSAweDAzO1xuXG4vKipcbiAqIEZpbmQgYSBjb21wcmVzc2lvbiByZWdpc3RlcmVkIGluIEpTWmlwLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXByZXNzaW9uTWV0aG9kIHRoZSBtZXRob2QgbWFnaWMgdG8gZmluZC5cbiAqIEByZXR1cm4ge09iamVjdHxudWxsfSB0aGUgSlNaaXAgY29tcHJlc3Npb24gb2JqZWN0LCBudWxsIGlmIG5vbmUgZm91bmQuXG4gKi9cbnZhciBmaW5kQ29tcHJlc3Npb24gPSBmdW5jdGlvbihjb21wcmVzc2lvbk1ldGhvZCkge1xuICAgIGZvciAodmFyIG1ldGhvZCBpbiBjb21wcmVzc2lvbnMpIHtcbiAgICAgICAgaWYgKCFjb21wcmVzc2lvbnMuaGFzT3duUHJvcGVydHkobWV0aG9kKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXByZXNzaW9uc1ttZXRob2RdLm1hZ2ljID09PSBjb21wcmVzc2lvbk1ldGhvZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXByZXNzaW9uc1ttZXRob2RdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuLy8gY2xhc3MgWmlwRW50cnkge3t7XG4vKipcbiAqIEFuIGVudHJ5IGluIHRoZSB6aXAgZmlsZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvZiB0aGUgY3VycmVudCBmaWxlLlxuICogQHBhcmFtIHtPYmplY3R9IGxvYWRPcHRpb25zIE9wdGlvbnMgZm9yIGxvYWRpbmcgdGhlIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gWmlwRW50cnkob3B0aW9ucywgbG9hZE9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMubG9hZE9wdGlvbnMgPSBsb2FkT3B0aW9ucztcbn1cblppcEVudHJ5LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBzYXkgaWYgdGhlIGZpbGUgaXMgZW5jcnlwdGVkLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGZpbGUgaXMgZW5jcnlwdGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNFbmNyeXB0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBiaXQgMSBpcyBzZXRcbiAgICAgICAgcmV0dXJuICh0aGlzLmJpdEZsYWcgJiAweDAwMDEpID09PSAweDAwMDE7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBzYXkgaWYgdGhlIGZpbGUgaGFzIHV0Zi04IGZpbGVuYW1lL2NvbW1lbnQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZmlsZW5hbWUvY29tbWVudCBpcyBpbiB1dGYtOCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHVzZVVURjg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBiaXQgMTEgaXMgc2V0XG4gICAgICAgIHJldHVybiAodGhpcy5iaXRGbGFnICYgMHgwODAwKSA9PT0gMHgwODAwO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgbG9jYWwgcGFydCBvZiBhIHppcCBmaWxlIGFuZCBhZGQgdGhlIGluZm8gaW4gdGhpcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXIgdGhlIHJlYWRlciB0byB1c2UuXG4gICAgICovXG4gICAgcmVhZExvY2FsUGFydDogZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICAgIHZhciBjb21wcmVzc2lvbiwgbG9jYWxFeHRyYUZpZWxkc0xlbmd0aDtcblxuICAgICAgICAvLyB3ZSBhbHJlYWR5IGtub3cgZXZlcnl0aGluZyBmcm9tIHRoZSBjZW50cmFsIGRpciAhXG4gICAgICAgIC8vIElmIHRoZSBjZW50cmFsIGRpciBkYXRhIGFyZSBmYWxzZSwgd2UgYXJlIGRvb21lZC5cbiAgICAgICAgLy8gT24gdGhlIGJyaWdodCBzaWRlLCB0aGUgbG9jYWwgcGFydCBpcyBzY2FyeSAgOiB6aXA2NCwgZGF0YSBkZXNjcmlwdG9ycywgYm90aCwgZXRjLlxuICAgICAgICAvLyBUaGUgbGVzcyBkYXRhIHdlIGdldCBoZXJlLCB0aGUgbW9yZSByZWxpYWJsZSB0aGlzIHNob3VsZCBiZS5cbiAgICAgICAgLy8gTGV0J3Mgc2tpcCB0aGUgd2hvbGUgaGVhZGVyIGFuZCBkYXNoIHRvIHRoZSBkYXRhICFcbiAgICAgICAgcmVhZGVyLnNraXAoMjIpO1xuICAgICAgICAvLyBpbiBzb21lIHppcCBjcmVhdGVkIG9uIHdpbmRvd3MsIHRoZSBmaWxlbmFtZSBzdG9yZWQgaW4gdGhlIGNlbnRyYWwgZGlyIGNvbnRhaW5zIFxcIGluc3RlYWQgb2YgLy5cbiAgICAgICAgLy8gU3RyYW5nZWx5LCB0aGUgZmlsZW5hbWUgaGVyZSBpcyBPSy5cbiAgICAgICAgLy8gSSB3b3VsZCBsb3ZlIHRvIHRyZWF0IHRoZXNlIHppcCBmaWxlcyBhcyBjb3JydXB0ZWQgKHNlZSBodHRwOi8vd3d3LmluZm8temlwLm9yZy9GQVEuaHRtbCNiYWNrc2xhc2hlc1xuICAgICAgICAvLyBvciBBUFBOT1RFIzQuNC4xNy4xLCBcIkFsbCBzbGFzaGVzIE1VU1QgYmUgZm9yd2FyZCBzbGFzaGVzICcvJ1wiKSBidXQgdGhlcmUgYXJlIGEgbG90IG9mIGJhZCB6aXAgZ2VuZXJhdG9ycy4uLlxuICAgICAgICAvLyBTZWFyY2ggXCJ1bnppcCBtaXNtYXRjaGluZyBcImxvY2FsXCIgZmlsZW5hbWUgY29udGludWluZyB3aXRoIFwiY2VudHJhbFwiIGZpbGVuYW1lIHZlcnNpb25cIiBvblxuICAgICAgICAvLyB0aGUgaW50ZXJuZXQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEkgdGhpbmsgSSBzZWUgdGhlIGxvZ2ljIGhlcmUgOiB0aGUgY2VudHJhbCBkaXJlY3RvcnkgaXMgdXNlZCB0byBkaXNwbGF5XG4gICAgICAgIC8vIGNvbnRlbnQgYW5kIHRoZSBsb2NhbCBkaXJlY3RvcnkgaXMgdXNlZCB0byBleHRyYWN0IHRoZSBmaWxlcy4gTWl4aW5nIC8gYW5kIFxcXG4gICAgICAgIC8vIG1heSBiZSB1c2VkIHRvIGRpc3BsYXkgXFwgdG8gd2luZG93cyB1c2VycyBhbmQgdXNlIC8gd2hlbiBleHRyYWN0aW5nIHRoZSBmaWxlcy5cbiAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgdGhpcyBsZWFkIGFsc28gdG8gc29tZSBpc3N1ZXMgOiBodHRwOi8vc2VjbGlzdHMub3JnL2Z1bGxkaXNjbG9zdXJlLzIwMDkvU2VwLzM5NFxuICAgICAgICB0aGlzLmZpbGVOYW1lTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIGxvY2FsRXh0cmFGaWVsZHNMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTsgLy8gY2FuJ3QgYmUgc3VyZSB0aGlzIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIGNlbnRyYWwgZGlyXG4gICAgICAgIC8vIHRoZSBmaWxlTmFtZSBpcyBzdG9yZWQgYXMgYmluYXJ5IGRhdGEsIHRoZSBoYW5kbGVVVEY4IG1ldGhvZCB3aWxsIHRha2UgY2FyZSBvZiB0aGUgZW5jb2RpbmcuXG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSByZWFkZXIucmVhZERhdGEodGhpcy5maWxlTmFtZUxlbmd0aCk7XG4gICAgICAgIHJlYWRlci5za2lwKGxvY2FsRXh0cmFGaWVsZHNMZW5ndGgpO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbXByZXNzZWRTaXplID09PSAtMSB8fCB0aGlzLnVuY29tcHJlc3NlZFNpemUgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWcgb3IgY29ycnVwdGVkIHppcCA6IGRpZG4ndCBnZXQgZW5vdWdoIGluZm9ybWF0aW9ucyBmcm9tIHRoZSBjZW50cmFsIGRpcmVjdG9yeSBcIiArIFwiKGNvbXByZXNzZWRTaXplID09PSAtMSB8fCB1bmNvbXByZXNzZWRTaXplID09PSAtMSlcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wcmVzc2lvbiA9IGZpbmRDb21wcmVzc2lvbih0aGlzLmNvbXByZXNzaW9uTWV0aG9kKTtcbiAgICAgICAgaWYgKGNvbXByZXNzaW9uID09PSBudWxsKSB7IC8vIG5vIGNvbXByZXNzaW9uIGZvdW5kXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIDogY29tcHJlc3Npb24gXCIgKyB1dGlscy5wcmV0dHkodGhpcy5jb21wcmVzc2lvbk1ldGhvZCkgKyBcIiB1bmtub3duIChpbm5lciBmaWxlIDogXCIgKyB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB0aGlzLmZpbGVOYW1lKSArIFwiKVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlY29tcHJlc3NlZCA9IG5ldyBDb21wcmVzc2VkT2JqZWN0KHRoaXMuY29tcHJlc3NlZFNpemUsIHRoaXMudW5jb21wcmVzc2VkU2l6ZSwgdGhpcy5jcmMzMiwgY29tcHJlc3Npb24sIHJlYWRlci5yZWFkRGF0YSh0aGlzLmNvbXByZXNzZWRTaXplKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGNlbnRyYWwgcGFydCBvZiBhIHppcCBmaWxlIGFuZCBhZGQgdGhlIGluZm8gaW4gdGhpcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXIgdGhlIHJlYWRlciB0byB1c2UuXG4gICAgICovXG4gICAgcmVhZENlbnRyYWxQYXJ0OiBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uTWFkZUJ5ID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHJlYWRlci5za2lwKDIpO1xuICAgICAgICAvLyB0aGlzLnZlcnNpb25OZWVkZWQgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5iaXRGbGFnID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb25NZXRob2QgPSByZWFkZXIucmVhZFN0cmluZygyKTtcbiAgICAgICAgdGhpcy5kYXRlID0gcmVhZGVyLnJlYWREYXRlKCk7XG4gICAgICAgIHRoaXMuY3JjMzIgPSByZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5jb21wcmVzc2VkU2l6ZSA9IHJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLnVuY29tcHJlc3NlZFNpemUgPSByZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdmFyIGZpbGVOYW1lTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZXh0cmFGaWVsZHNMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5maWxlQ29tbWVudExlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmRpc2tOdW1iZXJTdGFydCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmludGVybmFsRmlsZUF0dHJpYnV0ZXMgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzID0gcmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMubG9jYWxIZWFkZXJPZmZzZXQgPSByZWFkZXIucmVhZEludCg0KTtcblxuICAgICAgICBpZiAodGhpcy5pc0VuY3J5cHRlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmNyeXB0ZWQgemlwIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2lsbCBiZSByZWFkIGluIHRoZSBsb2NhbCBwYXJ0LCBzZWUgdGhlIGNvbW1lbnRzIHRoZXJlXG4gICAgICAgIHJlYWRlci5za2lwKGZpbGVOYW1lTGVuZ3RoKTtcbiAgICAgICAgdGhpcy5yZWFkRXh0cmFGaWVsZHMocmVhZGVyKTtcbiAgICAgICAgdGhpcy5wYXJzZVpJUDY0RXh0cmFGaWVsZChyZWFkZXIpO1xuICAgICAgICB0aGlzLmZpbGVDb21tZW50ID0gcmVhZGVyLnJlYWREYXRhKHRoaXMuZmlsZUNvbW1lbnRMZW5ndGgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aGUgZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzIGFuZCBnZXQgdGhlIHVuaXgvZG9zIHBlcm1pc3Npb25zLlxuICAgICAqL1xuICAgIHByb2Nlc3NBdHRyaWJ1dGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudW5peFBlcm1pc3Npb25zID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb3NQZXJtaXNzaW9ucyA9IG51bGw7XG4gICAgICAgIHZhciBtYWRlQnkgPSB0aGlzLnZlcnNpb25NYWRlQnkgPj4gODtcblxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHRoZSBET1MgZGlyZWN0b3J5IGZsYWcgc2V0LlxuICAgICAgICAvLyBXZSBsb29rIGZvciBpdCBpbiB0aGUgRE9TIGFuZCBVTklYIHBlcm1pc3Npb25zXG4gICAgICAgIC8vIGJ1dCBzb21lIHVua25vd24gcGxhdGZvcm0gY291bGQgc2V0IGl0IGFzIGEgY29tcGF0aWJpbGl0eSBmbGFnLlxuICAgICAgICB0aGlzLmRpciA9IHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyAmIDB4MDAxMCA/IHRydWUgOiBmYWxzZTtcblxuICAgICAgICBpZihtYWRlQnkgPT09IE1BREVfQllfRE9TKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCA2IGJpdHMgKDAgdG8gNSlcbiAgICAgICAgICAgIHRoaXMuZG9zUGVybWlzc2lvbnMgPSB0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgJiAweDNGO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYobWFkZUJ5ID09PSBNQURFX0JZX1VOSVgpIHtcbiAgICAgICAgICAgIHRoaXMudW5peFBlcm1pc3Npb25zID0gKHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyA+PiAxNikgJiAweEZGRkY7XG4gICAgICAgICAgICAvLyB0aGUgb2N0YWwgcGVybWlzc2lvbnMgYXJlIGluICh0aGlzLnVuaXhQZXJtaXNzaW9ucyAmIDB4MDFGRikudG9TdHJpbmcoOCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmYWlsIHNhZmUgOiBpZiB0aGUgbmFtZSBlbmRzIHdpdGggYSAvIGl0IHByb2JhYmx5IG1lYW5zIGEgZm9sZGVyXG4gICAgICAgIGlmICghdGhpcy5kaXIgJiYgdGhpcy5maWxlTmFtZVN0ci5zbGljZSgtMSkgPT09ICcvJykge1xuICAgICAgICAgICAgdGhpcy5kaXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBaSVA2NCBleHRyYSBmaWVsZCBhbmQgbWVyZ2UgdGhlIGluZm8gaW4gdGhlIGN1cnJlbnQgWmlwRW50cnkuXG4gICAgICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXIgdGhlIHJlYWRlciB0byB1c2UuXG4gICAgICovXG4gICAgcGFyc2VaSVA2NEV4dHJhRmllbGQ6IGZ1bmN0aW9uKHJlYWRlcikge1xuXG4gICAgICAgIGlmICghdGhpcy5leHRyYUZpZWxkc1sweDAwMDFdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaG91bGQgYmUgc29tZXRoaW5nLCBwcmVwYXJpbmcgdGhlIGV4dHJhIHJlYWRlclxuICAgICAgICB2YXIgZXh0cmFSZWFkZXIgPSByZWFkZXJGb3IodGhpcy5leHRyYUZpZWxkc1sweDAwMDFdLnZhbHVlKTtcblxuICAgICAgICAvLyBJIHJlYWxseSBob3BlIHRoYXQgdGhlc2UgNjRiaXRzIGludGVnZXIgY2FuIGZpdCBpbiAzMiBiaXRzIGludGVnZXIsIGJlY2F1c2UganNcbiAgICAgICAgLy8gd29uJ3QgbGV0IHVzIGhhdmUgbW9yZS5cbiAgICAgICAgaWYgKHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy51bmNvbXByZXNzZWRTaXplID0gZXh0cmFSZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb21wcmVzc2VkU2l6ZSA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy5jb21wcmVzc2VkU2l6ZSA9IGV4dHJhUmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubG9jYWxIZWFkZXJPZmZzZXQgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxIZWFkZXJPZmZzZXQgPSBleHRyYVJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRpc2tOdW1iZXJTdGFydCA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy5kaXNrTnVtYmVyU3RhcnQgPSBleHRyYVJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBjZW50cmFsIHBhcnQgb2YgYSB6aXAgZmlsZSBhbmQgYWRkIHRoZSBpbmZvIGluIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyIHRoZSByZWFkZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIHJlYWRFeHRyYUZpZWxkczogZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICAgIHZhciBlbmQgPSByZWFkZXIuaW5kZXggKyB0aGlzLmV4dHJhRmllbGRzTGVuZ3RoLFxuICAgICAgICAgICAgZXh0cmFGaWVsZElkLFxuICAgICAgICAgICAgZXh0cmFGaWVsZExlbmd0aCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRWYWx1ZTtcblxuICAgICAgICBpZiAoIXRoaXMuZXh0cmFGaWVsZHMpIHtcbiAgICAgICAgICAgIHRoaXMuZXh0cmFGaWVsZHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChyZWFkZXIuaW5kZXggPCBlbmQpIHtcbiAgICAgICAgICAgIGV4dHJhRmllbGRJZCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICAgICAgZXh0cmFGaWVsZExlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICAgICAgZXh0cmFGaWVsZFZhbHVlID0gcmVhZGVyLnJlYWREYXRhKGV4dHJhRmllbGRMZW5ndGgpO1xuXG4gICAgICAgICAgICB0aGlzLmV4dHJhRmllbGRzW2V4dHJhRmllbGRJZF0gPSB7XG4gICAgICAgICAgICAgICAgaWQ6IGV4dHJhRmllbGRJZCxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGV4dHJhRmllbGRMZW5ndGgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGV4dHJhRmllbGRWYWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQXBwbHkgYW4gVVRGOCB0cmFuc2Zvcm1hdGlvbiBpZiBuZWVkZWQuXG4gICAgICovXG4gICAgaGFuZGxlVVRGODogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkZWNvZGVQYXJhbVR5cGUgPSBzdXBwb3J0LnVpbnQ4YXJyYXkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIjtcbiAgICAgICAgaWYgKHRoaXMudXNlVVRGOCgpKSB7XG4gICAgICAgICAgICB0aGlzLmZpbGVOYW1lU3RyID0gdXRmOC51dGY4ZGVjb2RlKHRoaXMuZmlsZU5hbWUpO1xuICAgICAgICAgICAgdGhpcy5maWxlQ29tbWVudFN0ciA9IHV0ZjgudXRmOGRlY29kZSh0aGlzLmZpbGVDb21tZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB1cGF0aCA9IHRoaXMuZmluZEV4dHJhRmllbGRVbmljb2RlUGF0aCgpO1xuICAgICAgICAgICAgaWYgKHVwYXRoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlTmFtZVN0ciA9IHVwYXRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBU0NJSSB0ZXh0IG9yIHVuc3VwcG9ydGVkIGNvZGUgcGFnZVxuICAgICAgICAgICAgICAgIHZhciBmaWxlTmFtZUJ5dGVBcnJheSA9ICB1dGlscy50cmFuc2Zvcm1UbyhkZWNvZGVQYXJhbVR5cGUsIHRoaXMuZmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZU5hbWVTdHIgPSB0aGlzLmxvYWRPcHRpb25zLmRlY29kZUZpbGVOYW1lKGZpbGVOYW1lQnl0ZUFycmF5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHVjb21tZW50ID0gdGhpcy5maW5kRXh0cmFGaWVsZFVuaWNvZGVDb21tZW50KCk7XG4gICAgICAgICAgICBpZiAodWNvbW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVDb21tZW50U3RyID0gdWNvbW1lbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFTQ0lJIHRleHQgb3IgdW5zdXBwb3J0ZWQgY29kZSBwYWdlXG4gICAgICAgICAgICAgICAgdmFyIGNvbW1lbnRCeXRlQXJyYXkgPSAgdXRpbHMudHJhbnNmb3JtVG8oZGVjb2RlUGFyYW1UeXBlLCB0aGlzLmZpbGVDb21tZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVDb21tZW50U3RyID0gdGhpcy5sb2FkT3B0aW9ucy5kZWNvZGVGaWxlTmFtZShjb21tZW50Qnl0ZUFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSB1bmljb2RlIHBhdGggZGVjbGFyZWQgaW4gdGhlIGV4dHJhIGZpZWxkLCBpZiBhbnkuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgdW5pY29kZSBwYXRoLCBudWxsIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBmaW5kRXh0cmFGaWVsZFVuaWNvZGVQYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHVwYXRoRmllbGQgPSB0aGlzLmV4dHJhRmllbGRzWzB4NzA3NV07XG4gICAgICAgIGlmICh1cGF0aEZpZWxkKSB7XG4gICAgICAgICAgICB2YXIgZXh0cmFSZWFkZXIgPSByZWFkZXJGb3IodXBhdGhGaWVsZC52YWx1ZSk7XG5cbiAgICAgICAgICAgIC8vIHdyb25nIHZlcnNpb25cbiAgICAgICAgICAgIGlmIChleHRyYVJlYWRlci5yZWFkSW50KDEpICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRoZSBjcmMgb2YgdGhlIGZpbGVuYW1lIGNoYW5nZWQsIHRoaXMgZmllbGQgaXMgb3V0IG9mIGRhdGUuXG4gICAgICAgICAgICBpZiAoY3JjMzJmbih0aGlzLmZpbGVOYW1lKSAhPT0gZXh0cmFSZWFkZXIucmVhZEludCg0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdXRmOC51dGY4ZGVjb2RlKGV4dHJhUmVhZGVyLnJlYWREYXRhKHVwYXRoRmllbGQubGVuZ3RoIC0gNSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSB1bmljb2RlIGNvbW1lbnQgZGVjbGFyZWQgaW4gdGhlIGV4dHJhIGZpZWxkLCBpZiBhbnkuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgdW5pY29kZSBjb21tZW50LCBudWxsIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBmaW5kRXh0cmFGaWVsZFVuaWNvZGVDb21tZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHVjb21tZW50RmllbGQgPSB0aGlzLmV4dHJhRmllbGRzWzB4NjM3NV07XG4gICAgICAgIGlmICh1Y29tbWVudEZpZWxkKSB7XG4gICAgICAgICAgICB2YXIgZXh0cmFSZWFkZXIgPSByZWFkZXJGb3IodWNvbW1lbnRGaWVsZC52YWx1ZSk7XG5cbiAgICAgICAgICAgIC8vIHdyb25nIHZlcnNpb25cbiAgICAgICAgICAgIGlmIChleHRyYVJlYWRlci5yZWFkSW50KDEpICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRoZSBjcmMgb2YgdGhlIGNvbW1lbnQgY2hhbmdlZCwgdGhpcyBmaWVsZCBpcyBvdXQgb2YgZGF0ZS5cbiAgICAgICAgICAgIGlmIChjcmMzMmZuKHRoaXMuZmlsZUNvbW1lbnQpICE9PSBleHRyYVJlYWRlci5yZWFkSW50KDQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB1dGY4LnV0ZjhkZWNvZGUoZXh0cmFSZWFkZXIucmVhZERhdGEodWNvbW1lbnRGaWVsZC5sZW5ndGggLSA1KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gWmlwRW50cnk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgVWludDhBcnJheVJlYWRlciA9IHJlcXVpcmUoJy4vVWludDhBcnJheVJlYWRlcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gTm9kZUJ1ZmZlclJlYWRlcihkYXRhKSB7XG4gICAgVWludDhBcnJheVJlYWRlci5jYWxsKHRoaXMsIGRhdGEpO1xufVxudXRpbHMuaW5oZXJpdHMoTm9kZUJ1ZmZlclJlYWRlciwgVWludDhBcnJheVJlYWRlcik7XG5cbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLnJlYWREYXRhXG4gKi9cbk5vZGVCdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWREYXRhID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHRoaXMuY2hlY2tPZmZzZXQoc2l6ZSk7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBOb2RlQnVmZmVyUmVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERhdGFSZWFkZXIgPSByZXF1aXJlKCcuL0RhdGFSZWFkZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIFN0cmluZ1JlYWRlcihkYXRhKSB7XG4gICAgRGF0YVJlYWRlci5jYWxsKHRoaXMsIGRhdGEpO1xufVxudXRpbHMuaW5oZXJpdHMoU3RyaW5nUmVhZGVyLCBEYXRhUmVhZGVyKTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLmJ5dGVBdFxuICovXG5TdHJpbmdSZWFkZXIucHJvdG90eXBlLmJ5dGVBdCA9IGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy56ZXJvICsgaSk7XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmVcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZlNpZ25hdHVyZSA9IGZ1bmN0aW9uKHNpZykge1xuICAgIHJldHVybiB0aGlzLmRhdGEubGFzdEluZGV4T2Yoc2lnKSAtIHRoaXMuemVybztcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmVcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5yZWFkQW5kQ2hlY2tTaWduYXR1cmUgPSBmdW5jdGlvbiAoc2lnKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnJlYWREYXRhKDQpO1xuICAgIHJldHVybiBzaWcgPT09IGRhdGE7XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIucmVhZERhdGFcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgIC8vIHRoaXMgd2lsbCB3b3JrIGJlY2F1c2UgdGhlIGNvbnN0cnVjdG9yIGFwcGxpZWQgdGhlIFwiJiAweGZmXCIgbWFzay5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMuemVybyArIHRoaXMuaW5kZXgsIHRoaXMuemVybyArIHRoaXMuaW5kZXggKyBzaXplKTtcbiAgICB0aGlzLmluZGV4ICs9IHNpemU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFN0cmluZ1JlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciByZWFkZXJGb3IgPSByZXF1aXJlKCcuL3JlYWRlci9yZWFkZXJGb3InKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBzaWcgPSByZXF1aXJlKCcuL3NpZ25hdHVyZScpO1xudmFyIFppcEVudHJ5ID0gcmVxdWlyZSgnLi96aXBFbnRyeScpO1xudmFyIHV0ZjggPSByZXF1aXJlKCcuL3V0ZjgnKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZSgnLi9zdXBwb3J0Jyk7XG4vLyAgY2xhc3MgWmlwRW50cmllcyB7e3tcbi8qKlxuICogQWxsIHRoZSBlbnRyaWVzIGluIHRoZSB6aXAgZmlsZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IGxvYWRPcHRpb25zIE9wdGlvbnMgZm9yIGxvYWRpbmcgdGhlIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gWmlwRW50cmllcyhsb2FkT3B0aW9ucykge1xuICAgIHRoaXMuZmlsZXMgPSBbXTtcbiAgICB0aGlzLmxvYWRPcHRpb25zID0gbG9hZE9wdGlvbnM7XG59XG5aaXBFbnRyaWVzLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IHRoZSByZWFkZXIgaXMgb24gdGhlIHNwZWNpZmllZCBzaWduYXR1cmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cGVjdGVkU2lnbmF0dXJlIHRoZSBleHBlY3RlZCBzaWduYXR1cmUuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIGl0IGlzIGFuIG90aGVyIHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBjaGVja1NpZ25hdHVyZTogZnVuY3Rpb24oZXhwZWN0ZWRTaWduYXR1cmUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmUoZXhwZWN0ZWRTaWduYXR1cmUpKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRlci5pbmRleCAtPSA0O1xuICAgICAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHRoaXMucmVhZGVyLnJlYWRTdHJpbmcoNCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIG9yIGJ1ZzogdW5leHBlY3RlZCBzaWduYXR1cmUgXCIgKyBcIihcIiArIHV0aWxzLnByZXR0eShzaWduYXR1cmUpICsgXCIsIGV4cGVjdGVkIFwiICsgdXRpbHMucHJldHR5KGV4cGVjdGVkU2lnbmF0dXJlKSArIFwiKVwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIHNpZ25hdHVyZSBpcyBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFza2VkSW5kZXggdGhlIGluZGV4IHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHBlY3RlZFNpZ25hdHVyZSB0aGUgc2lnbmF0dXJlIHRvIGV4cGVjdC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBzaWduYXR1cmUgaXMgaGVyZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzU2lnbmF0dXJlOiBmdW5jdGlvbihhc2tlZEluZGV4LCBleHBlY3RlZFNpZ25hdHVyZSkge1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gdGhpcy5yZWFkZXIuaW5kZXg7XG4gICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KGFza2VkSW5kZXgpO1xuICAgICAgICB2YXIgc2lnbmF0dXJlID0gdGhpcy5yZWFkZXIucmVhZFN0cmluZyg0KTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHNpZ25hdHVyZSA9PT0gZXhwZWN0ZWRTaWduYXR1cmU7XG4gICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KGN1cnJlbnRJbmRleCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBlbmQgb2YgdGhlIGNlbnRyYWwgZGlyZWN0b3J5LlxuICAgICAqL1xuICAgIHJlYWRCbG9ja0VuZE9mQ2VudHJhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGlza051bWJlciA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZGlza1dpdGhDZW50cmFsRGlyU3RhcnQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzT25UaGlzRGlzayA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclJlY29yZHMgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJTaXplID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyT2Zmc2V0ID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcblxuICAgICAgICB0aGlzLnppcENvbW1lbnRMZW5ndGggPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICAvLyB3YXJuaW5nIDogdGhlIGVuY29kaW5nIGRlcGVuZHMgb2YgdGhlIHN5c3RlbSBsb2NhbGVcbiAgICAgICAgLy8gT24gYSBsaW51eCBtYWNoaW5lIHdpdGggTEFORz1lbl9VUy51dGY4LCB0aGlzIGZpZWxkIGlzIHV0ZjggZW5jb2RlZC5cbiAgICAgICAgLy8gT24gYSB3aW5kb3dzIG1hY2hpbmUsIHRoaXMgZmllbGQgaXMgZW5jb2RlZCB3aXRoIHRoZSBsb2NhbGl6ZWQgd2luZG93cyBjb2RlIHBhZ2UuXG4gICAgICAgIHZhciB6aXBDb21tZW50ID0gdGhpcy5yZWFkZXIucmVhZERhdGEodGhpcy56aXBDb21tZW50TGVuZ3RoKTtcbiAgICAgICAgdmFyIGRlY29kZVBhcmFtVHlwZSA9IHN1cHBvcnQudWludDhhcnJheSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiO1xuICAgICAgICAvLyBUbyBnZXQgY29uc2lzdGVudCBiZWhhdmlvciB3aXRoIHRoZSBnZW5lcmF0aW9uIHBhcnQsIHdlIHdpbGwgYXNzdW1lIHRoYXRcbiAgICAgICAgLy8gdGhpcyBpcyB1dGY4IGVuY29kZWQgdW5sZXNzIHNwZWNpZmllZCBvdGhlcndpc2UuXG4gICAgICAgIHZhciBkZWNvZGVDb250ZW50ID0gdXRpbHMudHJhbnNmb3JtVG8oZGVjb2RlUGFyYW1UeXBlLCB6aXBDb21tZW50KTtcbiAgICAgICAgdGhpcy56aXBDb21tZW50ID0gdGhpcy5sb2FkT3B0aW9ucy5kZWNvZGVGaWxlTmFtZShkZWNvZGVDb250ZW50KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGVuZCBvZiB0aGUgWmlwIDY0IGNlbnRyYWwgZGlyZWN0b3J5LlxuICAgICAqIE5vdCBtZXJnZWQgd2l0aCB0aGUgbWV0aG9kIHJlYWRFbmRPZkNlbnRyYWwgOlxuICAgICAqIFRoZSBlbmQgb2YgY2VudHJhbCBjYW4gY29leGlzdCB3aXRoIGl0cyBaaXA2NCBicm90aGVyLFxuICAgICAqIEkgZG9uJ3Qgd2FudCB0byByZWFkIHRoZSB3cm9uZyBudW1iZXIgb2YgYnl0ZXMgIVxuICAgICAqL1xuICAgIHJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy56aXA2NEVuZE9mQ2VudHJhbFNpemUgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB0aGlzLnJlYWRlci5za2lwKDQpO1xuICAgICAgICAvLyB0aGlzLnZlcnNpb25NYWRlQnkgPSB0aGlzLnJlYWRlci5yZWFkU3RyaW5nKDIpO1xuICAgICAgICAvLyB0aGlzLnZlcnNpb25OZWVkZWQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmRpc2tOdW1iZXIgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLmRpc2tXaXRoQ2VudHJhbERpclN0YXJ0ID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyUmVjb3Jkc09uVGhpc0Rpc2sgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyU2l6ZSA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpck9mZnNldCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG5cbiAgICAgICAgdGhpcy56aXA2NEV4dGVuc2libGVEYXRhID0ge307XG4gICAgICAgIHZhciBleHRyYURhdGFTaXplID0gdGhpcy56aXA2NEVuZE9mQ2VudHJhbFNpemUgLSA0NCxcbiAgICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRJZCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRMZW5ndGgsXG4gICAgICAgICAgICBleHRyYUZpZWxkVmFsdWU7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGV4dHJhRGF0YVNpemUpIHtcbiAgICAgICAgICAgIGV4dHJhRmllbGRJZCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgICAgICBleHRyYUZpZWxkTGVuZ3RoID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgICAgIGV4dHJhRmllbGRWYWx1ZSA9IHRoaXMucmVhZGVyLnJlYWREYXRhKGV4dHJhRmllbGRMZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy56aXA2NEV4dGVuc2libGVEYXRhW2V4dHJhRmllbGRJZF0gPSB7XG4gICAgICAgICAgICAgICAgaWQ6IGV4dHJhRmllbGRJZCxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGV4dHJhRmllbGRMZW5ndGgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGV4dHJhRmllbGRWYWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgZW5kIG9mIHRoZSBaaXAgNjQgY2VudHJhbCBkaXJlY3RvcnkgbG9jYXRvci5cbiAgICAgKi9cbiAgICByZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbExvY2F0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRpc2tXaXRoWmlwNjRDZW50cmFsRGlyU3RhcnQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB0aGlzLmRpc2tzQ291bnQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICBpZiAodGhpcy5kaXNrc0NvdW50ID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVsdGktdm9sdW1lcyB6aXAgYXJlIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGxvY2FsIGZpbGVzLCBiYXNlZCBvbiB0aGUgb2Zmc2V0IHJlYWQgaW4gdGhlIGNlbnRyYWwgcGFydC5cbiAgICAgKi9cbiAgICByZWFkTG9jYWxGaWxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpLCBmaWxlO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5maWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZmlsZSA9IHRoaXMuZmlsZXNbaV07XG4gICAgICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChmaWxlLmxvY2FsSGVhZGVyT2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tTaWduYXR1cmUoc2lnLkxPQ0FMX0ZJTEVfSEVBREVSKTtcbiAgICAgICAgICAgIGZpbGUucmVhZExvY2FsUGFydCh0aGlzLnJlYWRlcik7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZVVURjgoKTtcbiAgICAgICAgICAgIGZpbGUucHJvY2Vzc0F0dHJpYnV0ZXMoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgY2VudHJhbCBkaXJlY3RvcnkuXG4gICAgICovXG4gICAgcmVhZENlbnRyYWxEaXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZmlsZTtcblxuICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleCh0aGlzLmNlbnRyYWxEaXJPZmZzZXQpO1xuICAgICAgICB3aGlsZSAodGhpcy5yZWFkZXIucmVhZEFuZENoZWNrU2lnbmF0dXJlKHNpZy5DRU5UUkFMX0ZJTEVfSEVBREVSKSkge1xuICAgICAgICAgICAgZmlsZSA9IG5ldyBaaXBFbnRyeSh7XG4gICAgICAgICAgICAgICAgemlwNjQ6IHRoaXMuemlwNjRcbiAgICAgICAgICAgIH0sIHRoaXMubG9hZE9wdGlvbnMpO1xuICAgICAgICAgICAgZmlsZS5yZWFkQ2VudHJhbFBhcnQodGhpcy5yZWFkZXIpO1xuICAgICAgICAgICAgdGhpcy5maWxlcy5wdXNoKGZpbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY2VudHJhbERpclJlY29yZHMgIT09IHRoaXMuZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jZW50cmFsRGlyUmVjb3JkcyAhPT0gMCAmJiB0aGlzLmZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGV4cGVjdGVkIHNvbWUgcmVjb3JkcyBidXQgY291bGRuJ3QgZmluZCBBTlkuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyByZWFsbHkgc3VzcGljaW91cywgYXMgaWYgc29tZXRoaW5nIHdlbnQgd3JvbmcuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcCBvciBidWc6IGV4cGVjdGVkIFwiICsgdGhpcy5jZW50cmFsRGlyUmVjb3JkcyArIFwiIHJlY29yZHMgaW4gY2VudHJhbCBkaXIsIGdvdCBcIiArIHRoaXMuZmlsZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZm91bmQgc29tZSByZWNvcmRzIGJ1dCBub3QgYWxsLlxuICAgICAgICAgICAgICAgIC8vIFNvbWV0aGluZyBpcyB3cm9uZyBidXQgd2UgZ290IHNvbWV0aGluZyBmb3IgdGhlIHVzZXI6IG5vIGVycm9yIGhlcmUuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKFwiZXhwZWN0ZWRcIiwgdGhpcy5jZW50cmFsRGlyUmVjb3JkcywgXCJyZWNvcmRzIGluIGNlbnRyYWwgZGlyLCBnb3RcIiwgdGhpcy5maWxlcy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkuXG4gICAgICovXG4gICAgcmVhZEVuZE9mQ2VudHJhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZShzaWcuQ0VOVFJBTF9ESVJFQ1RPUllfRU5EKTtcbiAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250ZW50IGlzIGEgdHJ1bmNhdGVkIHppcCBvciBjb21wbGV0ZSBnYXJiYWdlLlxuICAgICAgICAgICAgLy8gQSBcIkxPQ0FMX0ZJTEVfSEVBREVSXCIgaXMgbm90IHJlcXVpcmVkIGF0IHRoZSBiZWdpbm5pbmcgKGF1dG9cbiAgICAgICAgICAgIC8vIGV4dHJhY3RpYmxlIHppcCBmb3IgZXhhbXBsZSkgYnV0IGl0IGNhbiBnaXZlIGEgZ29vZCBoaW50LlxuICAgICAgICAgICAgLy8gSWYgYW4gYWpheCByZXF1ZXN0IHdhcyB1c2VkIHdpdGhvdXQgcmVzcG9uc2VUeXBlLCB3ZSB3aWxsIGFsc29cbiAgICAgICAgICAgIC8vIGdldCB1bnJlYWRhYmxlIGRhdGEuXG4gICAgICAgICAgICB2YXIgaXNHYXJiYWdlID0gIXRoaXMuaXNTaWduYXR1cmUoMCwgc2lnLkxPQ0FMX0ZJTEVfSEVBREVSKTtcblxuICAgICAgICAgICAgaWYgKGlzR2FyYmFnZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGZpbmQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IDogaXMgdGhpcyBhIHppcCBmaWxlID8gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIklmIGl0IGlzLCBzZWUgaHR0cHM6Ly9zdHVrLmdpdGh1Yi5pby9qc3ppcC9kb2N1bWVudGF0aW9uL2hvd3RvL3JlYWRfemlwLmh0bWxcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXA6IGNhbid0IGZpbmQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgob2Zmc2V0KTtcbiAgICAgICAgdmFyIGVuZE9mQ2VudHJhbERpck9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5jaGVja1NpZ25hdHVyZShzaWcuQ0VOVFJBTF9ESVJFQ1RPUllfRU5EKTtcbiAgICAgICAgdGhpcy5yZWFkQmxvY2tFbmRPZkNlbnRyYWwoKTtcblxuXG4gICAgICAgIC8qIGV4dHJhY3QgZnJvbSB0aGUgemlwIHNwZWMgOlxuICAgICAgICAgICAgNCkgIElmIG9uZSBvZiB0aGUgZmllbGRzIGluIHRoZSBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnlcbiAgICAgICAgICAgICAgICByZWNvcmQgaXMgdG9vIHNtYWxsIHRvIGhvbGQgcmVxdWlyZWQgZGF0YSwgdGhlIGZpZWxkXG4gICAgICAgICAgICAgICAgc2hvdWxkIGJlIHNldCB0byAtMSAoMHhGRkZGIG9yIDB4RkZGRkZGRkYpIGFuZCB0aGVcbiAgICAgICAgICAgICAgICBaSVA2NCBmb3JtYXQgcmVjb3JkIHNob3VsZCBiZSBjcmVhdGVkLlxuICAgICAgICAgICAgNSkgIFRoZSBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgcmVjb3JkIGFuZCB0aGVcbiAgICAgICAgICAgICAgICBaaXA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgbG9jYXRvciByZWNvcmQgbXVzdFxuICAgICAgICAgICAgICAgIHJlc2lkZSBvbiB0aGUgc2FtZSBkaXNrIHdoZW4gc3BsaXR0aW5nIG9yIHNwYW5uaW5nXG4gICAgICAgICAgICAgICAgYW4gYXJjaGl2ZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLmRpc2tOdW1iZXIgPT09IHV0aWxzLk1BWF9WQUxVRV8xNkJJVFMgfHwgdGhpcy5kaXNrV2l0aENlbnRyYWxEaXJTdGFydCA9PT0gdXRpbHMuTUFYX1ZBTFVFXzE2QklUUyB8fCB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzT25UaGlzRGlzayA9PT0gdXRpbHMuTUFYX1ZBTFVFXzE2QklUUyB8fCB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzID09PSB1dGlscy5NQVhfVkFMVUVfMTZCSVRTIHx8IHRoaXMuY2VudHJhbERpclNpemUgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMgfHwgdGhpcy5jZW50cmFsRGlyT2Zmc2V0ID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICB0aGlzLnppcDY0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIFdhcm5pbmcgOiB0aGUgemlwNjQgZXh0ZW5zaW9uIGlzIHN1cHBvcnRlZCwgYnV0IE9OTFkgaWYgdGhlIDY0Yml0cyBpbnRlZ2VyIHJlYWQgZnJvbVxuICAgICAgICAgICAgdGhlIHppcCBmaWxlIGNhbiBmaXQgaW50byBhIDMyYml0cyBpbnRlZ2VyLiBUaGlzIGNhbm5vdCBiZSBzb2x2ZWQgOiBKYXZhU2NyaXB0IHJlcHJlc2VudHNcbiAgICAgICAgICAgIGFsbCBudW1iZXJzIGFzIDY0LWJpdCBkb3VibGUgcHJlY2lzaW9uIElFRUUgNzU0IGZsb2F0aW5nIHBvaW50IG51bWJlcnMuXG4gICAgICAgICAgICBTbywgd2UgaGF2ZSA1M2JpdHMgZm9yIGludGVnZXJzIGFuZCBiaXR3aXNlIG9wZXJhdGlvbnMgdHJlYXQgZXZlcnl0aGluZyBhcyAzMmJpdHMuXG4gICAgICAgICAgICBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvQml0d2lzZV9PcGVyYXRvcnNcbiAgICAgICAgICAgIGFuZCBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvcHVibGljYXRpb25zL2ZpbGVzL0VDTUEtU1QvRUNNQS0yNjIucGRmIHNlY3Rpb24gOC41XG4gICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAvLyBzaG91bGQgbG9vayBmb3IgYSB6aXA2NCBFT0NEIGxvY2F0b3JcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMucmVhZGVyLmxhc3RJbmRleE9mU2lnbmF0dXJlKHNpZy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9MT0NBVE9SKTtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcDogY2FuJ3QgZmluZCB0aGUgWklQNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IGxvY2F0b3JcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChvZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5jaGVja1NpZ25hdHVyZShzaWcuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUik7XG4gICAgICAgICAgICB0aGlzLnJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsTG9jYXRvcigpO1xuXG4gICAgICAgICAgICAvLyBub3cgdGhlIHppcDY0IEVPQ0QgcmVjb3JkXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNTaWduYXR1cmUodGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyLCBzaWcuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfRU5EKSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihcIlpJUDY0IGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSBub3Qgd2hlcmUgZXhwZWN0ZWQuXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciA9IHRoaXMucmVhZGVyLmxhc3RJbmRleE9mU2lnbmF0dXJlKHNpZy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXA6IGNhbid0IGZpbmQgdGhlIFpJUDY0IGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleCh0aGlzLnJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIpO1xuICAgICAgICAgICAgdGhpcy5jaGVja1NpZ25hdHVyZShzaWcuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfRU5EKTtcbiAgICAgICAgICAgIHRoaXMucmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleHBlY3RlZEVuZE9mQ2VudHJhbERpck9mZnNldCA9IHRoaXMuY2VudHJhbERpck9mZnNldCArIHRoaXMuY2VudHJhbERpclNpemU7XG4gICAgICAgIGlmICh0aGlzLnppcDY0KSB7XG4gICAgICAgICAgICBleHBlY3RlZEVuZE9mQ2VudHJhbERpck9mZnNldCArPSAyMDsgLy8gZW5kIG9mIGNlbnRyYWwgZGlyIDY0IGxvY2F0b3JcbiAgICAgICAgICAgIGV4cGVjdGVkRW5kT2ZDZW50cmFsRGlyT2Zmc2V0ICs9IDEyIC8qIHNob3VsZCBub3QgaW5jbHVkZSB0aGUgbGVhZGluZyAxMiBieXRlcyAqLyArIHRoaXMuemlwNjRFbmRPZkNlbnRyYWxTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV4dHJhQnl0ZXMgPSBlbmRPZkNlbnRyYWxEaXJPZmZzZXQgLSBleHBlY3RlZEVuZE9mQ2VudHJhbERpck9mZnNldDtcblxuICAgICAgICBpZiAoZXh0cmFCeXRlcyA+IDApIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihleHRyYUJ5dGVzLCBcImV4dHJhIGJ5dGVzIGF0IGJlZ2lubmluZyBvciB3aXRoaW4gemlwZmlsZVwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU2lnbmF0dXJlKGVuZE9mQ2VudHJhbERpck9mZnNldCwgc2lnLkNFTlRSQUxfRklMRV9IRUFERVIpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIG9mZnNldHMgc2VlbSB3cm9uZywgYnV0IHdlIGhhdmUgc29tZXRoaW5nIGF0IHRoZSBzcGVjaWZpZWQgb2Zmc2V0LlxuICAgICAgICAgICAgICAgIC8vIFNv4oCmIHdlIGtlZXAgaXQuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRoZSBvZmZzZXQgaXMgd3JvbmcsIHVwZGF0ZSB0aGUgXCJ6ZXJvXCIgb2YgdGhlIHJlYWRlclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaGFwcGVucyBpZiBkYXRhIGhhcyBiZWVuIHByZXBlbmRlZCAoY3J4IGZpbGVzIGZvciBleGFtcGxlKVxuICAgICAgICAgICAgICAgIHRoaXMucmVhZGVyLnplcm8gPSBleHRyYUJ5dGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwOiBtaXNzaW5nIFwiICsgTWF0aC5hYnMoZXh0cmFCeXRlcykgKyBcIiBieXRlcy5cIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHByZXBhcmVSZWFkZXI6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy5yZWFkZXIgPSByZWFkZXJGb3IoZGF0YSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIGEgemlwIGZpbGUgYW5kIGNyZWF0ZSBaaXBFbnRyaWVzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhIHRoZSBiaW5hcnkgc3RyaW5nIHJlcHJlc2VudGluZyBhIHppcCBmaWxlLlxuICAgICAqL1xuICAgIGxvYWQ6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy5wcmVwYXJlUmVhZGVyKGRhdGEpO1xuICAgICAgICB0aGlzLnJlYWRFbmRPZkNlbnRyYWwoKTtcbiAgICAgICAgdGhpcy5yZWFkQ2VudHJhbERpcigpO1xuICAgICAgICB0aGlzLnJlYWRMb2NhbEZpbGVzKCk7XG4gICAgfVxufTtcbi8vIH19fSBlbmQgb2YgWmlwRW50cmllc1xubW9kdWxlLmV4cG9ydHMgPSBaaXBFbnRyaWVzO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGV4dGVybmFsID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxcIik7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIFppcEVudHJpZXMgPSByZXF1aXJlKCcuL3ppcEVudHJpZXMnKTtcbnZhciBDcmMzMlByb2JlID0gcmVxdWlyZSgnLi9zdHJlYW0vQ3JjMzJQcm9iZScpO1xudmFyIG5vZGVqc1V0aWxzID0gcmVxdWlyZShcIi4vbm9kZWpzVXRpbHNcIik7XG5cbi8qKlxuICogQ2hlY2sgdGhlIENSQzMyIG9mIGFuIGVudHJ5LlxuICogQHBhcmFtIHtaaXBFbnRyeX0gemlwRW50cnkgdGhlIHppcCBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm4ge1Byb21pc2V9IHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrRW50cnlDUkMzMih6aXBFbnRyeSkge1xuICAgIHJldHVybiBuZXcgZXh0ZXJuYWwuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciB3b3JrZXIgPSB6aXBFbnRyeS5kZWNvbXByZXNzZWQuZ2V0Q29udGVudFdvcmtlcigpLnBpcGUobmV3IENyYzMyUHJvYmUoKSk7XG4gICAgICAgIHdvcmtlci5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAod29ya2VyLnN0cmVhbUluZm8uY3JjMzIgIT09IHppcEVudHJ5LmRlY29tcHJlc3NlZC5jcmMzMikge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIDogQ1JDMzIgbWlzbWF0Y2hcIikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN1bWUoKTtcbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkYXRhLCBvcHRpb25zKSB7XG4gICAgdmFyIHppcCA9IHRoaXM7XG4gICAgb3B0aW9ucyA9IHV0aWxzLmV4dGVuZChvcHRpb25zIHx8IHt9LCB7XG4gICAgICAgIGJhc2U2NDogZmFsc2UsXG4gICAgICAgIGNoZWNrQ1JDMzI6IGZhbHNlLFxuICAgICAgICBvcHRpbWl6ZWRCaW5hcnlTdHJpbmc6IGZhbHNlLFxuICAgICAgICBjcmVhdGVGb2xkZXJzOiBmYWxzZSxcbiAgICAgICAgZGVjb2RlRmlsZU5hbWU6IHV0ZjgudXRmOGRlY29kZVxuICAgIH0pO1xuXG4gICAgaWYgKG5vZGVqc1V0aWxzLmlzTm9kZSAmJiBub2RlanNVdGlscy5pc1N0cmVhbShkYXRhKSkge1xuICAgICAgICByZXR1cm4gZXh0ZXJuYWwuUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSlNaaXAgY2FuJ3QgYWNjZXB0IGEgc3RyZWFtIHdoZW4gbG9hZGluZyBhIHppcCBmaWxlLlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWxzLnByZXBhcmVDb250ZW50KFwidGhlIGxvYWRlZCB6aXAgZmlsZVwiLCBkYXRhLCB0cnVlLCBvcHRpb25zLm9wdGltaXplZEJpbmFyeVN0cmluZywgb3B0aW9ucy5iYXNlNjQpXG4gICAgLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgemlwRW50cmllcyA9IG5ldyBaaXBFbnRyaWVzKG9wdGlvbnMpO1xuICAgICAgICB6aXBFbnRyaWVzLmxvYWQoZGF0YSk7XG4gICAgICAgIHJldHVybiB6aXBFbnRyaWVzO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gY2hlY2tDUkMzMih6aXBFbnRyaWVzKSB7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtleHRlcm5hbC5Qcm9taXNlLnJlc29sdmUoemlwRW50cmllcyldO1xuICAgICAgICB2YXIgZmlsZXMgPSB6aXBFbnRyaWVzLmZpbGVzO1xuICAgICAgICBpZiAob3B0aW9ucy5jaGVja0NSQzMyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChjaGVja0VudHJ5Q1JDMzIoZmlsZXNbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0ZXJuYWwuUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gYWRkRmlsZXMocmVzdWx0cykge1xuICAgICAgICB2YXIgemlwRW50cmllcyA9IHJlc3VsdHMuc2hpZnQoKTtcbiAgICAgICAgdmFyIGZpbGVzID0gemlwRW50cmllcy5maWxlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZmlsZXNbaV07XG4gICAgICAgICAgICB6aXAuZmlsZShpbnB1dC5maWxlTmFtZVN0ciwgaW5wdXQuZGVjb21wcmVzc2VkLCB7XG4gICAgICAgICAgICAgICAgYmluYXJ5OiB0cnVlLFxuICAgICAgICAgICAgICAgIG9wdGltaXplZEJpbmFyeVN0cmluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRlOiBpbnB1dC5kYXRlLFxuICAgICAgICAgICAgICAgIGRpcjogaW5wdXQuZGlyLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQgOiBpbnB1dC5maWxlQ29tbWVudFN0ci5sZW5ndGggPyBpbnB1dC5maWxlQ29tbWVudFN0ciA6IG51bGwsXG4gICAgICAgICAgICAgICAgdW5peFBlcm1pc3Npb25zIDogaW5wdXQudW5peFBlcm1pc3Npb25zLFxuICAgICAgICAgICAgICAgIGRvc1Blcm1pc3Npb25zIDogaW5wdXQuZG9zUGVybWlzc2lvbnMsXG4gICAgICAgICAgICAgICAgY3JlYXRlRm9sZGVyczogb3B0aW9ucy5jcmVhdGVGb2xkZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoemlwRW50cmllcy56aXBDb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgemlwLmNvbW1lbnQgPSB6aXBFbnRyaWVzLnppcENvbW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gemlwO1xuICAgIH0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuLi9zdHJlYW0vR2VuZXJpY1dvcmtlcicpO1xuXG4vKipcbiAqIEEgd29ya2VyIHRoYXQgdXNlIGEgbm9kZWpzIHN0cmVhbSBhcyBzb3VyY2UuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZSBlbnRyeSBmb3IgdGhpcyBzdHJlYW0uXG4gKiBAcGFyYW0ge1JlYWRhYmxlfSBzdHJlYW0gdGhlIG5vZGVqcyBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlcihmaWxlbmFtZSwgc3RyZWFtKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiTm9kZWpzIHN0cmVhbSBpbnB1dCBhZGFwdGVyIGZvciBcIiArIGZpbGVuYW1lKTtcbiAgICB0aGlzLl91cHN0cmVhbUVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYmluZFN0cmVhbShzdHJlYW0pO1xufVxuXG51dGlscy5pbmhlcml0cyhOb2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIFByZXBhcmUgdGhlIHN0cmVhbSBhbmQgYmluZCB0aGUgY2FsbGJhY2tzIG9uIGl0LlxuICogRG8gdGhpcyBBU0FQIG9uIG5vZGUgMC4xMCAhIEEgbGF6eSBiaW5kaW5nIGRvZXNuJ3QgYWx3YXlzIHdvcmsuXG4gKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtIHRoZSBub2RlanMgc3RyZWFtIHRvIHVzZS5cbiAqL1xuTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyLnByb3RvdHlwZS5fYmluZFN0cmVhbSA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIHN0cmVhbVxuICAgIC5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHNlbGYucHVzaCh7XG4gICAgICAgICAgICBkYXRhOiBjaHVuayxcbiAgICAgICAgICAgIG1ldGEgOiB7XG4gICAgICAgICAgICAgICAgcGVyY2VudCA6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAub24oXCJlcnJvclwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZihzZWxmLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlZEVycm9yID0gZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9KVxuICAgIC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmKHNlbGYuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHNlbGYuX3Vwc3RyZWFtRW5kZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5lbmQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbk5vZGVqc1N0cmVhbUlucHV0QWRhcHRlci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoIUdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnBhdXNlLmNhbGwodGhpcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9zdHJlYW0ucGF1c2UoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucmVzdW1lLmNhbGwodGhpcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmKHRoaXMuX3Vwc3RyZWFtRW5kZWQpIHtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi4vc3RyZWFtL0dlbmVyaWNXb3JrZXInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi4vdXRmOCcpO1xudmFyIGNyYzMyID0gcmVxdWlyZSgnLi4vY3JjMzInKTtcbnZhciBzaWduYXR1cmUgPSByZXF1aXJlKCcuLi9zaWduYXR1cmUnKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gaW50ZWdlciBpbnRvIGEgc3RyaW5nIGluIGhleGFkZWNpbWFsLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWMgdGhlIG51bWJlciB0byBjb252ZXJ0LlxuICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVzIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZ2VuZXJhdGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgcmVzdWx0LlxuICovXG52YXIgZGVjVG9IZXggPSBmdW5jdGlvbihkZWMsIGJ5dGVzKSB7XG4gICAgdmFyIGhleCA9IFwiXCIsIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGJ5dGVzOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGVjICYgMHhmZik7XG4gICAgICAgIGRlYyA9IGRlYyA+Pj4gODtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIFVOSVggcGFydCBvZiB0aGUgZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtPYmplY3R9IHVuaXhQZXJtaXNzaW9ucyB0aGUgdW5peCBwZXJtaXNzaW9ucyBvciBudWxsLlxuICogQHBhcmFtIHtCb29sZWFufSBpc0RpciB0cnVlIGlmIHRoZSBlbnRyeSBpcyBhIGRpcmVjdG9yeSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHJldHVybiB7TnVtYmVyfSBhIDMyIGJpdCBpbnRlZ2VyLlxuICpcbiAqIGFkYXB0ZWQgZnJvbSBodHRwOi8vdW5peC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTQ3MDUvdGhlLXppcC1mb3JtYXRzLWV4dGVybmFsLWZpbGUtYXR0cmlidXRlIDpcbiAqXG4gKiBUVFRUc3N0cnd4cnd4cnd4MDAwMDAwMDAwMEFEVlNIUlxuICogXl5eXl9fX19fX19fX19fX19fX19fX19fX19fX19fX18gZmlsZSB0eXBlLCBzZWUgemlwaW5mby5jIChVTlhfKilcbiAqICAgICBeXl5fX19fX19fX19fX19fX19fX19fX19fX19fIHNldHVpZCwgc2V0Z2lkLCBzdGlja3lcbiAqICAgICAgICBeXl5eXl5eXl5fX19fX19fX19fX19fX19fIHBlcm1pc3Npb25zXG4gKiAgICAgICAgICAgICAgICAgXl5eXl5eXl5eXl9fX19fXyBub3QgdXNlZCA/XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIF5eXl5eXiBET1MgYXR0cmlidXRlIGJpdHMgOiBBcmNoaXZlLCBEaXJlY3RvcnksIFZvbHVtZSBsYWJlbCwgU3lzdGVtIGZpbGUsIEhpZGRlbiwgUmVhZCBvbmx5XG4gKi9cbnZhciBnZW5lcmF0ZVVuaXhFeHRlcm5hbEZpbGVBdHRyID0gZnVuY3Rpb24gKHVuaXhQZXJtaXNzaW9ucywgaXNEaXIpIHtcblxuICAgIHZhciByZXN1bHQgPSB1bml4UGVybWlzc2lvbnM7XG4gICAgaWYgKCF1bml4UGVybWlzc2lvbnMpIHtcbiAgICAgICAgLy8gSSBjYW4ndCB1c2Ugb2N0YWwgdmFsdWVzIGluIHN0cmljdCBtb2RlLCBoZW5jZSB0aGUgaGV4YS5cbiAgICAgICAgLy8gIDA0MDc3NSA9PiAweDQxZmRcbiAgICAgICAgLy8gMDEwMDY2NCA9PiAweDgxYjRcbiAgICAgICAgcmVzdWx0ID0gaXNEaXIgPyAweDQxZmQgOiAweDgxYjQ7XG4gICAgfVxuICAgIHJldHVybiAocmVzdWx0ICYgMHhGRkZGKSA8PCAxNjtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIERPUyBwYXJ0IG9mIHRoZSBleHRlcm5hbCBmaWxlIGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gZG9zUGVybWlzc2lvbnMgdGhlIGRvcyBwZXJtaXNzaW9ucyBvciBudWxsLlxuICogQHBhcmFtIHtCb29sZWFufSBpc0RpciB0cnVlIGlmIHRoZSBlbnRyeSBpcyBhIGRpcmVjdG9yeSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHJldHVybiB7TnVtYmVyfSBhIDMyIGJpdCBpbnRlZ2VyLlxuICpcbiAqIEJpdCAwICAgICBSZWFkLU9ubHlcbiAqIEJpdCAxICAgICBIaWRkZW5cbiAqIEJpdCAyICAgICBTeXN0ZW1cbiAqIEJpdCAzICAgICBWb2x1bWUgTGFiZWxcbiAqIEJpdCA0ICAgICBEaXJlY3RvcnlcbiAqIEJpdCA1ICAgICBBcmNoaXZlXG4gKi9cbnZhciBnZW5lcmF0ZURvc0V4dGVybmFsRmlsZUF0dHIgPSBmdW5jdGlvbiAoZG9zUGVybWlzc2lvbnMsIGlzRGlyKSB7XG5cbiAgICAvLyB0aGUgZGlyIGZsYWcgaXMgYWxyZWFkeSBzZXQgZm9yIGNvbXBhdGliaWxpdHlcbiAgICByZXR1cm4gKGRvc1Blcm1pc3Npb25zIHx8IDApICAmIDB4M0Y7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSB2YXJpb3VzIHBhcnRzIHVzZWQgaW4gdGhlIGNvbnN0cnVjdGlvbiBvZiB0aGUgZmluYWwgemlwIGZpbGUuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RyZWFtSW5mbyB0aGUgaGFzaCB3aXRoIGluZm9ybWF0aW9ucyBhYm91dCB0aGUgY29tcHJlc3NlZCBmaWxlLlxuICogQHBhcmFtIHtCb29sZWFufSBzdHJlYW1lZENvbnRlbnQgaXMgdGhlIGNvbnRlbnQgc3RyZWFtZWQgP1xuICogQHBhcmFtIHtCb29sZWFufSBzdHJlYW1pbmdFbmRlZCBpcyB0aGUgc3RyZWFtIGZpbmlzaGVkID9cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgdGhlIGN1cnJlbnQgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGF0Zm9ybSBsZXQncyBwcmV0ZW5kIHdlIGFyZSB0aGlzIHBsYXRmb3JtIChjaGFuZ2UgcGxhdGZvcm0gZGVwZW5kZW50cyBmaWVsZHMpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmNvZGVGaWxlTmFtZSB0aGUgZnVuY3Rpb24gdG8gZW5jb2RlIHRoZSBmaWxlIG5hbWUgLyBjb21tZW50LlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgemlwIHBhcnRzLlxuICovXG52YXIgZ2VuZXJhdGVaaXBQYXJ0cyA9IGZ1bmN0aW9uKHN0cmVhbUluZm8sIHN0cmVhbWVkQ29udGVudCwgc3RyZWFtaW5nRW5kZWQsIG9mZnNldCwgcGxhdGZvcm0sIGVuY29kZUZpbGVOYW1lKSB7XG4gICAgdmFyIGZpbGUgPSBzdHJlYW1JbmZvWydmaWxlJ10sXG4gICAgY29tcHJlc3Npb24gPSBzdHJlYW1JbmZvWydjb21wcmVzc2lvbiddLFxuICAgIHVzZUN1c3RvbUVuY29kaW5nID0gZW5jb2RlRmlsZU5hbWUgIT09IHV0ZjgudXRmOGVuY29kZSxcbiAgICBlbmNvZGVkRmlsZU5hbWUgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCBlbmNvZGVGaWxlTmFtZShmaWxlLm5hbWUpKSxcbiAgICB1dGZFbmNvZGVkRmlsZU5hbWUgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB1dGY4LnV0ZjhlbmNvZGUoZmlsZS5uYW1lKSksXG4gICAgY29tbWVudCA9IGZpbGUuY29tbWVudCxcbiAgICBlbmNvZGVkQ29tbWVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIGVuY29kZUZpbGVOYW1lKGNvbW1lbnQpKSxcbiAgICB1dGZFbmNvZGVkQ29tbWVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIHV0ZjgudXRmOGVuY29kZShjb21tZW50KSksXG4gICAgdXNlVVRGOEZvckZpbGVOYW1lID0gdXRmRW5jb2RlZEZpbGVOYW1lLmxlbmd0aCAhPT0gZmlsZS5uYW1lLmxlbmd0aCxcbiAgICB1c2VVVEY4Rm9yQ29tbWVudCA9IHV0ZkVuY29kZWRDb21tZW50Lmxlbmd0aCAhPT0gY29tbWVudC5sZW5ndGgsXG4gICAgZG9zVGltZSxcbiAgICBkb3NEYXRlLFxuICAgIGV4dHJhRmllbGRzID0gXCJcIixcbiAgICB1bmljb2RlUGF0aEV4dHJhRmllbGQgPSBcIlwiLFxuICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZCA9IFwiXCIsXG4gICAgZGlyID0gZmlsZS5kaXIsXG4gICAgZGF0ZSA9IGZpbGUuZGF0ZTtcblxuXG4gICAgdmFyIGRhdGFJbmZvID0ge1xuICAgICAgICBjcmMzMiA6IDAsXG4gICAgICAgIGNvbXByZXNzZWRTaXplIDogMCxcbiAgICAgICAgdW5jb21wcmVzc2VkU2l6ZSA6IDBcbiAgICB9O1xuXG4gICAgLy8gaWYgdGhlIGNvbnRlbnQgaXMgc3RyZWFtZWQsIHRoZSBzaXplcy9jcmMzMiBhcmUgb25seSBhdmFpbGFibGUgQUZURVJcbiAgICAvLyB0aGUgZW5kIG9mIHRoZSBzdHJlYW0uXG4gICAgaWYgKCFzdHJlYW1lZENvbnRlbnQgfHwgc3RyZWFtaW5nRW5kZWQpIHtcbiAgICAgICAgZGF0YUluZm8uY3JjMzIgPSBzdHJlYW1JbmZvWydjcmMzMiddO1xuICAgICAgICBkYXRhSW5mby5jb21wcmVzc2VkU2l6ZSA9IHN0cmVhbUluZm9bJ2NvbXByZXNzZWRTaXplJ107XG4gICAgICAgIGRhdGFJbmZvLnVuY29tcHJlc3NlZFNpemUgPSBzdHJlYW1JbmZvWyd1bmNvbXByZXNzZWRTaXplJ107XG4gICAgfVxuXG4gICAgdmFyIGJpdGZsYWcgPSAwO1xuICAgIGlmIChzdHJlYW1lZENvbnRlbnQpIHtcbiAgICAgICAgLy8gQml0IDM6IHRoZSBzaXplcy9jcmMzMiBhcmUgc2V0IHRvIHplcm8gaW4gdGhlIGxvY2FsIGhlYWRlci5cbiAgICAgICAgLy8gVGhlIGNvcnJlY3QgdmFsdWVzIGFyZSBwdXQgaW4gdGhlIGRhdGEgZGVzY3JpcHRvciBpbW1lZGlhdGVseVxuICAgICAgICAvLyBmb2xsb3dpbmcgdGhlIGNvbXByZXNzZWQgZGF0YS5cbiAgICAgICAgYml0ZmxhZyB8PSAweDAwMDg7XG4gICAgfVxuICAgIGlmICghdXNlQ3VzdG9tRW5jb2RpbmcgJiYgKHVzZVVURjhGb3JGaWxlTmFtZSB8fCB1c2VVVEY4Rm9yQ29tbWVudCkpIHtcbiAgICAgICAgLy8gQml0IDExOiBMYW5ndWFnZSBlbmNvZGluZyBmbGFnIChFRlMpLlxuICAgICAgICBiaXRmbGFnIHw9IDB4MDgwMDtcbiAgICB9XG5cblxuICAgIHZhciBleHRGaWxlQXR0ciA9IDA7XG4gICAgdmFyIHZlcnNpb25NYWRlQnkgPSAwO1xuICAgIGlmIChkaXIpIHtcbiAgICAgICAgLy8gZG9zIG9yIHVuaXgsIHdlIHNldCB0aGUgZG9zIGRpciBmbGFnXG4gICAgICAgIGV4dEZpbGVBdHRyIHw9IDB4MDAwMTA7XG4gICAgfVxuICAgIGlmKHBsYXRmb3JtID09PSBcIlVOSVhcIikge1xuICAgICAgICB2ZXJzaW9uTWFkZUJ5ID0gMHgwMzFFOyAvLyBVTklYLCB2ZXJzaW9uIDMuMFxuICAgICAgICBleHRGaWxlQXR0ciB8PSBnZW5lcmF0ZVVuaXhFeHRlcm5hbEZpbGVBdHRyKGZpbGUudW5peFBlcm1pc3Npb25zLCBkaXIpO1xuICAgIH0gZWxzZSB7IC8vIERPUyBvciBvdGhlciwgZmFsbGJhY2sgdG8gRE9TXG4gICAgICAgIHZlcnNpb25NYWRlQnkgPSAweDAwMTQ7IC8vIERPUywgdmVyc2lvbiAyLjBcbiAgICAgICAgZXh0RmlsZUF0dHIgfD0gZ2VuZXJhdGVEb3NFeHRlcm5hbEZpbGVBdHRyKGZpbGUuZG9zUGVybWlzc2lvbnMsIGRpcik7XG4gICAgfVxuXG4gICAgLy8gZGF0ZVxuICAgIC8vIEBzZWUgaHR0cDovL3d3dy5kZWxvcmllLmNvbS9kamdwcC9kb2MvcmJpbnRlci9pdC81Mi8xMy5odG1sXG4gICAgLy8gQHNlZSBodHRwOi8vd3d3LmRlbG9yaWUuY29tL2RqZ3BwL2RvYy9yYmludGVyL2l0LzY1LzE2Lmh0bWxcbiAgICAvLyBAc2VlIGh0dHA6Ly93d3cuZGVsb3JpZS5jb20vZGpncHAvZG9jL3JiaW50ZXIvaXQvNjYvMTYuaHRtbFxuXG4gICAgZG9zVGltZSA9IGRhdGUuZ2V0VVRDSG91cnMoKTtcbiAgICBkb3NUaW1lID0gZG9zVGltZSA8PCA2O1xuICAgIGRvc1RpbWUgPSBkb3NUaW1lIHwgZGF0ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgZG9zVGltZSA9IGRvc1RpbWUgPDwgNTtcbiAgICBkb3NUaW1lID0gZG9zVGltZSB8IGRhdGUuZ2V0VVRDU2Vjb25kcygpIC8gMjtcblxuICAgIGRvc0RhdGUgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTgwO1xuICAgIGRvc0RhdGUgPSBkb3NEYXRlIDw8IDQ7XG4gICAgZG9zRGF0ZSA9IGRvc0RhdGUgfCAoZGF0ZS5nZXRVVENNb250aCgpICsgMSk7XG4gICAgZG9zRGF0ZSA9IGRvc0RhdGUgPDwgNTtcbiAgICBkb3NEYXRlID0gZG9zRGF0ZSB8IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuXG4gICAgaWYgKHVzZVVURjhGb3JGaWxlTmFtZSkge1xuICAgICAgICAvLyBzZXQgdGhlIHVuaWNvZGUgcGF0aCBleHRyYSBmaWVsZC4gdW56aXAgbmVlZHMgYXQgbGVhc3Qgb25lIGV4dHJhXG4gICAgICAgIC8vIGZpZWxkIHRvIGNvcnJlY3RseSBoYW5kbGUgdW5pY29kZSBwYXRoLCBzbyB1c2luZyB0aGUgcGF0aCBpcyBhcyBnb29kXG4gICAgICAgIC8vIGFzIGFueSBvdGhlciBpbmZvcm1hdGlvbi4gVGhpcyBjb3VsZCBpbXByb3ZlIHRoZSBzaXR1YXRpb24gd2l0aFxuICAgICAgICAvLyBvdGhlciBhcmNoaXZlIG1hbmFnZXJzIHRvby5cbiAgICAgICAgLy8gVGhpcyBmaWVsZCBpcyB1c3VhbGx5IHVzZWQgd2l0aG91dCB0aGUgdXRmOCBmbGFnLCB3aXRoIGEgbm9uXG4gICAgICAgIC8vIHVuaWNvZGUgcGF0aCBpbiB0aGUgaGVhZGVyICh3aW5yYXIsIHdpbnppcCkuIFRoaXMgaGVscHMgKGEgYml0KVxuICAgICAgICAvLyB3aXRoIHRoZSBtZXNzeSBXaW5kb3dzJyBkZWZhdWx0IGNvbXByZXNzZWQgZm9sZGVycyBmZWF0dXJlIGJ1dFxuICAgICAgICAvLyBicmVha3Mgb24gcDd6aXAgd2hpY2ggZG9lc24ndCBzZWVrIHRoZSB1bmljb2RlIHBhdGggZXh0cmEgZmllbGQuXG4gICAgICAgIC8vIFNvIGZvciBub3csIFVURi04IGV2ZXJ5d2hlcmUgIVxuICAgICAgICB1bmljb2RlUGF0aEV4dHJhRmllbGQgPVxuICAgICAgICAgICAgLy8gVmVyc2lvblxuICAgICAgICAgICAgZGVjVG9IZXgoMSwgMSkgK1xuICAgICAgICAgICAgLy8gTmFtZUNSQzMyXG4gICAgICAgICAgICBkZWNUb0hleChjcmMzMihlbmNvZGVkRmlsZU5hbWUpLCA0KSArXG4gICAgICAgICAgICAvLyBVbmljb2RlTmFtZVxuICAgICAgICAgICAgdXRmRW5jb2RlZEZpbGVOYW1lO1xuXG4gICAgICAgIGV4dHJhRmllbGRzICs9XG4gICAgICAgICAgICAvLyBJbmZvLVpJUCBVbmljb2RlIFBhdGggRXh0cmEgRmllbGRcbiAgICAgICAgICAgIFwiXFx4NzVcXHg3MFwiICtcbiAgICAgICAgICAgIC8vIHNpemVcbiAgICAgICAgICAgIGRlY1RvSGV4KHVuaWNvZGVQYXRoRXh0cmFGaWVsZC5sZW5ndGgsIDIpICtcbiAgICAgICAgICAgIC8vIGNvbnRlbnRcbiAgICAgICAgICAgIHVuaWNvZGVQYXRoRXh0cmFGaWVsZDtcbiAgICB9XG5cbiAgICBpZih1c2VVVEY4Rm9yQ29tbWVudCkge1xuXG4gICAgICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZCA9XG4gICAgICAgICAgICAvLyBWZXJzaW9uXG4gICAgICAgICAgICBkZWNUb0hleCgxLCAxKSArXG4gICAgICAgICAgICAvLyBDb21tZW50Q1JDMzJcbiAgICAgICAgICAgIGRlY1RvSGV4KGNyYzMyKGVuY29kZWRDb21tZW50KSwgNCkgK1xuICAgICAgICAgICAgLy8gVW5pY29kZU5hbWVcbiAgICAgICAgICAgIHV0ZkVuY29kZWRDb21tZW50O1xuXG4gICAgICAgIGV4dHJhRmllbGRzICs9XG4gICAgICAgICAgICAvLyBJbmZvLVpJUCBVbmljb2RlIFBhdGggRXh0cmEgRmllbGRcbiAgICAgICAgICAgIFwiXFx4NzVcXHg2M1wiICtcbiAgICAgICAgICAgIC8vIHNpemVcbiAgICAgICAgICAgIGRlY1RvSGV4KHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZC5sZW5ndGgsIDIpICtcbiAgICAgICAgICAgIC8vIGNvbnRlbnRcbiAgICAgICAgICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZDtcbiAgICB9XG5cbiAgICB2YXIgaGVhZGVyID0gXCJcIjtcblxuICAgIC8vIHZlcnNpb24gbmVlZGVkIHRvIGV4dHJhY3RcbiAgICBoZWFkZXIgKz0gXCJcXHgwQVxceDAwXCI7XG4gICAgLy8gZ2VuZXJhbCBwdXJwb3NlIGJpdCBmbGFnXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGJpdGZsYWcsIDIpO1xuICAgIC8vIGNvbXByZXNzaW9uIG1ldGhvZFxuICAgIGhlYWRlciArPSBjb21wcmVzc2lvbi5tYWdpYztcbiAgICAvLyBsYXN0IG1vZCBmaWxlIHRpbWVcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZG9zVGltZSwgMik7XG4gICAgLy8gbGFzdCBtb2QgZmlsZSBkYXRlXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGRvc0RhdGUsIDIpO1xuICAgIC8vIGNyYy0zMlxuICAgIGhlYWRlciArPSBkZWNUb0hleChkYXRhSW5mby5jcmMzMiwgNCk7XG4gICAgLy8gY29tcHJlc3NlZCBzaXplXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGRhdGFJbmZvLmNvbXByZXNzZWRTaXplLCA0KTtcbiAgICAvLyB1bmNvbXByZXNzZWQgc2l6ZVxuICAgIGhlYWRlciArPSBkZWNUb0hleChkYXRhSW5mby51bmNvbXByZXNzZWRTaXplLCA0KTtcbiAgICAvLyBmaWxlIG5hbWUgbGVuZ3RoXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGVuY29kZWRGaWxlTmFtZS5sZW5ndGgsIDIpO1xuICAgIC8vIGV4dHJhIGZpZWxkIGxlbmd0aFxuICAgIGhlYWRlciArPSBkZWNUb0hleChleHRyYUZpZWxkcy5sZW5ndGgsIDIpO1xuXG5cbiAgICB2YXIgZmlsZVJlY29yZCA9IHNpZ25hdHVyZS5MT0NBTF9GSUxFX0hFQURFUiArIGhlYWRlciArIGVuY29kZWRGaWxlTmFtZSArIGV4dHJhRmllbGRzO1xuXG4gICAgdmFyIGRpclJlY29yZCA9IHNpZ25hdHVyZS5DRU5UUkFMX0ZJTEVfSEVBREVSICtcbiAgICAgICAgLy8gdmVyc2lvbiBtYWRlIGJ5ICgwMDogRE9TKVxuICAgICAgICBkZWNUb0hleCh2ZXJzaW9uTWFkZUJ5LCAyKSArXG4gICAgICAgIC8vIGZpbGUgaGVhZGVyIChjb21tb24gdG8gZmlsZSBhbmQgY2VudHJhbCBkaXJlY3RvcnkpXG4gICAgICAgIGhlYWRlciArXG4gICAgICAgIC8vIGZpbGUgY29tbWVudCBsZW5ndGhcbiAgICAgICAgZGVjVG9IZXgoZW5jb2RlZENvbW1lbnQubGVuZ3RoLCAyKSArXG4gICAgICAgIC8vIGRpc2sgbnVtYmVyIHN0YXJ0XG4gICAgICAgIFwiXFx4MDBcXHgwMFwiICtcbiAgICAgICAgLy8gaW50ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzIFRPRE9cbiAgICAgICAgXCJcXHgwMFxceDAwXCIgK1xuICAgICAgICAvLyBleHRlcm5hbCBmaWxlIGF0dHJpYnV0ZXNcbiAgICAgICAgZGVjVG9IZXgoZXh0RmlsZUF0dHIsIDQpICtcbiAgICAgICAgLy8gcmVsYXRpdmUgb2Zmc2V0IG9mIGxvY2FsIGhlYWRlclxuICAgICAgICBkZWNUb0hleChvZmZzZXQsIDQpICtcbiAgICAgICAgLy8gZmlsZSBuYW1lXG4gICAgICAgIGVuY29kZWRGaWxlTmFtZSArXG4gICAgICAgIC8vIGV4dHJhIGZpZWxkXG4gICAgICAgIGV4dHJhRmllbGRzICtcbiAgICAgICAgLy8gZmlsZSBjb21tZW50XG4gICAgICAgIGVuY29kZWRDb21tZW50O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmlsZVJlY29yZDogZmlsZVJlY29yZCxcbiAgICAgICAgZGlyUmVjb3JkOiBkaXJSZWNvcmRcbiAgICB9O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgRU9DRCByZWNvcmQuXG4gKiBAcGFyYW0ge051bWJlcn0gZW50cmllc0NvdW50IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgemlwIGZpbGUuXG4gKiBAcGFyYW0ge051bWJlcn0gY2VudHJhbERpckxlbmd0aCB0aGUgbGVuZ3RoIChpbiBieXRlcykgb2YgdGhlIGNlbnRyYWwgZGlyLlxuICogQHBhcmFtIHtOdW1iZXJ9IGxvY2FsRGlyTGVuZ3RoIHRoZSBsZW5ndGggKGluIGJ5dGVzKSBvZiB0aGUgbG9jYWwgZGlyLlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbW1lbnQgdGhlIHppcCBmaWxlIGNvbW1lbnQgYXMgYSBiaW5hcnkgc3RyaW5nLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5jb2RlRmlsZU5hbWUgdGhlIGZ1bmN0aW9uIHRvIGVuY29kZSB0aGUgY29tbWVudC5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIEVPQ0QgcmVjb3JkLlxuICovXG52YXIgZ2VuZXJhdGVDZW50cmFsRGlyZWN0b3J5RW5kID0gZnVuY3Rpb24gKGVudHJpZXNDb3VudCwgY2VudHJhbERpckxlbmd0aCwgbG9jYWxEaXJMZW5ndGgsIGNvbW1lbnQsIGVuY29kZUZpbGVOYW1lKSB7XG4gICAgdmFyIGRpckVuZCA9IFwiXCI7XG4gICAgdmFyIGVuY29kZWRDb21tZW50ID0gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgZW5jb2RlRmlsZU5hbWUoY29tbWVudCkpO1xuXG4gICAgLy8gZW5kIG9mIGNlbnRyYWwgZGlyIHNpZ25hdHVyZVxuICAgIGRpckVuZCA9IHNpZ25hdHVyZS5DRU5UUkFMX0RJUkVDVE9SWV9FTkQgK1xuICAgICAgICAvLyBudW1iZXIgb2YgdGhpcyBkaXNrXG4gICAgICAgIFwiXFx4MDBcXHgwMFwiICtcbiAgICAgICAgLy8gbnVtYmVyIG9mIHRoZSBkaXNrIHdpdGggdGhlIHN0YXJ0IG9mIHRoZSBjZW50cmFsIGRpcmVjdG9yeVxuICAgICAgICBcIlxceDAwXFx4MDBcIiArXG4gICAgICAgIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSBjZW50cmFsIGRpcmVjdG9yeSBvbiB0aGlzIGRpc2tcbiAgICAgICAgZGVjVG9IZXgoZW50cmllc0NvdW50LCAyKSArXG4gICAgICAgIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSBjZW50cmFsIGRpcmVjdG9yeVxuICAgICAgICBkZWNUb0hleChlbnRyaWVzQ291bnQsIDIpICtcbiAgICAgICAgLy8gc2l6ZSBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnkgICA0IGJ5dGVzXG4gICAgICAgIGRlY1RvSGV4KGNlbnRyYWxEaXJMZW5ndGgsIDQpICtcbiAgICAgICAgLy8gb2Zmc2V0IG9mIHN0YXJ0IG9mIGNlbnRyYWwgZGlyZWN0b3J5IHdpdGggcmVzcGVjdCB0byB0aGUgc3RhcnRpbmcgZGlzayBudW1iZXJcbiAgICAgICAgZGVjVG9IZXgobG9jYWxEaXJMZW5ndGgsIDQpICtcbiAgICAgICAgLy8gLlpJUCBmaWxlIGNvbW1lbnQgbGVuZ3RoXG4gICAgICAgIGRlY1RvSGV4KGVuY29kZWRDb21tZW50Lmxlbmd0aCwgMikgK1xuICAgICAgICAvLyAuWklQIGZpbGUgY29tbWVudFxuICAgICAgICBlbmNvZGVkQ29tbWVudDtcblxuICAgIHJldHVybiBkaXJFbmQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGRhdGEgZGVzY3JpcHRvcnMgZm9yIGEgZmlsZSBlbnRyeS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHJlYW1JbmZvIHRoZSBoYXNoIGdlbmVyYXRlZCBieSBhIHdvcmtlciwgY29udGFpbmluZyBpbmZvcm1hdGlvbnNcbiAqIG9uIHRoZSBmaWxlIGVudHJ5LlxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgZGF0YSBkZXNjcmlwdG9ycy5cbiAqL1xudmFyIGdlbmVyYXRlRGF0YURlc2NyaXB0b3JzID0gZnVuY3Rpb24gKHN0cmVhbUluZm8pIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IFwiXCI7XG4gICAgZGVzY3JpcHRvciA9IHNpZ25hdHVyZS5EQVRBX0RFU0NSSVBUT1IgK1xuICAgICAgICAvLyBjcmMtMzIgICAgICAgICAgICAgICAgICAgICAgICAgIDQgYnl0ZXNcbiAgICAgICAgZGVjVG9IZXgoc3RyZWFtSW5mb1snY3JjMzInXSwgNCkgK1xuICAgICAgICAvLyBjb21wcmVzc2VkIHNpemUgICAgICAgICAgICAgICAgIDQgYnl0ZXNcbiAgICAgICAgZGVjVG9IZXgoc3RyZWFtSW5mb1snY29tcHJlc3NlZFNpemUnXSwgNCkgK1xuICAgICAgICAvLyB1bmNvbXByZXNzZWQgc2l6ZSAgICAgICAgICAgICAgIDQgYnl0ZXNcbiAgICAgICAgZGVjVG9IZXgoc3RyZWFtSW5mb1sndW5jb21wcmVzc2VkU2l6ZSddLCA0KTtcblxuICAgIHJldHVybiBkZXNjcmlwdG9yO1xufTtcblxuXG4vKipcbiAqIEEgd29ya2VyIHRvIGNvbmNhdGVuYXRlIG90aGVyIHdvcmtlcnMgdG8gY3JlYXRlIGEgemlwIGZpbGUuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHN0cmVhbUZpbGVzIGB0cnVlYCB0byBzdHJlYW0gdGhlIGNvbnRlbnQgb2YgdGhlIGZpbGVzLFxuICogYGZhbHNlYCB0byBhY2N1bXVsYXRlIGl0LlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbW1lbnQgdGhlIGNvbW1lbnQgdG8gdXNlLlxuICogQHBhcmFtIHtTdHJpbmd9IHBsYXRmb3JtIHRoZSBwbGF0Zm9ybSB0byB1c2UsIFwiVU5JWFwiIG9yIFwiRE9TXCIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmNvZGVGaWxlTmFtZSB0aGUgZnVuY3Rpb24gdG8gZW5jb2RlIGZpbGUgbmFtZXMgYW5kIGNvbW1lbnRzLlxuICovXG5mdW5jdGlvbiBaaXBGaWxlV29ya2VyKHN0cmVhbUZpbGVzLCBjb21tZW50LCBwbGF0Zm9ybSwgZW5jb2RlRmlsZU5hbWUpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJaaXBGaWxlV29ya2VyXCIpO1xuICAgIC8vIFRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBzbyBmYXIuIFRoaXMgZG9lc24ndCBjb3VudCBhY2N1bXVsYXRlZCBjaHVua3MuXG4gICAgdGhpcy5ieXRlc1dyaXR0ZW4gPSAwO1xuICAgIC8vIFRoZSBjb21tZW50IG9mIHRoZSB6aXAgZmlsZVxuICAgIHRoaXMuemlwQ29tbWVudCA9IGNvbW1lbnQ7XG4gICAgLy8gVGhlIHBsYXRmb3JtIFwiZ2VuZXJhdGluZ1wiIHRoZSB6aXAgZmlsZS5cbiAgICB0aGlzLnppcFBsYXRmb3JtID0gcGxhdGZvcm07XG4gICAgLy8gdGhlIGZ1bmN0aW9uIHRvIGVuY29kZSBmaWxlIG5hbWVzIGFuZCBjb21tZW50cy5cbiAgICB0aGlzLmVuY29kZUZpbGVOYW1lID0gZW5jb2RlRmlsZU5hbWU7XG4gICAgLy8gU2hvdWxkIHdlIHN0cmVhbSB0aGUgY29udGVudCBvZiB0aGUgZmlsZXMgP1xuICAgIHRoaXMuc3RyZWFtRmlsZXMgPSBzdHJlYW1GaWxlcztcbiAgICAvLyBJZiBgc3RyZWFtRmlsZXNgIGlzIGZhbHNlLCB3ZSB3aWxsIG5lZWQgdG8gYWNjdW11bGF0ZSB0aGUgY29udGVudCBvZiB0aGVcbiAgICAvLyBmaWxlcyB0byBjYWxjdWxhdGUgc2l6ZXMgLyBjcmMzMiAoYW5kIHdyaXRlIHRoZW0gKmJlZm9yZSogdGhlIGNvbnRlbnQpLlxuICAgIC8vIFRoaXMgYm9vbGVhbiBpbmRpY2F0ZXMgaWYgd2UgYXJlIGFjY3VtdWxhdGluZyBjaHVua3MgKGl0IHdpbGwgY2hhbmdlIGEgbG90XG4gICAgLy8gZHVyaW5nIHRoZSBsaWZldGltZSBvZiB0aGlzIHdvcmtlcikuXG4gICAgdGhpcy5hY2N1bXVsYXRlID0gZmFsc2U7XG4gICAgLy8gVGhlIGJ1ZmZlciByZWNlaXZpbmcgY2h1bmtzIHdoZW4gYWNjdW11bGF0aW5nIGNvbnRlbnQuXG4gICAgdGhpcy5jb250ZW50QnVmZmVyID0gW107XG4gICAgLy8gVGhlIGxpc3Qgb2YgZ2VuZXJhdGVkIGRpcmVjdG9yeSByZWNvcmRzLlxuICAgIHRoaXMuZGlyUmVjb3JkcyA9IFtdO1xuICAgIC8vIFRoZSBvZmZzZXQgKGluIGJ5dGVzKSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHppcCBmaWxlIGZvciB0aGUgY3VycmVudCBzb3VyY2UuXG4gICAgdGhpcy5jdXJyZW50U291cmNlT2Zmc2V0ID0gMDtcbiAgICAvLyBUaGUgdG90YWwgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhpcyB6aXAgZmlsZS5cbiAgICB0aGlzLmVudHJpZXNDb3VudCA9IDA7XG4gICAgLy8gdGhlIG5hbWUgb2YgdGhlIGZpbGUgY3VycmVudGx5IGJlaW5nIGFkZGVkLCBudWxsIHdoZW4gaGFuZGxpbmcgdGhlIGVuZCBvZiB0aGUgemlwIGZpbGUuXG4gICAgLy8gVXNlZCBmb3IgdGhlIGVtaXRlZCBtZXRhZGF0YS5cbiAgICB0aGlzLmN1cnJlbnRGaWxlID0gbnVsbDtcblxuXG5cbiAgICB0aGlzLl9zb3VyY2VzID0gW107XG59XG51dGlscy5pbmhlcml0cyhaaXBGaWxlV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHVzaFxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rKSB7XG5cbiAgICB2YXIgY3VycmVudEZpbGVQZXJjZW50ID0gY2h1bmsubWV0YS5wZXJjZW50IHx8IDA7XG4gICAgdmFyIGVudHJpZXNDb3VudCA9IHRoaXMuZW50cmllc0NvdW50O1xuICAgIHZhciByZW1haW5pbmdGaWxlcyA9IHRoaXMuX3NvdXJjZXMubGVuZ3RoO1xuXG4gICAgaWYodGhpcy5hY2N1bXVsYXRlKSB7XG4gICAgICAgIHRoaXMuY29udGVudEJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJ5dGVzV3JpdHRlbiArPSBjaHVuay5kYXRhLmxlbmd0aDtcblxuICAgICAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywge1xuICAgICAgICAgICAgZGF0YSA6IGNodW5rLmRhdGEsXG4gICAgICAgICAgICBtZXRhIDoge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRGaWxlIDogdGhpcy5jdXJyZW50RmlsZSxcbiAgICAgICAgICAgICAgICBwZXJjZW50IDogZW50cmllc0NvdW50ID8gKGN1cnJlbnRGaWxlUGVyY2VudCArIDEwMCAqIChlbnRyaWVzQ291bnQgLSByZW1haW5pbmdGaWxlcyAtIDEpKSAvIGVudHJpZXNDb3VudCA6IDEwMFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRoZSB3b3JrZXIgc3RhcnRlZCBhIG5ldyBzb3VyY2UgKGFuIG90aGVyIHdvcmtlcikuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RyZWFtSW5mbyB0aGUgc3RyZWFtSW5mbyBvYmplY3QgZnJvbSB0aGUgbmV3IHNvdXJjZS5cbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUub3BlbmVkU291cmNlID0gZnVuY3Rpb24gKHN0cmVhbUluZm8pIHtcbiAgICB0aGlzLmN1cnJlbnRTb3VyY2VPZmZzZXQgPSB0aGlzLmJ5dGVzV3JpdHRlbjtcbiAgICB0aGlzLmN1cnJlbnRGaWxlID0gc3RyZWFtSW5mb1snZmlsZSddLm5hbWU7XG5cbiAgICB2YXIgc3RyZWFtZWRDb250ZW50ID0gdGhpcy5zdHJlYW1GaWxlcyAmJiAhc3RyZWFtSW5mb1snZmlsZSddLmRpcjtcblxuICAgIC8vIGRvbid0IHN0cmVhbSBmb2xkZXJzIChiZWNhdXNlIHRoZXkgZG9uJ3QgaGF2ZSBhbnkgY29udGVudClcbiAgICBpZihzdHJlYW1lZENvbnRlbnQpIHtcbiAgICAgICAgdmFyIHJlY29yZCA9IGdlbmVyYXRlWmlwUGFydHMoc3RyZWFtSW5mbywgc3RyZWFtZWRDb250ZW50LCBmYWxzZSwgdGhpcy5jdXJyZW50U291cmNlT2Zmc2V0LCB0aGlzLnppcFBsYXRmb3JtLCB0aGlzLmVuY29kZUZpbGVOYW1lKTtcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiByZWNvcmQuZmlsZVJlY29yZCxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDowfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSB3aG9sZSBmaWxlIGJlZm9yZSBwdXNoaW5nIGFueXRoaW5nXG4gICAgICAgIHRoaXMuYWNjdW11bGF0ZSA9IHRydWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUaGUgd29ya2VyIGZpbmlzaGVkIGEgc291cmNlIChhbiBvdGhlciB3b3JrZXIpLlxuICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbUluZm8gdGhlIHN0cmVhbUluZm8gb2JqZWN0IGZyb20gdGhlIGZpbmlzaGVkIHNvdXJjZS5cbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUuY2xvc2VkU291cmNlID0gZnVuY3Rpb24gKHN0cmVhbUluZm8pIHtcbiAgICB0aGlzLmFjY3VtdWxhdGUgPSBmYWxzZTtcbiAgICB2YXIgc3RyZWFtZWRDb250ZW50ID0gdGhpcy5zdHJlYW1GaWxlcyAmJiAhc3RyZWFtSW5mb1snZmlsZSddLmRpcjtcbiAgICB2YXIgcmVjb3JkID0gZ2VuZXJhdGVaaXBQYXJ0cyhzdHJlYW1JbmZvLCBzdHJlYW1lZENvbnRlbnQsIHRydWUsIHRoaXMuY3VycmVudFNvdXJjZU9mZnNldCwgdGhpcy56aXBQbGF0Zm9ybSwgdGhpcy5lbmNvZGVGaWxlTmFtZSk7XG5cbiAgICB0aGlzLmRpclJlY29yZHMucHVzaChyZWNvcmQuZGlyUmVjb3JkKTtcbiAgICBpZihzdHJlYW1lZENvbnRlbnQpIHtcbiAgICAgICAgLy8gYWZ0ZXIgdGhlIHN0cmVhbWVkIGZpbGUsIHdlIHB1dCBkYXRhIGRlc2NyaXB0b3JzXG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogZ2VuZXJhdGVEYXRhRGVzY3JpcHRvcnMoc3RyZWFtSW5mbyksXG4gICAgICAgICAgICBtZXRhIDoge3BlcmNlbnQ6MTAwfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGUgY29udGVudCB3YXNuJ3Qgc3RyZWFtZWQsIHdlIG5lZWQgdG8gcHVzaCBldmVyeXRoaW5nIG5vd1xuICAgICAgICAvLyBmaXJzdCB0aGUgZmlsZSByZWNvcmQsIHRoZW4gdGhlIGNvbnRlbnRcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiByZWNvcmQuZmlsZVJlY29yZCxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDowfVxuICAgICAgICB9KTtcbiAgICAgICAgd2hpbGUodGhpcy5jb250ZW50QnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXMuY29udGVudEJ1ZmZlci5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRGaWxlID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmZsdXNoXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGxvY2FsRGlyTGVuZ3RoID0gdGhpcy5ieXRlc1dyaXR0ZW47XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuZGlyUmVjb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IHRoaXMuZGlyUmVjb3Jkc1tpXSxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDoxMDB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgY2VudHJhbERpckxlbmd0aCA9IHRoaXMuYnl0ZXNXcml0dGVuIC0gbG9jYWxEaXJMZW5ndGg7XG5cbiAgICB2YXIgZGlyRW5kID0gZ2VuZXJhdGVDZW50cmFsRGlyZWN0b3J5RW5kKHRoaXMuZGlyUmVjb3Jkcy5sZW5ndGgsIGNlbnRyYWxEaXJMZW5ndGgsIGxvY2FsRGlyTGVuZ3RoLCB0aGlzLnppcENvbW1lbnQsIHRoaXMuZW5jb2RlRmlsZU5hbWUpO1xuXG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IGRpckVuZCxcbiAgICAgICAgbWV0YSA6IHtwZXJjZW50OjEwMH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogUHJlcGFyZSB0aGUgbmV4dCBzb3VyY2UgdG8gYmUgcmVhZC5cbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUucHJlcGFyZU5leHRTb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wcmV2aW91cyA9IHRoaXMuX3NvdXJjZXMuc2hpZnQoKTtcbiAgICB0aGlzLm9wZW5lZFNvdXJjZSh0aGlzLnByZXZpb3VzLnN0cmVhbUluZm8pO1xuICAgIGlmICh0aGlzLmlzUGF1c2VkKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXMucGF1c2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZXZpb3VzLnJlc3VtZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnJlZ2lzdGVyUHJldmlvdXNcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUucmVnaXN0ZXJQcmV2aW91cyA9IGZ1bmN0aW9uIChwcmV2aW91cykge1xuICAgIHRoaXMuX3NvdXJjZXMucHVzaChwcmV2aW91cyk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgcHJldmlvdXMub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgc2VsZi5wcm9jZXNzQ2h1bmsoY2h1bmspO1xuICAgIH0pO1xuICAgIHByZXZpb3VzLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuY2xvc2VkU291cmNlKHNlbGYucHJldmlvdXMuc3RyZWFtSW5mbyk7XG4gICAgICAgIGlmKHNlbGYuX3NvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZWxmLnByZXBhcmVOZXh0U291cmNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmVuZCgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcHJldmlvdXMub24oJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnJlc3VtZVxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoIUdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnJlc3VtZS5jYWxsKHRoaXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMucHJldmlvdXMgJiYgdGhpcy5fc291cmNlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wcmVwYXJlTmV4dFNvdXJjZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnByZXZpb3VzICYmICF0aGlzLl9zb3VyY2VzLmxlbmd0aCAmJiAhdGhpcy5nZW5lcmF0ZWRFcnJvcikge1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5lcnJvclxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHNvdXJjZXMgPSB0aGlzLl9zb3VyY2VzO1xuICAgIGlmKCFHZW5lcmljV29ya2VyLnByb3RvdHlwZS5lcnJvci5jYWxsKHRoaXMsIGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNvdXJjZXNbaV0uZXJyb3IoZSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgLy8gdGhlIGBlcnJvcmAgZXhwbG9kZWQsIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmxvY2tcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUubG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5sb2NrLmNhbGwodGhpcyk7XG4gICAgdmFyIHNvdXJjZXMgPSB0aGlzLl9zb3VyY2VzO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNvdXJjZXNbaV0ubG9jaygpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gWmlwRmlsZVdvcmtlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBHWmhlYWRlcigpIHtcbiAgLyogdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dCAqL1xuICB0aGlzLnRleHQgICAgICAgPSAwO1xuICAvKiBtb2RpZmljYXRpb24gdGltZSAqL1xuICB0aGlzLnRpbWUgICAgICAgPSAwO1xuICAvKiBleHRyYSBmbGFncyAobm90IHVzZWQgd2hlbiB3cml0aW5nIGEgZ3ppcCBmaWxlKSAqL1xuICB0aGlzLnhmbGFncyAgICAgPSAwO1xuICAvKiBvcGVyYXRpbmcgc3lzdGVtICovXG4gIHRoaXMub3MgICAgICAgICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gZXh0cmEgZmllbGQgb3IgWl9OVUxMIGlmIG5vbmUgKi9cbiAgdGhpcy5leHRyYSAgICAgID0gbnVsbDtcbiAgLyogZXh0cmEgZmllbGQgbGVuZ3RoICh2YWxpZCBpZiBleHRyYSAhPSBaX05VTEwpICovXG4gIHRoaXMuZXh0cmFfbGVuICA9IDA7IC8vIEFjdHVhbGx5LCB3ZSBkb24ndCBuZWVkIGl0IGluIEpTLFxuICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgbGVhdmUgZm9yIGZldyBjb2RlIG1vZGlmaWNhdGlvbnNcblxuICAvL1xuICAvLyBTZXR1cCBsaW1pdHMgaXMgbm90IG5lY2Vzc2FyeSBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5XG4gIC8vIGZvciBpbmZsYXRlIHVzZSBjb25zdGFudCBsaW1pdCBpbiA2NTUzNiBieXRlc1xuICAvL1xuXG4gIC8qIHNwYWNlIGF0IGV4dHJhIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuZXh0cmFfbWF4ICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGZpbGUgbmFtZSBvciBaX05VTEwgKi9cbiAgdGhpcy5uYW1lICAgICAgID0gJyc7XG4gIC8qIHNwYWNlIGF0IG5hbWUgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5uYW1lX21heCAgID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgY29tbWVudCBvciBaX05VTEwgKi9cbiAgdGhpcy5jb21tZW50ICAgID0gJyc7XG4gIC8qIHNwYWNlIGF0IGNvbW1lbnQgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5jb21tX21heCAgID0gMDtcbiAgLyogdHJ1ZSBpZiB0aGVyZSB3YXMgb3Igd2lsbCBiZSBhIGhlYWRlciBjcmMgKi9cbiAgdGhpcy5oY3JjICAgICAgID0gMDtcbiAgLyogdHJ1ZSB3aGVuIGRvbmUgcmVhZGluZyBnemlwIGhlYWRlciAobm90IHVzZWQgd2hlbiB3cml0aW5nIGEgZ3ppcCBmaWxlKSAqL1xuICB0aGlzLmRvbmUgICAgICAgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHWmhlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxudmFyIE1BWEJJVFMgPSAxNTtcbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbnZhciBsYmFzZSA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGJhc2UgKi9cbiAgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSxcbiAgMzUsIDQzLCA1MSwgNTksIDY3LCA4MywgOTksIDExNSwgMTMxLCAxNjMsIDE5NSwgMjI3LCAyNTgsIDAsIDBcbl07XG5cbnZhciBsZXh0ID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsXG4gIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjEsIDIxLCAyMSwgMjEsIDE2LCA3MiwgNzhcbl07XG5cbnZhciBkYmFzZSA9IFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgYmFzZSAqL1xuICAxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsXG4gIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSxcbiAgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3NywgMCwgMFxuXTtcblxudmFyIGRleHQgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE4LCAxOCwgMTksIDE5LCAyMCwgMjAsIDIxLCAyMSwgMjIsIDIyLFxuICAyMywgMjMsIDI0LCAyNCwgMjUsIDI1LCAyNiwgMjYsIDI3LCAyNyxcbiAgMjgsIDI4LCAyOSwgMjksIDY0LCA2NFxuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX3RhYmxlKHR5cGUsIGxlbnMsIGxlbnNfaW5kZXgsIGNvZGVzLCB0YWJsZSwgdGFibGVfaW5kZXgsIHdvcmssIG9wdHMpXG57XG4gIHZhciBiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgLy9oZXJlID0gb3B0cy5oZXJlOyAvKiB0YWJsZSBlbnRyeSBmb3IgZHVwbGljYXRpb24gKi9cblxuICB2YXIgbGVuID0gMDsgICAgICAgICAgICAgICAvKiBhIGNvZGUncyBsZW5ndGggaW4gYml0cyAqL1xuICB2YXIgc3ltID0gMDsgICAgICAgICAgICAgICAvKiBpbmRleCBvZiBjb2RlIHN5bWJvbHMgKi9cbiAgdmFyIG1pbiA9IDAsIG1heCA9IDA7ICAgICAgICAgIC8qIG1pbmltdW0gYW5kIG1heGltdW0gY29kZSBsZW5ndGhzICovXG4gIHZhciByb290ID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciByb290IHRhYmxlICovXG4gIHZhciBjdXJyID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciBjdXJyZW50IHRhYmxlICovXG4gIHZhciBkcm9wID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgYml0cyB0byBkcm9wIGZvciBzdWItdGFibGUgKi9cbiAgdmFyIGxlZnQgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgcHJlZml4IGNvZGVzIGF2YWlsYWJsZSAqL1xuICB2YXIgdXNlZCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGVudHJpZXMgaW4gdGFibGUgdXNlZCAqL1xuICB2YXIgaHVmZiA9IDA7ICAgICAgICAgICAgICAvKiBIdWZmbWFuIGNvZGUgKi9cbiAgdmFyIGluY3I7ICAgICAgICAgICAgICAvKiBmb3IgaW5jcmVtZW50aW5nIGNvZGUsIGluZGV4ICovXG4gIHZhciBmaWxsOyAgICAgICAgICAgICAgLyogaW5kZXggZm9yIHJlcGxpY2F0aW5nIGVudHJpZXMgKi9cbiAgdmFyIGxvdzsgICAgICAgICAgICAgICAvKiBsb3cgYml0cyBmb3IgY3VycmVudCByb290IGVudHJ5ICovXG4gIHZhciBtYXNrOyAgICAgICAgICAgICAgLyogbWFzayBmb3IgbG93IHJvb3QgYml0cyAqL1xuICB2YXIgbmV4dDsgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gdGFibGUgKi9cbiAgdmFyIGJhc2UgPSBudWxsOyAgICAgLyogYmFzZSB2YWx1ZSB0YWJsZSB0byB1c2UgKi9cbiAgdmFyIGJhc2VfaW5kZXggPSAwO1xuLy8gIHZhciBzaG9leHRyYTsgICAgLyogZXh0cmEgYml0cyB0YWJsZSB0byB1c2UgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHVzZSBiYXNlIGFuZCBleHRyYSBmb3Igc3ltYm9sID4gZW5kICovXG4gIHZhciBjb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgIC8qIG51bWJlciBvZiBjb2RlcyBvZiBlYWNoIGxlbmd0aCAqL1xuICB2YXIgb2ZmcyA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgICAvKiBvZmZzZXRzIGluIHRhYmxlIGZvciBlYWNoIGxlbmd0aCAqL1xuICB2YXIgZXh0cmEgPSBudWxsO1xuICB2YXIgZXh0cmFfaW5kZXggPSAwO1xuXG4gIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsO1xuXG4gIC8qXG4gICBQcm9jZXNzIGEgc2V0IG9mIGNvZGUgbGVuZ3RocyB0byBjcmVhdGUgYSBjYW5vbmljYWwgSHVmZm1hbiBjb2RlLiAgVGhlXG4gICBjb2RlIGxlbmd0aHMgYXJlIGxlbnNbMC4uY29kZXMtMV0uICBFYWNoIGxlbmd0aCBjb3JyZXNwb25kcyB0byB0aGVcbiAgIHN5bWJvbHMgMC4uY29kZXMtMS4gIFRoZSBIdWZmbWFuIGNvZGUgaXMgZ2VuZXJhdGVkIGJ5IGZpcnN0IHNvcnRpbmcgdGhlXG4gICBzeW1ib2xzIGJ5IGxlbmd0aCBmcm9tIHNob3J0IHRvIGxvbmcsIGFuZCByZXRhaW5pbmcgdGhlIHN5bWJvbCBvcmRlclxuICAgZm9yIGNvZGVzIHdpdGggZXF1YWwgbGVuZ3Rocy4gIFRoZW4gdGhlIGNvZGUgc3RhcnRzIHdpdGggYWxsIHplcm8gYml0c1xuICAgZm9yIHRoZSBmaXJzdCBjb2RlIG9mIHRoZSBzaG9ydGVzdCBsZW5ndGgsIGFuZCB0aGUgY29kZXMgYXJlIGludGVnZXJcbiAgIGluY3JlbWVudHMgZm9yIHRoZSBzYW1lIGxlbmd0aCwgYW5kIHplcm9zIGFyZSBhcHBlbmRlZCBhcyB0aGUgbGVuZ3RoXG4gICBpbmNyZWFzZXMuICBGb3IgdGhlIGRlZmxhdGUgZm9ybWF0LCB0aGVzZSBiaXRzIGFyZSBzdG9yZWQgYmFja3dhcmRzXG4gICBmcm9tIHRoZWlyIG1vcmUgbmF0dXJhbCBpbnRlZ2VyIGluY3JlbWVudCBvcmRlcmluZywgYW5kIHNvIHdoZW4gdGhlXG4gICBkZWNvZGluZyB0YWJsZXMgYXJlIGJ1aWx0IGluIHRoZSBsYXJnZSBsb29wIGJlbG93LCB0aGUgaW50ZWdlciBjb2Rlc1xuICAgYXJlIGluY3JlbWVudGVkIGJhY2t3YXJkcy5cblxuICAgVGhpcyByb3V0aW5lIGFzc3VtZXMsIGJ1dCBkb2VzIG5vdCBjaGVjaywgdGhhdCBhbGwgb2YgdGhlIGVudHJpZXMgaW5cbiAgIGxlbnNbXSBhcmUgaW4gdGhlIHJhbmdlIDAuLk1BWEJJVFMuICBUaGUgY2FsbGVyIG11c3QgYXNzdXJlIHRoaXMuXG4gICAxLi5NQVhCSVRTIGlzIGludGVycHJldGVkIGFzIHRoYXQgY29kZSBsZW5ndGguICB6ZXJvIG1lYW5zIHRoYXQgdGhhdFxuICAgc3ltYm9sIGRvZXMgbm90IG9jY3VyIGluIHRoaXMgY29kZS5cblxuICAgVGhlIGNvZGVzIGFyZSBzb3J0ZWQgYnkgY29tcHV0aW5nIGEgY291bnQgb2YgY29kZXMgZm9yIGVhY2ggbGVuZ3RoLFxuICAgY3JlYXRpbmcgZnJvbSB0aGF0IGEgdGFibGUgb2Ygc3RhcnRpbmcgaW5kaWNlcyBmb3IgZWFjaCBsZW5ndGggaW4gdGhlXG4gICBzb3J0ZWQgdGFibGUsIGFuZCB0aGVuIGVudGVyaW5nIHRoZSBzeW1ib2xzIGluIG9yZGVyIGluIHRoZSBzb3J0ZWRcbiAgIHRhYmxlLiAgVGhlIHNvcnRlZCB0YWJsZSBpcyB3b3JrW10sIHdpdGggdGhhdCBzcGFjZSBiZWluZyBwcm92aWRlZCBieVxuICAgdGhlIGNhbGxlci5cblxuICAgVGhlIGxlbmd0aCBjb3VudHMgYXJlIHVzZWQgZm9yIG90aGVyIHB1cnBvc2VzIGFzIHdlbGwsIGkuZS4gZmluZGluZ1xuICAgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbGVuZ3RoIGNvZGVzLCBkZXRlcm1pbmluZyBpZiB0aGVyZSBhcmUgYW55XG4gICBjb2RlcyBhdCBhbGwsIGNoZWNraW5nIGZvciBhIHZhbGlkIHNldCBvZiBsZW5ndGhzLCBhbmQgbG9va2luZyBhaGVhZFxuICAgYXQgbGVuZ3RoIGNvdW50cyB0byBkZXRlcm1pbmUgc3ViLXRhYmxlIHNpemVzIHdoZW4gYnVpbGRpbmcgdGhlXG4gICBkZWNvZGluZyB0YWJsZXMuXG4gICAqL1xuXG4gIC8qIGFjY3VtdWxhdGUgbGVuZ3RocyBmb3IgY29kZXMgKGFzc3VtZXMgbGVuc1tdIGFsbCBpbiAwLi5NQVhCSVRTKSAqL1xuICBmb3IgKGxlbiA9IDA7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGNvdW50W2xlbl0gPSAwO1xuICB9XG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgY291bnRbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rKztcbiAgfVxuXG4gIC8qIGJvdW5kIGNvZGUgbGVuZ3RocywgZm9yY2Ugcm9vdCB0byBiZSB3aXRoaW4gY29kZSBsZW5ndGhzICovXG4gIHJvb3QgPSBiaXRzO1xuICBmb3IgKG1heCA9IE1BWEJJVFM7IG1heCA+PSAxOyBtYXgtLSkge1xuICAgIGlmIChjb3VudFttYXhdICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPiBtYXgpIHtcbiAgICByb290ID0gbWF4O1xuICB9XG4gIGlmIChtYXggPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAvKiBubyBzeW1ib2xzIHRvIGNvZGUgYXQgYWxsICovXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0OyAgLy9oZXJlLm9wID0gKHZhciBjaGFyKTY0OyAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTsgICAvL2hlcmUuYml0cyA9ICh2YXIgY2hhcikxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwOyAgIC8vaGVyZS52YWwgPSAodmFyIHNob3J0KTA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0O1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuICAgIG9wdHMuYml0cyA9IDE7XG4gICAgcmV0dXJuIDA7ICAgICAvKiBubyBzeW1ib2xzLCBidXQgd2FpdCBmb3IgZGVjb2RpbmcgdG8gcmVwb3J0IGVycm9yICovXG4gIH1cbiAgZm9yIChtaW4gPSAxOyBtaW4gPCBtYXg7IG1pbisrKSB7XG4gICAgaWYgKGNvdW50W21pbl0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA8IG1pbikge1xuICAgIHJvb3QgPSBtaW47XG4gIH1cblxuICAvKiBjaGVjayBmb3IgYW4gb3Zlci1zdWJzY3JpYmVkIG9yIGluY29tcGxldGUgc2V0IG9mIGxlbmd0aHMgKi9cbiAgbGVmdCA9IDE7XG4gIGZvciAobGVuID0gMTsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgbGVmdCA8PD0gMTtcbiAgICBsZWZ0IC09IGNvdW50W2xlbl07XG4gICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSAgICAgICAgLyogb3Zlci1zdWJzY3JpYmVkICovXG4gIH1cbiAgaWYgKGxlZnQgPiAwICYmICh0eXBlID09PSBDT0RFUyB8fCBtYXggIT09IDEpKSB7XG4gICAgcmV0dXJuIC0xOyAgICAgICAgICAgICAgICAgICAgICAvKiBpbmNvbXBsZXRlIHNldCAqL1xuICB9XG5cbiAgLyogZ2VuZXJhdGUgb2Zmc2V0cyBpbnRvIHN5bWJvbCB0YWJsZSBmb3IgZWFjaCBsZW5ndGggZm9yIHNvcnRpbmcgKi9cbiAgb2Zmc1sxXSA9IDA7XG4gIGZvciAobGVuID0gMTsgbGVuIDwgTUFYQklUUzsgbGVuKyspIHtcbiAgICBvZmZzW2xlbiArIDFdID0gb2Zmc1tsZW5dICsgY291bnRbbGVuXTtcbiAgfVxuXG4gIC8qIHNvcnQgc3ltYm9scyBieSBsZW5ndGgsIGJ5IHN5bWJvbCBvcmRlciB3aXRoaW4gZWFjaCBsZW5ndGggKi9cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBpZiAobGVuc1tsZW5zX2luZGV4ICsgc3ltXSAhPT0gMCkge1xuICAgICAgd29ya1tvZmZzW2xlbnNbbGVuc19pbmRleCArIHN5bV1dKytdID0gc3ltO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICBDcmVhdGUgYW5kIGZpbGwgaW4gZGVjb2RpbmcgdGFibGVzLiAgSW4gdGhpcyBsb29wLCB0aGUgdGFibGUgYmVpbmdcbiAgIGZpbGxlZCBpcyBhdCBuZXh0IGFuZCBoYXMgY3VyciBpbmRleCBiaXRzLiAgVGhlIGNvZGUgYmVpbmcgdXNlZCBpcyBodWZmXG4gICB3aXRoIGxlbmd0aCBsZW4uICBUaGF0IGNvZGUgaXMgY29udmVydGVkIHRvIGFuIGluZGV4IGJ5IGRyb3BwaW5nIGRyb3BcbiAgIGJpdHMgb2ZmIG9mIHRoZSBib3R0b20uICBGb3IgY29kZXMgd2hlcmUgbGVuIGlzIGxlc3MgdGhhbiBkcm9wICsgY3VycixcbiAgIHRob3NlIHRvcCBkcm9wICsgY3VyciAtIGxlbiBiaXRzIGFyZSBpbmNyZW1lbnRlZCB0aHJvdWdoIGFsbCB2YWx1ZXMgdG9cbiAgIGZpbGwgdGhlIHRhYmxlIHdpdGggcmVwbGljYXRlZCBlbnRyaWVzLlxuXG4gICByb290IGlzIHRoZSBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgdGhlIHJvb3QgdGFibGUuICBXaGVuIGxlbiBleGNlZWRzXG4gICByb290LCBzdWItdGFibGVzIGFyZSBjcmVhdGVkIHBvaW50ZWQgdG8gYnkgdGhlIHJvb3QgZW50cnkgd2l0aCBhbiBpbmRleFxuICAgb2YgdGhlIGxvdyByb290IGJpdHMgb2YgaHVmZi4gIFRoaXMgaXMgc2F2ZWQgaW4gbG93IHRvIGNoZWNrIGZvciB3aGVuIGFcbiAgIG5ldyBzdWItdGFibGUgc2hvdWxkIGJlIHN0YXJ0ZWQuICBkcm9wIGlzIHplcm8gd2hlbiB0aGUgcm9vdCB0YWJsZSBpc1xuICAgYmVpbmcgZmlsbGVkLCBhbmQgZHJvcCBpcyByb290IHdoZW4gc3ViLXRhYmxlcyBhcmUgYmVpbmcgZmlsbGVkLlxuXG4gICBXaGVuIGEgbmV3IHN1Yi10YWJsZSBpcyBuZWVkZWQsIGl0IGlzIG5lY2Vzc2FyeSB0byBsb29rIGFoZWFkIGluIHRoZVxuICAgY29kZSBsZW5ndGhzIHRvIGRldGVybWluZSB3aGF0IHNpemUgc3ViLXRhYmxlIGlzIG5lZWRlZC4gIFRoZSBsZW5ndGhcbiAgIGNvdW50cyBhcmUgdXNlZCBmb3IgdGhpcywgYW5kIHNvIGNvdW50W10gaXMgZGVjcmVtZW50ZWQgYXMgY29kZXMgYXJlXG4gICBlbnRlcmVkIGluIHRoZSB0YWJsZXMuXG5cbiAgIHVzZWQga2VlcHMgdHJhY2sgb2YgaG93IG1hbnkgdGFibGUgZW50cmllcyBoYXZlIGJlZW4gYWxsb2NhdGVkIGZyb20gdGhlXG4gICBwcm92aWRlZCAqdGFibGUgc3BhY2UuICBJdCBpcyBjaGVja2VkIGZvciBMRU5TIGFuZCBESVNUIHRhYmxlcyBhZ2FpbnN0XG4gICB0aGUgY29uc3RhbnRzIEVOT1VHSF9MRU5TIGFuZCBFTk9VR0hfRElTVFMgdG8gZ3VhcmQgYWdhaW5zdCBjaGFuZ2VzIGluXG4gICB0aGUgaW5pdGlhbCByb290IHRhYmxlIHNpemUgY29uc3RhbnRzLiAgU2VlIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblxuICAgc3ltIGluY3JlbWVudHMgdGhyb3VnaCBhbGwgc3ltYm9scywgYW5kIHRoZSBsb29wIHRlcm1pbmF0ZXMgd2hlblxuICAgYWxsIGNvZGVzIG9mIGxlbmd0aCBtYXgsIGkuZS4gYWxsIGNvZGVzLCBoYXZlIGJlZW4gcHJvY2Vzc2VkLiAgVGhpc1xuICAgcm91dGluZSBwZXJtaXRzIGluY29tcGxldGUgY29kZXMsIHNvIGFub3RoZXIgbG9vcCBhZnRlciB0aGlzIG9uZSBmaWxsc1xuICAgaW4gdGhlIHJlc3Qgb2YgdGhlIGRlY29kaW5nIHRhYmxlcyB3aXRoIGludmFsaWQgY29kZSBtYXJrZXJzLlxuICAgKi9cblxuICAvKiBzZXQgdXAgZm9yIGNvZGUgdHlwZSAqL1xuICAvLyBwb29yIG1hbiBvcHRpbWl6YXRpb24gLSB1c2UgaWYtZWxzZSBpbnN0ZWFkIG9mIHN3aXRjaCxcbiAgLy8gdG8gYXZvaWQgZGVvcHRzIGluIG9sZCB2OFxuICBpZiAodHlwZSA9PT0gQ09ERVMpIHtcbiAgICBiYXNlID0gZXh0cmEgPSB3b3JrOyAgICAvKiBkdW1teSB2YWx1ZS0tbm90IHVzZWQgKi9cbiAgICBlbmQgPSAxOTtcblxuICB9IGVsc2UgaWYgKHR5cGUgPT09IExFTlMpIHtcbiAgICBiYXNlID0gbGJhc2U7XG4gICAgYmFzZV9pbmRleCAtPSAyNTc7XG4gICAgZXh0cmEgPSBsZXh0O1xuICAgIGV4dHJhX2luZGV4IC09IDI1NztcbiAgICBlbmQgPSAyNTY7XG5cbiAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgIC8qIERJU1RTICovXG4gICAgYmFzZSA9IGRiYXNlO1xuICAgIGV4dHJhID0gZGV4dDtcbiAgICBlbmQgPSAtMTtcbiAgfVxuXG4gIC8qIGluaXRpYWxpemUgb3B0cyBmb3IgbG9vcCAqL1xuICBodWZmID0gMDsgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSAqL1xuICBzeW0gPSAwOyAgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBzeW1ib2wgKi9cbiAgbGVuID0gbWluOyAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgbGVuZ3RoICovXG4gIG5leHQgPSB0YWJsZV9pbmRleDsgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgdG8gZmlsbCBpbiAqL1xuICBjdXJyID0gcm9vdDsgICAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSBpbmRleCBiaXRzICovXG4gIGRyb3AgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBjdXJyZW50IGJpdHMgdG8gZHJvcCBmcm9tIGNvZGUgZm9yIGluZGV4ICovXG4gIGxvdyA9IC0xOyAgICAgICAgICAgICAgICAgICAvKiB0cmlnZ2VyIG5ldyBzdWItdGFibGUgd2hlbiBsZW4gPiByb290ICovXG4gIHVzZWQgPSAxIDw8IHJvb3Q7ICAgICAgICAgIC8qIHVzZSByb290IHRhYmxlIGVudHJpZXMgKi9cbiAgbWFzayA9IHVzZWQgLSAxOyAgICAgICAgICAgIC8qIG1hc2sgZm9yIGNvbXBhcmluZyBsb3cgKi9cblxuICAvKiBjaGVjayBhdmFpbGFibGUgdGFibGUgc3BhY2UgKi9cbiAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8qIHByb2Nlc3MgYWxsIGNvZGVzIGFuZCBtYWtlIHRhYmxlIGVudHJpZXMgKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIGNyZWF0ZSB0YWJsZSBlbnRyeSAqL1xuICAgIGhlcmVfYml0cyA9IGxlbiAtIGRyb3A7XG4gICAgaWYgKHdvcmtbc3ltXSA8IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IDA7XG4gICAgICBoZXJlX3ZhbCA9IHdvcmtbc3ltXTtcbiAgICB9XG4gICAgZWxzZSBpZiAod29ya1tzeW1dID4gZW5kKSB7XG4gICAgICBoZXJlX29wID0gZXh0cmFbZXh0cmFfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgICAgaGVyZV92YWwgPSBiYXNlW2Jhc2VfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGhlcmVfb3AgPSAzMiArIDY0OyAgICAgICAgIC8qIGVuZCBvZiBibG9jayAqL1xuICAgICAgaGVyZV92YWwgPSAwO1xuICAgIH1cblxuICAgIC8qIHJlcGxpY2F0ZSBmb3IgdGhvc2UgaW5kaWNlcyB3aXRoIGxvdyBsZW4gYml0cyBlcXVhbCB0byBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIGRyb3ApO1xuICAgIGZpbGwgPSAxIDw8IGN1cnI7XG4gICAgbWluID0gZmlsbDsgICAgICAgICAgICAgICAgIC8qIHNhdmUgb2Zmc2V0IHRvIG5leHQgdGFibGUgKi9cbiAgICBkbyB7XG4gICAgICBmaWxsIC09IGluY3I7XG4gICAgICB0YWJsZVtuZXh0ICsgKGh1ZmYgPj4gZHJvcCkgKyBmaWxsXSA9IChoZXJlX2JpdHMgPDwgMjQpIHwgKGhlcmVfb3AgPDwgMTYpIHwgaGVyZV92YWwgfDA7XG4gICAgfSB3aGlsZSAoZmlsbCAhPT0gMCk7XG5cbiAgICAvKiBiYWNrd2FyZHMgaW5jcmVtZW50IHRoZSBsZW4tYml0IGNvZGUgaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSAxKTtcbiAgICB3aGlsZSAoaHVmZiAmIGluY3IpIHtcbiAgICAgIGluY3IgPj49IDE7XG4gICAgfVxuICAgIGlmIChpbmNyICE9PSAwKSB7XG4gICAgICBodWZmICY9IGluY3IgLSAxO1xuICAgICAgaHVmZiArPSBpbmNyO1xuICAgIH0gZWxzZSB7XG4gICAgICBodWZmID0gMDtcbiAgICB9XG5cbiAgICAvKiBnbyB0byBuZXh0IHN5bWJvbCwgdXBkYXRlIGNvdW50LCBsZW4gKi9cbiAgICBzeW0rKztcbiAgICBpZiAoLS1jb3VudFtsZW5dID09PSAwKSB7XG4gICAgICBpZiAobGVuID09PSBtYXgpIHsgYnJlYWs7IH1cbiAgICAgIGxlbiA9IGxlbnNbbGVuc19pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuXG4gICAgLyogY3JlYXRlIG5ldyBzdWItdGFibGUgaWYgbmVlZGVkICovXG4gICAgaWYgKGxlbiA+IHJvb3QgJiYgKGh1ZmYgJiBtYXNrKSAhPT0gbG93KSB7XG4gICAgICAvKiBpZiBmaXJzdCB0aW1lLCB0cmFuc2l0aW9uIHRvIHN1Yi10YWJsZXMgKi9cbiAgICAgIGlmIChkcm9wID09PSAwKSB7XG4gICAgICAgIGRyb3AgPSByb290O1xuICAgICAgfVxuXG4gICAgICAvKiBpbmNyZW1lbnQgcGFzdCBsYXN0IHRhYmxlICovXG4gICAgICBuZXh0ICs9IG1pbjsgICAgICAgICAgICAvKiBoZXJlIG1pbiBpcyAxIDw8IGN1cnIgKi9cblxuICAgICAgLyogZGV0ZXJtaW5lIGxlbmd0aCBvZiBuZXh0IHRhYmxlICovXG4gICAgICBjdXJyID0gbGVuIC0gZHJvcDtcbiAgICAgIGxlZnQgPSAxIDw8IGN1cnI7XG4gICAgICB3aGlsZSAoY3VyciArIGRyb3AgPCBtYXgpIHtcbiAgICAgICAgbGVmdCAtPSBjb3VudFtjdXJyICsgZHJvcF07XG4gICAgICAgIGlmIChsZWZ0IDw9IDApIHsgYnJlYWs7IH1cbiAgICAgICAgY3VycisrO1xuICAgICAgICBsZWZ0IDw8PSAxO1xuICAgICAgfVxuXG4gICAgICAvKiBjaGVjayBmb3IgZW5vdWdoIHNwYWNlICovXG4gICAgICB1c2VkICs9IDEgPDwgY3VycjtcbiAgICAgIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgLyogcG9pbnQgZW50cnkgaW4gcm9vdCB0YWJsZSB0byBzdWItdGFibGUgKi9cbiAgICAgIGxvdyA9IGh1ZmYgJiBtYXNrO1xuICAgICAgLyp0YWJsZS5vcFtsb3ddID0gY3VycjtcbiAgICAgIHRhYmxlLmJpdHNbbG93XSA9IHJvb3Q7XG4gICAgICB0YWJsZS52YWxbbG93XSA9IG5leHQgLSBvcHRzLnRhYmxlX2luZGV4OyovXG4gICAgICB0YWJsZVtsb3ddID0gKHJvb3QgPDwgMjQpIHwgKGN1cnIgPDwgMTYpIHwgKG5leHQgLSB0YWJsZV9pbmRleCkgfDA7XG4gICAgfVxuICB9XG5cbiAgLyogZmlsbCBpbiByZW1haW5pbmcgdGFibGUgZW50cnkgaWYgY29kZSBpcyBpbmNvbXBsZXRlIChndWFyYW50ZWVkIHRvIGhhdmVcbiAgIGF0IG1vc3Qgb25lIHJlbWFpbmluZyBlbnRyeSwgc2luY2UgaWYgdGhlIGNvZGUgaXMgaW5jb21wbGV0ZSwgdGhlXG4gICBtYXhpbXVtIGNvZGUgbGVuZ3RoIHRoYXQgd2FzIGFsbG93ZWQgdG8gZ2V0IHRoaXMgZmFyIGlzIG9uZSBiaXQpICovXG4gIGlmIChodWZmICE9PSAwKSB7XG4gICAgLy90YWJsZS5vcFtuZXh0ICsgaHVmZl0gPSA2NDsgICAgICAgICAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW25leHQgKyBodWZmXSA9IGxlbiAtIGRyb3A7XG4gICAgLy90YWJsZS52YWxbbmV4dCArIGh1ZmZdID0gMDtcbiAgICB0YWJsZVtuZXh0ICsgaHVmZl0gPSAoKGxlbiAtIGRyb3ApIDw8IDI0KSB8ICg2NCA8PCAxNikgfDA7XG4gIH1cblxuICAvKiBzZXQgcmV0dXJuIHBhcmFtZXRlcnMgKi9cbiAgLy9vcHRzLnRhYmxlX2luZGV4ICs9IHVzZWQ7XG4gIG9wdHMuYml0cyA9IHJvb3Q7XG4gIHJldHVybiAwO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBTZWUgc3RhdGUgZGVmcyBmcm9tIGluZmxhdGUuanNcbnZhciBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG5cbi8qXG4gICBEZWNvZGUgbGl0ZXJhbCwgbGVuZ3RoLCBhbmQgZGlzdGFuY2UgY29kZXMgYW5kIHdyaXRlIG91dCB0aGUgcmVzdWx0aW5nXG4gICBsaXRlcmFsIGFuZCBtYXRjaCBieXRlcyB1bnRpbCBlaXRoZXIgbm90IGVub3VnaCBpbnB1dCBvciBvdXRwdXQgaXNcbiAgIGF2YWlsYWJsZSwgYW4gZW5kLW9mLWJsb2NrIGlzIGVuY291bnRlcmVkLCBvciBhIGRhdGEgZXJyb3IgaXMgZW5jb3VudGVyZWQuXG4gICBXaGVuIGxhcmdlIGVub3VnaCBpbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgYXJlIHN1cHBsaWVkIHRvIGluZmxhdGUoKSwgZm9yXG4gICBleGFtcGxlLCBhIDE2SyBpbnB1dCBidWZmZXIgYW5kIGEgNjRLIG91dHB1dCBidWZmZXIsIG1vcmUgdGhhbiA5NSUgb2YgdGhlXG4gICBpbmZsYXRlIGV4ZWN1dGlvbiB0aW1lIGlzIHNwZW50IGluIHRoaXMgcm91dGluZS5cblxuICAgRW50cnkgYXNzdW1wdGlvbnM6XG5cbiAgICAgICAgc3RhdGUubW9kZSA9PT0gTEVOXG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPj0gNlxuICAgICAgICBzdHJtLmF2YWlsX291dCA+PSAyNThcbiAgICAgICAgc3RhcnQgPj0gc3RybS5hdmFpbF9vdXRcbiAgICAgICAgc3RhdGUuYml0cyA8IDhcblxuICAgT24gcmV0dXJuLCBzdGF0ZS5tb2RlIGlzIG9uZSBvZjpcblxuICAgICAgICBMRU4gLS0gcmFuIG91dCBvZiBlbm91Z2ggb3V0cHV0IHNwYWNlIG9yIGVub3VnaCBhdmFpbGFibGUgaW5wdXRcbiAgICAgICAgVFlQRSAtLSByZWFjaGVkIGVuZCBvZiBibG9jayBjb2RlLCBpbmZsYXRlKCkgdG8gaW50ZXJwcmV0IG5leHQgYmxvY2tcbiAgICAgICAgQkFEIC0tIGVycm9yIGluIGJsb2NrIGRhdGFcblxuICAgTm90ZXM6XG5cbiAgICAtIFRoZSBtYXhpbXVtIGlucHV0IGJpdHMgdXNlZCBieSBhIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGlzIDE1IGJpdHMgZm9yIHRoZVxuICAgICAgbGVuZ3RoIGNvZGUsIDUgYml0cyBmb3IgdGhlIGxlbmd0aCBleHRyYSwgMTUgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGNvZGUsXG4gICAgICBhbmQgMTMgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGV4dHJhLiAgVGhpcyB0b3RhbHMgNDggYml0cywgb3Igc2l4IGJ5dGVzLlxuICAgICAgVGhlcmVmb3JlIGlmIHN0cm0uYXZhaWxfaW4gPj0gNiwgdGhlbiB0aGVyZSBpcyBlbm91Z2ggaW5wdXQgdG8gYXZvaWRcbiAgICAgIGNoZWNraW5nIGZvciBhdmFpbGFibGUgaW5wdXQgd2hpbGUgZGVjb2RpbmcuXG5cbiAgICAtIFRoZSBtYXhpbXVtIGJ5dGVzIHRoYXQgYSBzaW5nbGUgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgY2FuIG91dHB1dCBpcyAyNThcbiAgICAgIGJ5dGVzLCB3aGljaCBpcyB0aGUgbWF4aW11bSBsZW5ndGggdGhhdCBjYW4gYmUgY29kZWQuICBpbmZsYXRlX2Zhc3QoKVxuICAgICAgcmVxdWlyZXMgc3RybS5hdmFpbF9vdXQgPj0gMjU4IGZvciBlYWNoIGxvb3AgdG8gYXZvaWQgY2hlY2tpbmcgZm9yXG4gICAgICBvdXRwdXQgc3BhY2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV9mYXN0KHN0cm0sIHN0YXJ0KSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIF9pbjsgICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaW5wdXQgKi9cbiAgdmFyIGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIGhhdmUgZW5vdWdoIGlucHV0IHdoaWxlIGluIDwgbGFzdCAqL1xuICB2YXIgX291dDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGJlZzsgICAgICAgICAgICAgICAgICAgIC8qIGluZmxhdGUoKSdzIGluaXRpYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHdoaWxlIG91dCA8IGVuZCwgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSAqL1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgdmFyIGRtYXg7ICAgICAgICAgICAgICAgICAgIC8qIG1heGltdW0gZGlzdGFuY2UgZnJvbSB6bGliIGhlYWRlciAqL1xuLy8jZW5kaWZcbiAgdmFyIHdzaXplOyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB2YXIgd2hhdmU7ICAgICAgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB2YXIgd25leHQ7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIC8vIFVzZSBgc193aW5kb3dgIGluc3RlYWQgYHdpbmRvd2AsIGF2b2lkIGNvbmZsaWN0IHdpdGggaW5zdHJ1bWVudGF0aW9uIHRvb2xzXG4gIHZhciBzX3dpbmRvdzsgICAgICAgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIHdzaXplICE9IDAgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaG9sZCAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5iaXRzICovXG4gIHZhciBsY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmxlbmNvZGUgKi9cbiAgdmFyIGRjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uZGlzdGNvZGUgKi9cbiAgdmFyIGxtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGxlbmd0aCBjb2RlcyAqL1xuICB2YXIgZG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgZGlzdGFuY2UgY29kZXMgKi9cbiAgdmFyIGhlcmU7ICAgICAgICAgICAgICAgICAgIC8qIHJldHJpZXZlZCB0YWJsZSBlbnRyeSAqL1xuICB2YXIgb3A7ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBiaXRzLCBvcGVyYXRpb24sIGV4dHJhIGJpdHMsIG9yICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgd2luZG93IHBvc2l0aW9uLCB3aW5kb3cgYnl0ZXMgdG8gY29weSAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoLCB1bnVzZWQgYnl0ZXMgKi9cbiAgdmFyIGRpc3Q7ICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGRpc3RhbmNlICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuXG5cbiAgdmFyIGlucHV0LCBvdXRwdXQ7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcblxuICAvKiBjb3B5IHN0YXRlIHRvIGxvY2FsIHZhcmlhYmxlcyAqL1xuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIC8vaGVyZSA9IHN0YXRlLmhlcmU7XG4gIF9pbiA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBsYXN0ID0gX2luICsgKHN0cm0uYXZhaWxfaW4gLSA1KTtcbiAgX291dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBiZWcgPSBfb3V0IC0gKHN0YXJ0IC0gc3RybS5hdmFpbF9vdXQpO1xuICBlbmQgPSBfb3V0ICsgKHN0cm0uYXZhaWxfb3V0IC0gMjU3KTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIGRtYXggPSBzdGF0ZS5kbWF4O1xuLy8jZW5kaWZcbiAgd3NpemUgPSBzdGF0ZS53c2l6ZTtcbiAgd2hhdmUgPSBzdGF0ZS53aGF2ZTtcbiAgd25leHQgPSBzdGF0ZS53bmV4dDtcbiAgc193aW5kb3cgPSBzdGF0ZS53aW5kb3c7XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgbGNvZGUgPSBzdGF0ZS5sZW5jb2RlO1xuICBkY29kZSA9IHN0YXRlLmRpc3Rjb2RlO1xuICBsbWFzayA9ICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMTtcbiAgZG1hc2sgPSAoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxO1xuXG5cbiAgLyogZGVjb2RlIGxpdGVyYWxzIGFuZCBsZW5ndGgvZGlzdGFuY2VzIHVudGlsIGVuZC1vZi1ibG9jayBvciBub3QgZW5vdWdoXG4gICAgIGlucHV0IGRhdGEgb3Igb3V0cHV0IHNwYWNlICovXG5cbiAgdG9wOlxuICBkbyB7XG4gICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgfVxuXG4gICAgaGVyZSA9IGxjb2RlW2hvbGQgJiBsbWFza107XG5cbiAgICBkb2xlbjpcbiAgICBmb3IgKDs7KSB7IC8vIEdvdG8gZW11bGF0aW9uXG4gICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgIGJpdHMgLT0gb3A7XG4gICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG4gICAgICBpZiAob3AgPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxpdGVyYWwgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgb3V0cHV0W19vdXQrK10gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBiYXNlICovXG4gICAgICAgIGxlbiA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgIGlmIChvcCkge1xuICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbiArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIGxlbikpO1xuICAgICAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgaGVyZSA9IGRjb2RlW2hvbGQgJiBkbWFza107XG5cbiAgICAgICAgZG9kaXN0OlxuICAgICAgICBmb3IgKDs7KSB7IC8vIGdvdG8gZW11bGF0aW9uXG4gICAgICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuXG4gICAgICAgICAgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFzZSAqL1xuICAgICAgICAgICAgZGlzdCA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXN0ICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICAgICAgaWYgKGRpc3QgPiBkbWF4KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIGRpc3QpKTtcbiAgICAgICAgICAgIG9wID0gX291dCAtIGJlZzsgICAgICAgICAgICAgICAgLyogbWF4IGRpc3RhbmNlIGluIG91dHB1dCAqL1xuICAgICAgICAgICAgaWYgKGRpc3QgPiBvcCkgeyAgICAgICAgICAgICAgICAvKiBzZWUgaWYgY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBvcCA9IGRpc3QgLSBvcDsgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBpZiAob3AgPiB3aGF2ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgICAgICAgaWYgKGxlbiA8PSBvcCAtIHdoYXZlKSB7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgbGVuIC09IG9wIC0gd2hhdmU7XG4vLyAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3AgPiB3aGF2ZSk7XG4vLyAgICAgICAgICAgICAgICBpZiAob3AgPT09IDApIHtcbi8vICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0O1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZyb20gPSAwOyAvLyB3aW5kb3cgaW5kZXhcbiAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBzX3dpbmRvdztcbiAgICAgICAgICAgICAgaWYgKHduZXh0ID09PSAwKSB7ICAgICAgICAgICAvKiB2ZXJ5IGNvbW1vbiBjYXNlICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAod25leHQgPCBvcCkgeyAgICAgIC8qIHdyYXAgYXJvdW5kIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgKyB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIG9wIC09IHduZXh0O1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSBlbmQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IDA7XG4gICAgICAgICAgICAgICAgICBpZiAod25leHQgPCBsZW4pIHsgIC8qIHNvbWUgZnJvbSBzdGFydCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgICAgb3AgPSB3bmV4dDtcbiAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAvKiBjb250aWd1b3VzIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdoaWxlIChsZW4gPiAyKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAgICAgLyogY29weSBkaXJlY3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgIC8qIG1pbmltdW0gbGVuZ3RoIGlzIHRocmVlICovXG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiA+IDIpO1xuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgIC8qIDJuZCBsZXZlbCBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgICAgICBoZXJlID0gZGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgICAgIGNvbnRpbnVlIGRvZGlzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgICAgIC8qIDJuZCBsZXZlbCBsZW5ndGggY29kZSAqL1xuICAgICAgICBoZXJlID0gbGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgY29udGludWUgZG9sZW47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDMyKSB7ICAgICAgICAgICAgICAgICAgICAgLyogZW5kLW9mLWJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgfVxuICB9IHdoaWxlIChfaW4gPCBsYXN0ICYmIF9vdXQgPCBlbmQpO1xuXG4gIC8qIHJldHVybiB1bnVzZWQgYnl0ZXMgKG9uIGVudHJ5LCBiaXRzIDwgOCwgc28gaW4gd29uJ3QgZ28gdG9vIGZhciBiYWNrKSAqL1xuICBsZW4gPSBiaXRzID4+IDM7XG4gIF9pbiAtPSBsZW47XG4gIGJpdHMgLT0gbGVuIDw8IDM7XG4gIGhvbGQgJj0gKDEgPDwgYml0cykgLSAxO1xuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmV0dXJuICovXG4gIHN0cm0ubmV4dF9pbiA9IF9pbjtcbiAgc3RybS5uZXh0X291dCA9IF9vdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSAoX2luIDwgbGFzdCA/IDUgKyAobGFzdCAtIF9pbikgOiA1IC0gKF9pbiAtIGxhc3QpKTtcbiAgc3RybS5hdmFpbF9vdXQgPSAoX291dCA8IGVuZCA/IDI1NyArIChlbmQgLSBfb3V0KSA6IDI1NyAtIChfb3V0IC0gZW5kKSk7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgcmV0dXJuO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgICAgICAgICA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xudmFyIGFkbGVyMzIgICAgICAgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgICAgICAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIGluZmxhdGVfZmFzdCAgPSByZXF1aXJlKCcuL2luZmZhc3QnKTtcbnZhciBpbmZsYXRlX3RhYmxlID0gcmVxdWlyZSgnLi9pbmZ0cmVlcycpO1xuXG52YXIgQ09ERVMgPSAwO1xudmFyIExFTlMgPSAxO1xudmFyIERJU1RTID0gMjtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuLy92YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbi8vdmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xuLy92YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xudmFyIFpfQkxPQ0sgICAgICAgICA9IDU7XG52YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG52YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xudmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SICAgICA9IC01O1xuLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7XG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuXG4vKiBTVEFURVMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgICAgSEVBRCA9IDE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1hZ2ljIGhlYWRlciAqL1xudmFyICAgIEZMQUdTID0gMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtZXRob2QgYW5kIGZsYWdzIChnemlwKSAqL1xudmFyICAgIFRJTUUgPSAzOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtb2RpZmljYXRpb24gdGltZSAoZ3ppcCkgKi9cbnZhciAgICBPUyA9IDQ7ICAgICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgZmxhZ3MgYW5kIG9wZXJhdGluZyBzeXN0ZW0gKGd6aXApICovXG52YXIgICAgRVhMRU4gPSA1OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGxlbmd0aCAoZ3ppcCkgKi9cbnZhciAgICBFWFRSQSA9IDY7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgYnl0ZXMgKGd6aXApICovXG52YXIgICAgTkFNRSA9IDc7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBmaWxlIG5hbWUgKGd6aXApICovXG52YXIgICAgQ09NTUVOVCA9IDg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBjb21tZW50IChnemlwKSAqL1xudmFyICAgIEhDUkMgPSA5OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBoZWFkZXIgY3JjIChnemlwKSAqL1xudmFyICAgIERJQ1RJRCA9IDEwOyAgICAvKiBpOiB3YWl0aW5nIGZvciBkaWN0aW9uYXJ5IGNoZWNrIHZhbHVlICovXG52YXIgICAgRElDVCA9IDExOyAgICAgIC8qIHdhaXRpbmcgZm9yIGluZmxhdGVTZXREaWN0aW9uYXJ5KCkgY2FsbCAqL1xudmFyICAgICAgICBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xudmFyICAgICAgICBUWVBFRE8gPSAxMzsgICAgLyogaTogc2FtZSwgYnV0IHNraXAgY2hlY2sgdG8gZXhpdCBpbmZsYXRlIG9uIG5ldyBibG9jayAqL1xudmFyICAgICAgICBTVE9SRUQgPSAxNDsgICAgLyogaTogd2FpdGluZyBmb3Igc3RvcmVkIHNpemUgKGxlbmd0aCBhbmQgY29tcGxlbWVudCkgKi9cbnZhciAgICAgICAgQ09QWV8gPSAxNTsgICAgIC8qIGkvbzogc2FtZSBhcyBDT1BZIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgICAgICAgIENPUFkgPSAxNjsgICAgICAvKiBpL286IHdhaXRpbmcgZm9yIGlucHV0IG9yIG91dHB1dCB0byBjb3B5IHN0b3JlZCBibG9jayAqL1xudmFyICAgICAgICBUQUJMRSA9IDE3OyAgICAgLyogaTogd2FpdGluZyBmb3IgZHluYW1pYyBibG9jayB0YWJsZSBsZW5ndGhzICovXG52YXIgICAgICAgIExFTkxFTlMgPSAxODsgICAvKiBpOiB3YWl0aW5nIGZvciBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgQ09ERUxFTlMgPSAxOTsgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQgYW5kIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xudmFyICAgICAgICAgICAgTEVOXyA9IDIwOyAgICAgIC8qIGk6IHNhbWUgYXMgTEVOIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgICAgICAgICAgICBMRU4gPSAyMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdC9lb2IgY29kZSAqL1xudmFyICAgICAgICAgICAgTEVORVhUID0gMjI7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aCBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBESVNUID0gMjM7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgY29kZSAqL1xudmFyICAgICAgICAgICAgRElTVEVYVCA9IDI0OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGV4dHJhIGJpdHMgKi9cbnZhciAgICAgICAgICAgIE1BVENIID0gMjU7ICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gY29weSBzdHJpbmcgKi9cbnZhciAgICAgICAgICAgIExJVCA9IDI2OyAgICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gd3JpdGUgbGl0ZXJhbCAqL1xudmFyICAgIENIRUNLID0gMjc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgY2hlY2sgdmFsdWUgKi9cbnZhciAgICBMRU5HVEggPSAyODsgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGxlbmd0aCAoZ3ppcCkgKi9cbnZhciAgICBET05FID0gMjk7ICAgICAgLyogZmluaXNoZWQgY2hlY2ssIGRvbmUgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIE1FTSA9IDMxOyAgICAgICAvKiBnb3QgYW4gaW5mbGF0ZSgpIG1lbW9yeSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIFNZTkMgPSAzMjsgICAgICAvKiBsb29raW5nIGZvciBzeW5jaHJvbml6YXRpb24gYnl0ZXMgdG8gcmVzdGFydCBpbmZsYXRlKCkgKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5cbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAgKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9XQklUUyA9IE1BWF9XQklUUztcblxuXG5mdW5jdGlvbiB6c3dhcDMyKHEpIHtcbiAgcmV0dXJuICAoKChxID4+PiAyNCkgJiAweGZmKSArXG4gICAgICAgICAgKChxID4+PiA4KSAmIDB4ZmYwMCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYwMCkgPDwgOCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYpIDw8IDI0KSk7XG59XG5cblxuZnVuY3Rpb24gSW5mbGF0ZVN0YXRlKCkge1xuICB0aGlzLm1vZGUgPSAwOyAgICAgICAgICAgICAvKiBjdXJyZW50IGluZmxhdGUgbW9kZSAqL1xuICB0aGlzLmxhc3QgPSBmYWxzZTsgICAgICAgICAgLyogdHJ1ZSBpZiBwcm9jZXNzaW5nIGxhc3QgYmxvY2sgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5oYXZlZGljdCA9IGZhbHNlOyAgICAgIC8qIHRydWUgaWYgZGljdGlvbmFyeSBwcm92aWRlZCAqL1xuICB0aGlzLmZsYWdzID0gMDsgICAgICAgICAgICAgLyogZ3ppcCBoZWFkZXIgbWV0aG9kIGFuZCBmbGFncyAoMCBpZiB6bGliKSAqL1xuICB0aGlzLmRtYXggPSAwOyAgICAgICAgICAgICAgLyogemxpYiBoZWFkZXIgbWF4IGRpc3RhbmNlIChJTkZMQVRFX1NUUklDVCkgKi9cbiAgdGhpcy5jaGVjayA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIGNoZWNrIHZhbHVlICovXG4gIHRoaXMudG90YWwgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBvdXRwdXQgY291bnQgKi9cbiAgLy8gVE9ETzogbWF5IGJlIHt9XG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgICAgICAgICAvKiB3aGVyZSB0byBzYXZlIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uICovXG5cbiAgLyogc2xpZGluZyB3aW5kb3cgKi9cbiAgdGhpcy53Yml0cyA9IDA7ICAgICAgICAgICAgIC8qIGxvZyBiYXNlIDIgb2YgcmVxdWVzdGVkIHdpbmRvdyBzaXplICovXG4gIHRoaXMud3NpemUgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdGhpcy53aGF2ZSA9IDA7ICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdGhpcy53bmV4dCA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICB0aGlzLndpbmRvdyA9IG51bGw7ICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiBuZWVkZWQgKi9cblxuICAvKiBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5ob2xkID0gMDsgICAgICAgICAgICAgIC8qIGlucHV0IGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmJpdHMgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGJpdHMgaW4gXCJpblwiICovXG5cbiAgLyogZm9yIHN0cmluZyBhbmQgc3RvcmVkIGJsb2NrIGNvcHlpbmcgKi9cbiAgdGhpcy5sZW5ndGggPSAwOyAgICAgICAgICAgIC8qIGxpdGVyYWwgb3IgbGVuZ3RoIG9mIGRhdGEgdG8gY29weSAqL1xuICB0aGlzLm9mZnNldCA9IDA7ICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayB0byBjb3B5IHN0cmluZyBmcm9tICovXG5cbiAgLyogZm9yIHRhYmxlIGFuZCBjb2RlIGRlY29kaW5nICovXG4gIHRoaXMuZXh0cmEgPSAwOyAgICAgICAgICAgICAvKiBleHRyYSBiaXRzIG5lZWRlZCAqL1xuXG4gIC8qIGZpeGVkIGFuZCBkeW5hbWljIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuY29kZSA9IG51bGw7ICAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAqL1xuICB0aGlzLmRpc3Rjb2RlID0gbnVsbDsgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKi9cbiAgdGhpcy5sZW5iaXRzID0gMDsgICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGxlbmNvZGUgKi9cbiAgdGhpcy5kaXN0Yml0cyA9IDA7ICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGRpc3Rjb2RlICovXG5cbiAgLyogZHluYW1pYyB0YWJsZSBidWlsZGluZyAqL1xuICB0aGlzLm5jb2RlID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5sZW4gPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5uZGlzdCA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5oYXZlID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aHMgaW4gbGVuc1tdICovXG4gIHRoaXMubmV4dCA9IG51bGw7ICAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiBjb2Rlc1tdICovXG5cbiAgdGhpcy5sZW5zID0gbmV3IHV0aWxzLkJ1ZjE2KDMyMCk7IC8qIHRlbXBvcmFyeSBzdG9yYWdlIGZvciBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy53b3JrID0gbmV3IHV0aWxzLkJ1ZjE2KDI4OCk7IC8qIHdvcmsgYXJlYSBmb3IgY29kZSB0YWJsZSBidWlsZGluZyAqL1xuXG4gIC8qXG4gICBiZWNhdXNlIHdlIGRvbid0IGhhdmUgcG9pbnRlcnMgaW4ganMsIHdlIHVzZSBsZW5jb2RlIGFuZCBkaXN0Y29kZSBkaXJlY3RseVxuICAgYXMgYnVmZmVycyBzbyB3ZSBkb24ndCBuZWVkIGNvZGVzXG4gICovXG4gIC8vdGhpcy5jb2RlcyA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0gpOyAgICAgICAvKiBzcGFjZSBmb3IgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5keW4gPSBudWxsOyAgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLmRpc3RkeW4gPSBudWxsOyAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuc2FuZSA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGlmIGZhbHNlLCBhbGxvdyBpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgKi9cbiAgdGhpcy5iYWNrID0gMDsgICAgICAgICAgICAgICAgICAgLyogYml0cyBiYWNrIG9mIGxhc3QgdW5wcm9jZXNzZWQgbGVuZ3RoL2xpdCAqL1xuICB0aGlzLndhcyA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBpbml0aWFsIGxlbmd0aCBvZiBtYXRjaCAqL1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSBzdGF0ZS50b3RhbCA9IDA7XG4gIHN0cm0ubXNnID0gJyc7IC8qWl9OVUxMKi9cbiAgaWYgKHN0YXRlLndyYXApIHsgICAgICAgLyogdG8gc3VwcG9ydCBpbGwtY29uY2VpdmVkIEphdmEgdGVzdCBzdWl0ZSAqL1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS53cmFwICYgMTtcbiAgfVxuICBzdGF0ZS5tb2RlID0gSEVBRDtcbiAgc3RhdGUubGFzdCA9IDA7XG4gIHN0YXRlLmhhdmVkaWN0ID0gMDtcbiAgc3RhdGUuZG1heCA9IDMyNzY4O1xuICBzdGF0ZS5oZWFkID0gbnVsbC8qWl9OVUxMKi87XG4gIHN0YXRlLmhvbGQgPSAwO1xuICBzdGF0ZS5iaXRzID0gMDtcbiAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0xFTlMpO1xuICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0RJU1RTKTtcblxuICBzdGF0ZS5zYW5lID0gMTtcbiAgc3RhdGUuYmFjayA9IC0xO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IHJlc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RhdGUud3NpemUgPSAwO1xuICBzdGF0ZS53aGF2ZSA9IDA7XG4gIHN0YXRlLnduZXh0ID0gMDtcbiAgcmV0dXJuIGluZmxhdGVSZXNldEtlZXAoc3RybSk7XG5cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKSB7XG4gIHZhciB3cmFwO1xuICB2YXIgc3RhdGU7XG5cbiAgLyogZ2V0IHRoZSBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBleHRyYWN0IHdyYXAgcmVxdWVzdCBmcm9tIHdpbmRvd0JpdHMgcGFyYW1ldGVyICovXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkge1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuICBlbHNlIHtcbiAgICB3cmFwID0gKHdpbmRvd0JpdHMgPj4gNCkgKyAxO1xuICAgIGlmICh3aW5kb3dCaXRzIDwgNDgpIHtcbiAgICAgIHdpbmRvd0JpdHMgJj0gMTU7XG4gICAgfVxuICB9XG5cbiAgLyogc2V0IG51bWJlciBvZiB3aW5kb3cgYml0cywgZnJlZSB3aW5kb3cgaWYgZGlmZmVyZW50ICovXG4gIGlmICh3aW5kb3dCaXRzICYmICh3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUpKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIGlmIChzdGF0ZS53aW5kb3cgIT09IG51bGwgJiYgc3RhdGUud2JpdHMgIT09IHdpbmRvd0JpdHMpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXNldCB0aGUgcmVzdCBvZiBpdCAqL1xuICBzdGF0ZS53cmFwID0gd3JhcDtcbiAgc3RhdGUud2JpdHMgPSB3aW5kb3dCaXRzO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0KHN0cm0pO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgcmV0O1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICAvL3N0cm0ubXNnID0gWl9OVUxMOyAgICAgICAgICAgICAgICAgLyogaW4gY2FzZSB3ZSByZXR1cm4gYW4gZXJyb3IgKi9cblxuICBzdGF0ZSA9IG5ldyBJbmZsYXRlU3RhdGUoKTtcblxuICAvL2lmIChzdGF0ZSA9PT0gWl9OVUxMKSByZXR1cm4gWl9NRU1fRVJST1I7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogYWxsb2NhdGVkXFxuXCIpKTtcbiAgc3RybS5zdGF0ZSA9IHN0YXRlO1xuICBzdGF0ZS53aW5kb3cgPSBudWxsLypaX05VTEwqLztcbiAgcmV0ID0gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKTtcbiAgaWYgKHJldCAhPT0gWl9PSykge1xuICAgIHN0cm0uc3RhdGUgPSBudWxsLypaX05VTEwqLztcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdChzdHJtKSB7XG4gIHJldHVybiBpbmZsYXRlSW5pdDIoc3RybSwgREVGX1dCSVRTKTtcbn1cblxuXG4vKlxuIFJldHVybiBzdGF0ZSB3aXRoIGxlbmd0aCBhbmQgZGlzdGFuY2UgZGVjb2RpbmcgdGFibGVzIGFuZCBpbmRleCBzaXplcyBzZXQgdG9cbiBmaXhlZCBjb2RlIGRlY29kaW5nLiAgTm9ybWFsbHkgdGhpcyByZXR1cm5zIGZpeGVkIHRhYmxlcyBmcm9tIGluZmZpeGVkLmguXG4gSWYgQlVJTERGSVhFRCBpcyBkZWZpbmVkLCB0aGVuIGluc3RlYWQgdGhpcyByb3V0aW5lIGJ1aWxkcyB0aGUgdGFibGVzIHRoZVxuIGZpcnN0IHRpbWUgaXQncyBjYWxsZWQsIGFuZCByZXR1cm5zIHRob3NlIHRhYmxlcyB0aGUgZmlyc3QgdGltZSBhbmRcbiB0aGVyZWFmdGVyLiAgVGhpcyByZWR1Y2VzIHRoZSBzaXplIG9mIHRoZSBjb2RlIGJ5IGFib3V0IDJLIGJ5dGVzLCBpblxuIGV4Y2hhbmdlIGZvciBhIGxpdHRsZSBleGVjdXRpb24gdGltZS4gIEhvd2V2ZXIsIEJVSUxERklYRUQgc2hvdWxkIG5vdCBiZVxuIHVzZWQgZm9yIHRocmVhZGVkIGFwcGxpY2F0aW9ucywgc2luY2UgdGhlIHJld3JpdGluZyBvZiB0aGUgdGFibGVzIGFuZCB2aXJnaW5cbiBtYXkgbm90IGJlIHRocmVhZC1zYWZlLlxuICovXG52YXIgdmlyZ2luID0gdHJ1ZTtcblxudmFyIGxlbmZpeCwgZGlzdGZpeDsgLy8gV2UgaGF2ZSBubyBwb2ludGVycyBpbiBKUywgc28ga2VlcCB0YWJsZXMgc2VwYXJhdGVcblxuZnVuY3Rpb24gZml4ZWR0YWJsZXMoc3RhdGUpIHtcbiAgLyogYnVpbGQgZml4ZWQgaHVmZm1hbiB0YWJsZXMgaWYgZmlyc3QgY2FsbCAobWF5IG5vdCBiZSB0aHJlYWQgc2FmZSkgKi9cbiAgaWYgKHZpcmdpbikge1xuICAgIHZhciBzeW07XG5cbiAgICBsZW5maXggPSBuZXcgdXRpbHMuQnVmMzIoNTEyKTtcbiAgICBkaXN0Zml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDMyKTtcblxuICAgIC8qIGxpdGVyYWwvbGVuZ3RoIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMTQ0KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuICAgIHdoaWxlIChzeW0gPCAyNTYpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA5OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4MCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDc7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjg4KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuXG4gICAgaW5mbGF0ZV90YWJsZShMRU5TLCAgc3RhdGUubGVucywgMCwgMjg4LCBsZW5maXgsICAgMCwgc3RhdGUud29yaywgeyBiaXRzOiA5IH0pO1xuXG4gICAgLyogZGlzdGFuY2UgdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAzMikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDU7IH1cblxuICAgIGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIDAsIDMyLCAgIGRpc3RmaXgsIDAsIHN0YXRlLndvcmssIHsgYml0czogNSB9KTtcblxuICAgIC8qIGRvIHRoaXMganVzdCBvbmNlICovXG4gICAgdmlyZ2luID0gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5sZW5jb2RlID0gbGVuZml4O1xuICBzdGF0ZS5sZW5iaXRzID0gOTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBkaXN0Zml4O1xuICBzdGF0ZS5kaXN0Yml0cyA9IDU7XG59XG5cblxuLypcbiBVcGRhdGUgdGhlIHdpbmRvdyB3aXRoIHRoZSBsYXN0IHdzaXplIChub3JtYWxseSAzMkspIGJ5dGVzIHdyaXR0ZW4gYmVmb3JlXG4gcmV0dXJuaW5nLiAgSWYgd2luZG93IGRvZXMgbm90IGV4aXN0IHlldCwgY3JlYXRlIGl0LiAgVGhpcyBpcyBvbmx5IGNhbGxlZFxuIHdoZW4gYSB3aW5kb3cgaXMgYWxyZWFkeSBpbiB1c2UsIG9yIHdoZW4gb3V0cHV0IGhhcyBiZWVuIHdyaXR0ZW4gZHVyaW5nIHRoaXNcbiBpbmZsYXRlIGNhbGwsIGJ1dCB0aGUgZW5kIG9mIHRoZSBkZWZsYXRlIHN0cmVhbSBoYXMgbm90IGJlZW4gcmVhY2hlZCB5ZXQuXG4gSXQgaXMgYWxzbyBjYWxsZWQgdG8gY3JlYXRlIGEgd2luZG93IGZvciBkaWN0aW9uYXJ5IGRhdGEgd2hlbiBhIGRpY3Rpb25hcnlcbiBpcyBsb2FkZWQuXG5cbiBQcm92aWRpbmcgb3V0cHV0IGJ1ZmZlcnMgbGFyZ2VyIHRoYW4gMzJLIHRvIGluZmxhdGUoKSBzaG91bGQgcHJvdmlkZSBhIHNwZWVkXG4gYWR2YW50YWdlLCBzaW5jZSBvbmx5IHRoZSBsYXN0IDMySyBvZiBvdXRwdXQgaXMgY29waWVkIHRvIHRoZSBzbGlkaW5nIHdpbmRvd1xuIHVwb24gcmV0dXJuIGZyb20gaW5mbGF0ZSgpLCBhbmQgc2luY2UgYWxsIGRpc3RhbmNlcyBhZnRlciB0aGUgZmlyc3QgMzJLIG9mXG4gb3V0cHV0IHdpbGwgZmFsbCBpbiB0aGUgb3V0cHV0IGRhdGEsIG1ha2luZyBtYXRjaCBjb3BpZXMgc2ltcGxlciBhbmQgZmFzdGVyLlxuIFRoZSBhZHZhbnRhZ2UgbWF5IGJlIGRlcGVuZGVudCBvbiB0aGUgc2l6ZSBvZiB0aGUgcHJvY2Vzc29yJ3MgZGF0YSBjYWNoZXMuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZXdpbmRvdyhzdHJtLCBzcmMsIGVuZCwgY29weSkge1xuICB2YXIgZGlzdDtcbiAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBpZiBpdCBoYXNuJ3QgYmVlbiBkb25lIGFscmVhZHksIGFsbG9jYXRlIHNwYWNlIGZvciB0aGUgd2luZG93ICovXG4gIGlmIChzdGF0ZS53aW5kb3cgPT09IG51bGwpIHtcbiAgICBzdGF0ZS53c2l6ZSA9IDEgPDwgc3RhdGUud2JpdHM7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gMDtcblxuICAgIHN0YXRlLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHN0YXRlLndzaXplKTtcbiAgfVxuXG4gIC8qIGNvcHkgc3RhdGUtPndzaXplIG9yIGxlc3Mgb3V0cHV0IGJ5dGVzIGludG8gdGhlIGNpcmN1bGFyIHdpbmRvdyAqL1xuICBpZiAoY29weSA+PSBzdGF0ZS53c2l6ZSkge1xuICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBzdGF0ZS53c2l6ZSwgc3RhdGUud3NpemUsIDApO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICB9XG4gIGVsc2Uge1xuICAgIGRpc3QgPSBzdGF0ZS53c2l6ZSAtIHN0YXRlLnduZXh0O1xuICAgIGlmIChkaXN0ID4gY29weSkge1xuICAgICAgZGlzdCA9IGNvcHk7XG4gICAgfVxuICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93ICsgc3RhdGUtPnduZXh0LCBlbmQgLSBjb3B5LCBkaXN0KTtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgZGlzdCwgc3RhdGUud25leHQpO1xuICAgIGNvcHkgLT0gZGlzdDtcbiAgICBpZiAoY29weSkge1xuICAgICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3csIGVuZCAtIGNvcHksIGNvcHkpO1xuICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGNvcHksIDApO1xuICAgICAgc3RhdGUud25leHQgPSBjb3B5O1xuICAgICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzdGF0ZS53bmV4dCArPSBkaXN0O1xuICAgICAgaWYgKHN0YXRlLnduZXh0ID09PSBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53bmV4dCA9IDA7IH1cbiAgICAgIGlmIChzdGF0ZS53aGF2ZSA8IHN0YXRlLndzaXplKSB7IHN0YXRlLndoYXZlICs9IGRpc3Q7IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIHN0YXRlO1xuICB2YXIgaW5wdXQsIG91dHB1dDsgICAgICAgICAgLy8gaW5wdXQvb3V0cHV0IGJ1ZmZlcnNcbiAgdmFyIG5leHQ7ICAgICAgICAgICAgICAgICAgIC8qIG5leHQgaW5wdXQgSU5ERVggKi9cbiAgdmFyIHB1dDsgICAgICAgICAgICAgICAgICAgIC8qIG5leHQgb3V0cHV0IElOREVYICovXG4gIHZhciBoYXZlLCBsZWZ0OyAgICAgICAgICAgICAvKiBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogYml0IGJ1ZmZlciAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogYml0cyBpbiBiaXQgYnVmZmVyICovXG4gIHZhciBfaW4sIF9vdXQ7ICAgICAgICAgICAgICAvKiBzYXZlIHN0YXJ0aW5nIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIHZhciBjb3B5OyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2Ygc3RvcmVkIG9yIG1hdGNoIGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggYnl0ZXMgZnJvbSAqL1xuICB2YXIgZnJvbV9zb3VyY2U7XG4gIHZhciBoZXJlID0gMDsgICAgICAgICAgICAgICAvKiBjdXJyZW50IGRlY29kaW5nIHRhYmxlIGVudHJ5ICovXG4gIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsOyAvLyBwYWtlZCBcImhlcmVcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICAvL3ZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBwYXJlbnQgdGFibGUgZW50cnkgKi9cbiAgdmFyIGxhc3RfYml0cywgbGFzdF9vcCwgbGFzdF92YWw7IC8vIHBha2VkIFwibGFzdFwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggdG8gY29weSBmb3IgcmVwZWF0cywgYml0cyB0byBkcm9wICovXG4gIHZhciByZXQ7ICAgICAgICAgICAgICAgICAgICAvKiByZXR1cm4gY29kZSAqL1xuICB2YXIgaGJ1ZiA9IG5ldyB1dGlscy5CdWY4KDQpOyAgICAvKiBidWZmZXIgZm9yIGd6aXAgaGVhZGVyIGNyYyBjYWxjdWxhdGlvbiAqL1xuICB2YXIgb3B0cztcblxuICB2YXIgbjsgLy8gdGVtcG9yYXJ5IHZhciBmb3IgTkVFRF9CSVRTXG5cbiAgdmFyIG9yZGVyID0gLyogcGVybXV0YXRpb24gb2YgY29kZSBsZW5ndGhzICovXG4gICAgWyAxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1IF07XG5cblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHwgIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7IHN0YXRlLm1vZGUgPSBUWVBFRE87IH0gICAgLyogc2tpcCBjaGVjayAqL1xuXG5cbiAgLy8tLS0gTE9BRCgpIC0tLVxuICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIC8vLS0tXG5cbiAgX2luID0gaGF2ZTtcbiAgX291dCA9IGxlZnQ7XG4gIHJldCA9IFpfT0s7XG5cbiAgaW5mX2xlYXZlOiAvLyBnb3RvIGVtdWxhdGlvblxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChzdGF0ZS5tb2RlKSB7XG4gICAgICBjYXNlIEhFQUQ6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEVETztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChzdGF0ZS53cmFwICYgMikgJiYgaG9sZCA9PT0gMHg4YjFmKSB7ICAvKiBnemlwIGhlYWRlciAqL1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gMC8qY3JjMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuXG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubW9kZSA9IEZMQUdTO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmZsYWdzID0gMDsgICAgICAgICAgIC8qIGV4cGVjdCB6bGliIGhlYWRlciAqL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHN0YXRlLndyYXAgJiAxKSB8fCAgIC8qIGNoZWNrIGlmIHpsaWIgaGVhZGVyIGFsbG93ZWQgKi9cbiAgICAgICAgICAoKChob2xkICYgMHhmZikvKkJJVFMoOCkqLyA8PCA4KSArIChob2xkID4+IDgpKSAlIDMxKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGhlYWRlciBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBsZW4gPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA4O1xuICAgICAgICBpZiAoc3RhdGUud2JpdHMgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS53Yml0cyA9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW4gPiBzdGF0ZS53Yml0cykge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgd2luZG93IHNpemUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZG1heCA9IDEgPDwgbGVuO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgemxpYiBoZWFkZXIgb2tcXG5cIikpO1xuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIHN0YXRlLm1vZGUgPSBob2xkICYgMHgyMDAgPyBESUNUSUQgOiBUWVBFO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZMQUdTOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUuZmxhZ3MgPSBob2xkO1xuICAgICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMHhmZikgIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweGUwMDApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGhlYWRlciBmbGFncyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnRleHQgPSAoKGhvbGQgPj4gOCkgJiAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gVElNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUSU1FOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnRpbWUgPSBob2xkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzQoc3RhdGUuY2hlY2ssIGhvbGQpXG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIGhidWZbMl0gPSAoaG9sZCA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzNdID0gKGhvbGQgPj4+IDI0KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgNCwgMCk7XG4gICAgICAgICAgLy89PT1cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IE9TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE9TOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnhmbGFncyA9IChob2xkICYgMHhmZik7XG4gICAgICAgICAgc3RhdGUuaGVhZC5vcyA9IChob2xkID4+IDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBFWExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBFWExFTjpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkO1xuICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX2xlbiA9IGhvbGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG51bGwvKlpfTlVMTCovO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBFWFRSQTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBFWFRSQTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUuaGVhZC5leHRyYV9sZW4gLSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgICAgIGlmICghc3RhdGUuaGVhZC5leHRyYSkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB1bnR5cGVkIGFycmF5IGZvciBtb3JlIGNvbnZlbmllbnQgcHJvY2Vzc2luZyBsYXRlclxuICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBuZXcgQXJyYXkoc3RhdGUuaGVhZC5leHRyYV9sZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KFxuICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgICAgICAvLyBleHRyYSBmaWVsZCBpcyBsaW1pdGVkIHRvIDY1NTM2IGJ5dGVzXG4gICAgICAgICAgICAgICAgLy8gLSBubyBuZWVkIGZvciBhZGRpdGlvbmFsIHNpemUgY2hlY2tcbiAgICAgICAgICAgICAgICBjb3B5LFxuICAgICAgICAgICAgICAgIC8qbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuID8gc3RhdGUuaGVhZC5leHRyYV9tYXggOiBjb3B5LCovXG4gICAgICAgICAgICAgICAgbGVuXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIC8vem1lbWNweShzdGF0ZS5oZWFkLmV4dHJhICsgbGVuLCBuZXh0LFxuICAgICAgICAgICAgICAvLyAgICAgICAgbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4ID9cbiAgICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuIDogY29weSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IE5BTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTkFNRTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwODAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgLy8gVE9ETzogMiBvciAxIGJ5dGVzP1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5uYW1lX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG5cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT01NRU5UO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPTU1FTlQ6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MTAwMCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGNvcHkgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQuY29tbV9tYXgqLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IEhDUkM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgSENSQzpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLmNoZWNrICYgMHhmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaGVhZGVyIGNyYyBtaXNtYXRjaCc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5oY3JjID0gKChzdGF0ZS5mbGFncyA+PiA5KSAmIDEpO1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUNUSUQ6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSB6c3dhcDMyKGhvbGQpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IERJQ1Q7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElDVDpcbiAgICAgICAgaWYgKHN0YXRlLmhhdmVkaWN0ID09PSAwKSB7XG4gICAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgICAgLy8tLS1cbiAgICAgICAgICByZXR1cm4gWl9ORUVEX0RJQ1Q7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFOlxuICAgICAgICBpZiAoZmx1c2ggPT09IFpfQkxPQ0sgfHwgZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRURPOlxuICAgICAgICBpZiAoc3RhdGUubGFzdCkge1xuICAgICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUubW9kZSA9IENIRUNLO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGFzdCA9IChob2xkICYgMHgwMSkvKkJJVFMoMSkqLztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoMSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDE7XG4gICAgICAgIGJpdHMgLT0gMTtcbiAgICAgICAgLy8tLS0vL1xuXG4gICAgICAgIHN3aXRjaCAoKGhvbGQgJiAweDAzKS8qQklUUygyKSovKSB7XG4gICAgICAgICAgY2FzZSAwOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogc3RvcmVkIGJsb2NrICovXG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBzdG9yZWQgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBTVE9SRUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBmaXhlZCBibG9jayAqL1xuICAgICAgICAgICAgZml4ZWR0YWJsZXMoc3RhdGUpO1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZml4ZWQgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fOyAgICAgICAgICAgICAvKiBkZWNvZGUgY29kZXMgKi9cbiAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykge1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGR5bmFtaWMgYmxvY2sgKi9cbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGR5bmFtaWMgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUQUJMRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYmxvY2sgdHlwZSc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNUT1JFRDpcbiAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vLyAvKiBnbyB0byBieXRlIGJvdW5kYXJ5ICovXG4gICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChob2xkICYgMHhmZmZmKSAhPT0gKChob2xkID4+PiAxNikgXiAweGZmZmYpKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Rocyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkICYgMHhmZmZmO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBsZW5ndGggJXVcXG5cIixcbiAgICAgICAgLy8gICAgICAgIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFlfO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWV86XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFk6XG4gICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgICAgaWYgKGNvcHkgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgLy8tLS0gem1lbWNweShwdXQsIG5leHQsIGNvcHkpOyAtLS1cbiAgICAgICAgICB1dGlscy5hcnJheVNldChvdXRwdXQsIGlucHV0LCBuZXh0LCBjb3B5LCBwdXQpO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgICBwdXQgKz0gY29weTtcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBlbmRcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRBQkxFOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNCk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTQpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubmxlbiA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDI1NztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5uZGlzdCA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDE7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmNvZGUgPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA0O1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNDtcbiAgICAgICAgYml0cyAtPSA0O1xuICAgICAgICAvLy0tLS8vXG4vLyNpZm5kZWYgUEtaSVBfQlVHX1dPUktBUk9VTkRcbiAgICAgICAgaWYgKHN0YXRlLm5sZW4gPiAyODYgfHwgc3RhdGUubmRpc3QgPiAzMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3RvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHRhYmxlIHNpemVzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5MRU5TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkxFTlM6XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmNvZGUpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgMTkpIHtcbiAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvL3N0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgICAgICAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICAgIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW47XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSA3O1xuXG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShDT0RFUywgc3RhdGUubGVucywgMCwgMTksIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgbGVuZ3RocyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBjb2RlIGxlbmd0aHMgb2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPREVMRU5TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPREVMRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07LypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhlcmVfdmFsIDwgMTYpIHtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGhlcmVfdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoZXJlX3ZhbCA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMik7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAyO1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUubGVuc1tzdGF0ZS5oYXZlIC0gMV07XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDAzKTsvL0JJVFMoMik7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhlcmVfdmFsID09PSAxNykge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAzKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDM7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyA3KTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDc7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAxMSArIChob2xkICYgMHg3Zik7Ly9CSVRTKDcpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyg3KSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gNztcbiAgICAgICAgICAgICAgYml0cyAtPSA3O1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSArIGNvcHkgPiBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNvcHktLSkge1xuICAgICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogaGFuZGxlIGVycm9yIGJyZWFrcyBpbiB3aGlsZSAqL1xuICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gQkFEKSB7IGJyZWFrOyB9XG5cbiAgICAgICAgLyogY2hlY2sgZm9yIGVuZC1vZi1ibG9jayBjb2RlIChiZXR0ZXIgaGF2ZSBvbmUpICovXG4gICAgICAgIGlmIChzdGF0ZS5sZW5zWzI1Nl0gPT09IDApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgLS0gbWlzc2luZyBlbmQtb2YtYmxvY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBidWlsZCBjb2RlIHRhYmxlcyAtLSBub3RlOiBkbyBub3QgY2hhbmdlIHRoZSBsZW5iaXRzIG9yIGRpc3RiaXRzXG4gICAgICAgICAgIHZhbHVlcyBoZXJlICg5IGFuZCA2KSB3aXRob3V0IHJlYWRpbmcgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgICAgICAgICAgY29uY2VybmluZyB0aGUgRU5PVUdIIGNvbnN0YW50cywgd2hpY2ggZGVwZW5kIG9uIHRob3NlIHZhbHVlcyAqL1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gOTtcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoTEVOUywgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSA2O1xuICAgICAgICAvL3N0YXRlLmRpc3Rjb2RlLmNvcHkoc3RhdGUuY29kZXMpO1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluO1xuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5kaXN0Yml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCBzdGF0ZS5ubGVuLCBzdGF0ZS5uZGlzdCwgc3RhdGUuZGlzdGNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAgIC8vIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZXMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsICdpbmZsYXRlOiAgICAgICBjb2RlcyBva1xcbicpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTl87XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5fOlxuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTjpcbiAgICAgICAgaWYgKGhhdmUgPj0gNiAmJiBsZWZ0ID49IDI1OCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgaW5mbGF0ZV9mYXN0KHN0cm0sIF9vdXQpO1xuICAgICAgICAgIC8vLS0tIExPQUQoKSAtLS1cbiAgICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICAgICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICAgICAgICAgIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICAgICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgICAgICAgICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgICAgICAgICBob2xkID0gc3RhdGUuaG9sZDtcbiAgICAgICAgICBiaXRzID0gc3RhdGUuYml0cztcbiAgICAgICAgICAvLy0tLVxuXG4gICAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHtcbiAgICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuYmFjayA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOyAgLypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKGhlcmVfYml0cyA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYmIChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBzdGF0ZS5sZW5ndGggPSBoZXJlX3ZhbDtcbiAgICAgICAgaWYgKGhlcmVfb3AgPT09IDApIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gTElUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgMzIpIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZXh0cmEgPSBoZXJlX29wICYgMTU7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5FWFQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVORVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICBzdGF0ZS53YXMgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBESVNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJU1Q6XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxKV07LypCSVRTKHN0YXRlLmRpc3RiaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUub2Zmc2V0ID0gaGVyZV92YWw7XG4gICAgICAgIHN0YXRlLmV4dHJhID0gKGhlcmVfb3ApICYgMTU7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBESVNURVhUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJU1RFWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUub2Zmc2V0ICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBzdGF0ZS5kbWF4KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgc3RhdGUub2Zmc2V0KSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBNQVRDSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBNQVRDSDpcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGNvcHkgPSBfb3V0IC0gbGVmdDtcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IGNvcHkpIHsgICAgICAgICAvKiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgY29weSA9IHN0YXRlLm9mZnNldCAtIGNvcHk7XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53aGF2ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgIFRyYWNlKChzdGRlcnIsIFwiaW5mbGF0ZS5jIHRvbyBmYXJcXG5cIikpO1xuLy8gICAgICAgICAgY29weSAtPSBzdGF0ZS53aGF2ZTtcbi8vICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbi8vICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuLy8gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuLy8gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4vLyAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgIG91dHB1dFtwdXQrK10gPSAwO1xuLy8gICAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbi8vICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuLy8gICAgICAgICAgYnJlYWs7XG4vLyNlbmRpZlxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLnduZXh0KSB7XG4gICAgICAgICAgICBjb3B5IC09IHN0YXRlLnduZXh0O1xuICAgICAgICAgICAgZnJvbSA9IHN0YXRlLndzaXplIC0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud25leHQgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBzdGF0ZS53aW5kb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogY29weSBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgIGZyb20gPSBwdXQgLSBzdGF0ZS5vZmZzZXQ7XG4gICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG91dHB1dFtwdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExJVDpcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIG91dHB1dFtwdXQrK10gPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGxlZnQtLTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENIRUNLOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIC8vIFVzZSAnfCcgaW5zdGVhZCBvZiAnKycgdG8gbWFrZSBzdXJlIHRoYXQgcmVzdWx0IGlzIHNpZ25lZFxuICAgICAgICAgICAgaG9sZCB8PSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBfb3V0IC09IGxlZnQ7XG4gICAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgICAgICAgICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICAgICAgICAgIGlmIChfb3V0KSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPVxuICAgICAgICAgICAgICAgIC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBwdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgICAgICAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSk7XG5cbiAgICAgICAgICB9XG4gICAgICAgICAgX291dCA9IGxlZnQ7XG4gICAgICAgICAgLy8gTkI6IGNyYzMyIHN0b3JlZCBhcyBzaWduZWQgMzItYml0IGludCwgenN3YXAzMiByZXR1cm5zIHNpZ25lZCB0b29cbiAgICAgICAgICBpZiAoKHN0YXRlLmZsYWdzID8gaG9sZCA6IHpzd2FwMzIoaG9sZCkpICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGRhdGEgY2hlY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgY2hlY2sgbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOR1RIO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkdUSDpcbiAgICAgICAgaWYgKHN0YXRlLndyYXAgJiYgc3RhdGUuZmxhZ3MpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUudG90YWwgJiAweGZmZmZmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGxlbmd0aCBjaGVjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBsZW5ndGggbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRE9ORTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBET05FOlxuICAgICAgICByZXQgPSBaX1NUUkVBTV9FTkQ7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgQkFEOlxuICAgICAgICByZXQgPSBaX0RBVEFfRVJST1I7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgTUVNOlxuICAgICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgICBjYXNlIFNZTkM6XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICB9XG4gIH1cblxuICAvLyBpbmZfbGVhdmUgPC0gaGVyZSBpcyByZWFsIHBsYWNlIGZvciBcImdvdG8gaW5mX2xlYXZlXCIsIGVtdWxhdGVkIHZpYSBcImJyZWFrIGluZl9sZWF2ZVwiXG5cbiAgLypcbiAgICAgUmV0dXJuIGZyb20gaW5mbGF0ZSgpLCB1cGRhdGluZyB0aGUgdG90YWwgY291bnRzIGFuZCB0aGUgY2hlY2sgdmFsdWUuXG4gICAgIElmIHRoZXJlIHdhcyBubyBwcm9ncmVzcyBkdXJpbmcgdGhlIGluZmxhdGUoKSBjYWxsLCByZXR1cm4gYSBidWZmZXJcbiAgICAgZXJyb3IuICBDYWxsIHVwZGF0ZXdpbmRvdygpIHRvIGNyZWF0ZSBhbmQvb3IgdXBkYXRlIHRoZSB3aW5kb3cgc3RhdGUuXG4gICAgIE5vdGU6IGEgbWVtb3J5IGVycm9yIGZyb20gaW5mbGF0ZSgpIGlzIG5vbi1yZWNvdmVyYWJsZS5cbiAgICovXG5cbiAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIC8vLS0tXG5cbiAgaWYgKHN0YXRlLndzaXplIHx8IChfb3V0ICE9PSBzdHJtLmF2YWlsX291dCAmJiBzdGF0ZS5tb2RlIDwgQkFEICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPCBDSEVDSyB8fCBmbHVzaCAhPT0gWl9GSU5JU0gpKSkge1xuICAgIGlmICh1cGRhdGV3aW5kb3coc3RybSwgc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQsIF9vdXQgLSBzdHJtLmF2YWlsX291dCkpIHtcbiAgICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgfVxuICB9XG4gIF9pbiAtPSBzdHJtLmF2YWlsX2luO1xuICBfb3V0IC09IHN0cm0uYXZhaWxfb3V0O1xuICBzdHJtLnRvdGFsX2luICs9IF9pbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgaWYgKHN0YXRlLndyYXAgJiYgX291dCkge1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBzdHJtLm5leHRfb3V0IC0gX291dCwgX291dCk7Ki9cbiAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpKTtcbiAgfVxuICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gVFlQRSA/IDEyOCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IExFTl8gfHwgc3RhdGUubW9kZSA9PT0gQ09QWV8gPyAyNTYgOiAwKTtcbiAgaWYgKCgoX2luID09PSAwICYmIF9vdXQgPT09IDApIHx8IGZsdXNoID09PSBaX0ZJTklTSCkgJiYgcmV0ID09PSBaX09LKSB7XG4gICAgcmV0ID0gWl9CVUZfRVJST1I7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUVuZChzdHJtKSB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIC8qfHwgc3RybS0+emZyZWUgPT0gKGZyZWVfZnVuYykwKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUud2luZG93KSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuICBzdHJtLnN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVHZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICB2YXIgc3RhdGU7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuXG4gIC8qIHNhdmUgaGVhZGVyIHN0cnVjdHVyZSAqL1xuICBzdGF0ZS5oZWFkID0gaGVhZDtcbiAgaGVhZC5kb25lID0gZmFsc2U7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHN0YXRlO1xuICB2YXIgZGljdGlkO1xuICB2YXIgcmV0O1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSAvKiA9PSBaX05VTEwgKi8gfHwgIXN0cm0uc3RhdGUgLyogPT0gWl9OVUxMICovKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKHN0YXRlLndyYXAgIT09IDAgJiYgc3RhdGUubW9kZSAhPT0gRElDVCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBjb3JyZWN0IGRpY3Rpb25hcnkgaWRlbnRpZmllciAqL1xuICBpZiAoc3RhdGUubW9kZSA9PT0gRElDVCkge1xuICAgIGRpY3RpZCA9IDE7IC8qIGFkbGVyMzIoMCwgbnVsbCwgMCkqL1xuICAgIC8qIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gICAgaWYgKGRpY3RpZCAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG4gICAgfVxuICB9XG4gIC8qIGNvcHkgZGljdGlvbmFyeSB0byB3aW5kb3cgdXNpbmcgdXBkYXRld2luZG93KCksIHdoaWNoIHdpbGwgYW1lbmQgdGhlXG4gICBleGlzdGluZyBkaWN0aW9uYXJ5IGlmIGFwcHJvcHJpYXRlICovXG4gIHJldCA9IHVwZGF0ZXdpbmRvdyhzdHJtLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCBkaWN0TGVuZ3RoKTtcbiAgaWYgKHJldCkge1xuICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICB9XG4gIHN0YXRlLmhhdmVkaWN0ID0gMTtcbiAgLy8gVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBkaWN0aW9uYXJ5IHNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5leHBvcnRzLmluZmxhdGVSZXNldCA9IGluZmxhdGVSZXNldDtcbmV4cG9ydHMuaW5mbGF0ZVJlc2V0MiA9IGluZmxhdGVSZXNldDI7XG5leHBvcnRzLmluZmxhdGVSZXNldEtlZXAgPSBpbmZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5pbmZsYXRlSW5pdCA9IGluZmxhdGVJbml0O1xuZXhwb3J0cy5pbmZsYXRlSW5pdDIgPSBpbmZsYXRlSW5pdDI7XG5leHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlRW5kID0gaW5mbGF0ZUVuZDtcbmV4cG9ydHMuaW5mbGF0ZUdldEhlYWRlciA9IGluZmxhdGVHZXRIZWFkZXI7XG5leHBvcnRzLmluZmxhdGVTZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVJbmZvID0gJ3Bha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbmV4cG9ydHMuaW5mbGF0ZUNvcHkgPSBpbmZsYXRlQ29weTtcbmV4cG9ydHMuaW5mbGF0ZUdldERpY3Rpb25hcnkgPSBpbmZsYXRlR2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuaW5mbGF0ZU1hcmsgPSBpbmZsYXRlTWFyaztcbmV4cG9ydHMuaW5mbGF0ZVByaW1lID0gaW5mbGF0ZVByaW1lO1xuZXhwb3J0cy5pbmZsYXRlU3luYyA9IGluZmxhdGVTeW5jO1xuZXhwb3J0cy5pbmZsYXRlU3luY1BvaW50ID0gaW5mbGF0ZVN5bmNQb2ludDtcbmV4cG9ydHMuaW5mbGF0ZVVuZGVybWluZSA9IGluZmxhdGVVbmRlcm1pbmU7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB6bGliX2luZmxhdGUgPSByZXF1aXJlKCcuL3psaWIvaW5mbGF0ZScpO1xudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvY29tbW9uJyk7XG52YXIgc3RyaW5ncyAgICAgID0gcmVxdWlyZSgnLi91dGlscy9zdHJpbmdzJyk7XG52YXIgYyAgICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL2NvbnN0YW50cycpO1xudmFyIG1zZyAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9tZXNzYWdlcycpO1xudmFyIFpTdHJlYW0gICAgICA9IHJlcXVpcmUoJy4vemxpYi96c3RyZWFtJyk7XG52YXIgR1poZWFkZXIgICAgID0gcmVxdWlyZSgnLi96bGliL2d6aGVhZGVyJyk7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogY2xhc3MgSW5mbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2luZmxhdGVdXVxuICogYW5kIFtbaW5mbGF0ZVJhd11dLlxuICoqL1xuXG4vKiBpbnRlcm5hbFxuICogaW5mbGF0ZS5jaHVua3MgLT4gQXJyYXlcbiAqXG4gKiBDaHVua3Mgb2Ygb3V0cHV0IGRhdGEsIGlmIFtbSW5mbGF0ZSNvbkRhdGFdXSBub3Qgb3ZlcnJpZGRlbi5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLnJlc3VsdCAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICpcbiAqIFVuY29tcHJlc3NlZCByZXN1bHQsIGdlbmVyYXRlZCBieSBkZWZhdWx0IFtbSW5mbGF0ZSNvbkRhdGFdXVxuICogYW5kIFtbSW5mbGF0ZSNvbkVuZF1dIGhhbmRsZXJzLiBGaWxsZWQgYWZ0ZXIgeW91IHB1c2ggbGFzdCBjaHVua1xuICogKGNhbGwgW1tJbmZsYXRlI3B1c2hdXSB3aXRoIGBaX0ZJTklTSGAgLyBgdHJ1ZWAgcGFyYW0pIG9yIGlmIHlvdVxuICogcHVzaCBhIGNodW5rIHdpdGggZXhwbGljaXQgZmx1c2ggKGNhbGwgW1tJbmZsYXRlI3B1c2hdXSB3aXRoXG4gKiBgWl9TWU5DX0ZMVVNIYCBwYXJhbSkuXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5lcnIgLT4gTnVtYmVyXG4gKlxuICogRXJyb3IgY29kZSBhZnRlciBpbmZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLlxuICogU2hvdWxkIGJlIGNoZWNrZWQgaWYgYnJva2VuIGRhdGEgcG9zc2libGUuXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5tc2cgLT4gU3RyaW5nXG4gKlxuICogRXJyb3IgbWVzc2FnZSwgaWYgW1tJbmZsYXRlLmVycl1dICE9IDBcbiAqKi9cblxuXG4vKipcbiAqIG5ldyBJbmZsYXRlKG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIENyZWF0ZXMgbmV3IGluZmxhdG9yIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHBhcmFtcy4gVGhyb3dzIGV4Y2VwdGlvblxuICogb24gYmFkIHBhcmFtcy4gU3VwcG9ydGVkIG9wdGlvbnM6XG4gKlxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYGRpY3Rpb25hcnlgXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6XG4gKlxuICogLSBgY2h1bmtTaXplYCAtIHNpemUgb2YgZ2VuZXJhdGVkIGRhdGEgY2h1bmtzICgxNksgYnkgZGVmYXVsdClcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGluZmxhdGVcbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICogQnkgZGVmYXVsdCwgd2hlbiBubyBvcHRpb25zIHNldCwgYXV0b2RldGVjdCBkZWZsYXRlL2d6aXAgZGF0YSBmb3JtYXQgdmlhXG4gKiB3cmFwcGVyIGhlYWRlci5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgY2h1bmsxID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIGNodW5rMiA9IFVpbnQ4QXJyYXkoWzEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5XSk7XG4gKlxuICogdmFyIGluZmxhdGUgPSBuZXcgcGFrby5JbmZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBpbmZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBpbmZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChpbmZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoaW5mbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coaW5mbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBJbmZsYXRlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEluZmxhdGUpKSByZXR1cm4gbmV3IEluZmxhdGUob3B0aW9ucyk7XG5cbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHtcbiAgICBjaHVua1NpemU6IDE2Mzg0LFxuICAgIHdpbmRvd0JpdHM6IDAsXG4gICAgdG86ICcnXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIHZhciBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cbiAgLy8gRm9yY2Ugd2luZG93IHNpemUgZm9yIGByYXdgIGRhdGEsIGlmIG5vdCBzZXQgZGlyZWN0bHksXG4gIC8vIGJlY2F1c2Ugd2UgaGF2ZSBubyBoZWFkZXIgZm9yIGF1dG9kZXRlY3QuXG4gIGlmIChvcHQucmF3ICYmIChvcHQud2luZG93Qml0cyA+PSAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikpIHtcbiAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0cztcbiAgICBpZiAob3B0LndpbmRvd0JpdHMgPT09IDApIHsgb3B0LndpbmRvd0JpdHMgPSAtMTU7IH1cbiAgfVxuXG4gIC8vIElmIGB3aW5kb3dCaXRzYCBub3QgZGVmaW5lZCAoYW5kIG1vZGUgbm90IHJhdykgLSBzZXQgYXV0b2RldGVjdCBmbGFnIGZvciBnemlwL2RlZmxhdGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+PSAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikgJiZcbiAgICAgICEob3B0aW9ucyAmJiBvcHRpb25zLndpbmRvd0JpdHMpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMzI7XG4gIH1cblxuICAvLyBHemlwIGhlYWRlciBoYXMgbm8gaW5mbyBhYm91dCB3aW5kb3dzIHNpemUsIHdlIGNhbiBkbyBhdXRvZGV0ZWN0IG9ubHlcbiAgLy8gZm9yIGRlZmxhdGUuIFNvLCBpZiB3aW5kb3cgc2l6ZSBub3Qgc2V0LCBmb3JjZSBpdCB0byBtYXggd2hlbiBnemlwIHBvc3NpYmxlXG4gIGlmICgob3B0LndpbmRvd0JpdHMgPiAxNSkgJiYgKG9wdC53aW5kb3dCaXRzIDwgNDgpKSB7XG4gICAgLy8gYml0IDMgKDE2KSAtPiBnemlwcGVkIGRhdGFcbiAgICAvLyBiaXQgNCAoMzIpIC0+IGF1dG9kZXRlY3QgZ3ppcC9kZWZsYXRlXG4gICAgaWYgKChvcHQud2luZG93Qml0cyAmIDE1KSA9PT0gMCkge1xuICAgICAgb3B0LndpbmRvd0JpdHMgfD0gMTU7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5lcnIgICAgPSAwOyAgICAgIC8vIGVycm9yIGNvZGUsIGlmIGhhcHBlbnMgKDAgPSBaX09LKVxuICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVuZGVkICA9IGZhbHNlOyAgLy8gdXNlZCB0byBhdm9pZCBtdWx0aXBsZSBvbkVuZCgpIGNhbGxzXG4gIHRoaXMuY2h1bmtzID0gW107ICAgICAvLyBjaHVua3Mgb2YgY29tcHJlc3NlZCBkYXRhXG5cbiAgdGhpcy5zdHJtICAgPSBuZXcgWlN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICB2YXIgc3RhdHVzICA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlSW5pdDIoXG4gICAgdGhpcy5zdHJtLFxuICAgIG9wdC53aW5kb3dCaXRzXG4gICk7XG5cbiAgaWYgKHN0YXR1cyAhPT0gYy5aX09LKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgfVxuXG4gIHRoaXMuaGVhZGVyID0gbmV3IEdaaGVhZGVyKCk7XG5cbiAgemxpYl9pbmZsYXRlLmluZmxhdGVHZXRIZWFkZXIodGhpcy5zdHJtLCB0aGlzLmhlYWRlcik7XG59XG5cbi8qKlxuICogSW5mbGF0ZSNwdXNoKGRhdGFbLCBtb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fEFycmF5QnVmZmVyfFN0cmluZyk6IGlucHV0IGRhdGFcbiAqIC0gbW9kZSAoTnVtYmVyfEJvb2xlYW4pOiAwLi42IGZvciBjb3JyZXNwb25kaW5nIFpfTk9fRkxVU0guLlpfVFJFRSBtb2Rlcy5cbiAqICAgU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsIGB0cnVlYCBtZWFucyBaX0ZJTklTSC5cbiAqXG4gKiBTZW5kcyBpbnB1dCBkYXRhIHRvIGluZmxhdGUgcGlwZSwgZ2VuZXJhdGluZyBbW0luZmxhdGUjb25EYXRhXV0gY2FsbHMgd2l0aFxuICogbmV3IG91dHB1dCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdCBoYXZlXG4gKiBtb2RlIFpfRklOSVNIIChvciBgdHJ1ZWApLiBUaGF0IHdpbGwgZmx1c2ggaW50ZXJuYWwgcGVuZGluZyBidWZmZXJzIGFuZCBjYWxsXG4gKiBbW0luZmxhdGUjb25FbmRdXS4gRm9yIGludGVyaW0gZXhwbGljaXQgZmx1c2hlcyAod2l0aG91dCBlbmRpbmcgdGhlIHN0cmVhbSkgeW91XG4gKiBjYW4gdXNlIG1vZGUgWl9TWU5DX0ZMVVNILCBrZWVwaW5nIHRoZSBkZWNvbXByZXNzaW9uIGNvbnRleHQuXG4gKlxuICogT24gZmFpbCBjYWxsIFtbSW5mbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgYFVpbnQ4QXJyYXlgIG9uIGlucHV0IGZvciBiZXN0IHNwZWVkIChvdXRwdXRcbiAqIGZvcm1hdCBpcyBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5KS4gQWxzbywgZG9uJ3Qgc2tpcCBsYXN0IHBhcmFtIGFuZCBhbHdheXNcbiAqIHVzZSB0aGUgc2FtZSB0eXBlIGluIHlvdXIgY29kZSAoYm9vbGVhbiBvciBudW1iZXIpLiBUaGF0IHdpbGwgaW1wcm92ZSBKUyBzcGVlZC5cbiAqXG4gKiBGb3IgcmVndWxhciBgQXJyYXlgLXMgbWFrZSBzdXJlIGFsbCBlbGVtZW50cyBhcmUgWzAuLjI1NV0uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBtb2RlKSB7XG4gIHZhciBzdHJtID0gdGhpcy5zdHJtO1xuICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgdmFyIGRpY3Rpb25hcnkgPSB0aGlzLm9wdGlvbnMuZGljdGlvbmFyeTtcbiAgdmFyIHN0YXR1cywgX21vZGU7XG4gIHZhciBuZXh0X291dF91dGY4LCB0YWlsLCB1dGY4c3RyO1xuICB2YXIgZGljdDtcblxuICAvLyBGbGFnIHRvIHByb3Blcmx5IHByb2Nlc3MgWl9CVUZfRVJST1Igb24gdGVzdGluZyBpbmZsYXRlIGNhbGxcbiAgLy8gd2hlbiB3ZSBjaGVjayB0aGF0IGFsbCBvdXRwdXQgZGF0YSB3YXMgZmx1c2hlZC5cbiAgdmFyIGFsbG93QnVmRXJyb3IgPSBmYWxzZTtcblxuICBpZiAodGhpcy5lbmRlZCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgX21vZGUgPSAobW9kZSA9PT0gfn5tb2RlKSA/IG1vZGUgOiAoKG1vZGUgPT09IHRydWUpID8gYy5aX0ZJTklTSCA6IGMuWl9OT19GTFVTSCk7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gT25seSBiaW5hcnkgc3RyaW5ncyBjYW4gYmUgZGVjb21wcmVzc2VkIG9uIHByYWN0aWNlXG4gICAgc3RybS5pbnB1dCA9IHN0cmluZ3MuYmluc3RyaW5nMmJ1ZihkYXRhKTtcbiAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHN0cm0uaW5wdXQgPSBkYXRhO1xuICB9XG5cbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoO1xuXG4gIGRvIHtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IHV0aWxzLkJ1ZjgoY2h1bmtTaXplKTtcbiAgICAgIHN0cm0ubmV4dF9vdXQgPSAwO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGUoc3RybSwgYy5aX05PX0ZMVVNIKTsgICAgLyogbm8gYmFkIHJldHVybiB2YWx1ZSAqL1xuXG4gICAgaWYgKHN0YXR1cyA9PT0gYy5aX05FRURfRElDVCAmJiBkaWN0aW9uYXJ5KSB7XG4gICAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gICAgICBpZiAodHlwZW9mIGRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRpY3QgPSBzdHJpbmdzLnN0cmluZzJidWYoZGljdGlvbmFyeSk7XG4gICAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KGRpY3Rpb25hcnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGljdCA9IGRpY3Rpb25hcnk7XG4gICAgICB9XG5cbiAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpO1xuXG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gYy5aX0JVRl9FUlJPUiAmJiBhbGxvd0J1ZkVycm9yID09PSB0cnVlKSB7XG4gICAgICBzdGF0dXMgPSBjLlpfT0s7XG4gICAgICBhbGxvd0J1ZkVycm9yID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzdHJtLm5leHRfb3V0KSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCB8fCAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiAoX21vZGUgPT09IGMuWl9GSU5JU0ggfHwgX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSkpIHtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgbmV4dF9vdXRfdXRmOCA9IHN0cmluZ3MudXRmOGJvcmRlcihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCk7XG5cbiAgICAgICAgICB0YWlsID0gc3RybS5uZXh0X291dCAtIG5leHRfb3V0X3V0Zjg7XG4gICAgICAgICAgdXRmOHN0ciA9IHN0cmluZ3MuYnVmMnN0cmluZyhzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCk7XG5cbiAgICAgICAgICAvLyBtb3ZlIHRhaWxcbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gdGFpbDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZSAtIHRhaWw7XG4gICAgICAgICAgaWYgKHRhaWwpIHsgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4LCB0YWlsLCAwKTsgfVxuXG4gICAgICAgICAgdGhpcy5vbkRhdGEodXRmOHN0cik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdoZW4gbm8gbW9yZSBpbnB1dCBkYXRhLCB3ZSBzaG91bGQgY2hlY2sgdGhhdCBpbnRlcm5hbCBpbmZsYXRlIGJ1ZmZlcnNcbiAgICAvLyBhcmUgZmx1c2hlZC4gVGhlIG9ubHkgd2F5IHRvIGRvIGl0IHdoZW4gYXZhaWxfb3V0ID0gMCAtIHJ1biBvbmUgbW9yZVxuICAgIC8vIGluZmxhdGUgcGFzcy4gQnV0IGlmIG91dHB1dCBkYXRhIG5vdCBleGlzdHMsIGluZmxhdGUgcmV0dXJuIFpfQlVGX0VSUk9SLlxuICAgIC8vIEhlcmUgd2Ugc2V0IGZsYWcgdG8gcHJvY2VzcyB0aGlzIGVycm9yIHByb3Blcmx5LlxuICAgIC8vXG4gICAgLy8gTk9URS4gRGVmbGF0ZSBkb2VzIG5vdCByZXR1cm4gZXJyb3IgaW4gdGhpcyBjYXNlIGFuZCBkb2VzIG5vdCBuZWVkcyBzdWNoXG4gICAgLy8gbG9naWMuXG4gICAgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIGFsbG93QnVmRXJyb3IgPSB0cnVlO1xuICAgIH1cblxuICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQpO1xuXG4gIGlmIChzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EKSB7XG4gICAgX21vZGUgPSBjLlpfRklOSVNIO1xuICB9XG5cbiAgLy8gRmluYWxpemUgb24gdGhlIGxhc3QgY2h1bmsuXG4gIGlmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCkge1xuICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0dXMgPT09IGMuWl9PSztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGludGVyaW0gcmVzdWx0cyBpZiBaX1NZTkNfRkxVU0guXG4gIGlmIChfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpIHtcbiAgICB0aGlzLm9uRW5kKGMuWl9PSyk7XG4gICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogb3V0cHV0IGRhdGEuIFR5cGUgb2YgYXJyYXkgZGVwZW5kc1xuICogICBvbiBqcyBlbmdpbmUgc3VwcG9ydC4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCwgZWFjaCBjaHVua1xuICogICB3aWxsIGJlIHN0cmluZy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRW5kKHN0YXR1cykgLT4gVm9pZFxuICogLSBzdGF0dXMgKE51bWJlcik6IGluZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLFxuICogICBvdGhlciBpZiBub3QuXG4gKlxuICogQ2FsbGVkIGVpdGhlciBhZnRlciB5b3UgdGVsbCBpbmZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKSBvciBzaG91bGQgYmUgZmx1c2hlZCAoWl9TWU5DX0ZMVVNIKVxuICogb3IgaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IGMuWl9PSykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBHbHVlICYgY29udmVydCBoZXJlLCB1bnRpbCB3ZSB0ZWFjaCBwYWtvIHRvIHNlbmRcbiAgICAgIC8vIHV0ZjggYWxpZ25lZCBzdHJpbmdzIHRvIG9uRGF0YVxuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBpbmZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIERlY29tcHJlc3MgYGRhdGFgIHdpdGggaW5mbGF0ZS91bmd6aXAgYW5kIGBvcHRpb25zYC4gQXV0b2RldGVjdFxuICogZm9ybWF0IHZpYSB3cmFwcGVyIGhlYWRlciBieSBkZWZhdWx0LiBUaGF0J3Mgd2h5IHdlIGRvbid0IHByb3ZpZGVcbiAqIHNlcGFyYXRlIGB1bmd6aXBgIG1ldGhvZC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSB3aW5kb3dCaXRzXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGlucHV0ID0gcGFrby5kZWZsYXRlKFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgb3V0cHV0O1xuICpcbiAqIHRyeSB7XG4gKiAgIG91dHB1dCA9IHBha28uaW5mbGF0ZShpbnB1dCk7XG4gKiB9IGNhdGNoIChlcnIpXG4gKiAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGluZmxhdG9yID0gbmV3IEluZmxhdGUob3B0aW9ucyk7XG5cbiAgaW5mbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGluZmxhdG9yLmVycikgeyB0aHJvdyBpbmZsYXRvci5tc2cgfHwgbXNnW2luZmxhdG9yLmVycl07IH1cblxuICByZXR1cm4gaW5mbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogaW5mbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2luZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiB1bmd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogSnVzdCBzaG9ydGN1dCB0byBbW2luZmxhdGVdXSwgYmVjYXVzZSBpdCBhdXRvZGV0ZWN0cyBmb3JtYXRcbiAqIGJ5IGhlYWRlci5jb250ZW50LiBEb25lIGZvciBjb252ZW5pZW5jZS5cbiAqKi9cblxuXG5leHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZVJhdyA9IGluZmxhdGVSYXc7XG5leHBvcnRzLnVuZ3ppcCAgPSBpbmZsYXRlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vL3ZhciBaX0ZJTFRFUkVEICAgICAgICAgID0gMTtcbi8vdmFyIFpfSFVGRk1BTl9PTkxZICAgICAgPSAyO1xuLy92YXIgWl9STEUgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbi8vdmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG52YXIgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbnZhciBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuLy8gRnJvbSB6dXRpbC5oXG5cbnZhciBTVE9SRURfQkxPQ0sgPSAwO1xudmFyIFNUQVRJQ19UUkVFUyA9IDE7XG52YXIgRFlOX1RSRUVTICAgID0gMjtcbi8qIFRoZSB0aHJlZSBraW5kcyBvZiBibG9jayB0eXBlICovXG5cbnZhciBNSU5fTUFUQ0ggICAgPSAzO1xudmFyIE1BWF9NQVRDSCAgICA9IDI1ODtcbi8qIFRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIG1hdGNoIGxlbmd0aHMgKi9cblxuLy8gRnJvbSBkZWZsYXRlLmhcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW50ZXJuYWwgY29tcHJlc3Npb24gc3RhdGUuXG4gKi9cblxudmFyIExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xuXG52YXIgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xuXG52YXIgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xuXG52YXIgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG5cbnZhciBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cblxudmFyIEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xuXG52YXIgTUFYX0JJVFMgICAgICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBCdWZfc2l6ZSAgICAgID0gMTY7XG4vKiBzaXplIG9mIGJpdCBidWZmZXIgaW4gYmlfYnVmICovXG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdGFudHNcbiAqL1xuXG52YXIgTUFYX0JMX0JJVFMgPSA3O1xuLyogQml0IGxlbmd0aCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JMX0JJVFMgYml0cyAqL1xuXG52YXIgRU5EX0JMT0NLICAgPSAyNTY7XG4vKiBlbmQgb2YgYmxvY2sgbGl0ZXJhbCBjb2RlICovXG5cbnZhciBSRVBfM182ICAgICA9IDE2O1xuLyogcmVwZWF0IHByZXZpb3VzIGJpdCBsZW5ndGggMy02IHRpbWVzICgyIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG52YXIgUkVQWl8zXzEwICAgPSAxNztcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDMtMTAgdGltZXMgICgzIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG52YXIgUkVQWl8xMV8xMzggPSAxODtcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDExLTEzOCB0aW1lcyAgKDcgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG52YXIgZXh0cmFfbGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggbGVuZ3RoIGNvZGUgKi9cbiAgWzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMF07XG5cbnZhciBleHRyYV9kYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBkaXN0YW5jZSBjb2RlICovXG4gIFswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzXTtcblxudmFyIGV4dHJhX2JsYml0cyA9ICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGJpdCBsZW5ndGggY29kZSAqL1xuICBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyLDMsN107XG5cbnZhciBibF9vcmRlciA9XG4gIFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XTtcbi8qIGVzbGludC1lbmFibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cblxuLyogVGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMgYXJlIHNlbnQgaW4gb3JkZXIgb2YgZGVjcmVhc2luZ1xuICogcHJvYmFiaWxpdHksIHRvIGF2b2lkIHRyYW5zbWl0dGluZyB0aGUgbGVuZ3RocyBmb3IgdW51c2VkIGJpdCBsZW5ndGggY29kZXMuXG4gKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBMb2NhbCBkYXRhLiBUaGVzZSBhcmUgaW5pdGlhbGl6ZWQgb25seSBvbmNlLlxuICovXG5cbi8vIFdlIHByZS1maWxsIGFycmF5cyB3aXRoIDAgdG8gYXZvaWQgdW5pbml0aWFsaXplZCBnYXBzXG5cbnZhciBESVNUX0NPREVfTEVOID0gNTEyOyAvKiBzZWUgZGVmaW5pdGlvbiBvZiBhcnJheSBkaXN0X2NvZGUgYmVsb3cgKi9cblxuLy8gISEhISBVc2UgZmxhdCBhcnJheSBpbnN0ZWFkIG9mIHN0cnVjdHVyZSwgRnJlcSA9IGkqMiwgTGVuID0gaSoyKzFcbnZhciBzdGF0aWNfbHRyZWUgID0gbmV3IEFycmF5KChMX0NPREVTICsgMikgKiAyKTtcbnplcm8oc3RhdGljX2x0cmVlKTtcbi8qIFRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlLiBTaW5jZSB0aGUgYml0IGxlbmd0aHMgYXJlIGltcG9zZWQsIHRoZXJlIGlzIG5vXG4gKiBuZWVkIGZvciB0aGUgTF9DT0RFUyBleHRyYSBjb2RlcyB1c2VkIGR1cmluZyBoZWFwIGNvbnN0cnVjdGlvbi4gSG93ZXZlclxuICogVGhlIGNvZGVzIDI4NiBhbmQgMjg3IGFyZSBuZWVkZWQgdG8gYnVpbGQgYSBjYW5vbmljYWwgdHJlZSAoc2VlIF90cl9pbml0XG4gKiBiZWxvdykuXG4gKi9cblxudmFyIHN0YXRpY19kdHJlZSAgPSBuZXcgQXJyYXkoRF9DT0RFUyAqIDIpO1xuemVybyhzdGF0aWNfZHRyZWUpO1xuLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlLiAoQWN0dWFsbHkgYSB0cml2aWFsIHRyZWUgc2luY2UgYWxsIGNvZGVzIHVzZVxuICogNSBiaXRzLilcbiAqL1xuXG52YXIgX2Rpc3RfY29kZSAgICA9IG5ldyBBcnJheShESVNUX0NPREVfTEVOKTtcbnplcm8oX2Rpc3RfY29kZSk7XG4vKiBEaXN0YW5jZSBjb2Rlcy4gVGhlIGZpcnN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgZGlzdGFuY2VzXG4gKiAzIC4uIDI1OCwgdGhlIGxhc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSB0b3AgOCBiaXRzIG9mXG4gKiB0aGUgMTUgYml0IGRpc3RhbmNlcy5cbiAqL1xuXG52YXIgX2xlbmd0aF9jb2RlICA9IG5ldyBBcnJheShNQVhfTUFUQ0ggLSBNSU5fTUFUQ0ggKyAxKTtcbnplcm8oX2xlbmd0aF9jb2RlKTtcbi8qIGxlbmd0aCBjb2RlIGZvciBlYWNoIG5vcm1hbGl6ZWQgbWF0Y2ggbGVuZ3RoICgwID09IE1JTl9NQVRDSCkgKi9cblxudmFyIGJhc2VfbGVuZ3RoICAgPSBuZXcgQXJyYXkoTEVOR1RIX0NPREVTKTtcbnplcm8oYmFzZV9sZW5ndGgpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBsZW5ndGggZm9yIGVhY2ggY29kZSAoMCA9IE1JTl9NQVRDSCkgKi9cblxudmFyIGJhc2VfZGlzdCAgICAgPSBuZXcgQXJyYXkoRF9DT0RFUyk7XG56ZXJvKGJhc2VfZGlzdCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGRpc3RhbmNlIGZvciBlYWNoIGNvZGUgKDAgPSBkaXN0YW5jZSBvZiAxKSAqL1xuXG5cbmZ1bmN0aW9uIFN0YXRpY1RyZWVEZXNjKHN0YXRpY190cmVlLCBleHRyYV9iaXRzLCBleHRyYV9iYXNlLCBlbGVtcywgbWF4X2xlbmd0aCkge1xuXG4gIHRoaXMuc3RhdGljX3RyZWUgID0gc3RhdGljX3RyZWU7ICAvKiBzdGF0aWMgdHJlZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYml0cyAgID0gZXh0cmFfYml0czsgICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGNvZGUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2Jhc2UgICA9IGV4dHJhX2Jhc2U7ICAgLyogYmFzZSBpbmRleCBmb3IgZXh0cmFfYml0cyAqL1xuICB0aGlzLmVsZW1zICAgICAgICA9IGVsZW1zOyAgICAgICAgLyogbWF4IG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgdHJlZSAqL1xuICB0aGlzLm1heF9sZW5ndGggICA9IG1heF9sZW5ndGg7ICAgLyogbWF4IGJpdCBsZW5ndGggZm9yIHRoZSBjb2RlcyAqL1xuXG4gIC8vIHNob3cgaWYgYHN0YXRpY190cmVlYCBoYXMgZGF0YSBvciBkdW1teSAtIG5lZWRlZCBmb3IgbW9ub21vcnBoaWMgb2JqZWN0c1xuICB0aGlzLmhhc19zdHJlZSAgICA9IHN0YXRpY190cmVlICYmIHN0YXRpY190cmVlLmxlbmd0aDtcbn1cblxuXG52YXIgc3RhdGljX2xfZGVzYztcbnZhciBzdGF0aWNfZF9kZXNjO1xudmFyIHN0YXRpY19ibF9kZXNjO1xuXG5cbmZ1bmN0aW9uIFRyZWVEZXNjKGR5bl90cmVlLCBzdGF0X2Rlc2MpIHtcbiAgdGhpcy5keW5fdHJlZSA9IGR5bl90cmVlOyAgICAgLyogdGhlIGR5bmFtaWMgdHJlZSAqL1xuICB0aGlzLm1heF9jb2RlID0gMDsgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdGhpcy5zdGF0X2Rlc2MgPSBzdGF0X2Rlc2M7ICAgLyogdGhlIGNvcnJlc3BvbmRpbmcgc3RhdGljIHRyZWUgKi9cbn1cblxuXG5cbmZ1bmN0aW9uIGRfY29kZShkaXN0KSB7XG4gIHJldHVybiBkaXN0IDwgMjU2ID8gX2Rpc3RfY29kZVtkaXN0XSA6IF9kaXN0X2NvZGVbMjU2ICsgKGRpc3QgPj4+IDcpXTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIE91dHB1dCBhIHNob3J0IExTQiBmaXJzdCBvbiB0aGUgc3RyZWFtLlxuICogSU4gYXNzZXJ0aW9uOiB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpbiBwZW5kaW5nQnVmLlxuICovXG5mdW5jdGlvbiBwdXRfc2hvcnQocywgdykge1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHcpICYgMHhmZikpO1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHVzaCkodykgPj4gOCkpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcgPj4+IDgpICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSB2YWx1ZSBvbiBhIGdpdmVuIG51bWJlciBvZiBiaXRzLlxuICogSU4gYXNzZXJ0aW9uOiBsZW5ndGggPD0gMTYgYW5kIHZhbHVlIGZpdHMgaW4gbGVuZ3RoIGJpdHMuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYml0cyhzLCB2YWx1ZSwgbGVuZ3RoKSB7XG4gIGlmIChzLmJpX3ZhbGlkID4gKEJ1Zl9zaXplIC0gbGVuZ3RoKSkge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gdmFsdWUgPj4gKEJ1Zl9zaXplIC0gcy5iaV92YWxpZCk7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGggLSBCdWZfc2l6ZTtcbiAgfSBlbHNlIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGg7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzZW5kX2NvZGUocywgYywgdHJlZSkge1xuICBzZW5kX2JpdHMocywgdHJlZVtjICogMl0vKi5Db2RlKi8sIHRyZWVbYyAqIDIgKyAxXS8qLkxlbiovKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJldmVyc2UgdGhlIGZpcnN0IGxlbiBiaXRzIG9mIGEgY29kZSwgdXNpbmcgc3RyYWlnaHRmb3J3YXJkIGNvZGUgKGEgZmFzdGVyXG4gKiBtZXRob2Qgd291bGQgdXNlIGEgdGFibGUpXG4gKiBJTiBhc3NlcnRpb246IDEgPD0gbGVuIDw9IDE1XG4gKi9cbmZ1bmN0aW9uIGJpX3JldmVyc2UoY29kZSwgbGVuKSB7XG4gIHZhciByZXMgPSAwO1xuICBkbyB7XG4gICAgcmVzIHw9IGNvZGUgJiAxO1xuICAgIGNvZGUgPj4+PSAxO1xuICAgIHJlcyA8PD0gMTtcbiAgfSB3aGlsZSAoLS1sZW4gPiAwKTtcbiAgcmV0dXJuIHJlcyA+Pj4gMTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyLCBrZWVwaW5nIGF0IG1vc3QgNyBiaXRzIGluIGl0LlxuICovXG5mdW5jdGlvbiBiaV9mbHVzaChzKSB7XG4gIGlmIChzLmJpX3ZhbGlkID09PSAxNikge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSAwO1xuICAgIHMuYmlfdmFsaWQgPSAwO1xuXG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+PSA4KSB7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZiAmIDB4ZmY7XG4gICAgcy5iaV9idWYgPj49IDg7XG4gICAgcy5iaV92YWxpZCAtPSA4O1xuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzIGZvciBhIHRyZWUgYW5kIHVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aFxuICogZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LCBoZWFwW2hlYXBfbWF4XSBhbmRcbiAqICAgIGFib3ZlIGFyZSB0aGUgdHJlZSBub2RlcyBzb3J0ZWQgYnkgaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkIGxlbiBpcyBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aCwgdGhlXG4gKiAgICAgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGZyZXF1ZW5jaWVzIGZvciBlYWNoIGJpdCBsZW5ndGguXG4gKiAgICAgVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXMgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzXG4gKiAgICAgbm90IG51bGwuXG4gKi9cbmZ1bmN0aW9uIGdlbl9iaXRsZW4ocywgZGVzYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7ICAgIC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgdmFyIHRyZWUgICAgICAgICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIHZhciBtYXhfY29kZSAgICAgICAgPSBkZXNjLm1heF9jb2RlO1xuICB2YXIgc3RyZWUgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIHZhciBoYXNfc3RyZWUgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIHZhciBleHRyYSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iaXRzO1xuICB2YXIgYmFzZSAgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYmFzZTtcbiAgdmFyIG1heF9sZW5ndGggICAgICA9IGRlc2Muc3RhdF9kZXNjLm1heF9sZW5ndGg7XG4gIHZhciBoOyAgICAgICAgICAgICAgLyogaGVhcCBpbmRleCAqL1xuICB2YXIgbiwgbTsgICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgYml0czsgICAgICAgICAgIC8qIGJpdCBsZW5ndGggKi9cbiAgdmFyIHhiaXRzOyAgICAgICAgICAvKiBleHRyYSBiaXRzICovXG4gIHZhciBmOyAgICAgICAgICAgICAgLyogZnJlcXVlbmN5ICovXG4gIHZhciBvdmVyZmxvdyA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIHdpdGggYml0IGxlbmd0aCB0b28gbGFyZ2UgKi9cblxuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBzLmJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIC8qIEluIGEgZmlyc3QgcGFzcywgY29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyAod2hpY2ggbWF5XG4gICAqIG92ZXJmbG93IGluIHRoZSBjYXNlIG9mIHRoZSBiaXQgbGVuZ3RoIHRyZWUpLlxuICAgKi9cbiAgdHJlZVtzLmhlYXBbcy5oZWFwX21heF0gKiAyICsgMV0vKi5MZW4qLyA9IDA7IC8qIHJvb3Qgb2YgdGhlIGhlYXAgKi9cblxuICBmb3IgKGggPSBzLmhlYXBfbWF4ICsgMTsgaCA8IEhFQVBfU0laRTsgaCsrKSB7XG4gICAgbiA9IHMuaGVhcFtoXTtcbiAgICBiaXRzID0gdHJlZVt0cmVlW24gKiAyICsgMV0vKi5EYWQqLyAqIDIgKyAxXS8qLkxlbiovICsgMTtcbiAgICBpZiAoYml0cyA+IG1heF9sZW5ndGgpIHtcbiAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoO1xuICAgICAgb3ZlcmZsb3crKztcbiAgICB9XG4gICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgIC8qIFdlIG92ZXJ3cml0ZSB0cmVlW25dLkRhZCB3aGljaCBpcyBubyBsb25nZXIgbmVlZGVkICovXG5cbiAgICBpZiAobiA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9IC8qIG5vdCBhIGxlYWYgbm9kZSAqL1xuXG4gICAgcy5ibF9jb3VudFtiaXRzXSsrO1xuICAgIHhiaXRzID0gMDtcbiAgICBpZiAobiA+PSBiYXNlKSB7XG4gICAgICB4Yml0cyA9IGV4dHJhW24gLSBiYXNlXTtcbiAgICB9XG4gICAgZiA9IHRyZWVbbiAqIDJdLyouRnJlcSovO1xuICAgIHMub3B0X2xlbiArPSBmICogKGJpdHMgKyB4Yml0cyk7XG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuICs9IGYgKiAoc3RyZWVbbiAqIDIgKyAxXS8qLkxlbiovICsgeGJpdHMpO1xuICAgIH1cbiAgfVxuICBpZiAob3ZlcmZsb3cgPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgLy8gVHJhY2UoKHN0ZGVycixcIlxcbmJpdCBsZW5ndGggb3ZlcmZsb3dcXG5cIikpO1xuICAvKiBUaGlzIGhhcHBlbnMgZm9yIGV4YW1wbGUgb24gb2JqMiBhbmQgcGljIG9mIHRoZSBDYWxnYXJ5IGNvcnB1cyAqL1xuXG4gIC8qIEZpbmQgdGhlIGZpcnN0IGJpdCBsZW5ndGggd2hpY2ggY291bGQgaW5jcmVhc2U6ICovXG4gIGRvIHtcbiAgICBiaXRzID0gbWF4X2xlbmd0aCAtIDE7XG4gICAgd2hpbGUgKHMuYmxfY291bnRbYml0c10gPT09IDApIHsgYml0cy0tOyB9XG4gICAgcy5ibF9jb3VudFtiaXRzXS0tOyAgICAgIC8qIG1vdmUgb25lIGxlYWYgZG93biB0aGUgdHJlZSAqL1xuICAgIHMuYmxfY291bnRbYml0cyArIDFdICs9IDI7IC8qIG1vdmUgb25lIG92ZXJmbG93IGl0ZW0gYXMgaXRzIGJyb3RoZXIgKi9cbiAgICBzLmJsX2NvdW50W21heF9sZW5ndGhdLS07XG4gICAgLyogVGhlIGJyb3RoZXIgb2YgdGhlIG92ZXJmbG93IGl0ZW0gYWxzbyBtb3ZlcyBvbmUgc3RlcCB1cCxcbiAgICAgKiBidXQgdGhpcyBkb2VzIG5vdCBhZmZlY3QgYmxfY291bnRbbWF4X2xlbmd0aF1cbiAgICAgKi9cbiAgICBvdmVyZmxvdyAtPSAyO1xuICB9IHdoaWxlIChvdmVyZmxvdyA+IDApO1xuXG4gIC8qIE5vdyByZWNvbXB1dGUgYWxsIGJpdCBsZW5ndGhzLCBzY2FubmluZyBpbiBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAgICogaCBpcyBzdGlsbCBlcXVhbCB0byBIRUFQX1NJWkUuIChJdCBpcyBzaW1wbGVyIHRvIHJlY29uc3RydWN0IGFsbFxuICAgKiBsZW5ndGhzIGluc3RlYWQgb2YgZml4aW5nIG9ubHkgdGhlIHdyb25nIG9uZXMuIFRoaXMgaWRlYSBpcyB0YWtlblxuICAgKiBmcm9tICdhcicgd3JpdHRlbiBieSBIYXJ1aGlrbyBPa3VtdXJhLilcbiAgICovXG4gIGZvciAoYml0cyA9IG1heF9sZW5ndGg7IGJpdHMgIT09IDA7IGJpdHMtLSkge1xuICAgIG4gPSBzLmJsX2NvdW50W2JpdHNdO1xuICAgIHdoaWxlIChuICE9PSAwKSB7XG4gICAgICBtID0gcy5oZWFwWy0taF07XG4gICAgICBpZiAobSA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9XG4gICAgICBpZiAodHJlZVttICogMiArIDFdLyouTGVuKi8gIT09IGJpdHMpIHtcbiAgICAgICAgLy8gVHJhY2UoKHN0ZGVycixcImNvZGUgJWQgYml0cyAlZC0+JWRcXG5cIiwgbSwgdHJlZVttXS5MZW4sIGJpdHMpKTtcbiAgICAgICAgcy5vcHRfbGVuICs9IChiaXRzIC0gdHJlZVttICogMiArIDFdLyouTGVuKi8pICogdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgICAgIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAgIH1cbiAgICAgIG4tLTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEdlbmVyYXRlIHRoZSBjb2RlcyBmb3IgYSBnaXZlbiB0cmVlIGFuZCBiaXQgY291bnRzICh3aGljaCBuZWVkIG5vdCBiZVxuICogb3B0aW1hbCkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgYml0IGxlbmd0aCBzdGF0aXN0aWNzIGZvclxuICogdGhlIGdpdmVuIHRyZWUgYW5kIHRoZSBmaWVsZCBsZW4gaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb246IHRoZSBmaWVsZCBjb2RlIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMgb2Ygbm9uXG4gKiAgICAgemVybyBjb2RlIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBibF9jb3VudClcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgICAgICAgICAgIC8qIHRoZSB0cmVlIHRvIGRlY29yYXRlICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbi8vICAgIHVzaGYgKmJsX2NvdW50OyAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggKi9cbntcbiAgdmFyIG5leHRfY29kZSA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpOyAvKiBuZXh0IGNvZGUgdmFsdWUgZm9yIGVhY2ggYml0IGxlbmd0aCAqL1xuICB2YXIgY29kZSA9IDA7ICAgICAgICAgICAgICAvKiBydW5uaW5nIGNvZGUgdmFsdWUgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgLyogYml0IGluZGV4ICovXG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgaW5kZXggKi9cblxuICAvKiBUaGUgZGlzdHJpYnV0aW9uIGNvdW50cyBhcmUgZmlyc3QgdXNlZCB0byBnZW5lcmF0ZSB0aGUgY29kZSB2YWx1ZXNcbiAgICogd2l0aG91dCBiaXQgcmV2ZXJzYWwuXG4gICAqL1xuICBmb3IgKGJpdHMgPSAxOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBuZXh0X2NvZGVbYml0c10gPSBjb2RlID0gKGNvZGUgKyBibF9jb3VudFtiaXRzIC0gMV0pIDw8IDE7XG4gIH1cbiAgLyogQ2hlY2sgdGhhdCB0aGUgYml0IGNvdW50cyBpbiBibF9jb3VudCBhcmUgY29uc2lzdGVudC4gVGhlIGxhc3QgY29kZVxuICAgKiBtdXN0IGJlIGFsbCBvbmVzLlxuICAgKi9cbiAgLy9Bc3NlcnQgKGNvZGUgKyBibF9jb3VudFtNQVhfQklUU10tMSA9PSAoMTw8TUFYX0JJVFMpLTEsXG4gIC8vICAgICAgICBcImluY29uc2lzdGVudCBiaXQgY291bnRzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLFwiXFxuZ2VuX2NvZGVzOiBtYXhfY29kZSAlZCBcIiwgbWF4X2NvZGUpKTtcblxuICBmb3IgKG4gPSAwOyAgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgdmFyIGxlbiA9IHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovO1xuICAgIGlmIChsZW4gPT09IDApIHsgY29udGludWU7IH1cbiAgICAvKiBOb3cgcmV2ZXJzZSB0aGUgYml0cyAqL1xuICAgIHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuZXh0X2NvZGVbbGVuXSsrLCBsZW4pO1xuXG4gICAgLy9UcmFjZWN2KHRyZWUgIT0gc3RhdGljX2x0cmVlLCAoc3RkZXJyLFwiXFxubiAlM2QgJWMgbCAlMmQgYyAlNHggKCV4KSBcIixcbiAgICAvLyAgICAgbiwgKGlzZ3JhcGgobikgPyBuIDogJyAnKSwgbGVuLCB0cmVlW25dLkNvZGUsIG5leHRfY29kZVtsZW5dLTEpKTtcbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdmFyaW91cyAnY29uc3RhbnQnIHRhYmxlcy5cbiAqL1xuZnVuY3Rpb24gdHJfc3RhdGljX2luaXQoKSB7XG4gIHZhciBuOyAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBiaXRzOyAgICAgLyogYml0IGNvdW50ZXIgKi9cbiAgdmFyIGxlbmd0aDsgICAvKiBsZW5ndGggdmFsdWUgKi9cbiAgdmFyIGNvZGU7ICAgICAvKiBjb2RlIHZhbHVlICovXG4gIHZhciBkaXN0OyAgICAgLyogZGlzdGFuY2UgaW5kZXggKi9cbiAgdmFyIGJsX2NvdW50ID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vIGRvIGNoZWNrIGluIF90cl9pbml0KClcbiAgLy9pZiAoc3RhdGljX2luaXRfZG9uZSkgcmV0dXJuO1xuXG4gIC8qIEZvciBzb21lIGVtYmVkZGVkIHRhcmdldHMsIGdsb2JhbCB2YXJpYWJsZXMgYXJlIG5vdCBpbml0aWFsaXplZDogKi9cbi8qI2lmZGVmIE5PX0lOSVRfR0xPQkFMX1BPSU5URVJTXG4gIHN0YXRpY19sX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfbHRyZWU7XG4gIHN0YXRpY19sX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2xiaXRzO1xuICBzdGF0aWNfZF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2R0cmVlO1xuICBzdGF0aWNfZF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9kYml0cztcbiAgc3RhdGljX2JsX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2JsYml0cztcbiNlbmRpZiovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBsZW5ndGggKDAuLjI1NSkgLT4gbGVuZ3RoIGNvZGUgKDAuLjI4KSAqL1xuICBsZW5ndGggPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgTEVOR1RIX0NPREVTIC0gMTsgY29kZSsrKSB7XG4gICAgYmFzZV9sZW5ndGhbY29kZV0gPSBsZW5ndGg7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2xiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfbGVuZ3RoX2NvZGVbbGVuZ3RoKytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGxlbmd0aCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGxlbmd0aCAhPSAyNTZcIik7XG4gIC8qIE5vdGUgdGhhdCB0aGUgbGVuZ3RoIDI1NSAobWF0Y2ggbGVuZ3RoIDI1OCkgY2FuIGJlIHJlcHJlc2VudGVkXG4gICAqIGluIHR3byBkaWZmZXJlbnQgd2F5czogY29kZSAyODQgKyA1IGJpdHMgb3IgY29kZSAyODUsIHNvIHdlXG4gICAqIG92ZXJ3cml0ZSBsZW5ndGhfY29kZVsyNTVdIHRvIHVzZSB0aGUgYmVzdCBlbmNvZGluZzpcbiAgICovXG4gIF9sZW5ndGhfY29kZVtsZW5ndGggLSAxXSA9IGNvZGU7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBkaXN0ICgwLi4zMkspIC0+IGRpc3QgY29kZSAoMC4uMjkpICovXG4gIGRpc3QgPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgMTY7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3Q7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2RiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlW2Rpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGRpc3QgIT0gMjU2XCIpO1xuICBkaXN0ID4+PSA3OyAvKiBmcm9tIG5vdyBvbiwgYWxsIGRpc3RhbmNlcyBhcmUgZGl2aWRlZCBieSAxMjggKi9cbiAgZm9yICg7IGNvZGUgPCBEX0NPREVTOyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0IDw8IDc7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IChleHRyYV9kYml0c1tjb2RlXSAtIDcpKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlWzI1NiArIGRpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IDI1NitkaXN0ICE9IDUxMlwiKTtcblxuICAvKiBDb25zdHJ1Y3QgdGhlIGNvZGVzIG9mIHRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlICovXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIGJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIG4gPSAwO1xuICB3aGlsZSAobiA8PSAxNDMpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNTUpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gOTtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOV0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNzkpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNztcbiAgICBuKys7XG4gICAgYmxfY291bnRbN10rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyODcpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICAvKiBDb2RlcyAyODYgYW5kIDI4NyBkbyBub3QgZXhpc3QsIGJ1dCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGVcbiAgICogdHJlZSBjb25zdHJ1Y3Rpb24gdG8gZ2V0IGEgY2Fub25pY2FsIEh1ZmZtYW4gdHJlZSAobG9uZ2VzdCBjb2RlXG4gICAqIGFsbCBvbmVzKVxuICAgKi9cbiAgZ2VuX2NvZGVzKHN0YXRpY19sdHJlZSwgTF9DT0RFUyArIDEsIGJsX2NvdW50KTtcblxuICAvKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUgaXMgdHJpdmlhbDogKi9cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7IG4rKykge1xuICAgIHN0YXRpY19kdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA1O1xuICAgIHN0YXRpY19kdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG4sIDUpO1xuICB9XG5cbiAgLy8gTm93IGRhdGEgcmVhZHkgYW5kIHdlIGNhbiBpbml0IHN0YXRpYyB0cmVlc1xuICBzdGF0aWNfbF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19sdHJlZSwgZXh0cmFfbGJpdHMsIExJVEVSQUxTICsgMSwgTF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfZF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19kdHJlZSwgZXh0cmFfZGJpdHMsIDAsICAgICAgICAgIERfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2JsX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2MobmV3IEFycmF5KDApLCBleHRyYV9ibGJpdHMsIDAsICAgICAgICAgQkxfQ09ERVMsIE1BWF9CTF9CSVRTKTtcblxuICAvL3N0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSBhIG5ldyBibG9jay5cbiAqL1xuZnVuY3Rpb24gaW5pdF9ibG9jayhzKSB7XG4gIHZhciBuOyAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSB0cmVlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8IExfQ09ERVM7ICBuKyspIHsgcy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgIG4rKykgeyBzLmR5bl9kdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBCTF9DT0RFUzsgbisrKSB7IHMuYmxfdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG5cbiAgcy5keW5fbHRyZWVbRU5EX0JMT0NLICogMl0vKi5GcmVxKi8gPSAxO1xuICBzLm9wdF9sZW4gPSBzLnN0YXRpY19sZW4gPSAwO1xuICBzLmxhc3RfbGl0ID0gcy5tYXRjaGVzID0gMDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyIGFuZCBhbGlnbiB0aGUgb3V0cHV0IG9uIGEgYnl0ZSBib3VuZGFyeVxuICovXG5mdW5jdGlvbiBiaV93aW5kdXAocylcbntcbiAgaWYgKHMuYmlfdmFsaWQgPiA4KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID4gMCkge1xuICAgIC8vcHV0X2J5dGUocywgKEJ5dGUpcy0+YmlfYnVmKTtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmO1xuICB9XG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSBhIHN0b3JlZCBibG9jaywgc3RvcmluZyBmaXJzdCB0aGUgbGVuZ3RoIGFuZCBpdHNcbiAqIG9uZSdzIGNvbXBsZW1lbnQgaWYgcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiBjb3B5X2Jsb2NrKHMsIGJ1ZiwgbGVuLCBoZWFkZXIpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgICAgKmJ1ZjsgICAgLyogdGhlIGlucHV0IGRhdGEgKi9cbi8vdW5zaWduZWQgbGVuOyAgICAgLyogaXRzIGxlbmd0aCAqL1xuLy9pbnQgICAgICBoZWFkZXI7ICAvKiB0cnVlIGlmIGJsb2NrIGhlYWRlciBtdXN0IGJlIHdyaXR0ZW4gKi9cbntcbiAgYmlfd2luZHVwKHMpOyAgICAgICAgLyogYWxpZ24gb24gYnl0ZSBib3VuZGFyeSAqL1xuXG4gIGlmIChoZWFkZXIpIHtcbiAgICBwdXRfc2hvcnQocywgbGVuKTtcbiAgICBwdXRfc2hvcnQocywgfmxlbik7XG4gIH1cbi8vICB3aGlsZSAobGVuLS0pIHtcbi8vICAgIHB1dF9ieXRlKHMsICpidWYrKyk7XG4vLyAgfVxuICB1dGlscy5hcnJheVNldChzLnBlbmRpbmdfYnVmLCBzLndpbmRvdywgYnVmLCBsZW4sIHMucGVuZGluZyk7XG4gIHMucGVuZGluZyArPSBsZW47XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcGFyZXMgdG8gc3VidHJlZXMsIHVzaW5nIHRoZSB0cmVlIGRlcHRoIGFzIHRpZSBicmVha2VyIHdoZW5cbiAqIHRoZSBzdWJ0cmVlcyBoYXZlIGVxdWFsIGZyZXF1ZW5jeS4gVGhpcyBtaW5pbWl6ZXMgdGhlIHdvcnN0IGNhc2UgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBzbWFsbGVyKHRyZWUsIG4sIG0sIGRlcHRoKSB7XG4gIHZhciBfbjIgPSBuICogMjtcbiAgdmFyIF9tMiA9IG0gKiAyO1xuICByZXR1cm4gKHRyZWVbX24yXS8qLkZyZXEqLyA8IHRyZWVbX20yXS8qLkZyZXEqLyB8fFxuICAgICAgICAgKHRyZWVbX24yXS8qLkZyZXEqLyA9PT0gdHJlZVtfbTJdLyouRnJlcSovICYmIGRlcHRoW25dIDw9IGRlcHRoW21dKSk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVzdG9yZSB0aGUgaGVhcCBwcm9wZXJ0eSBieSBtb3ZpbmcgZG93biB0aGUgdHJlZSBzdGFydGluZyBhdCBub2RlIGssXG4gKiBleGNoYW5naW5nIGEgbm9kZSB3aXRoIHRoZSBzbWFsbGVzdCBvZiBpdHMgdHdvIHNvbnMgaWYgbmVjZXNzYXJ5LCBzdG9wcGluZ1xuICogd2hlbiB0aGUgaGVhcCBwcm9wZXJ0eSBpcyByZS1lc3RhYmxpc2hlZCAoZWFjaCBmYXRoZXIgc21hbGxlciB0aGFuIGl0c1xuICogdHdvIHNvbnMpLlxuICovXG5mdW5jdGlvbiBwcWRvd25oZWFwKHMsIHRyZWUsIGspXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgIC8qIHRoZSB0cmVlIHRvIHJlc3RvcmUgKi9cbi8vICAgIGludCBrOyAgICAgICAgICAgICAgIC8qIG5vZGUgdG8gbW92ZSBkb3duICovXG57XG4gIHZhciB2ID0gcy5oZWFwW2tdO1xuICB2YXIgaiA9IGsgPDwgMTsgIC8qIGxlZnQgc29uIG9mIGsgKi9cbiAgd2hpbGUgKGogPD0gcy5oZWFwX2xlbikge1xuICAgIC8qIFNldCBqIHRvIHRoZSBzbWFsbGVzdCBvZiB0aGUgdHdvIHNvbnM6ICovXG4gICAgaWYgKGogPCBzLmhlYXBfbGVuICYmXG4gICAgICBzbWFsbGVyKHRyZWUsIHMuaGVhcFtqICsgMV0sIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHtcbiAgICAgIGorKztcbiAgICB9XG4gICAgLyogRXhpdCBpZiB2IGlzIHNtYWxsZXIgdGhhbiBib3RoIHNvbnMgKi9cbiAgICBpZiAoc21hbGxlcih0cmVlLCB2LCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7IGJyZWFrOyB9XG5cbiAgICAvKiBFeGNoYW5nZSB2IHdpdGggdGhlIHNtYWxsZXN0IHNvbiAqL1xuICAgIHMuaGVhcFtrXSA9IHMuaGVhcFtqXTtcbiAgICBrID0gajtcblxuICAgIC8qIEFuZCBjb250aW51ZSBkb3duIHRoZSB0cmVlLCBzZXR0aW5nIGogdG8gdGhlIGxlZnQgc29uIG9mIGsgKi9cbiAgICBqIDw8PSAxO1xuICB9XG4gIHMuaGVhcFtrXSA9IHY7XG59XG5cblxuLy8gaW5saW5lZCBtYW51YWxseVxuLy8gdmFyIFNNQUxMRVNUID0gMTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBibG9jayBkYXRhIGNvbXByZXNzZWQgdXNpbmcgdGhlIGdpdmVuIEh1ZmZtYW4gdHJlZXNcbiAqL1xuZnVuY3Rpb24gY29tcHJlc3NfYmxvY2socywgbHRyZWUsIGR0cmVlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGNvbnN0IGN0X2RhdGEgKmx0cmVlOyAvKiBsaXRlcmFsIHRyZWUgKi9cbi8vICAgIGNvbnN0IGN0X2RhdGEgKmR0cmVlOyAvKiBkaXN0YW5jZSB0cmVlICovXG57XG4gIHZhciBkaXN0OyAgICAgICAgICAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbiAgdmFyIGxjOyAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3QgPT0gMCkgKi9cbiAgdmFyIGx4ID0gMDsgICAgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG4gIHZhciBjb2RlOyAgICAgICAgICAgLyogdGhlIGNvZGUgdG8gc2VuZCAqL1xuICB2YXIgZXh0cmE7ICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzIHRvIHNlbmQgKi9cblxuICBpZiAocy5sYXN0X2xpdCAhPT0gMCkge1xuICAgIGRvIHtcbiAgICAgIGRpc3QgPSAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyXSA8PCA4KSB8IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDIgKyAxXSk7XG4gICAgICBsYyA9IHMucGVuZGluZ19idWZbcy5sX2J1ZiArIGx4XTtcbiAgICAgIGx4Kys7XG5cbiAgICAgIGlmIChkaXN0ID09PSAwKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBsYywgbHRyZWUpOyAvKiBzZW5kIGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAgIC8vVHJhY2Vjdihpc2dyYXBoKGxjKSwgKHN0ZGVycixcIiAnJWMnIFwiLCBsYykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgICAgICBjb2RlID0gX2xlbmd0aF9jb2RlW2xjXTtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUgKyBMSVRFUkFMUyArIDEsIGx0cmVlKTsgLyogc2VuZCB0aGUgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9sYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgbGMgLT0gYmFzZV9sZW5ndGhbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGxjLCBleHRyYSk7ICAgICAgIC8qIHNlbmQgdGhlIGV4dHJhIGxlbmd0aCBiaXRzICovXG4gICAgICAgIH1cbiAgICAgICAgZGlzdC0tOyAvKiBkaXN0IGlzIG5vdyB0aGUgbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgICAgIGNvZGUgPSBkX2NvZGUoZGlzdCk7XG4gICAgICAgIC8vQXNzZXJ0IChjb2RlIDwgRF9DT0RFUywgXCJiYWQgZF9jb2RlXCIpO1xuXG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlLCBkdHJlZSk7ICAgICAgIC8qIHNlbmQgdGhlIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9kYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgZGlzdCAtPSBiYXNlX2Rpc3RbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGRpc3QsIGV4dHJhKTsgICAvKiBzZW5kIHRoZSBleHRyYSBkaXN0YW5jZSBiaXRzICovXG4gICAgICAgIH1cbiAgICAgIH0gLyogbGl0ZXJhbCBvciBtYXRjaCBwYWlyID8gKi9cblxuICAgICAgLyogQ2hlY2sgdGhhdCB0aGUgb3ZlcmxheSBiZXR3ZWVuIHBlbmRpbmdfYnVmIGFuZCBkX2J1ZitsX2J1ZiBpcyBvazogKi9cbiAgICAgIC8vQXNzZXJ0KCh1SW50KShzLT5wZW5kaW5nKSA8IHMtPmxpdF9idWZzaXplICsgMipseCxcbiAgICAgIC8vICAgICAgIFwicGVuZGluZ0J1ZiBvdmVyZmxvd1wiKTtcblxuICAgIH0gd2hpbGUgKGx4IDwgcy5sYXN0X2xpdCk7XG4gIH1cblxuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBsdHJlZSk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3Qgb25lIEh1ZmZtYW4gdHJlZSBhbmQgYXNzaWducyB0aGUgY29kZSBiaXQgc3RyaW5ncyBhbmQgbGVuZ3Rocy5cbiAqIFVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aCBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZCBmcmVxIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkcyBsZW4gYW5kIGNvZGUgYXJlIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoXG4gKiAgICAgYW5kIGNvcnJlc3BvbmRpbmcgY29kZS4gVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXNcbiAqICAgICBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXMgbm90IG51bGwuIFRoZSBmaWVsZCBtYXhfY29kZSBpcyBzZXQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkX3RyZWUocywgZGVzYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7IC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgdmFyIHRyZWUgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgdmFyIHN0cmVlICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIHZhciBoYXNfc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIHZhciBlbGVtcyAgICA9IGRlc2Muc3RhdF9kZXNjLmVsZW1zO1xuICB2YXIgbiwgbTsgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIGhlYXAgZWxlbWVudHMgKi9cbiAgdmFyIG1heF9jb2RlID0gLTE7IC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB2YXIgbm9kZTsgICAgICAgICAgLyogbmV3IG5vZGUgYmVpbmcgY3JlYXRlZCAqL1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgaW5pdGlhbCBoZWFwLCB3aXRoIGxlYXN0IGZyZXF1ZW50IGVsZW1lbnQgaW5cbiAgICogaGVhcFtTTUFMTEVTVF0uIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uXG4gICAqIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqL1xuICBzLmhlYXBfbGVuID0gMDtcbiAgcy5oZWFwX21heCA9IEhFQVBfU0laRTtcblxuICBmb3IgKG4gPSAwOyBuIDwgZWxlbXM7IG4rKykge1xuICAgIGlmICh0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA9IG47XG4gICAgICBzLmRlcHRoW25dID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlIHBremlwIGZvcm1hdCByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IG9uZSBkaXN0YW5jZSBjb2RlIGV4aXN0cyxcbiAgICogYW5kIHRoYXQgYXQgbGVhc3Qgb25lIGJpdCBzaG91bGQgYmUgc2VudCBldmVuIGlmIHRoZXJlIGlzIG9ubHkgb25lXG4gICAqIHBvc3NpYmxlIGNvZGUuIFNvIHRvIGF2b2lkIHNwZWNpYWwgY2hlY2tzIGxhdGVyIG9uIHdlIGZvcmNlIGF0IGxlYXN0XG4gICAqIHR3byBjb2RlcyBvZiBub24gemVybyBmcmVxdWVuY3kuXG4gICAqL1xuICB3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHtcbiAgICBub2RlID0gcy5oZWFwWysrcy5oZWFwX2xlbl0gPSAobWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDApO1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gMTtcbiAgICBzLmRlcHRoW25vZGVdID0gMDtcbiAgICBzLm9wdF9sZW4tLTtcblxuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiAtPSBzdHJlZVtub2RlICogMiArIDFdLyouTGVuKi87XG4gICAgfVxuICAgIC8qIG5vZGUgaXMgMCBvciAxIHNvIGl0IGRvZXMgbm90IGhhdmUgZXh0cmEgYml0cyAqL1xuICB9XG4gIGRlc2MubWF4X2NvZGUgPSBtYXhfY29kZTtcblxuICAvKiBUaGUgZWxlbWVudHMgaGVhcFtoZWFwX2xlbi8yKzEgLi4gaGVhcF9sZW5dIGFyZSBsZWF2ZXMgb2YgdGhlIHRyZWUsXG4gICAqIGVzdGFibGlzaCBzdWItaGVhcHMgb2YgaW5jcmVhc2luZyBsZW5ndGhzOlxuICAgKi9cbiAgZm9yIChuID0gKHMuaGVhcF9sZW4gPj4gMS8qaW50IC8yKi8pOyBuID49IDE7IG4tLSkgeyBwcWRvd25oZWFwKHMsIHRyZWUsIG4pOyB9XG5cbiAgLyogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgYnkgcmVwZWF0ZWRseSBjb21iaW5pbmcgdGhlIGxlYXN0IHR3b1xuICAgKiBmcmVxdWVudCBub2Rlcy5cbiAgICovXG4gIG5vZGUgPSBlbGVtczsgICAgICAgICAgICAgIC8qIG5leHQgaW50ZXJuYWwgbm9kZSBvZiB0aGUgdHJlZSAqL1xuICBkbyB7XG4gICAgLy9wcXJlbW92ZShzLCB0cmVlLCBuKTsgIC8qIG4gPSBub2RlIG9mIGxlYXN0IGZyZXF1ZW5jeSAqL1xuICAgIC8qKiogcHFyZW1vdmUgKioqL1xuICAgIG4gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcbiAgICAvKioqL1xuXG4gICAgbSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTsgLyogbSA9IG5vZGUgb2YgbmV4dCBsZWFzdCBmcmVxdWVuY3kgKi9cblxuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbjsgLyoga2VlcCB0aGUgbm9kZXMgc29ydGVkIGJ5IGZyZXF1ZW5jeSAqL1xuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTtcblxuICAgIC8qIENyZWF0ZSBhIG5ldyBub2RlIGZhdGhlciBvZiBuIGFuZCBtICovXG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSB0cmVlW24gKiAyXS8qLkZyZXEqLyArIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAocy5kZXB0aFtuXSA+PSBzLmRlcHRoW21dID8gcy5kZXB0aFtuXSA6IHMuZGVwdGhbbV0pICsgMTtcbiAgICB0cmVlW24gKiAyICsgMV0vKi5EYWQqLyA9IHRyZWVbbSAqIDIgKyAxXS8qLkRhZCovID0gbm9kZTtcblxuICAgIC8qIGFuZCBpbnNlcnQgdGhlIG5ldyBub2RlIGluIHRoZSBoZWFwICovXG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gbm9kZSsrO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG5cbiAgfSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTtcblxuICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcblxuICAvKiBBdCB0aGlzIHBvaW50LCB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LiBXZSBjYW4gbm93XG4gICAqIGdlbmVyYXRlIHRoZSBiaXQgbGVuZ3Rocy5cbiAgICovXG4gIGdlbl9iaXRsZW4ocywgZGVzYyk7XG5cbiAgLyogVGhlIGZpZWxkIGxlbiBpcyBub3cgc2V0LCB3ZSBjYW4gZ2VuZXJhdGUgdGhlIGJpdCBjb2RlcyAqL1xuICBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIHMuYmxfY291bnQpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2NhbiBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSB0byBkZXRlcm1pbmUgdGhlIGZyZXF1ZW5jaWVzIG9mIHRoZSBjb2Rlc1xuICogaW4gdGhlIGJpdCBsZW5ndGggdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2Nhbl90cmVlKHMsIHRyZWUsIG1heF9jb2RlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIHZhciBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgdmFyIGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgdmFyIG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICB2YXIgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuICB0cmVlWyhtYXhfY29kZSArIDEpICogMiArIDFdLyouTGVuKi8gPSAweGZmZmY7IC8qIGd1YXJkICovXG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovICs9IGNvdW50O1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcblxuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikgeyBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8rKzsgfVxuICAgICAgcy5ibF90cmVlW1JFUF8zXzYgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgcy5ibF90cmVlW1JFUFpfM18xMCAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcy5ibF90cmVlW1JFUFpfMTFfMTM4ICogMl0vKi5GcmVxKi8rKztcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcblxuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSBpbiBjb21wcmVzc2VkIGZvcm0sIHVzaW5nIHRoZSBjb2RlcyBpblxuICogYmxfdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2VuZF90cmVlKHMsIHRyZWUsIG1heF9jb2RlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7IC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICB2YXIgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIHZhciBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIHZhciBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgdmFyIG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIC8qIHRyZWVbbWF4X2NvZGUrMV0uTGVuID0gLTE7ICovICAvKiBndWFyZCBhbHJlYWR5IHNldCAqL1xuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgZG8geyBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpOyB9IHdoaWxlICgtLWNvdW50ICE9PSAwKTtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7XG4gICAgICAgIGNvdW50LS07XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChjb3VudCA+PSAzICYmIGNvdW50IDw9IDYsIFwiIDNfNj9cIik7XG4gICAgICBzZW5kX2NvZGUocywgUkVQXzNfNiwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDIpO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfM18xMCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDMpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzExXzEzOCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDExLCA3KTtcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGZvciB0aGUgYml0IGxlbmd0aHMgYW5kIHJldHVybiB0aGUgaW5kZXggaW5cbiAqIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICovXG5mdW5jdGlvbiBidWlsZF9ibF90cmVlKHMpIHtcbiAgdmFyIG1heF9ibGluZGV4OyAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgYml0IGxlbmd0aCBmcmVxdWVuY2llcyBmb3IgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgc2Nhbl90cmVlKHMsIHMuZHluX2x0cmVlLCBzLmxfZGVzYy5tYXhfY29kZSk7XG4gIHNjYW5fdHJlZShzLCBzLmR5bl9kdHJlZSwgcy5kX2Rlc2MubWF4X2NvZGUpO1xuXG4gIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWU6ICovXG4gIGJ1aWxkX3RyZWUocywgcy5ibF9kZXNjKTtcbiAgLyogb3B0X2xlbiBub3cgaW5jbHVkZXMgdGhlIGxlbmd0aCBvZiB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMsIGV4Y2VwdFxuICAgKiB0aGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aHMgY29kZXMgYW5kIHRoZSA1KzUrNCBiaXRzIGZvciB0aGUgY291bnRzLlxuICAgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBiaXQgbGVuZ3RoIGNvZGVzIHRvIHNlbmQuIFRoZSBwa3ppcCBmb3JtYXRcbiAgICogcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCA0IGJpdCBsZW5ndGggY29kZXMgYmUgc2VudC4gKGFwcG5vdGUudHh0IHNheXNcbiAgICogMyBidXQgdGhlIGFjdHVhbCB2YWx1ZSB1c2VkIGlzIDQuKVxuICAgKi9cbiAgZm9yIChtYXhfYmxpbmRleCA9IEJMX0NPREVTIC0gMTsgbWF4X2JsaW5kZXggPj0gMzsgbWF4X2JsaW5kZXgtLSkge1xuICAgIGlmIChzLmJsX3RyZWVbYmxfb3JkZXJbbWF4X2JsaW5kZXhdICogMiArIDFdLyouTGVuKi8gIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvKiBVcGRhdGUgb3B0X2xlbiB0byBpbmNsdWRlIHRoZSBiaXQgbGVuZ3RoIHRyZWUgYW5kIGNvdW50cyAqL1xuICBzLm9wdF9sZW4gKz0gMyAqIChtYXhfYmxpbmRleCArIDEpICsgNSArIDUgKyA0O1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmR5biB0cmVlczogZHluICVsZCwgc3RhdCAlbGRcIixcbiAgLy8gICAgICAgIHMtPm9wdF9sZW4sIHMtPnN0YXRpY19sZW4pKTtcblxuICByZXR1cm4gbWF4X2JsaW5kZXg7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBoZWFkZXIgZm9yIGEgYmxvY2sgdXNpbmcgZHluYW1pYyBIdWZmbWFuIHRyZWVzOiB0aGUgY291bnRzLCB0aGVcbiAqIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMsIHRoZSBsaXRlcmFsIHRyZWUgYW5kIHRoZSBkaXN0YW5jZSB0cmVlLlxuICogSU4gYXNzZXJ0aW9uOiBsY29kZXMgPj0gMjU3LCBkY29kZXMgPj0gMSwgYmxjb2RlcyA+PSA0LlxuICovXG5mdW5jdGlvbiBzZW5kX2FsbF90cmVlcyhzLCBsY29kZXMsIGRjb2RlcywgYmxjb2Rlcylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBpbnQgbGNvZGVzLCBkY29kZXMsIGJsY29kZXM7IC8qIG51bWJlciBvZiBjb2RlcyBmb3IgZWFjaCB0cmVlICovXG57XG4gIHZhciByYW5rOyAgICAgICAgICAgICAgICAgICAgLyogaW5kZXggaW4gYmxfb3JkZXIgKi9cblxuICAvL0Fzc2VydCAobGNvZGVzID49IDI1NyAmJiBkY29kZXMgPj0gMSAmJiBibGNvZGVzID49IDQsIFwibm90IGVub3VnaCBjb2Rlc1wiKTtcbiAgLy9Bc3NlcnQgKGxjb2RlcyA8PSBMX0NPREVTICYmIGRjb2RlcyA8PSBEX0NPREVTICYmIGJsY29kZXMgPD0gQkxfQ09ERVMsXG4gIC8vICAgICAgICBcInRvbyBtYW55IGNvZGVzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvdW50czogXCIpKTtcbiAgc2VuZF9iaXRzKHMsIGxjb2RlcyAtIDI1NywgNSk7IC8qIG5vdCArMjU1IGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBzZW5kX2JpdHMocywgZGNvZGVzIC0gMSwgICA1KTtcbiAgc2VuZF9iaXRzKHMsIGJsY29kZXMgLSA0LCAgNCk7IC8qIG5vdCAtMyBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgZm9yIChyYW5rID0gMDsgcmFuayA8IGJsY29kZXM7IHJhbmsrKykge1xuICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY29kZSAlMmQgXCIsIGJsX29yZGVyW3JhbmtdKSk7XG4gICAgc2VuZF9iaXRzKHMsIHMuYmxfdHJlZVtibF9vcmRlcltyYW5rXSAqIDIgKyAxXS8qLkxlbiovLCAzKTtcbiAgfVxuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9sdHJlZSwgbGNvZGVzIC0gMSk7IC8qIGxpdGVyYWwgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmxpdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fZHRyZWUsIGRjb2RlcyAtIDEpOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENoZWNrIGlmIHRoZSBkYXRhIHR5cGUgaXMgVEVYVCBvciBCSU5BUlksIHVzaW5nIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtOlxuICogLSBURVhUIGlmIHRoZSB0d28gY29uZGl0aW9ucyBiZWxvdyBhcmUgc2F0aXNmaWVkOlxuICogICAgYSkgVGhlcmUgYXJlIG5vIG5vbi1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJibGFjayBsaXN0XCIgKDAuLjYsIDE0Li4yNSwgMjguLjMxKS5cbiAqICAgIGIpIFRoZXJlIGlzIGF0IGxlYXN0IG9uZSBwcmludGFibGUgY2hhcmFjdGVyIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwid2hpdGUgbGlzdFwiICg5IHtUQUJ9LCAxMCB7TEZ9LCAxMyB7Q1J9LCAzMi4uMjU1KS5cbiAqIC0gQklOQVJZIG90aGVyd2lzZS5cbiAqIC0gVGhlIGZvbGxvd2luZyBwYXJ0aWFsbHktcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGZvcm0gYVxuICogICBcImdyYXkgbGlzdFwiIHRoYXQgaXMgaWdub3JlZCBpbiB0aGlzIGRldGVjdGlvbiBhbGdvcml0aG06XG4gKiAgICg3IHtCRUx9LCA4IHtCU30sIDExIHtWVH0sIDEyIHtGRn0sIDI2IHtTVUJ9LCAyNyB7RVNDfSkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgRnJlcSBvZiBkeW5fbHRyZWUgYXJlIHNldC5cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0X2RhdGFfdHlwZShzKSB7XG4gIC8qIGJsYWNrX21hc2sgaXMgdGhlIGJpdCBtYXNrIG9mIGJsYWNrLWxpc3RlZCBieXRlc1xuICAgKiBzZXQgYml0cyAwLi42LCAxNC4uMjUsIGFuZCAyOC4uMzFcbiAgICogMHhmM2ZmYzA3ZiA9IGJpbmFyeSAxMTExMDAxMTExMTExMTExMTEwMDAwMDAwMTExMTExMVxuICAgKi9cbiAgdmFyIGJsYWNrX21hc2sgPSAweGYzZmZjMDdmO1xuICB2YXIgbjtcblxuICAvKiBDaGVjayBmb3Igbm9uLXRleHR1YWwgKFwiYmxhY2stbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDw9IDMxOyBuKyssIGJsYWNrX21hc2sgPj4+PSAxKSB7XG4gICAgaWYgKChibGFja19tYXNrICYgMSkgJiYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkpIHtcbiAgICAgIHJldHVybiBaX0JJTkFSWTtcbiAgICB9XG4gIH1cblxuICAvKiBDaGVjayBmb3IgdGV4dHVhbCAoXCJ3aGl0ZS1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGlmIChzLmR5bl9sdHJlZVs5ICogMl0vKi5GcmVxKi8gIT09IDAgfHwgcy5keW5fbHRyZWVbMTAgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fFxuICAgICAgcy5keW5fbHRyZWVbMTMgKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgIHJldHVybiBaX1RFWFQ7XG4gIH1cbiAgZm9yIChuID0gMzI7IG4gPCBMSVRFUkFMUzsgbisrKSB7XG4gICAgaWYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcmV0dXJuIFpfVEVYVDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGVyZSBhcmUgbm8gXCJibGFjay1saXN0ZWRcIiBvciBcIndoaXRlLWxpc3RlZFwiIGJ5dGVzOlxuICAgKiB0aGlzIHN0cmVhbSBlaXRoZXIgaXMgZW1wdHkgb3IgaGFzIHRvbGVyYXRlZCAoXCJncmF5LWxpc3RlZFwiKSBieXRlcyBvbmx5LlxuICAgKi9cbiAgcmV0dXJuIFpfQklOQVJZO1xufVxuXG5cbnZhciBzdGF0aWNfaW5pdF9kb25lID0gZmFsc2U7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdHJlZSBkYXRhIHN0cnVjdHVyZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBfdHJfaW5pdChzKVxue1xuXG4gIGlmICghc3RhdGljX2luaXRfZG9uZSkge1xuICAgIHRyX3N0YXRpY19pbml0KCk7XG4gICAgc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG4gIH1cblxuICBzLmxfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fbHRyZWUsIHN0YXRpY19sX2Rlc2MpO1xuICBzLmRfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fZHRyZWUsIHN0YXRpY19kX2Rlc2MpO1xuICBzLmJsX2Rlc2MgPSBuZXcgVHJlZURlc2Mocy5ibF90cmVlLCBzdGF0aWNfYmxfZGVzYyk7XG5cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcblxuICAvKiBJbml0aWFsaXplIHRoZSBmaXJzdCBibG9jayBvZiB0aGUgZmlyc3QgZmlsZTogKi9cbiAgaW5pdF9ibG9jayhzKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBzdG9yZWQgYmxvY2tcbiAqL1xuZnVuY3Rpb24gX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2sgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgc2VuZF9iaXRzKHMsIChTVE9SRURfQkxPQ0sgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7ICAgIC8qIHNlbmQgYmxvY2sgdHlwZSAqL1xuICBjb3B5X2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgdHJ1ZSk7IC8qIHdpdGggaGVhZGVyICovXG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIG9uZSBlbXB0eSBzdGF0aWMgYmxvY2sgdG8gZ2l2ZSBlbm91Z2ggbG9va2FoZWFkIGZvciBpbmZsYXRlLlxuICogVGhpcyB0YWtlcyAxMCBiaXRzLCBvZiB3aGljaCA3IG1heSByZW1haW4gaW4gdGhlIGJpdCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIF90cl9hbGlnbihzKSB7XG4gIHNlbmRfYml0cyhzLCBTVEFUSUNfVFJFRVMgPDwgMSwgMyk7XG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIHN0YXRpY19sdHJlZSk7XG4gIGJpX2ZsdXNoKHMpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nIGZvciB0aGUgY3VycmVudCBibG9jazogZHluYW1pYyB0cmVlcywgc3RhdGljXG4gKiB0cmVlcyBvciBzdG9yZSwgYW5kIG91dHB1dCB0aGUgZW5jb2RlZCBibG9jayB0byB0aGUgemlwIGZpbGUuXG4gKi9cbmZ1bmN0aW9uIF90cl9mbHVzaF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2ssIG9yIE5VTEwgaWYgdG9vIG9sZCAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICB2YXIgb3B0X2xlbmIsIHN0YXRpY19sZW5iOyAgLyogb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBpbiBieXRlcyAqL1xuICB2YXIgbWF4X2JsaW5kZXggPSAwOyAgICAgICAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIEJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzIHVubGVzcyBhIHN0b3JlZCBibG9jayBpcyBmb3JjZWQgKi9cbiAgaWYgKHMubGV2ZWwgPiAwKSB7XG5cbiAgICAvKiBDaGVjayBpZiB0aGUgZmlsZSBpcyBiaW5hcnkgb3IgdGV4dCAqL1xuICAgIGlmIChzLnN0cm0uZGF0YV90eXBlID09PSBaX1VOS05PV04pIHtcbiAgICAgIHMuc3RybS5kYXRhX3R5cGUgPSBkZXRlY3RfZGF0YV90eXBlKHMpO1xuICAgIH1cblxuICAgIC8qIENvbnN0cnVjdCB0aGUgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgICBidWlsZF90cmVlKHMsIHMubF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuXG4gICAgYnVpbGRfdHJlZShzLCBzLmRfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG4gICAgLyogQXQgdGhpcyBwb2ludCwgb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBhcmUgdGhlIHRvdGFsIGJpdCBsZW5ndGhzIG9mXG4gICAgICogdGhlIGNvbXByZXNzZWQgYmxvY2sgZGF0YSwgZXhjbHVkaW5nIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cblxuICAgIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWUgZm9yIHRoZSBhYm92ZSB0d28gdHJlZXMsIGFuZCBnZXQgdGhlIGluZGV4XG4gICAgICogaW4gYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gICAgICovXG4gICAgbWF4X2JsaW5kZXggPSBidWlsZF9ibF90cmVlKHMpO1xuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nLiBDb21wdXRlIHRoZSBibG9jayBsZW5ndGhzIGluIGJ5dGVzLiAqL1xuICAgIG9wdF9sZW5iID0gKHMub3B0X2xlbiArIDMgKyA3KSA+Pj4gMztcbiAgICBzdGF0aWNfbGVuYiA9IChzLnN0YXRpY19sZW4gKyAzICsgNykgPj4+IDM7XG5cbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5vcHQgJWx1KCVsdSkgc3RhdCAlbHUoJWx1KSBzdG9yZWQgJWx1IGxpdCAldSBcIixcbiAgICAvLyAgICAgICAgb3B0X2xlbmIsIHMtPm9wdF9sZW4sIHN0YXRpY19sZW5iLCBzLT5zdGF0aWNfbGVuLCBzdG9yZWRfbGVuLFxuICAgIC8vICAgICAgICBzLT5sYXN0X2xpdCkpO1xuXG4gICAgaWYgKHN0YXRpY19sZW5iIDw9IG9wdF9sZW5iKSB7IG9wdF9sZW5iID0gc3RhdGljX2xlbmI7IH1cblxuICB9IGVsc2Uge1xuICAgIC8vIEFzc2VydChidWYgIT0gKGNoYXIqKTAsIFwibG9zdCBidWZcIik7XG4gICAgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYiA9IHN0b3JlZF9sZW4gKyA1OyAvKiBmb3JjZSBhIHN0b3JlZCBibG9jayAqL1xuICB9XG5cbiAgaWYgKChzdG9yZWRfbGVuICsgNCA8PSBvcHRfbGVuYikgJiYgKGJ1ZiAhPT0gLTEpKSB7XG4gICAgLyogNDogdHdvIHdvcmRzIGZvciB0aGUgbGVuZ3RocyAqL1xuXG4gICAgLyogVGhlIHRlc3QgYnVmICE9IE5VTEwgaXMgb25seSBuZWNlc3NhcnkgaWYgTElUX0JVRlNJWkUgPiBXU0laRS5cbiAgICAgKiBPdGhlcndpc2Ugd2UgY2FuJ3QgaGF2ZSBwcm9jZXNzZWQgbW9yZSB0aGFuIFdTSVpFIGlucHV0IGJ5dGVzIHNpbmNlXG4gICAgICogdGhlIGxhc3QgYmxvY2sgZmx1c2gsIGJlY2F1c2UgY29tcHJlc3Npb24gd291bGQgaGF2ZSBiZWVuXG4gICAgICogc3VjY2Vzc2Z1bC4gSWYgTElUX0JVRlNJWkUgPD0gV1NJWkUsIGl0IGlzIG5ldmVyIHRvbyBsYXRlIHRvXG4gICAgICogdHJhbnNmb3JtIGEgYmxvY2sgaW50byBhIHN0b3JlZCBibG9jay5cbiAgICAgKi9cbiAgICBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCk7XG5cbiAgfSBlbHNlIGlmIChzLnN0cmF0ZWd5ID09PSBaX0ZJWEVEIHx8IHN0YXRpY19sZW5iID09PSBvcHRfbGVuYikge1xuXG4gICAgc2VuZF9iaXRzKHMsIChTVEFUSUNfVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgY29tcHJlc3NfYmxvY2socywgc3RhdGljX2x0cmVlLCBzdGF0aWNfZHRyZWUpO1xuXG4gIH0gZWxzZSB7XG4gICAgc2VuZF9iaXRzKHMsIChEWU5fVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgc2VuZF9hbGxfdHJlZXMocywgcy5sX2Rlc2MubWF4X2NvZGUgKyAxLCBzLmRfZGVzYy5tYXhfY29kZSArIDEsIG1heF9ibGluZGV4ICsgMSk7XG4gICAgY29tcHJlc3NfYmxvY2socywgcy5keW5fbHRyZWUsIHMuZHluX2R0cmVlKTtcbiAgfVxuICAvLyBBc3NlcnQgKHMtPmNvbXByZXNzZWRfbGVuID09IHMtPmJpdHNfc2VudCwgXCJiYWQgY29tcHJlc3NlZCBzaXplXCIpO1xuICAvKiBUaGUgYWJvdmUgY2hlY2sgaXMgbWFkZSBtb2QgMl4zMiwgZm9yIGZpbGVzIGxhcmdlciB0aGFuIDUxMiBNQlxuICAgKiBhbmQgdUxvbmcgaW1wbGVtZW50ZWQgb24gMzIgYml0cy5cbiAgICovXG4gIGluaXRfYmxvY2socyk7XG5cbiAgaWYgKGxhc3QpIHtcbiAgICBiaV93aW5kdXAocyk7XG4gIH1cbiAgLy8gVHJhY2V2KChzdGRlcnIsXCJcXG5jb21wcmxlbiAlbHUoJWx1KSBcIiwgcy0+Y29tcHJlc3NlZF9sZW4+PjMsXG4gIC8vICAgICAgIHMtPmNvbXByZXNzZWRfbGVuLTcqbGFzdCkpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhdmUgdGhlIG1hdGNoIGluZm8gYW5kIHRhbGx5IHRoZSBmcmVxdWVuY3kgY291bnRzLiBSZXR1cm4gdHJ1ZSBpZlxuICogdGhlIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBfdHJfdGFsbHkocywgZGlzdCwgbGMpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdW5zaWduZWQgZGlzdDsgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4vLyAgICB1bnNpZ25lZCBsYzsgICAgLyogbWF0Y2ggbGVuZ3RoLU1JTl9NQVRDSCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdD09MCkgKi9cbntcbiAgLy92YXIgb3V0X2xlbmd0aCwgaW5fbGVuZ3RoLCBkY29kZTtcblxuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMl0gICAgID0gKGRpc3QgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDIgKyAxXSA9IGRpc3QgJiAweGZmO1xuXG4gIHMucGVuZGluZ19idWZbcy5sX2J1ZiArIHMubGFzdF9saXRdID0gbGMgJiAweGZmO1xuICBzLmxhc3RfbGl0Kys7XG5cbiAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAvKiBsYyBpcyB0aGUgdW5tYXRjaGVkIGNoYXIgKi9cbiAgICBzLmR5bl9sdHJlZVtsYyAqIDJdLyouRnJlcSovKys7XG4gIH0gZWxzZSB7XG4gICAgcy5tYXRjaGVzKys7XG4gICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgIGRpc3QtLTsgICAgICAgICAgICAgLyogZGlzdCA9IG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgIC8vQXNzZXJ0KCh1c2gpZGlzdCA8ICh1c2gpTUFYX0RJU1QocykgJiZcbiAgICAvLyAgICAgICAodXNoKWxjIDw9ICh1c2gpKE1BWF9NQVRDSC1NSU5fTUFUQ0gpICYmXG4gICAgLy8gICAgICAgKHVzaClkX2NvZGUoZGlzdCkgPCAodXNoKURfQ09ERVMsICBcIl90cl90YWxseTogYmFkIG1hdGNoXCIpO1xuXG4gICAgcy5keW5fbHRyZWVbKF9sZW5ndGhfY29kZVtsY10gKyBMSVRFUkFMUyArIDEpICogMl0vKi5GcmVxKi8rKztcbiAgICBzLmR5bl9kdHJlZVtkX2NvZGUoZGlzdCkgKiAyXS8qLkZyZXEqLysrO1xuICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG5cbi8vI2lmZGVmIFRSVU5DQVRFX0JMT0NLXG4vLyAgLyogVHJ5IHRvIGd1ZXNzIGlmIGl0IGlzIHByb2ZpdGFibGUgdG8gc3RvcCB0aGUgY3VycmVudCBibG9jayBoZXJlICovXG4vLyAgaWYgKChzLmxhc3RfbGl0ICYgMHgxZmZmKSA9PT0gMCAmJiBzLmxldmVsID4gMikge1xuLy8gICAgLyogQ29tcHV0ZSBhbiB1cHBlciBib3VuZCBmb3IgdGhlIGNvbXByZXNzZWQgbGVuZ3RoICovXG4vLyAgICBvdXRfbGVuZ3RoID0gcy5sYXN0X2xpdCo4O1xuLy8gICAgaW5fbGVuZ3RoID0gcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQ7XG4vL1xuLy8gICAgZm9yIChkY29kZSA9IDA7IGRjb2RlIDwgRF9DT0RFUzsgZGNvZGUrKykge1xuLy8gICAgICBvdXRfbGVuZ3RoICs9IHMuZHluX2R0cmVlW2Rjb2RlKjJdLyouRnJlcSovICogKDUgKyBleHRyYV9kYml0c1tkY29kZV0pO1xuLy8gICAgfVxuLy8gICAgb3V0X2xlbmd0aCA+Pj49IDM7XG4vLyAgICAvL1RyYWNldigoc3RkZXJyLFwiXFxubGFzdF9saXQgJXUsIGluICVsZCwgb3V0IH4lbGQoJWxkJSUpIFwiLFxuLy8gICAgLy8gICAgICAgcy0+bGFzdF9saXQsIGluX2xlbmd0aCwgb3V0X2xlbmd0aCxcbi8vICAgIC8vICAgICAgIDEwMEwgLSBvdXRfbGVuZ3RoKjEwMEwvaW5fbGVuZ3RoKSk7XG4vLyAgICBpZiAocy5tYXRjaGVzIDwgKHMubGFzdF9saXQ+PjEpLyppbnQgLzIqLyAmJiBvdXRfbGVuZ3RoIDwgKGluX2xlbmd0aD4+MSkvKmludCAvMiovKSB7XG4vLyAgICAgIHJldHVybiB0cnVlO1xuLy8gICAgfVxuLy8gIH1cbi8vI2VuZGlmXG5cbiAgcmV0dXJuIChzLmxhc3RfbGl0ID09PSBzLmxpdF9idWZzaXplIC0gMSk7XG4gIC8qIFdlIGF2b2lkIGVxdWFsaXR5IHdpdGggbGl0X2J1ZnNpemUgYmVjYXVzZSBvZiB3cmFwYXJvdW5kIGF0IDY0S1xuICAgKiBvbiAxNiBiaXQgbWFjaGluZXMgYW5kIGJlY2F1c2Ugc3RvcmVkIGJsb2NrcyBhcmUgcmVzdHJpY3RlZCB0b1xuICAgKiA2NEstMSBieXRlcy5cbiAgICovXG59XG5cbmV4cG9ydHMuX3RyX2luaXQgID0gX3RyX2luaXQ7XG5leHBvcnRzLl90cl9zdG9yZWRfYmxvY2sgPSBfdHJfc3RvcmVkX2Jsb2NrO1xuZXhwb3J0cy5fdHJfZmx1c2hfYmxvY2sgID0gX3RyX2ZsdXNoX2Jsb2NrO1xuZXhwb3J0cy5fdHJfdGFsbHkgPSBfdHJfdGFsbHk7XG5leHBvcnRzLl90cl9hbGlnbiA9IF90cl9hbGlnbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgICA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xudmFyIHRyZWVzICAgPSByZXF1aXJlKCcuL3RyZWVzJyk7XG52YXIgYWRsZXIzMiA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xudmFyIGNyYzMyICAgPSByZXF1aXJlKCcuL2NyYzMyJyk7XG52YXIgbXNnICAgICA9IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xudmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG52YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcbi8vdmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG52YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xudmFyIFpfQkxPQ0sgICAgICAgICA9IDU7XG4vL3ZhciBaX1RSRUVTICAgICAgICAgPSA2O1xuXG5cbi8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAqL1xudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbi8vdmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbi8vdmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SICAgICA9IC01O1xuLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7XG5cblxuLyogY29tcHJlc3Npb24gbGV2ZWxzICovXG4vL3ZhciBaX05PX0NPTVBSRVNTSU9OICAgICAgPSAwO1xuLy92YXIgWl9CRVNUX1NQRUVEICAgICAgICAgID0gMTtcbi8vdmFyIFpfQkVTVF9DT01QUkVTU0lPTiAgICA9IDk7XG52YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7XG5cblxudmFyIFpfRklMVEVSRUQgICAgICAgICAgICA9IDE7XG52YXIgWl9IVUZGTUFOX09OTFkgICAgICAgID0gMjtcbnZhciBaX1JMRSAgICAgICAgICAgICAgICAgPSAzO1xudmFyIFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG52YXIgWl9ERUZBVUxUX1NUUkFURUdZICAgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuLy92YXIgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbi8vdmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxudmFyIFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cblxuLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbnZhciBNQVhfTUVNX0xFVkVMID0gOTtcbi8qIE1heGltdW0gdmFsdWUgZm9yIG1lbUxldmVsIGluIGRlZmxhdGVJbml0MiAqL1xudmFyIE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG52YXIgREVGX01FTV9MRVZFTCA9IDg7XG5cblxudmFyIExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cbnZhciBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG52YXIgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG52YXIgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG52YXIgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG52YXIgTUFYX0JJVFMgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxudmFyIE1JTl9NQVRDSCA9IDM7XG52YXIgTUFYX01BVENIID0gMjU4O1xudmFyIE1JTl9MT09LQUhFQUQgPSAoTUFYX01BVENIICsgTUlOX01BVENIICsgMSk7XG5cbnZhciBQUkVTRVRfRElDVCA9IDB4MjA7XG5cbnZhciBJTklUX1NUQVRFID0gNDI7XG52YXIgRVhUUkFfU1RBVEUgPSA2OTtcbnZhciBOQU1FX1NUQVRFID0gNzM7XG52YXIgQ09NTUVOVF9TVEFURSA9IDkxO1xudmFyIEhDUkNfU1RBVEUgPSAxMDM7XG52YXIgQlVTWV9TVEFURSA9IDExMztcbnZhciBGSU5JU0hfU1RBVEUgPSA2NjY7XG5cbnZhciBCU19ORUVEX01PUkUgICAgICA9IDE7IC8qIGJsb2NrIG5vdCBjb21wbGV0ZWQsIG5lZWQgbW9yZSBpbnB1dCBvciBtb3JlIG91dHB1dCAqL1xudmFyIEJTX0JMT0NLX0RPTkUgICAgID0gMjsgLyogYmxvY2sgZmx1c2ggcGVyZm9ybWVkICovXG52YXIgQlNfRklOSVNIX1NUQVJURUQgPSAzOyAvKiBmaW5pc2ggc3RhcnRlZCwgbmVlZCBvbmx5IG1vcmUgb3V0cHV0IGF0IG5leHQgZGVmbGF0ZSAqL1xudmFyIEJTX0ZJTklTSF9ET05FICAgID0gNDsgLyogZmluaXNoIGRvbmUsIGFjY2VwdCBubyBtb3JlIGlucHV0IG9yIG91dHB1dCAqL1xuXG52YXIgT1NfQ09ERSA9IDB4MDM7IC8vIFVuaXggOikgLiBEb24ndCBkZXRlY3QsIHVzZSB0aGlzIGRlZmF1bHQuXG5cbmZ1bmN0aW9uIGVycihzdHJtLCBlcnJvckNvZGUpIHtcbiAgc3RybS5tc2cgPSBtc2dbZXJyb3JDb2RlXTtcbiAgcmV0dXJuIGVycm9yQ29kZTtcbn1cblxuZnVuY3Rpb24gcmFuayhmKSB7XG4gIHJldHVybiAoKGYpIDw8IDEpIC0gKChmKSA+IDQgPyA5IDogMCk7XG59XG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IHZhciBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUuIEFsbCBkZWZsYXRlKCkgb3V0cHV0IGdvZXNcbiAqIHRocm91Z2ggdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXRcbiAqIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5vdXRwdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGludG8gaXQuXG4gKiAoU2VlIGFsc28gcmVhZF9idWYoKSkuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoX3BlbmRpbmcoc3RybSkge1xuICB2YXIgcyA9IHN0cm0uc3RhdGU7XG5cbiAgLy9fdHJfZmx1c2hfYml0cyhzKTtcbiAgdmFyIGxlbiA9IHMucGVuZGluZztcbiAgaWYgKGxlbiA+IHN0cm0uYXZhaWxfb3V0KSB7XG4gICAgbGVuID0gc3RybS5hdmFpbF9vdXQ7XG4gIH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm47IH1cblxuICB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nX291dCwgbGVuLCBzdHJtLm5leHRfb3V0KTtcbiAgc3RybS5uZXh0X291dCArPSBsZW47XG4gIHMucGVuZGluZ19vdXQgKz0gbGVuO1xuICBzdHJtLnRvdGFsX291dCArPSBsZW47XG4gIHN0cm0uYXZhaWxfb3V0IC09IGxlbjtcbiAgcy5wZW5kaW5nIC09IGxlbjtcbiAgaWYgKHMucGVuZGluZyA9PT0gMCkge1xuICAgIHMucGVuZGluZ19vdXQgPSAwO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZmx1c2hfYmxvY2tfb25seShzLCBsYXN0KSB7XG4gIHRyZWVzLl90cl9mbHVzaF9ibG9jayhzLCAocy5ibG9ja19zdGFydCA+PSAwID8gcy5ibG9ja19zdGFydCA6IC0xKSwgcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQsIGxhc3QpO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgZmx1c2hfcGVuZGluZyhzLnN0cm0pO1xufVxuXG5cbmZ1bmN0aW9uIHB1dF9ieXRlKHMsIGIpIHtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFB1dCBhIHNob3J0IGluIHRoZSBwZW5kaW5nIGJ1ZmZlci4gVGhlIDE2LWJpdCB2YWx1ZSBpcyBwdXQgaW4gTVNCIG9yZGVyLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgc3RyZWFtIHN0YXRlIGlzIGNvcnJlY3QgYW5kIHRoZXJlIGlzIGVub3VnaCByb29tIGluXG4gKiBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gcHV0U2hvcnRNU0IocywgYikge1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiID4+IDgpKTtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiAmIDB4ZmYpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAoYiA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGIgJiAweGZmO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVhZCBhIG5ldyBidWZmZXIgZnJvbSB0aGUgY3VycmVudCBpbnB1dCBzdHJlYW0sIHVwZGF0ZSB0aGUgYWRsZXIzMlxuICogYW5kIHRvdGFsIG51bWJlciBvZiBieXRlcyByZWFkLiAgQWxsIGRlZmxhdGUoKSBpbnB1dCBnb2VzIHRocm91Z2hcbiAqIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0IHRvIGF2b2lkXG4gKiBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+aW5wdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGZyb20gaXQuXG4gKiAoU2VlIGFsc28gZmx1c2hfcGVuZGluZygpKS5cbiAqL1xuZnVuY3Rpb24gcmVhZF9idWYoc3RybSwgYnVmLCBzdGFydCwgc2l6ZSkge1xuICB2YXIgbGVuID0gc3RybS5hdmFpbF9pbjtcblxuICBpZiAobGVuID4gc2l6ZSkgeyBsZW4gPSBzaXplOyB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuIDA7IH1cblxuICBzdHJtLmF2YWlsX2luIC09IGxlbjtcblxuICAvLyB6bWVtY3B5KGJ1Ziwgc3RybS0+bmV4dF9pbiwgbGVuKTtcbiAgdXRpbHMuYXJyYXlTZXQoYnVmLCBzdHJtLmlucHV0LCBzdHJtLm5leHRfaW4sIGxlbiwgc3RhcnQpO1xuICBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAxKSB7XG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIGVsc2UgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMikge1xuICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgc3RybS5uZXh0X2luICs9IGxlbjtcbiAgc3RybS50b3RhbF9pbiArPSBsZW47XG5cbiAgcmV0dXJuIGxlbjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNldCBtYXRjaF9zdGFydCB0byB0aGUgbG9uZ2VzdCBtYXRjaCBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gc3RyaW5nIGFuZFxuICogcmV0dXJuIGl0cyBsZW5ndGguIE1hdGNoZXMgc2hvcnRlciBvciBlcXVhbCB0byBwcmV2X2xlbmd0aCBhcmUgZGlzY2FyZGVkLFxuICogaW4gd2hpY2ggY2FzZSB0aGUgcmVzdWx0IGlzIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFuZCBtYXRjaF9zdGFydCBpc1xuICogZ2FyYmFnZS5cbiAqIElOIGFzc2VydGlvbnM6IGN1cl9tYXRjaCBpcyB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiBmb3IgdGhlIGN1cnJlbnRcbiAqICAgc3RyaW5nIChzdHJzdGFydCkgYW5kIGl0cyBkaXN0YW5jZSBpcyA8PSBNQVhfRElTVCwgYW5kIHByZXZfbGVuZ3RoID49IDFcbiAqIE9VVCBhc3NlcnRpb246IHRoZSBtYXRjaCBsZW5ndGggaXMgbm90IGdyZWF0ZXIgdGhhbiBzLT5sb29rYWhlYWQuXG4gKi9cbmZ1bmN0aW9uIGxvbmdlc3RfbWF0Y2gocywgY3VyX21hdGNoKSB7XG4gIHZhciBjaGFpbl9sZW5ndGggPSBzLm1heF9jaGFpbl9sZW5ndGg7ICAgICAgLyogbWF4IGhhc2ggY2hhaW4gbGVuZ3RoICovXG4gIHZhciBzY2FuID0gcy5zdHJzdGFydDsgLyogY3VycmVudCBzdHJpbmcgKi9cbiAgdmFyIG1hdGNoOyAgICAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2hlZCBzdHJpbmcgKi9cbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBtYXRjaCAqL1xuICB2YXIgYmVzdF9sZW4gPSBzLnByZXZfbGVuZ3RoOyAgICAgICAgICAgICAgLyogYmVzdCBtYXRjaCBsZW5ndGggc28gZmFyICovXG4gIHZhciBuaWNlX21hdGNoID0gcy5uaWNlX21hdGNoOyAgICAgICAgICAgICAvKiBzdG9wIGlmIG1hdGNoIGxvbmcgZW5vdWdoICovXG4gIHZhciBsaW1pdCA9IChzLnN0cnN0YXJ0ID4gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpID9cbiAgICAgIHMuc3Ryc3RhcnQgLSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSA6IDAvKk5JTCovO1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7IC8vIHNob3J0Y3V0XG5cbiAgdmFyIHdtYXNrID0gcy53X21hc2s7XG4gIHZhciBwcmV2ICA9IHMucHJldjtcblxuICAvKiBTdG9wIHdoZW4gY3VyX21hdGNoIGJlY29tZXMgPD0gbGltaXQuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLFxuICAgKiB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nIG9mIHdpbmRvdyBpbmRleCAwLlxuICAgKi9cblxuICB2YXIgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgdmFyIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICB2YXIgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcblxuICAvKiBUaGUgY29kZSBpcyBvcHRpbWl6ZWQgZm9yIEhBU0hfQklUUyA+PSA4IGFuZCBNQVhfTUFUQ0gtMiBtdWx0aXBsZSBvZiAxNi5cbiAgICogSXQgaXMgZWFzeSB0byBnZXQgcmlkIG9mIHRoaXMgb3B0aW1pemF0aW9uIGlmIG5lY2Vzc2FyeS5cbiAgICovXG4gIC8vIEFzc2VydChzLT5oYXNoX2JpdHMgPj0gOCAmJiBNQVhfTUFUQ0ggPT0gMjU4LCBcIkNvZGUgdG9vIGNsZXZlclwiKTtcblxuICAvKiBEbyBub3Qgd2FzdGUgdG9vIG11Y2ggdGltZSBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBnb29kIG1hdGNoOiAqL1xuICBpZiAocy5wcmV2X2xlbmd0aCA+PSBzLmdvb2RfbWF0Y2gpIHtcbiAgICBjaGFpbl9sZW5ndGggPj49IDI7XG4gIH1cbiAgLyogRG8gbm90IGxvb2sgZm9yIG1hdGNoZXMgYmV5b25kIHRoZSBlbmQgb2YgdGhlIGlucHV0LiBUaGlzIGlzIG5lY2Vzc2FyeVxuICAgKiB0byBtYWtlIGRlZmxhdGUgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIGlmIChuaWNlX21hdGNoID4gcy5sb29rYWhlYWQpIHsgbmljZV9tYXRjaCA9IHMubG9va2FoZWFkOyB9XG5cbiAgLy8gQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUtTUlOX0xPT0tBSEVBRCwgXCJuZWVkIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgLy8gQXNzZXJ0KGN1cl9tYXRjaCA8IHMtPnN0cnN0YXJ0LCBcIm5vIGZ1dHVyZVwiKTtcbiAgICBtYXRjaCA9IGN1cl9tYXRjaDtcblxuICAgIC8qIFNraXAgdG8gbmV4dCBtYXRjaCBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGNhbm5vdCBpbmNyZWFzZVxuICAgICAqIG9yIGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbGVzcyB0aGFuIDIuICBOb3RlIHRoYXQgdGhlIGNoZWNrcyBiZWxvd1xuICAgICAqIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgb2NjdXIgb2NjYXNpb25hbGx5IGZvciBwZXJmb3JtYW5jZVxuICAgICAqIHJlYXNvbnMuICBUaGVyZWZvcmUgdW5pbml0aWFsaXplZCBtZW1vcnkgd2lsbCBiZSBhY2Nlc3NlZCwgYW5kXG4gICAgICogY29uZGl0aW9uYWwganVtcHMgd2lsbCBiZSBtYWRlIHRoYXQgZGVwZW5kIG9uIHRob3NlIHZhbHVlcy5cbiAgICAgKiBIb3dldmVyIHRoZSBsZW5ndGggb2YgdGhlIG1hdGNoIGlzIGxpbWl0ZWQgdG8gdGhlIGxvb2thaGVhZCwgc29cbiAgICAgKiB0aGUgb3V0cHV0IG9mIGRlZmxhdGUgaXMgbm90IGFmZmVjdGVkIGJ5IHRoZSB1bmluaXRpYWxpemVkIHZhbHVlcy5cbiAgICAgKi9cblxuICAgIGlmIChfd2luW21hdGNoICsgYmVzdF9sZW5dICAgICAhPT0gc2Nhbl9lbmQgIHx8XG4gICAgICAgIF93aW5bbWF0Y2ggKyBiZXN0X2xlbiAtIDFdICE9PSBzY2FuX2VuZDEgfHxcbiAgICAgICAgX3dpblttYXRjaF0gICAgICAgICAgICAgICAgIT09IF93aW5bc2Nhbl0gfHxcbiAgICAgICAgX3dpblsrK21hdGNoXSAgICAgICAgICAgICAgIT09IF93aW5bc2NhbiArIDFdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKiBUaGUgY2hlY2sgYXQgYmVzdF9sZW4tMSBjYW4gYmUgcmVtb3ZlZCBiZWNhdXNlIGl0IHdpbGwgYmUgbWFkZVxuICAgICAqIGFnYWluIGxhdGVyLiAoVGhpcyBoZXVyaXN0aWMgaXMgbm90IGFsd2F5cyBhIHdpbi4pXG4gICAgICogSXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjb21wYXJlIHNjYW5bMl0gYW5kIG1hdGNoWzJdIHNpbmNlIHRoZXlcbiAgICAgKiBhcmUgYWx3YXlzIGVxdWFsIHdoZW4gdGhlIG90aGVyIGJ5dGVzIG1hdGNoLCBnaXZlbiB0aGF0XG4gICAgICogdGhlIGhhc2gga2V5cyBhcmUgZXF1YWwgYW5kIHRoYXQgSEFTSF9CSVRTID49IDguXG4gICAgICovXG4gICAgc2NhbiArPSAyO1xuICAgIG1hdGNoKys7XG4gICAgLy8gQXNzZXJ0KCpzY2FuID09ICptYXRjaCwgXCJtYXRjaFsyXT9cIik7XG5cbiAgICAvKiBXZSBjaGVjayBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IGV2ZXJ5IDh0aCBjb21wYXJpc29uO1xuICAgICAqIHRoZSAyNTZ0aCBjaGVjayB3aWxsIGJlIG1hZGUgYXQgc3Ryc3RhcnQrMjU4LlxuICAgICAqL1xuICAgIGRvIHtcbiAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgIH0gd2hpbGUgKF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcblxuICAgIC8vIEFzc2VydChzY2FuIDw9IHMtPndpbmRvdysodW5zaWduZWQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcblxuICAgIGxlbiA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICBzY2FuID0gc3RyZW5kIC0gTUFYX01BVENIO1xuXG4gICAgaWYgKGxlbiA+IGJlc3RfbGVuKSB7XG4gICAgICBzLm1hdGNoX3N0YXJ0ID0gY3VyX21hdGNoO1xuICAgICAgYmVzdF9sZW4gPSBsZW47XG4gICAgICBpZiAobGVuID49IG5pY2VfbWF0Y2gpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgICAgIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG4gICAgfVxuICB9IHdoaWxlICgoY3VyX21hdGNoID0gcHJldltjdXJfbWF0Y2ggJiB3bWFza10pID4gbGltaXQgJiYgLS1jaGFpbl9sZW5ndGggIT09IDApO1xuXG4gIGlmIChiZXN0X2xlbiA8PSBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBiZXN0X2xlbjtcbiAgfVxuICByZXR1cm4gcy5sb29rYWhlYWQ7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGaWxsIHRoZSB3aW5kb3cgd2hlbiB0aGUgbG9va2FoZWFkIGJlY29tZXMgaW5zdWZmaWNpZW50LlxuICogVXBkYXRlcyBzdHJzdGFydCBhbmQgbG9va2FoZWFkLlxuICpcbiAqIElOIGFzc2VydGlvbjogbG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRFxuICogT1VUIGFzc2VydGlvbnM6IHN0cnN0YXJ0IDw9IHdpbmRvd19zaXplLU1JTl9MT09LQUhFQURcbiAqICAgIEF0IGxlYXN0IG9uZSBieXRlIGhhcyBiZWVuIHJlYWQsIG9yIGF2YWlsX2luID09IDA7IHJlYWRzIGFyZVxuICogICAgcGVyZm9ybWVkIGZvciBhdCBsZWFzdCB0d28gYnl0ZXMgKHJlcXVpcmVkIGZvciB0aGUgemlwIHRyYW5zbGF0ZV9lb2xcbiAqICAgIG9wdGlvbiAtLSBub3Qgc3VwcG9ydGVkIGhlcmUpLlxuICovXG5mdW5jdGlvbiBmaWxsX3dpbmRvdyhzKSB7XG4gIHZhciBfd19zaXplID0gcy53X3NpemU7XG4gIHZhciBwLCBuLCBtLCBtb3JlLCBzdHI7XG5cbiAgLy9Bc3NlcnQocy0+bG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCwgXCJhbHJlYWR5IGVub3VnaCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIG1vcmUgPSBzLndpbmRvd19zaXplIC0gcy5sb29rYWhlYWQgLSBzLnN0cnN0YXJ0O1xuXG4gICAgLy8gSlMgaW50cyBoYXZlIDMyIGJpdCwgYmxvY2sgYmVsb3cgbm90IG5lZWRlZFxuICAgIC8qIERlYWwgd2l0aCAhQCMkJSA2NEsgbGltaXQ6ICovXG4gICAgLy9pZiAoc2l6ZW9mKGludCkgPD0gMikge1xuICAgIC8vICAgIGlmIChtb3JlID09IDAgJiYgcy0+c3Ryc3RhcnQgPT0gMCAmJiBzLT5sb29rYWhlYWQgPT0gMCkge1xuICAgIC8vICAgICAgICBtb3JlID0gd3NpemU7XG4gICAgLy9cbiAgICAvLyAgfSBlbHNlIGlmIChtb3JlID09ICh1bnNpZ25lZCkoLTEpKSB7XG4gICAgLy8gICAgICAgIC8qIFZlcnkgdW5saWtlbHksIGJ1dCBwb3NzaWJsZSBvbiAxNiBiaXQgbWFjaGluZSBpZlxuICAgIC8vICAgICAgICAgKiBzdHJzdGFydCA9PSAwICYmIGxvb2thaGVhZCA9PSAxIChpbnB1dCBkb25lIGEgYnl0ZSBhdCB0aW1lKVxuICAgIC8vICAgICAgICAgKi9cbiAgICAvLyAgICAgICAgbW9yZS0tO1xuICAgIC8vICAgIH1cbiAgICAvL31cblxuXG4gICAgLyogSWYgdGhlIHdpbmRvdyBpcyBhbG1vc3QgZnVsbCBhbmQgdGhlcmUgaXMgaW5zdWZmaWNpZW50IGxvb2thaGVhZCxcbiAgICAgKiBtb3ZlIHRoZSB1cHBlciBoYWxmIHRvIHRoZSBsb3dlciBvbmUgdG8gbWFrZSByb29tIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0ID49IF93X3NpemUgKyAoX3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG5cbiAgICAgIHV0aWxzLmFycmF5U2V0KHMud2luZG93LCBzLndpbmRvdywgX3dfc2l6ZSwgX3dfc2l6ZSwgMCk7XG4gICAgICBzLm1hdGNoX3N0YXJ0IC09IF93X3NpemU7XG4gICAgICBzLnN0cnN0YXJ0IC09IF93X3NpemU7XG4gICAgICAvKiB3ZSBub3cgaGF2ZSBzdHJzdGFydCA+PSBNQVhfRElTVCAqL1xuICAgICAgcy5ibG9ja19zdGFydCAtPSBfd19zaXplO1xuXG4gICAgICAvKiBTbGlkZSB0aGUgaGFzaCB0YWJsZSAoY291bGQgYmUgYXZvaWRlZCB3aXRoIDMyIGJpdCB2YWx1ZXNcbiAgICAgICBhdCB0aGUgZXhwZW5zZSBvZiBtZW1vcnkgdXNhZ2UpLiBXZSBzbGlkZSBldmVuIHdoZW4gbGV2ZWwgPT0gMFxuICAgICAgIHRvIGtlZXAgdGhlIGhhc2ggdGFibGUgY29uc2lzdGVudCBpZiB3ZSBzd2l0Y2ggYmFjayB0byBsZXZlbCA+IDBcbiAgICAgICBsYXRlci4gKFVzaW5nIGxldmVsIDAgcGVybWFuZW50bHkgaXMgbm90IGFuIG9wdGltYWwgdXNhZ2Ugb2ZcbiAgICAgICB6bGliLCBzbyB3ZSBkb24ndCBjYXJlIGFib3V0IHRoaXMgcGF0aG9sb2dpY2FsIGNhc2UuKVxuICAgICAgICovXG5cbiAgICAgIG4gPSBzLmhhc2hfc2l6ZTtcbiAgICAgIHAgPSBuO1xuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5oZWFkWy0tcF07XG4gICAgICAgIHMuaGVhZFtwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbiA9IF93X3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMucHJldlstLXBdO1xuICAgICAgICBzLnByZXZbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgICAgLyogSWYgbiBpcyBub3Qgb24gYW55IGhhc2ggY2hhaW4sIHByZXZbbl0gaXMgZ2FyYmFnZSBidXRcbiAgICAgICAgICogaXRzIHZhbHVlIHdpbGwgbmV2ZXIgYmUgdXNlZC5cbiAgICAgICAgICovXG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBtb3JlICs9IF93X3NpemU7XG4gICAgfVxuICAgIGlmIChzLnN0cm0uYXZhaWxfaW4gPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8qIElmIHRoZXJlIHdhcyBubyBzbGlkaW5nOlxuICAgICAqICAgIHN0cnN0YXJ0IDw9IFdTSVpFK01BWF9ESVNULTEgJiYgbG9va2FoZWFkIDw9IE1JTl9MT09LQUhFQUQgLSAxICYmXG4gICAgICogICAgbW9yZSA9PSB3aW5kb3dfc2l6ZSAtIGxvb2thaGVhZCAtIHN0cnN0YXJ0XG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIChNSU5fTE9PS0FIRUFELTEgKyBXU0laRSArIE1BWF9ESVNULTEpXG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIDIqV1NJWkUgKyAyXG4gICAgICogSW4gdGhlIEJJR19NRU0gb3IgTU1BUCBjYXNlIChub3QgeWV0IHN1cHBvcnRlZCksXG4gICAgICogICB3aW5kb3dfc2l6ZSA9PSBpbnB1dF9zaXplICsgTUlOX0xPT0tBSEVBRCAgJiZcbiAgICAgKiAgIHN0cnN0YXJ0ICsgcy0+bG9va2FoZWFkIDw9IGlucHV0X3NpemUgPT4gbW9yZSA+PSBNSU5fTE9PS0FIRUFELlxuICAgICAqIE90aGVyd2lzZSwgd2luZG93X3NpemUgPT0gMipXU0laRSBzbyBtb3JlID49IDIuXG4gICAgICogSWYgdGhlcmUgd2FzIHNsaWRpbmcsIG1vcmUgPj0gV1NJWkUuIFNvIGluIGFsbCBjYXNlcywgbW9yZSA+PSAyLlxuICAgICAqL1xuICAgIC8vQXNzZXJ0KG1vcmUgPj0gMiwgXCJtb3JlIDwgMlwiKTtcbiAgICBuID0gcmVhZF9idWYocy5zdHJtLCBzLndpbmRvdywgcy5zdHJzdGFydCArIHMubG9va2FoZWFkLCBtb3JlKTtcbiAgICBzLmxvb2thaGVhZCArPSBuO1xuXG4gICAgLyogSW5pdGlhbGl6ZSB0aGUgaGFzaCB2YWx1ZSBub3cgdGhhdCB3ZSBoYXZlIHNvbWUgaW5wdXQ6ICovXG4gICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPj0gTUlOX01BVENIKSB7XG4gICAgICBzdHIgPSBzLnN0cnN0YXJ0IC0gcy5pbnNlcnQ7XG4gICAgICBzLmluc19oID0gcy53aW5kb3dbc3RyXTtcblxuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyAxXSk7ICovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyAxXSkgJiBzLmhhc2hfbWFzaztcbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgQ2FsbCB1cGRhdGVfaGFzaCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICB3aGlsZSAocy5pbnNlcnQpIHtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcblxuICAgICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICAgIHN0cisrO1xuICAgICAgICBzLmluc2VydC0tO1xuICAgICAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA8IE1JTl9NQVRDSCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZSB3aG9sZSBpbnB1dCBoYXMgbGVzcyB0aGFuIE1JTl9NQVRDSCBieXRlcywgaW5zX2ggaXMgZ2FyYmFnZSxcbiAgICAgKiBidXQgdGhpcyBpcyBub3QgaW1wb3J0YW50IHNpbmNlIG9ubHkgbGl0ZXJhbCBieXRlcyB3aWxsIGJlIGVtaXR0ZWQuXG4gICAgICovXG5cbiAgfSB3aGlsZSAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIHMuc3RybS5hdmFpbF9pbiAhPT0gMCk7XG5cbiAgLyogSWYgdGhlIFdJTl9JTklUIGJ5dGVzIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgZGF0YSBoYXZlIG5ldmVyIGJlZW5cbiAgICogd3JpdHRlbiwgdGhlbiB6ZXJvIHRob3NlIGJ5dGVzIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayByZXBvcnRzIG9mXG4gICAqIHRoZSB1c2Ugb2YgdW5pbml0aWFsaXplZCAob3IgdW5pbml0aWFsaXNlZCBhcyBKdWxpYW4gd3JpdGVzKSBieXRlcyBieVxuICAgKiB0aGUgbG9uZ2VzdCBtYXRjaCByb3V0aW5lcy4gIFVwZGF0ZSB0aGUgaGlnaCB3YXRlciBtYXJrIGZvciB0aGUgbmV4dFxuICAgKiB0aW1lIHRocm91Z2ggaGVyZS4gIFdJTl9JTklUIGlzIHNldCB0byBNQVhfTUFUQ0ggc2luY2UgdGhlIGxvbmdlc3QgbWF0Y2hcbiAgICogcm91dGluZXMgYWxsb3cgc2Nhbm5pbmcgdG8gc3Ryc3RhcnQgKyBNQVhfTUFUQ0gsIGlnbm9yaW5nIGxvb2thaGVhZC5cbiAgICovXG4vLyAgaWYgKHMuaGlnaF93YXRlciA8IHMud2luZG93X3NpemUpIHtcbi8vICAgIHZhciBjdXJyID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkO1xuLy8gICAgdmFyIGluaXQgPSAwO1xuLy9cbi8vICAgIGlmIChzLmhpZ2hfd2F0ZXIgPCBjdXJyKSB7XG4vLyAgICAgIC8qIFByZXZpb3VzIGhpZ2ggd2F0ZXIgbWFyayBiZWxvdyBjdXJyZW50IGRhdGEgLS0gemVybyBXSU5fSU5JVFxuLy8gICAgICAgKiBieXRlcyBvciB1cCB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSBzLndpbmRvd19zaXplIC0gY3Vycjtcbi8vICAgICAgaWYgKGluaXQgPiBXSU5fSU5JVClcbi8vICAgICAgICBpbml0ID0gV0lOX0lOSVQ7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIGN1cnIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciA9IGN1cnIgKyBpbml0O1xuLy8gICAgfVxuLy8gICAgZWxzZSBpZiAocy0+aGlnaF93YXRlciA8ICh1bGcpY3VyciArIFdJTl9JTklUKSB7XG4vLyAgICAgIC8qIEhpZ2ggd2F0ZXIgbWFyayBhdCBvciBhYm92ZSBjdXJyZW50IGRhdGEsIGJ1dCBiZWxvdyBjdXJyZW50IGRhdGFcbi8vICAgICAgICogcGx1cyBXSU5fSU5JVCAtLSB6ZXJvIG91dCB0byBjdXJyZW50IGRhdGEgcGx1cyBXSU5fSU5JVCwgb3IgdXBcbi8vICAgICAgICogdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gKHVsZyljdXJyICsgV0lOX0lOSVQgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICBpZiAoaW5pdCA+IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcilcbi8vICAgICAgICBpbml0ID0gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBzLT5oaWdoX3dhdGVyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgKz0gaW5pdDtcbi8vICAgIH1cbi8vICB9XG4vL1xuLy8gIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplIC0gTUlOX0xPT0tBSEVBRCxcbi8vICAgIFwibm90IGVub3VnaCByb29tIGZvciBzZWFyY2hcIik7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSB3aXRob3V0IGNvbXByZXNzaW9uIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm5cbiAqIHRoZSBjdXJyZW50IGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBpbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgc2luY2VcbiAqIHVuY29tcHJlc3NpYmxlIGRhdGEgaXMgcHJvYmFibHkgbm90IHVzZWZ1bC4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkXG4gKiBvbmx5IGZvciB0aGUgbGV2ZWw9MCBjb21wcmVzc2lvbiBvcHRpb24uXG4gKiBOT1RFOiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBvcHRpbWl6ZWQgdG8gYXZvaWQgZXh0cmEgY29weWluZyBmcm9tXG4gKiB3aW5kb3cgdG8gcGVuZGluZ19idWYuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfc3RvcmVkKHMsIGZsdXNoKSB7XG4gIC8qIFN0b3JlZCBibG9ja3MgYXJlIGxpbWl0ZWQgdG8gMHhmZmZmIGJ5dGVzLCBwZW5kaW5nX2J1ZiBpcyBsaW1pdGVkXG4gICAqIHRvIHBlbmRpbmdfYnVmX3NpemUsIGFuZCBlYWNoIHN0b3JlZCBibG9jayBoYXMgYSA1IGJ5dGUgaGVhZGVyOlxuICAgKi9cbiAgdmFyIG1heF9ibG9ja19zaXplID0gMHhmZmZmO1xuXG4gIGlmIChtYXhfYmxvY2tfc2l6ZSA+IHMucGVuZGluZ19idWZfc2l6ZSAtIDUpIHtcbiAgICBtYXhfYmxvY2tfc2l6ZSA9IHMucGVuZGluZ19idWZfc2l6ZSAtIDU7XG4gIH1cblxuICAvKiBDb3B5IGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSBpbnB1dCB0byBvdXRwdXQ6ICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBGaWxsIHRoZSB3aW5kb3cgYXMgbXVjaCBhcyBwb3NzaWJsZTogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gMSkge1xuXG4gICAgICAvL0Fzc2VydChzLT5zdHJzdGFydCA8IHMtPndfc2l6ZStNQVhfRElTVChzKSB8fFxuICAgICAgLy8gIHMtPmJsb2NrX3N0YXJ0ID49IChsb25nKXMtPndfc2l6ZSwgXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgaWYgKCEocy5zdHJzdGFydCA8IHMud19zaXplICsgKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgfHxcbi8vICAgICAgICBzLmJsb2NrX3N0YXJ0ID49IHMud19zaXplKSkge1xuLy8gICAgICAgIHRocm93ICBuZXcgRXJyb3IoXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgfVxuXG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuXG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cbiAgICAvL0Fzc2VydChzLT5ibG9ja19zdGFydCA+PSAwTCwgXCJibG9jayBnb25lXCIpO1xuLy8gICAgaWYgKHMuYmxvY2tfc3RhcnQgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJibG9jayBnb25lXCIpO1xuXG4gICAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgICBzLmxvb2thaGVhZCA9IDA7XG5cbiAgICAvKiBFbWl0IGEgc3RvcmVkIGJsb2NrIGlmIHBlbmRpbmdfYnVmIHdpbGwgYmUgZnVsbDogKi9cbiAgICB2YXIgbWF4X3N0YXJ0ID0gcy5ibG9ja19zdGFydCArIG1heF9ibG9ja19zaXplO1xuXG4gICAgaWYgKHMuc3Ryc3RhcnQgPT09IDAgfHwgcy5zdHJzdGFydCA+PSBtYXhfc3RhcnQpIHtcbiAgICAgIC8qIHN0cnN0YXJ0ID09IDAgaXMgcG9zc2libGUgd2hlbiB3cmFwYXJvdW5kIG9uIDE2LWJpdCBtYWNoaW5lICovXG4gICAgICBzLmxvb2thaGVhZCA9IHMuc3Ryc3RhcnQgLSBtYXhfc3RhcnQ7XG4gICAgICBzLnN0cnN0YXJ0ID0gbWF4X3N0YXJ0O1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cblxuXG4gICAgfVxuICAgIC8qIEZsdXNoIGlmIHdlIG1heSBoYXZlIHRvIHNsaWRlLCBvdGhlcndpc2UgYmxvY2tfc3RhcnQgbWF5IGJlY29tZVxuICAgICAqIG5lZ2F0aXZlIGFuZCB0aGUgZGF0YSB3aWxsIGJlIGdvbmU6XG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0ID49IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuXG4gIHMuaW5zZXJ0ID0gMDtcblxuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cblxuICBpZiAocy5zdHJzdGFydCA+IHMuYmxvY2tfc3RhcnQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfTkVFRF9NT1JFO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXByZXNzIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm4gdGhlIGN1cnJlbnRcbiAqIGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBwZXJmb3JtIGxhenkgZXZhbHVhdGlvbiBvZiBtYXRjaGVzIGFuZCBpbnNlcnRzXG4gKiBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBvbmx5IGZvciB1bm1hdGNoZWQgc3RyaW5ncyBvciBmb3Igc2hvcnRcbiAqIG1hdGNoZXMuIEl0IGlzIHVzZWQgb25seSBmb3IgdGhlIGZhc3QgY29tcHJlc3Npb24gb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9mYXN0KHMsIGZsdXNoKSB7XG4gIHZhciBoYXNoX2hlYWQ7ICAgICAgICAvKiBoZWFkIG9mIHRoZSBoYXNoIGNoYWluICovXG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrOyAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBhbHdheXMgbWF0Y2hfbGVuZ3RoIDwgTUlOX01BVENIXG4gICAgICovXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgKChzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkKSA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkpIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuICAgIH1cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvLyBjaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCk7IC8vIGZvciBkZWJ1ZyBvbmx5XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuXG4gICAgICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoXG4gICAgICAgKiBpcyBub3QgdG9vIGxhcmdlLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgICAgICovXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gcy5tYXhfbGF6eV9tYXRjaC8qbWF4X2luc2VydF9sZW5ndGgqLyAmJiBzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGgtLTsgLyogc3RyaW5nIGF0IHN0cnN0YXJ0IGFscmVhZHkgaW4gdGFibGUgKi9cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgICAgLyogc3Ryc3RhcnQgbmV2ZXIgZXhjZWVkcyBXU0laRS1NQVhfTUFUQ0gsIHNvIHRoZXJlIGFyZVxuICAgICAgICAgICAqIGFsd2F5cyBNSU5fTUFUQ0ggYnl0ZXMgYWhlYWQuXG4gICAgICAgICAgICovXG4gICAgICAgIH0gd2hpbGUgKC0tcy5tYXRjaF9sZW5ndGggIT09IDApO1xuICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICB9IGVsc2VcbiAgICAgIHtcbiAgICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgICAgICBzLmluc19oID0gcy53aW5kb3dbcy5zdHJzdGFydF07XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQrMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgMV0pICYgcy5oYXNoX21hc2s7XG5cbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgICAgICAgICBDYWxsIFVQREFURV9IQVNIKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgICAgLyogSWYgbG9va2FoZWFkIDwgTUlOX01BVENILCBpbnNfaCBpcyBnYXJiYWdlLCBidXQgaXQgZG9lcyBub3RcbiAgICAgICAgICogbWF0dGVyIHNpbmNlIGl0IHdpbGwgYmUgcmVjb21wdXRlZCBhdCBuZXh0IGRlZmxhdGUgY2FsbC5cbiAgICAgICAgICovXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy53aW5kb3dbcy5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAoKHMuc3Ryc3RhcnQgPCAoTUlOX01BVENIIC0gMSkpID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDEpO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2FtZSBhcyBhYm92ZSwgYnV0IGFjaGlldmVzIGJldHRlciBjb21wcmVzc2lvbi4gV2UgdXNlIGEgbGF6eVxuICogZXZhbHVhdGlvbiBmb3IgbWF0Y2hlczogYSBtYXRjaCBpcyBmaW5hbGx5IGFkb3B0ZWQgb25seSBpZiB0aGVyZSBpc1xuICogbm8gYmV0dGVyIG1hdGNoIGF0IHRoZSBuZXh0IHdpbmRvdyBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zbG93KHMsIGZsdXNoKSB7XG4gIHZhciBoYXNoX2hlYWQ7ICAgICAgICAgIC8qIGhlYWQgb2YgaGFzaCBjaGFpbiAqL1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgdmFyIG1heF9pbnNlcnQ7XG5cbiAgLyogUHJvY2VzcyB0aGUgaW5wdXQgYmxvY2suICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKi9cbiAgICBzLnByZXZfbGVuZ3RoID0gcy5tYXRjaF9sZW5ndGg7XG4gICAgcy5wcmV2X21hdGNoID0gcy5tYXRjaF9zdGFydDtcbiAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG5cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiBzLnByZXZfbGVuZ3RoIDwgcy5tYXhfbGF6eV9tYXRjaCAmJlxuICAgICAgICBzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpLypNQVhfRElTVChzKSovKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cblxuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IDUgJiZcbiAgICAgICAgIChzLnN0cmF0ZWd5ID09PSBaX0ZJTFRFUkVEIHx8IChzLm1hdGNoX2xlbmd0aCA9PT0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0ID4gNDA5Ni8qVE9PX0ZBUiovKSkpIHtcblxuICAgICAgICAvKiBJZiBwcmV2X21hdGNoIGlzIGFsc28gTUlOX01BVENILCBtYXRjaF9zdGFydCBpcyBnYXJiYWdlXG4gICAgICAgICAqIGJ1dCB3ZSB3aWxsIGlnbm9yZSB0aGUgY3VycmVudCBtYXRjaCBhbnl3YXkuXG4gICAgICAgICAqL1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZXJlIHdhcyBhIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBzdGVwIGFuZCB0aGUgY3VycmVudFxuICAgICAqIG1hdGNoIGlzIG5vdCBiZXR0ZXIsIG91dHB1dCB0aGUgcHJldmlvdXMgbWF0Y2g6XG4gICAgICovXG4gICAgaWYgKHMucHJldl9sZW5ndGggPj0gTUlOX01BVENIICYmIHMubWF0Y2hfbGVuZ3RoIDw9IHMucHJldl9sZW5ndGgpIHtcbiAgICAgIG1heF9pbnNlcnQgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQgLSBNSU5fTUFUQ0g7XG4gICAgICAvKiBEbyBub3QgaW5zZXJ0IHN0cmluZ3MgaW4gaGFzaCB0YWJsZSBiZXlvbmQgdGhpcy4gKi9cblxuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LTEsIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCk7XG5cbiAgICAgIC8qKipfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7KioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENIKTtcbiAgICAgIC8qIEluc2VydCBpbiBoYXNoIHRhYmxlIGFsbCBzdHJpbmdzIHVwIHRvIHRoZSBlbmQgb2YgdGhlIG1hdGNoLlxuICAgICAgICogc3Ryc3RhcnQtMSBhbmQgc3Ryc3RhcnQgYXJlIGFscmVhZHkgaW5zZXJ0ZWQuIElmIHRoZXJlIGlzIG5vdFxuICAgICAgICogZW5vdWdoIGxvb2thaGVhZCwgdGhlIGxhc3QgdHdvIHN0cmluZ3MgYXJlIG5vdCBpbnNlcnRlZCBpblxuICAgICAgICogdGhlIGhhc2ggdGFibGUuXG4gICAgICAgKi9cbiAgICAgIHMubG9va2FoZWFkIC09IHMucHJldl9sZW5ndGggLSAxO1xuICAgICAgcy5wcmV2X2xlbmd0aCAtPSAyO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoKytzLnN0cnN0YXJ0IDw9IG1heF9pbnNlcnQpIHtcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKC0tcy5wcmV2X2xlbmd0aCAhPT0gMCk7XG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIC8qKiovXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgICAvKiBJZiB0aGVyZSB3YXMgbm8gbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHBvc2l0aW9uLCBvdXRwdXQgYVxuICAgICAgICogc2luZ2xlIGxpdGVyYWwuIElmIHRoZXJlIHdhcyBhIG1hdGNoIGJ1dCB0aGUgY3VycmVudCBtYXRjaFxuICAgICAgICogaXMgbG9uZ2VyLCB0cnVuY2F0ZSB0aGUgcHJldmlvdXMgbWF0Y2ggdG8gYSBzaW5nbGUgbGl0ZXJhbC5cbiAgICAgICAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLX09OTFkocywgMCkgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgLyoqKi9cbiAgICAgIH1cbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBUaGVyZSBpcyBubyBwcmV2aW91cyBtYXRjaCB0byBjb21wYXJlIHdpdGgsIHdhaXQgZm9yXG4gICAgICAgKiB0aGUgbmV4dCBzdGVwIHRvIGRlY2lkZS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGZsdXNoICE9IFpfTk9fRkxVU0gsIFwibm8gZmx1c2g/XCIpO1xuICBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIH1cbiAgcy5pbnNlcnQgPSBzLnN0cnN0YXJ0IDwgTUlOX01BVENIIC0gMSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX1JMRSwgc2ltcGx5IGxvb2sgZm9yIHJ1bnMgb2YgYnl0ZXMsIGdlbmVyYXRlIG1hdGNoZXMgb25seSBvZiBkaXN0YW5jZVxuICogb25lLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS4gIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mXG4gKiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBaX1JMRS4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfcmxlKHMsIGZsdXNoKSB7XG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG4gIHZhciBwcmV2OyAgICAgICAgICAgICAgLyogYnl0ZSBhdCBkaXN0YW5jZSBvbmUgdG8gbWF0Y2ggKi9cbiAgdmFyIHNjYW4sIHN0cmVuZDsgICAgICAvKiBzY2FuIGdvZXMgdXAgdG8gc3RyZW5kIGZvciBsZW5ndGggb2YgcnVuICovXG5cbiAgdmFyIF93aW4gPSBzLndpbmRvdztcblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIGxvbmdlc3QgcnVuLCBwbHVzIG9uZSBmb3IgdGhlIHVucm9sbGVkIGxvb3AuXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBTZWUgaG93IG1hbnkgdGltZXMgdGhlIHByZXZpb3VzIGJ5dGUgcmVwZWF0cyAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgPiAwKSB7XG4gICAgICBzY2FuID0gcy5zdHJzdGFydCAtIDE7XG4gICAgICBwcmV2ID0gX3dpbltzY2FuXTtcbiAgICAgIGlmIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSkge1xuICAgICAgICBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgICAgIH0gd2hpbGUgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPiBzLmxvb2thaGVhZCkge1xuICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5sb29rYWhlYWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1SW50KShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG4gICAgfVxuXG4gICAgLyogRW1pdCBtYXRjaCBpZiBoYXZlIHJ1biBvZiBNSU5fTUFUQ0ggb3IgbG9uZ2VyLCBlbHNlIGVtaXQgbGl0ZXJhbCAqL1xuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5zdHJzdGFydCAtIDEsIHMubWF0Y2hfbGVuZ3RoKTtcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfSFVGRk1BTl9PTkxZLCBkbyBub3QgbG9vayBmb3IgbWF0Y2hlcy4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuXG4gKiAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBIdWZmbWFuLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSB7XG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBoYXZlIGEgbGl0ZXJhbCB0byB3cml0ZS4gKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7ICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBPdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcbiAgICBzLmxvb2thaGVhZC0tO1xuICAgIHMuc3Ryc3RhcnQrKztcbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogVmFsdWVzIGZvciBtYXhfbGF6eV9tYXRjaCwgZ29vZF9tYXRjaCBhbmQgbWF4X2NoYWluX2xlbmd0aCwgZGVwZW5kaW5nIG9uXG4gKiB0aGUgZGVzaXJlZCBwYWNrIGxldmVsICgwLi45KS4gVGhlIHZhbHVlcyBnaXZlbiBiZWxvdyBoYXZlIGJlZW4gdHVuZWQgdG9cbiAqIGV4Y2x1ZGUgd29yc3QgY2FzZSBwZXJmb3JtYW5jZSBmb3IgcGF0aG9sb2dpY2FsIGZpbGVzLiBCZXR0ZXIgdmFsdWVzIG1heSBiZVxuICogZm91bmQgZm9yIHNwZWNpZmljIGZpbGVzLlxuICovXG5mdW5jdGlvbiBDb25maWcoZ29vZF9sZW5ndGgsIG1heF9sYXp5LCBuaWNlX2xlbmd0aCwgbWF4X2NoYWluLCBmdW5jKSB7XG4gIHRoaXMuZ29vZF9sZW5ndGggPSBnb29kX2xlbmd0aDtcbiAgdGhpcy5tYXhfbGF6eSA9IG1heF9sYXp5O1xuICB0aGlzLm5pY2VfbGVuZ3RoID0gbmljZV9sZW5ndGg7XG4gIHRoaXMubWF4X2NoYWluID0gbWF4X2NoYWluO1xuICB0aGlzLmZ1bmMgPSBmdW5jO1xufVxuXG52YXIgY29uZmlndXJhdGlvbl90YWJsZTtcblxuY29uZmlndXJhdGlvbl90YWJsZSA9IFtcbiAgLyogICAgICBnb29kIGxhenkgbmljZSBjaGFpbiAqL1xuICBuZXcgQ29uZmlnKDAsIDAsIDAsIDAsIGRlZmxhdGVfc3RvcmVkKSwgICAgICAgICAgLyogMCBzdG9yZSBvbmx5ICovXG4gIG5ldyBDb25maWcoNCwgNCwgOCwgNCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgICAvKiAxIG1heCBzcGVlZCwgbm8gbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoNCwgNSwgMTYsIDgsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAvKiAyICovXG4gIG5ldyBDb25maWcoNCwgNiwgMzIsIDMyLCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAvKiAzICovXG5cbiAgbmV3IENvbmZpZyg0LCA0LCAxNiwgMTYsIGRlZmxhdGVfc2xvdyksICAgICAgICAgIC8qIDQgbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDMyLCAzMiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAvKiA1ICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDEyOCwgMTI4LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA2ICovXG4gIG5ldyBDb25maWcoOCwgMzIsIDEyOCwgMjU2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA3ICovXG4gIG5ldyBDb25maWcoMzIsIDEyOCwgMjU4LCAxMDI0LCBkZWZsYXRlX3Nsb3cpLCAgICAvKiA4ICovXG4gIG5ldyBDb25maWcoMzIsIDI1OCwgMjU4LCA0MDk2LCBkZWZsYXRlX3Nsb3cpICAgICAvKiA5IG1heCBjb21wcmVzc2lvbiAqL1xuXTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIFwibG9uZ2VzdCBtYXRjaFwiIHJvdXRpbmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbVxuICovXG5mdW5jdGlvbiBsbV9pbml0KHMpIHtcbiAgcy53aW5kb3dfc2l6ZSA9IDIgKiBzLndfc2l6ZTtcblxuICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gIC8qIFNldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnM6XG4gICAqL1xuICBzLm1heF9sYXp5X21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfbGF6eTtcbiAgcy5nb29kX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5nb29kX2xlbmd0aDtcbiAgcy5uaWNlX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5uaWNlX2xlbmd0aDtcbiAgcy5tYXhfY2hhaW5fbGVuZ3RoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfY2hhaW47XG5cbiAgcy5zdHJzdGFydCA9IDA7XG4gIHMuYmxvY2tfc3RhcnQgPSAwO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMuaW5zZXJ0ID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzLmluc19oID0gMDtcbn1cblxuXG5mdW5jdGlvbiBEZWZsYXRlU3RhdGUoKSB7XG4gIHRoaXMuc3RybSA9IG51bGw7ICAgICAgICAgICAgLyogcG9pbnRlciBiYWNrIHRvIHRoaXMgemxpYiBzdHJlYW0gKi9cbiAgdGhpcy5zdGF0dXMgPSAwOyAgICAgICAgICAgIC8qIGFzIHRoZSBuYW1lIGltcGxpZXMgKi9cbiAgdGhpcy5wZW5kaW5nX2J1ZiA9IG51bGw7ICAgICAgLyogb3V0cHV0IHN0aWxsIHBlbmRpbmcgKi9cbiAgdGhpcy5wZW5kaW5nX2J1Zl9zaXplID0gMDsgIC8qIHNpemUgb2YgcGVuZGluZ19idWYgKi9cbiAgdGhpcy5wZW5kaW5nX291dCA9IDA7ICAgICAgIC8qIG5leHQgcGVuZGluZyBieXRlIHRvIG91dHB1dCB0byB0aGUgc3RyZWFtICovXG4gIHRoaXMucGVuZGluZyA9IDA7ICAgICAgICAgICAvKiBuYiBvZiBieXRlcyBpbiB0aGUgcGVuZGluZyBidWZmZXIgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5nemhlYWQgPSBudWxsOyAgICAgICAgIC8qIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uIHRvIHdyaXRlICovXG4gIHRoaXMuZ3ppbmRleCA9IDA7ICAgICAgICAgICAvKiB3aGVyZSBpbiBleHRyYSwgbmFtZSwgb3IgY29tbWVudCAqL1xuICB0aGlzLm1ldGhvZCA9IFpfREVGTEFURUQ7IC8qIGNhbiBvbmx5IGJlIERFRkxBVEVEICovXG4gIHRoaXMubGFzdF9mbHVzaCA9IC0xOyAgIC8qIHZhbHVlIG9mIGZsdXNoIHBhcmFtIGZvciBwcmV2aW91cyBkZWZsYXRlIGNhbGwgKi9cblxuICB0aGlzLndfc2l6ZSA9IDA7ICAvKiBMWjc3IHdpbmRvdyBzaXplICgzMksgYnkgZGVmYXVsdCkgKi9cbiAgdGhpcy53X2JpdHMgPSAwOyAgLyogbG9nMih3X3NpemUpICAoOC4uMTYpICovXG4gIHRoaXMud19tYXNrID0gMDsgIC8qIHdfc2l6ZSAtIDEgKi9cblxuICB0aGlzLndpbmRvdyA9IG51bGw7XG4gIC8qIFNsaWRpbmcgd2luZG93LiBJbnB1dCBieXRlcyBhcmUgcmVhZCBpbnRvIHRoZSBzZWNvbmQgaGFsZiBvZiB0aGUgd2luZG93LFxuICAgKiBhbmQgbW92ZSB0byB0aGUgZmlyc3QgaGFsZiBsYXRlciB0byBrZWVwIGEgZGljdGlvbmFyeSBvZiBhdCBsZWFzdCB3U2l6ZVxuICAgKiBieXRlcy4gV2l0aCB0aGlzIG9yZ2FuaXphdGlvbiwgbWF0Y2hlcyBhcmUgbGltaXRlZCB0byBhIGRpc3RhbmNlIG9mXG4gICAqIHdTaXplLU1BWF9NQVRDSCBieXRlcywgYnV0IHRoaXMgZW5zdXJlcyB0aGF0IElPIGlzIGFsd2F5c1xuICAgKiBwZXJmb3JtZWQgd2l0aCBhIGxlbmd0aCBtdWx0aXBsZSBvZiB0aGUgYmxvY2sgc2l6ZS5cbiAgICovXG5cbiAgdGhpcy53aW5kb3dfc2l6ZSA9IDA7XG4gIC8qIEFjdHVhbCBzaXplIG9mIHdpbmRvdzogMip3U2l6ZSwgZXhjZXB0IHdoZW4gdGhlIHVzZXIgaW5wdXQgYnVmZmVyXG4gICAqIGlzIGRpcmVjdGx5IHVzZWQgYXMgc2xpZGluZyB3aW5kb3cuXG4gICAqL1xuXG4gIHRoaXMucHJldiA9IG51bGw7XG4gIC8qIExpbmsgdG8gb2xkZXIgc3RyaW5nIHdpdGggc2FtZSBoYXNoIGluZGV4LiBUbyBsaW1pdCB0aGUgc2l6ZSBvZiB0aGlzXG4gICAqIGFycmF5IHRvIDY0SywgdGhpcyBsaW5rIGlzIG1haW50YWluZWQgb25seSBmb3IgdGhlIGxhc3QgMzJLIHN0cmluZ3MuXG4gICAqIEFuIGluZGV4IGluIHRoaXMgYXJyYXkgaXMgdGh1cyBhIHdpbmRvdyBpbmRleCBtb2R1bG8gMzJLLlxuICAgKi9cblxuICB0aGlzLmhlYWQgPSBudWxsOyAgIC8qIEhlYWRzIG9mIHRoZSBoYXNoIGNoYWlucyBvciBOSUwuICovXG5cbiAgdGhpcy5pbnNfaCA9IDA7ICAgICAgIC8qIGhhc2ggaW5kZXggb2Ygc3RyaW5nIHRvIGJlIGluc2VydGVkICovXG4gIHRoaXMuaGFzaF9zaXplID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gaGFzaCB0YWJsZSAqL1xuICB0aGlzLmhhc2hfYml0cyA9IDA7ICAgLyogbG9nMihoYXNoX3NpemUpICovXG4gIHRoaXMuaGFzaF9tYXNrID0gMDsgICAvKiBoYXNoX3NpemUtMSAqL1xuXG4gIHRoaXMuaGFzaF9zaGlmdCA9IDA7XG4gIC8qIE51bWJlciBvZiBiaXRzIGJ5IHdoaWNoIGluc19oIG11c3QgYmUgc2hpZnRlZCBhdCBlYWNoIGlucHV0XG4gICAqIHN0ZXAuIEl0IG11c3QgYmUgc3VjaCB0aGF0IGFmdGVyIE1JTl9NQVRDSCBzdGVwcywgdGhlIG9sZGVzdFxuICAgKiBieXRlIG5vIGxvbmdlciB0YWtlcyBwYXJ0IGluIHRoZSBoYXNoIGtleSwgdGhhdCBpczpcbiAgICogICBoYXNoX3NoaWZ0ICogTUlOX01BVENIID49IGhhc2hfYml0c1xuICAgKi9cblxuICB0aGlzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgLyogV2luZG93IHBvc2l0aW9uIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGN1cnJlbnQgb3V0cHV0IGJsb2NrLiBHZXRzXG4gICAqIG5lZ2F0aXZlIHdoZW4gdGhlIHdpbmRvdyBpcyBtb3ZlZCBiYWNrd2FyZHMuXG4gICAqL1xuXG4gIHRoaXMubWF0Y2hfbGVuZ3RoID0gMDsgICAgICAvKiBsZW5ndGggb2YgYmVzdCBtYXRjaCAqL1xuICB0aGlzLnByZXZfbWF0Y2ggPSAwOyAgICAgICAgLyogcHJldmlvdXMgbWF0Y2ggKi9cbiAgdGhpcy5tYXRjaF9hdmFpbGFibGUgPSAwOyAgIC8qIHNldCBpZiBwcmV2aW91cyBtYXRjaCBleGlzdHMgKi9cbiAgdGhpcy5zdHJzdGFydCA9IDA7ICAgICAgICAgIC8qIHN0YXJ0IG9mIHN0cmluZyB0byBpbnNlcnQgKi9cbiAgdGhpcy5tYXRjaF9zdGFydCA9IDA7ICAgICAgIC8qIHN0YXJ0IG9mIG1hdGNoaW5nIHN0cmluZyAqL1xuICB0aGlzLmxvb2thaGVhZCA9IDA7ICAgICAgICAgLyogbnVtYmVyIG9mIHZhbGlkIGJ5dGVzIGFoZWFkIGluIHdpbmRvdyAqL1xuXG4gIHRoaXMucHJldl9sZW5ndGggPSAwO1xuICAvKiBMZW5ndGggb2YgdGhlIGJlc3QgbWF0Y2ggYXQgcHJldmlvdXMgc3RlcC4gTWF0Y2hlcyBub3QgZ3JlYXRlciB0aGFuIHRoaXNcbiAgICogYXJlIGRpc2NhcmRlZC4gVGhpcyBpcyB1c2VkIGluIHRoZSBsYXp5IG1hdGNoIGV2YWx1YXRpb24uXG4gICAqL1xuXG4gIHRoaXMubWF4X2NoYWluX2xlbmd0aCA9IDA7XG4gIC8qIFRvIHNwZWVkIHVwIGRlZmxhdGlvbiwgaGFzaCBjaGFpbnMgYXJlIG5ldmVyIHNlYXJjaGVkIGJleW9uZCB0aGlzXG4gICAqIGxlbmd0aC4gIEEgaGlnaGVyIGxpbWl0IGltcHJvdmVzIGNvbXByZXNzaW9uIHJhdGlvIGJ1dCBkZWdyYWRlcyB0aGVcbiAgICogc3BlZWQuXG4gICAqL1xuXG4gIHRoaXMubWF4X2xhenlfbWF0Y2ggPSAwO1xuICAvKiBBdHRlbXB0IHRvIGZpbmQgYSBiZXR0ZXIgbWF0Y2ggb25seSB3aGVuIHRoZSBjdXJyZW50IG1hdGNoIGlzIHN0cmljdGx5XG4gICAqIHNtYWxsZXIgdGhhbiB0aGlzIHZhbHVlLiBUaGlzIG1lY2hhbmlzbSBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uXG4gICAqIGxldmVscyA+PSA0LlxuICAgKi9cbiAgLy8gVGhhdCdzIGFsaWFzIHRvIG1heF9sYXp5X21hdGNoLCBkb24ndCB1c2UgZGlyZWN0bHlcbiAgLy90aGlzLm1heF9pbnNlcnRfbGVuZ3RoID0gMDtcbiAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBub3RcbiAgICogZ3JlYXRlciB0aGFuIHRoaXMgbGVuZ3RoLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgKiBtYXhfaW5zZXJ0X2xlbmd0aCBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uIGxldmVscyA8PSAzLlxuICAgKi9cblxuICB0aGlzLmxldmVsID0gMDsgICAgIC8qIGNvbXByZXNzaW9uIGxldmVsICgxLi45KSAqL1xuICB0aGlzLnN0cmF0ZWd5ID0gMDsgIC8qIGZhdm9yIG9yIGZvcmNlIEh1ZmZtYW4gY29kaW5nKi9cblxuICB0aGlzLmdvb2RfbWF0Y2ggPSAwO1xuICAvKiBVc2UgYSBmYXN0ZXIgc2VhcmNoIHdoZW4gdGhlIHByZXZpb3VzIG1hdGNoIGlzIGxvbmdlciB0aGFuIHRoaXMgKi9cblxuICB0aGlzLm5pY2VfbWF0Y2ggPSAwOyAvKiBTdG9wIHNlYXJjaGluZyB3aGVuIGN1cnJlbnQgbWF0Y2ggZXhjZWVkcyB0aGlzICovXG5cbiAgICAgICAgICAgICAgLyogdXNlZCBieSB0cmVlcy5jOiAqL1xuXG4gIC8qIERpZG4ndCB1c2UgY3RfZGF0YSB0eXBlZGVmIGJlbG93IHRvIHN1cHByZXNzIGNvbXBpbGVyIHdhcm5pbmcgKi9cblxuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9sdHJlZVtIRUFQX1NJWkVdOyAgIC8qIGxpdGVyYWwgYW5kIGxlbmd0aCB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2R0cmVlWzIqRF9DT0RFUysxXTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGJsX3RyZWVbMipCTF9DT0RFUysxXTsgIC8qIEh1ZmZtYW4gdHJlZSBmb3IgYml0IGxlbmd0aHMgKi9cblxuICAvLyBVc2UgZmxhdCBhcnJheSBvZiBET1VCTEUgc2l6ZSwgd2l0aCBpbnRlcmxlYXZlZCBmYXRhLFxuICAvLyBiZWNhdXNlIEpTIGRvZXMgbm90IHN1cHBvcnQgZWZmZWN0aXZlXG4gIHRoaXMuZHluX2x0cmVlICA9IG5ldyB1dGlscy5CdWYxNihIRUFQX1NJWkUgKiAyKTtcbiAgdGhpcy5keW5fZHRyZWUgID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogRF9DT0RFUyArIDEpICogMik7XG4gIHRoaXMuYmxfdHJlZSAgICA9IG5ldyB1dGlscy5CdWYxNigoMiAqIEJMX0NPREVTICsgMSkgKiAyKTtcbiAgemVybyh0aGlzLmR5bl9sdHJlZSk7XG4gIHplcm8odGhpcy5keW5fZHRyZWUpO1xuICB6ZXJvKHRoaXMuYmxfdHJlZSk7XG5cbiAgdGhpcy5sX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGxpdGVyYWwgdHJlZSAqL1xuICB0aGlzLmRfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgZGlzdGFuY2UgdHJlZSAqL1xuICB0aGlzLmJsX2Rlc2MgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgYml0IGxlbmd0aCB0cmVlICovXG5cbiAgLy91c2ggYmxfY291bnRbTUFYX0JJVFMrMV07XG4gIHRoaXMuYmxfY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYX0JJVFMgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy9pbnQgaGVhcFsyKkxfQ09ERVMrMV07ICAgICAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHRoaXMuaGVhcCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOyAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHplcm8odGhpcy5oZWFwKTtcblxuICB0aGlzLmhlYXBfbGVuID0gMDsgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGhlYXAgKi9cbiAgdGhpcy5oZWFwX21heCA9IDA7ICAgICAgICAgICAgICAgLyogZWxlbWVudCBvZiBsYXJnZXN0IGZyZXF1ZW5jeSAqL1xuICAvKiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKiBUaGUgc2FtZSBoZWFwIGFycmF5IGlzIHVzZWQgdG8gYnVpbGQgYWxsIHRyZWVzLlxuICAgKi9cblxuICB0aGlzLmRlcHRoID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7IC8vdWNoIGRlcHRoWzIqTF9DT0RFUysxXTtcbiAgemVybyh0aGlzLmRlcHRoKTtcbiAgLyogRGVwdGggb2YgZWFjaCBzdWJ0cmVlIHVzZWQgYXMgdGllIGJyZWFrZXIgZm9yIHRyZWVzIG9mIGVxdWFsIGZyZXF1ZW5jeVxuICAgKi9cblxuICB0aGlzLmxfYnVmID0gMDsgICAgICAgICAgLyogYnVmZmVyIGluZGV4IGZvciBsaXRlcmFscyBvciBsZW5ndGhzICovXG5cbiAgdGhpcy5saXRfYnVmc2l6ZSA9IDA7XG4gIC8qIFNpemUgb2YgbWF0Y2ggYnVmZmVyIGZvciBsaXRlcmFscy9sZW5ndGhzLiAgVGhlcmUgYXJlIDQgcmVhc29ucyBmb3JcbiAgICogbGltaXRpbmcgbGl0X2J1ZnNpemUgdG8gNjRLOlxuICAgKiAgIC0gZnJlcXVlbmNpZXMgY2FuIGJlIGtlcHQgaW4gMTYgYml0IGNvdW50ZXJzXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgdGhlIGZpcnN0IGJsb2NrLCBhbGwgaW5wdXRcbiAgICogICAgIGRhdGEgaXMgc3RpbGwgaW4gdGhlIHdpbmRvdyBzbyB3ZSBjYW4gc3RpbGwgZW1pdCBhIHN0b3JlZCBibG9jayBldmVuXG4gICAqICAgICB3aGVuIGlucHV0IGNvbWVzIGZyb20gc3RhbmRhcmQgaW5wdXQuICAoVGhpcyBjYW4gYWxzbyBiZSBkb25lIGZvclxuICAgKiAgICAgYWxsIGJsb2NrcyBpZiBsaXRfYnVmc2l6ZSBpcyBub3QgZ3JlYXRlciB0aGFuIDMySy4pXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgYSBmaWxlIHNtYWxsZXIgdGhhbiA2NEssIHdlIGNhblxuICAgKiAgICAgZXZlbiBlbWl0IGEgc3RvcmVkIGZpbGUgaW5zdGVhZCBvZiBhIHN0b3JlZCBibG9jayAoc2F2aW5nIDUgYnl0ZXMpLlxuICAgKiAgICAgVGhpcyBpcyBhcHBsaWNhYmxlIG9ubHkgZm9yIHppcCAobm90IGd6aXAgb3IgemxpYikuXG4gICAqICAgLSBjcmVhdGluZyBuZXcgSHVmZm1hbiB0cmVlcyBsZXNzIGZyZXF1ZW50bHkgbWF5IG5vdCBwcm92aWRlIGZhc3RcbiAgICogICAgIGFkYXB0YXRpb24gdG8gY2hhbmdlcyBpbiB0aGUgaW5wdXQgZGF0YSBzdGF0aXN0aWNzLiAoVGFrZSBmb3JcbiAgICogICAgIGV4YW1wbGUgYSBiaW5hcnkgZmlsZSB3aXRoIHBvb3JseSBjb21wcmVzc2libGUgY29kZSBmb2xsb3dlZCBieVxuICAgKiAgICAgYSBoaWdobHkgY29tcHJlc3NpYmxlIHN0cmluZyB0YWJsZS4pIFNtYWxsZXIgYnVmZmVyIHNpemVzIGdpdmVcbiAgICogICAgIGZhc3QgYWRhcHRhdGlvbiBidXQgaGF2ZSBvZiBjb3Vyc2UgdGhlIG92ZXJoZWFkIG9mIHRyYW5zbWl0dGluZ1xuICAgKiAgICAgdHJlZXMgbW9yZSBmcmVxdWVudGx5LlxuICAgKiAgIC0gSSBjYW4ndCBjb3VudCBhYm92ZSA0XG4gICAqL1xuXG4gIHRoaXMubGFzdF9saXQgPSAwOyAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cblxuICB0aGlzLmRfYnVmID0gMDtcbiAgLyogQnVmZmVyIGluZGV4IGZvciBkaXN0YW5jZXMuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCBkX2J1ZiBhbmQgbF9idWYgaGF2ZVxuICAgKiB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuIFRvIHVzZSBkaWZmZXJlbnQgbGVuZ3RocywgYW4gZXh0cmEgZmxhZ1xuICAgKiBhcnJheSB3b3VsZCBiZSBuZWNlc3NhcnkuXG4gICAqL1xuXG4gIHRoaXMub3B0X2xlbiA9IDA7ICAgICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIG9wdGltYWwgdHJlZXMgKi9cbiAgdGhpcy5zdGF0aWNfbGVuID0gMDsgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggc3RhdGljIHRyZWVzICovXG4gIHRoaXMubWF0Y2hlcyA9IDA7ICAgICAgIC8qIG51bWJlciBvZiBzdHJpbmcgbWF0Y2hlcyBpbiBjdXJyZW50IGJsb2NrICovXG4gIHRoaXMuaW5zZXJ0ID0gMDsgICAgICAgIC8qIGJ5dGVzIGF0IGVuZCBvZiB3aW5kb3cgbGVmdCB0byBpbnNlcnQgKi9cblxuXG4gIHRoaXMuYmlfYnVmID0gMDtcbiAgLyogT3V0cHV0IGJ1ZmZlci4gYml0cyBhcmUgaW5zZXJ0ZWQgc3RhcnRpbmcgYXQgdGhlIGJvdHRvbSAobGVhc3RcbiAgICogc2lnbmlmaWNhbnQgYml0cykuXG4gICAqL1xuICB0aGlzLmJpX3ZhbGlkID0gMDtcbiAgLyogTnVtYmVyIG9mIHZhbGlkIGJpdHMgaW4gYmlfYnVmLiAgQWxsIGJpdHMgYWJvdmUgdGhlIGxhc3QgdmFsaWQgYml0XG4gICAqIGFyZSBhbHdheXMgemVyby5cbiAgICovXG5cbiAgLy8gVXNlZCBmb3Igd2luZG93IG1lbW9yeSBpbml0LiBXZSBzYWZlbHkgaWdub3JlIGl0IGZvciBKUy4gVGhhdCBtYWtlc1xuICAvLyBzZW5zZSBvbmx5IGZvciBwb2ludGVycyBhbmQgbWVtb3J5IGNoZWNrIHRvb2xzLlxuICAvL3RoaXMuaGlnaF93YXRlciA9IDA7XG4gIC8qIEhpZ2ggd2F0ZXIgbWFyayBvZmZzZXQgaW4gd2luZG93IGZvciBpbml0aWFsaXplZCBieXRlcyAtLSBieXRlcyBhYm92ZVxuICAgKiB0aGlzIGFyZSBzZXQgdG8gemVybyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgd2FybmluZ3Mgd2hlblxuICAgKiBsb25nZXN0IG1hdGNoIHJvdXRpbmVzIGFjY2VzcyBieXRlcyBwYXN0IHRoZSBpbnB1dC4gIFRoaXMgaXMgdGhlblxuICAgKiB1cGRhdGVkIHRvIHRoZSBuZXcgaGlnaCB3YXRlciBtYXJrLlxuICAgKi9cbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pIHtcbiAgdmFyIHM7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSAwO1xuICBzdHJtLmRhdGFfdHlwZSA9IFpfVU5LTk9XTjtcblxuICBzID0gc3RybS5zdGF0ZTtcbiAgcy5wZW5kaW5nID0gMDtcbiAgcy5wZW5kaW5nX291dCA9IDA7XG5cbiAgaWYgKHMud3JhcCA8IDApIHtcbiAgICBzLndyYXAgPSAtcy53cmFwO1xuICAgIC8qIHdhcyBtYWRlIG5lZ2F0aXZlIGJ5IGRlZmxhdGUoLi4uLCBaX0ZJTklTSCk7ICovXG4gIH1cbiAgcy5zdGF0dXMgPSAocy53cmFwID8gSU5JVF9TVEFURSA6IEJVU1lfU1RBVEUpO1xuICBzdHJtLmFkbGVyID0gKHMud3JhcCA9PT0gMikgP1xuICAgIDAgIC8vIGNyYzMyKDAsIFpfTlVMTCwgMClcbiAgOlxuICAgIDE7IC8vIGFkbGVyMzIoMCwgWl9OVUxMLCAwKVxuICBzLmxhc3RfZmx1c2ggPSBaX05PX0ZMVVNIO1xuICB0cmVlcy5fdHJfaW5pdChzKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVJlc2V0KHN0cm0pIHtcbiAgdmFyIHJldCA9IGRlZmxhdGVSZXNldEtlZXAoc3RybSk7XG4gIGlmIChyZXQgPT09IFpfT0spIHtcbiAgICBsbV9pbml0KHN0cm0uc3RhdGUpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVNldEhlYWRlcihzdHJtLCBoZWFkKSB7XG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgaWYgKHN0cm0uc3RhdGUud3JhcCAhPT0gMikgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RybS5zdGF0ZS5nemhlYWQgPSBoZWFkO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIG1ldGhvZCwgd2luZG93Qml0cywgbWVtTGV2ZWwsIHN0cmF0ZWd5KSB7XG4gIGlmICghc3RybSkgeyAvLyA9PT0gWl9OVUxMXG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIHZhciB3cmFwID0gMTtcblxuICBpZiAobGV2ZWwgPT09IFpfREVGQVVMVF9DT01QUkVTU0lPTikge1xuICAgIGxldmVsID0gNjtcbiAgfVxuXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkgeyAvKiBzdXBwcmVzcyB6bGliIHdyYXBwZXIgKi9cbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmICh3aW5kb3dCaXRzID4gMTUpIHtcbiAgICB3cmFwID0gMjsgICAgICAgICAgIC8qIHdyaXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkICovXG4gICAgd2luZG93Qml0cyAtPSAxNjtcbiAgfVxuXG5cbiAgaWYgKG1lbUxldmVsIDwgMSB8fCBtZW1MZXZlbCA+IE1BWF9NRU1fTEVWRUwgfHwgbWV0aG9kICE9PSBaX0RFRkxBVEVEIHx8XG4gICAgd2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1IHx8IGxldmVsIDwgMCB8fCBsZXZlbCA+IDkgfHxcbiAgICBzdHJhdGVneSA8IDAgfHwgc3RyYXRlZ3kgPiBaX0ZJWEVEKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuXG4gIGlmICh3aW5kb3dCaXRzID09PSA4KSB7XG4gICAgd2luZG93Qml0cyA9IDk7XG4gIH1cbiAgLyogdW50aWwgMjU2LWJ5dGUgd2luZG93IGJ1ZyBmaXhlZCAqL1xuXG4gIHZhciBzID0gbmV3IERlZmxhdGVTdGF0ZSgpO1xuXG4gIHN0cm0uc3RhdGUgPSBzO1xuICBzLnN0cm0gPSBzdHJtO1xuXG4gIHMud3JhcCA9IHdyYXA7XG4gIHMuZ3poZWFkID0gbnVsbDtcbiAgcy53X2JpdHMgPSB3aW5kb3dCaXRzO1xuICBzLndfc2l6ZSA9IDEgPDwgcy53X2JpdHM7XG4gIHMud19tYXNrID0gcy53X3NpemUgLSAxO1xuXG4gIHMuaGFzaF9iaXRzID0gbWVtTGV2ZWwgKyA3O1xuICBzLmhhc2hfc2l6ZSA9IDEgPDwgcy5oYXNoX2JpdHM7XG4gIHMuaGFzaF9tYXNrID0gcy5oYXNoX3NpemUgLSAxO1xuICBzLmhhc2hfc2hpZnQgPSB+figocy5oYXNoX2JpdHMgKyBNSU5fTUFUQ0ggLSAxKSAvIE1JTl9NQVRDSCk7XG5cbiAgcy53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSAqIDIpO1xuICBzLmhlYWQgPSBuZXcgdXRpbHMuQnVmMTYocy5oYXNoX3NpemUpO1xuICBzLnByZXYgPSBuZXcgdXRpbHMuQnVmMTYocy53X3NpemUpO1xuXG4gIC8vIERvbid0IG5lZWQgbWVtIGluaXQgbWFnaWMgZm9yIEpTLlxuICAvL3MuaGlnaF93YXRlciA9IDA7ICAvKiBub3RoaW5nIHdyaXR0ZW4gdG8gcy0+d2luZG93IHlldCAqL1xuXG4gIHMubGl0X2J1ZnNpemUgPSAxIDw8IChtZW1MZXZlbCArIDYpOyAvKiAxNksgZWxlbWVudHMgYnkgZGVmYXVsdCAqL1xuXG4gIHMucGVuZGluZ19idWZfc2l6ZSA9IHMubGl0X2J1ZnNpemUgKiA0O1xuXG4gIC8vb3ZlcmxheSA9ICh1c2hmICopIFpBTExPQyhzdHJtLCBzLT5saXRfYnVmc2l6ZSwgc2l6ZW9mKHVzaCkrMik7XG4gIC8vcy0+cGVuZGluZ19idWYgPSAodWNoZiAqKSBvdmVybGF5O1xuICBzLnBlbmRpbmdfYnVmID0gbmV3IHV0aWxzLkJ1Zjgocy5wZW5kaW5nX2J1Zl9zaXplKTtcblxuICAvLyBJdCBpcyBvZmZzZXQgZnJvbSBgcy5wZW5kaW5nX2J1ZmAgKHNpemUgaXMgYHMubGl0X2J1ZnNpemUgKiAyYClcbiAgLy9zLT5kX2J1ZiA9IG92ZXJsYXkgKyBzLT5saXRfYnVmc2l6ZS9zaXplb2YodXNoKTtcbiAgcy5kX2J1ZiA9IDEgKiBzLmxpdF9idWZzaXplO1xuXG4gIC8vcy0+bF9idWYgPSBzLT5wZW5kaW5nX2J1ZiArICgxK3NpemVvZih1c2gpKSpzLT5saXRfYnVmc2l6ZTtcbiAgcy5sX2J1ZiA9ICgxICsgMikgKiBzLmxpdF9idWZzaXplO1xuXG4gIHMubGV2ZWwgPSBsZXZlbDtcbiAgcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICBzLm1ldGhvZCA9IG1ldGhvZDtcblxuICByZXR1cm4gZGVmbGF0ZVJlc2V0KHN0cm0pO1xufVxuXG5mdW5jdGlvbiBkZWZsYXRlSW5pdChzdHJtLCBsZXZlbCkge1xuICByZXR1cm4gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBaX0RFRkxBVEVELCBNQVhfV0JJVFMsIERFRl9NRU1fTEVWRUwsIFpfREVGQVVMVF9TVFJBVEVHWSk7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZShzdHJtLCBmbHVzaCkge1xuICB2YXIgb2xkX2ZsdXNoLCBzO1xuICB2YXIgYmVnLCB2YWw7IC8vIGZvciBnemlwIGhlYWRlciB3cml0ZSBvbmx5XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8XG4gICAgZmx1c2ggPiBaX0JMT0NLIHx8IGZsdXNoIDwgMCkge1xuICAgIHJldHVybiBzdHJtID8gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKSA6IFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKCFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHx8XG4gICAgICAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBmbHVzaCAhPT0gWl9GSU5JU0gpKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCAoc3RybS5hdmFpbF9vdXQgPT09IDApID8gWl9CVUZfRVJST1IgOiBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzLnN0cm0gPSBzdHJtOyAvKiBqdXN0IGluIGNhc2UgKi9cbiAgb2xkX2ZsdXNoID0gcy5sYXN0X2ZsdXNoO1xuICBzLmxhc3RfZmx1c2ggPSBmbHVzaDtcblxuICAvKiBXcml0ZSB0aGUgaGVhZGVyICovXG4gIGlmIChzLnN0YXR1cyA9PT0gSU5JVF9TVEFURSkge1xuXG4gICAgaWYgKHMud3JhcCA9PT0gMikgeyAvLyBHWklQIGhlYWRlclxuICAgICAgc3RybS5hZGxlciA9IDA7ICAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgcHV0X2J5dGUocywgMzEpO1xuICAgICAgcHV0X2J5dGUocywgMTM5KTtcbiAgICAgIHB1dF9ieXRlKHMsIDgpO1xuICAgICAgaWYgKCFzLmd6aGVhZCkgeyAvLyBzLT5nemhlYWQgPT0gWl9OVUxMXG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBPU19DT0RFKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50ZXh0ID8gMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHMuZ3poZWFkLmhjcmMgPyAyIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmV4dHJhID8gMCA6IDQpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5uYW1lID8gMCA6IDgpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5jb21tZW50ID8gMCA6IDE2KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMTYpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDI0KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLm9zICYgMHhmZik7XG4gICAgICAgIGlmIChzLmd6aGVhZC5leHRyYSAmJiBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmKTtcbiAgICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQuZXh0cmEubGVuZ3RoID4+IDgpICYgMHhmZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IEVYVFJBX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIC8vIERFRkxBVEUgaGVhZGVyXG4gICAge1xuICAgICAgdmFyIGhlYWRlciA9IChaX0RFRkxBVEVEICsgKChzLndfYml0cyAtIDgpIDw8IDQpKSA8PCA4O1xuICAgICAgdmFyIGxldmVsX2ZsYWdzID0gLTE7XG5cbiAgICAgIGlmIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyKSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA8IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsID09PSA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMztcbiAgICAgIH1cbiAgICAgIGhlYWRlciB8PSAobGV2ZWxfZmxhZ3MgPDwgNik7XG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgeyBoZWFkZXIgfD0gUFJFU0VUX0RJQ1Q7IH1cbiAgICAgIGhlYWRlciArPSAzMSAtIChoZWFkZXIgJSAzMSk7XG5cbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIHB1dFNob3J0TVNCKHMsIGhlYWRlcik7XG5cbiAgICAgIC8qIFNhdmUgdGhlIGFkbGVyMzIgb2YgdGhlIHByZXNldCBkaWN0aW9uYXJ5OiAqL1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSAxOyAvLyBhZGxlcjMyKDBMLCBaX05VTEwsIDApO1xuICAgIH1cbiAgfVxuXG4vLyNpZmRlZiBHWklQXG4gIGlmIChzLnN0YXR1cyA9PT0gRVhUUkFfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuZXh0cmEvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuXG4gICAgICB3aGlsZSAocy5nemluZGV4IDwgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmZmZikpIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYVtzLmd6aW5kZXhdICYgMHhmZik7XG4gICAgICAgIHMuZ3ppbmRleCsrO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAocy5nemluZGV4ID09PSBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBOQU1FX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLm5hbWUvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5uYW1lLmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IENPTU1FTlRfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuY29tbWVudC8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLmNvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQuY29tbWVudC5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gSENSQ19TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA+IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgfVxuICAgICAgaWYgKHMucGVuZGluZyArIDIgPD0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgc3RybS5hZGxlciA9IDA7IC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgfVxuICB9XG4vLyNlbmRpZlxuXG4gIC8qIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUgKi9cbiAgaWYgKHMucGVuZGluZyAhPT0gMCkge1xuICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAvKiBTaW5jZSBhdmFpbF9vdXQgaXMgMCwgZGVmbGF0ZSB3aWxsIGJlIGNhbGxlZCBhZ2FpbiB3aXRoXG4gICAgICAgKiBtb3JlIG91dHB1dCBzcGFjZSwgYnV0IHBvc3NpYmx5IHdpdGggYm90aCBwZW5kaW5nIGFuZFxuICAgICAgICogYXZhaWxfaW4gZXF1YWwgdG8gemVyby4gVGhlcmUgd29uJ3QgYmUgYW55dGhpbmcgdG8gZG8sXG4gICAgICAgKiBidXQgdGhpcyBpcyBub3QgYW4gZXJyb3Igc2l0dWF0aW9uIHNvIG1ha2Ugc3VyZSB3ZVxuICAgICAgICogcmV0dXJuIE9LIGluc3RlYWQgb2YgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCBvZiBkZWZsYXRlOlxuICAgICAgICovXG4gICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgIHJldHVybiBaX09LO1xuICAgIH1cblxuICAgIC8qIE1ha2Ugc3VyZSB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZG8gYW5kIGF2b2lkIGR1cGxpY2F0ZSBjb25zZWN1dGl2ZVxuICAgICAqIGZsdXNoZXMuIEZvciByZXBlYXRlZCBhbmQgdXNlbGVzcyBjYWxscyB3aXRoIFpfRklOSVNILCB3ZSBrZWVwXG4gICAgICogcmV0dXJuaW5nIFpfU1RSRUFNX0VORCBpbnN0ZWFkIG9mIFpfQlVGX0VSUk9SLlxuICAgICAqL1xuICB9IGVsc2UgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgcmFuayhmbHVzaCkgPD0gcmFuayhvbGRfZmx1c2gpICYmXG4gICAgZmx1c2ggIT09IFpfRklOSVNIKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBVc2VyIG11c3Qgbm90IHByb3ZpZGUgbW9yZSBpbnB1dCBhZnRlciB0aGUgZmlyc3QgRklOSVNIOiAqL1xuICBpZiAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBTdGFydCBhIG5ldyBibG9jayBvciBjb250aW51ZSB0aGUgY3VycmVudCBvbmUuXG4gICAqL1xuICBpZiAoc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLmxvb2thaGVhZCAhPT0gMCB8fFxuICAgIChmbHVzaCAhPT0gWl9OT19GTFVTSCAmJiBzLnN0YXR1cyAhPT0gRklOSVNIX1NUQVRFKSkge1xuICAgIHZhciBic3RhdGUgPSAocy5zdHJhdGVneSA9PT0gWl9IVUZGTUFOX09OTFkpID8gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSA6XG4gICAgICAocy5zdHJhdGVneSA9PT0gWl9STEUgPyBkZWZsYXRlX3JsZShzLCBmbHVzaCkgOlxuICAgICAgICBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmZ1bmMocywgZmx1c2gpKTtcblxuICAgIGlmIChic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX0RPTkUpIHtcbiAgICAgIHMuc3RhdHVzID0gRklOSVNIX1NUQVRFO1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19ORUVEX01PUkUgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgICAvKiBhdm9pZCBCVUZfRVJST1IgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgIH1cbiAgICAgIHJldHVybiBaX09LO1xuICAgICAgLyogSWYgZmx1c2ggIT0gWl9OT19GTFVTSCAmJiBhdmFpbF9vdXQgPT0gMCwgdGhlIG5leHQgY2FsbFxuICAgICAgICogb2YgZGVmbGF0ZSBzaG91bGQgdXNlIHRoZSBzYW1lIGZsdXNoIHBhcmFtZXRlciB0byBtYWtlIHN1cmVcbiAgICAgICAqIHRoYXQgdGhlIGZsdXNoIGlzIGNvbXBsZXRlLiBTbyB3ZSBkb24ndCBoYXZlIHRvIG91dHB1dCBhblxuICAgICAgICogZW1wdHkgYmxvY2sgaGVyZSwgdGhpcyB3aWxsIGJlIGRvbmUgYXQgbmV4dCBjYWxsLiBUaGlzIGFsc29cbiAgICAgICAqIGVuc3VyZXMgdGhhdCBmb3IgYSB2ZXJ5IHNtYWxsIG91dHB1dCBidWZmZXIsIHdlIGVtaXQgYXQgbW9zdFxuICAgICAgICogb25lIGVtcHR5IGJsb2NrLlxuICAgICAgICovXG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX0JMT0NLX0RPTkUpIHtcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9QQVJUSUFMX0ZMVVNIKSB7XG4gICAgICAgIHRyZWVzLl90cl9hbGlnbihzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZsdXNoICE9PSBaX0JMT0NLKSB7IC8qIEZVTExfRkxVU0ggb3IgU1lOQ19GTFVTSCAqL1xuXG4gICAgICAgIHRyZWVzLl90cl9zdG9yZWRfYmxvY2socywgMCwgMCwgZmFsc2UpO1xuICAgICAgICAvKiBGb3IgYSBmdWxsIGZsdXNoLCB0aGlzIGVtcHR5IGJsb2NrIHdpbGwgYmUgcmVjb2duaXplZFxuICAgICAgICAgKiBhcyBhIHNwZWNpYWwgbWFya2VyIGJ5IGluZmxhdGVfc3luYygpLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZVTExfRkxVU0gpIHtcbiAgICAgICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi8gICAgICAgICAgICAgLyogZm9yZ2V0IGhpc3RvcnkgKi9cbiAgICAgICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICAgICAgICBzLmluc2VydCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xOyAvKiBhdm9pZCBCVUZfRVJST1IgYXQgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0KHN0cm0tPmF2YWlsX291dCA+IDAsIFwiYnVnMlwiKTtcbiAgLy9pZiAoc3RybS5hdmFpbF9vdXQgPD0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJidWcyXCIpO31cblxuICBpZiAoZmx1c2ggIT09IFpfRklOSVNIKSB7IHJldHVybiBaX09LOyB9XG4gIGlmIChzLndyYXAgPD0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRU5EOyB9XG5cbiAgLyogV3JpdGUgdGhlIHRyYWlsZXIgKi9cbiAgaWYgKHMud3JhcCA9PT0gMikge1xuICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDI0KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDI0KSAmIDB4ZmYpO1xuICB9XG4gIGVsc2VcbiAge1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgfVxuXG4gIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gIC8qIElmIGF2YWlsX291dCBpcyB6ZXJvLCB0aGUgYXBwbGljYXRpb24gd2lsbCBjYWxsIGRlZmxhdGUgYWdhaW5cbiAgICogdG8gZmx1c2ggdGhlIHJlc3QuXG4gICAqL1xuICBpZiAocy53cmFwID4gMCkgeyBzLndyYXAgPSAtcy53cmFwOyB9XG4gIC8qIHdyaXRlIHRoZSB0cmFpbGVyIG9ubHkgb25jZSEgKi9cbiAgcmV0dXJuIHMucGVuZGluZyAhPT0gMCA/IFpfT0sgOiBaX1NUUkVBTV9FTkQ7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVFbmQoc3RybSkge1xuICB2YXIgc3RhdHVzO1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdHVzID0gc3RybS5zdGF0ZS5zdGF0dXM7XG4gIGlmIChzdGF0dXMgIT09IElOSVRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEVYVFJBX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBOQU1FX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBDT01NRU5UX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBIQ1JDX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBCVVNZX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBGSU5JU0hfU1RBVEVcbiAgKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnN0YXRlID0gbnVsbDtcblxuICByZXR1cm4gc3RhdHVzID09PSBCVVNZX1NUQVRFID8gZXJyKHN0cm0sIFpfREFUQV9FUlJPUikgOiBaX09LO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemVzIHRoZSBjb21wcmVzc2lvbiBkaWN0aW9uYXJ5IGZyb20gdGhlIGdpdmVuIGJ5dGVcbiAqIHNlcXVlbmNlIHdpdGhvdXQgcHJvZHVjaW5nIGFueSBjb21wcmVzc2VkIG91dHB1dC5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkge1xuICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIHZhciBzO1xuICB2YXIgc3RyLCBuO1xuICB2YXIgd3JhcDtcbiAgdmFyIGF2YWlsO1xuICB2YXIgbmV4dDtcbiAgdmFyIGlucHV0O1xuICB2YXIgdG1wRGljdDtcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICB3cmFwID0gcy53cmFwO1xuXG4gIGlmICh3cmFwID09PSAyIHx8ICh3cmFwID09PSAxICYmIHMuc3RhdHVzICE9PSBJTklUX1NUQVRFKSB8fCBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIHdoZW4gdXNpbmcgemxpYiB3cmFwcGVycywgY29tcHV0ZSBBZGxlci0zMiBmb3IgcHJvdmlkZWQgZGljdGlvbmFyeSAqL1xuICBpZiAod3JhcCA9PT0gMSkge1xuICAgIC8qIGFkbGVyMzIoc3RybS0+YWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICB9XG5cbiAgcy53cmFwID0gMDsgICAvKiBhdm9pZCBjb21wdXRpbmcgQWRsZXItMzIgaW4gcmVhZF9idWYgKi9cblxuICAvKiBpZiBkaWN0aW9uYXJ5IHdvdWxkIGZpbGwgd2luZG93LCBqdXN0IHJlcGxhY2UgdGhlIGhpc3RvcnkgKi9cbiAgaWYgKGRpY3RMZW5ndGggPj0gcy53X3NpemUpIHtcbiAgICBpZiAod3JhcCA9PT0gMCkgeyAgICAgICAgICAgIC8qIGFscmVhZHkgZW1wdHkgb3RoZXJ3aXNlICovXG4gICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcbiAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICBzLmluc2VydCA9IDA7XG4gICAgfVxuICAgIC8qIHVzZSB0aGUgdGFpbCAqL1xuICAgIC8vIGRpY3Rpb25hcnkgPSBkaWN0aW9uYXJ5LnNsaWNlKGRpY3RMZW5ndGggLSBzLndfc2l6ZSk7XG4gICAgdG1wRGljdCA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplKTtcbiAgICB1dGlscy5hcnJheVNldCh0bXBEaWN0LCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoIC0gcy53X3NpemUsIHMud19zaXplLCAwKTtcbiAgICBkaWN0aW9uYXJ5ID0gdG1wRGljdDtcbiAgICBkaWN0TGVuZ3RoID0gcy53X3NpemU7XG4gIH1cbiAgLyogaW5zZXJ0IGRpY3Rpb25hcnkgaW50byB3aW5kb3cgYW5kIGhhc2ggKi9cbiAgYXZhaWwgPSBzdHJtLmF2YWlsX2luO1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBkaWN0TGVuZ3RoO1xuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmlucHV0ID0gZGljdGlvbmFyeTtcbiAgZmlsbF93aW5kb3cocyk7XG4gIHdoaWxlIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICBzdHIgPSBzLnN0cnN0YXJ0O1xuICAgIG4gPSBzLmxvb2thaGVhZCAtIChNSU5fTUFUQ0ggLSAxKTtcbiAgICBkbyB7XG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcblxuICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcblxuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgc3RyKys7XG4gICAgfSB3aGlsZSAoLS1uKTtcbiAgICBzLnN0cnN0YXJ0ID0gc3RyO1xuICAgIHMubG9va2FoZWFkID0gTUlOX01BVENIIC0gMTtcbiAgICBmaWxsX3dpbmRvdyhzKTtcbiAgfVxuICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgcy5pbnNlcnQgPSBzLmxvb2thaGVhZDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uaW5wdXQgPSBpbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGF2YWlsO1xuICBzLndyYXAgPSB3cmFwO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5leHBvcnRzLmRlZmxhdGVJbml0ID0gZGVmbGF0ZUluaXQ7XG5leHBvcnRzLmRlZmxhdGVJbml0MiA9IGRlZmxhdGVJbml0MjtcbmV4cG9ydHMuZGVmbGF0ZVJlc2V0ID0gZGVmbGF0ZVJlc2V0O1xuZXhwb3J0cy5kZWZsYXRlUmVzZXRLZWVwID0gZGVmbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuZGVmbGF0ZVNldEhlYWRlciA9IGRlZmxhdGVTZXRIZWFkZXI7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlRW5kID0gZGVmbGF0ZUVuZDtcbmV4cG9ydHMuZGVmbGF0ZVNldERpY3Rpb25hcnkgPSBkZWZsYXRlU2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuZGVmbGF0ZUluZm8gPSAncGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0cy5kZWZsYXRlQm91bmQgPSBkZWZsYXRlQm91bmQ7XG5leHBvcnRzLmRlZmxhdGVDb3B5ID0gZGVmbGF0ZUNvcHk7XG5leHBvcnRzLmRlZmxhdGVQYXJhbXMgPSBkZWZsYXRlUGFyYW1zO1xuZXhwb3J0cy5kZWZsYXRlUGVuZGluZyA9IGRlZmxhdGVQZW5kaW5nO1xuZXhwb3J0cy5kZWZsYXRlUHJpbWUgPSBkZWZsYXRlUHJpbWU7XG5leHBvcnRzLmRlZmxhdGVUdW5lID0gZGVmbGF0ZVR1bmU7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB6bGliX2RlZmxhdGUgPSByZXF1aXJlKCcuL3psaWIvZGVmbGF0ZScpO1xudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvY29tbW9uJyk7XG52YXIgc3RyaW5ncyAgICAgID0gcmVxdWlyZSgnLi91dGlscy9zdHJpbmdzJyk7XG52YXIgbXNnICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL21lc3NhZ2VzJyk7XG52YXIgWlN0cmVhbSAgICAgID0gcmVxdWlyZSgnLi96bGliL3pzdHJlYW0nKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbnZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG5cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG52YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcblxudmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xO1xuXG52YXIgWl9ERUZBVUxUX1NUUkFURUdZICAgID0gMDtcblxudmFyIFpfREVGTEFURUQgID0gODtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKipcbiAqIGNsYXNzIERlZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tkZWZsYXRlXV0sXG4gKiBbW2RlZmxhdGVSYXddXSBhbmQgW1tnemlwXV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBEZWZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tEZWZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZGVuLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXl8QXJyYXlcbiAqXG4gKiBDb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tEZWZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tEZWZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkgIG9yIGlmIHlvdVxuICogcHVzaCBhIGNodW5rIHdpdGggZXhwbGljaXQgZmx1c2ggKGNhbGwgW1tEZWZsYXRlI3B1c2hdXSB3aXRoXG4gKiBgWl9TWU5DX0ZMVVNIYCBwYXJhbSkuXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5lcnIgLT4gTnVtYmVyXG4gKlxuICogRXJyb3IgY29kZSBhZnRlciBkZWZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLlxuICogWW91IHdpbGwgbm90IG5lZWQgaXQgaW4gcmVhbCBsaWZlLCBiZWNhdXNlIGRlZmxhdGUgZXJyb3JzXG4gKiBhcmUgcG9zc2libGUgb25seSBvbiB3cm9uZyBvcHRpb25zIG9yIGJhZCBgb25EYXRhYCAvIGBvbkVuZGBcbiAqIGN1c3RvbSBoYW5kbGVycy5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0RlZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IERlZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgZGVmbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGBsZXZlbGBcbiAqIC0gYHdpbmRvd0JpdHNgXG4gKiAtIGBtZW1MZXZlbGBcbiAqIC0gYHN0cmF0ZWd5YFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgZGVmbGF0ZVxuICogLSBgZ3ppcGAgKEJvb2xlYW4pIC0gY3JlYXRlIGd6aXAgd3JhcHBlclxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgXCJiaW5hcnkgc3RyaW5nXCJcbiAqICAgIChlYWNoIGNoYXIgY29kZSBbMC4uMjU1XSlcbiAqIC0gYGhlYWRlcmAgKE9iamVjdCkgLSBjdXN0b20gaGVhZGVyIGZvciBnemlwXG4gKiAgIC0gYHRleHRgIChCb29sZWFuKSAtIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHRcbiAqICAgLSBgdGltZWAgKE51bWJlcikgLSBtb2RpZmljYXRpb24gdGltZSwgdW5peCB0aW1lc3RhbXBcbiAqICAgLSBgb3NgIChOdW1iZXIpIC0gb3BlcmF0aW9uIHN5c3RlbSBjb2RlXG4gKiAgIC0gYGV4dHJhYCAoQXJyYXkpIC0gYXJyYXkgb2YgYnl0ZXMgd2l0aCBleHRyYSBkYXRhIChtYXggNjU1MzYpXG4gKiAgIC0gYG5hbWVgIChTdHJpbmcpIC0gZmlsZSBuYW1lIChiaW5hcnkgc3RyaW5nKVxuICogICAtIGBjb21tZW50YCAoU3RyaW5nKSAtIGNvbW1lbnQgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGhjcmNgIChCb29sZWFuKSAtIHRydWUgaWYgaGVhZGVyIGNyYyBzaG91bGQgYmUgYWRkZWRcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgY2h1bmsxID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIGNodW5rMiA9IFVpbnQ4QXJyYXkoWzEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5XSk7XG4gKlxuICogdmFyIGRlZmxhdGUgPSBuZXcgcGFrby5EZWZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBkZWZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBkZWZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChkZWZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoZGVmbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coZGVmbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBEZWZsYXRlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERlZmxhdGUpKSByZXR1cm4gbmV3IERlZmxhdGUob3B0aW9ucyk7XG5cbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHtcbiAgICBsZXZlbDogWl9ERUZBVUxUX0NPTVBSRVNTSU9OLFxuICAgIG1ldGhvZDogWl9ERUZMQVRFRCxcbiAgICBjaHVua1NpemU6IDE2Mzg0LFxuICAgIHdpbmRvd0JpdHM6IDE1LFxuICAgIG1lbUxldmVsOiA4LFxuICAgIHN0cmF0ZWd5OiBaX0RFRkFVTFRfU1RSQVRFR1ksXG4gICAgdG86ICcnXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIHZhciBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkpIHtcbiAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKG9wdC5nemlwICYmIChvcHQud2luZG93Qml0cyA+IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDE2O1xuICB9XG5cbiAgdGhpcy5lcnIgICAgPSAwOyAgICAgIC8vIGVycm9yIGNvZGUsIGlmIGhhcHBlbnMgKDAgPSBaX09LKVxuICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVuZGVkICA9IGZhbHNlOyAgLy8gdXNlZCB0byBhdm9pZCBtdWx0aXBsZSBvbkVuZCgpIGNhbGxzXG4gIHRoaXMuY2h1bmtzID0gW107ICAgICAvLyBjaHVua3Mgb2YgY29tcHJlc3NlZCBkYXRhXG5cbiAgdGhpcy5zdHJtID0gbmV3IFpTdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgdmFyIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlSW5pdDIoXG4gICAgdGhpcy5zdHJtLFxuICAgIG9wdC5sZXZlbCxcbiAgICBvcHQubWV0aG9kLFxuICAgIG9wdC53aW5kb3dCaXRzLFxuICAgIG9wdC5tZW1MZXZlbCxcbiAgICBvcHQuc3RyYXRlZ3lcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBaX09LKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgfVxuXG4gIGlmIChvcHQuaGVhZGVyKSB7XG4gICAgemxpYl9kZWZsYXRlLmRlZmxhdGVTZXRIZWFkZXIodGhpcy5zdHJtLCBvcHQuaGVhZGVyKTtcbiAgfVxuXG4gIGlmIChvcHQuZGljdGlvbmFyeSkge1xuICAgIHZhciBkaWN0O1xuICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICAgIGRpY3QgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIGRpY3QgPSBuZXcgVWludDhBcnJheShvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpY3QgPSBvcHQuZGljdGlvbmFyeTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0KTtcblxuICAgIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGljdF9zZXQgPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogRGVmbGF0ZSNwdXNoKGRhdGFbLCBtb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fEFycmF5QnVmZmVyfFN0cmluZyk6IGlucHV0IGRhdGEuIFN0cmluZ3Mgd2lsbCBiZVxuICogICBjb252ZXJ0ZWQgdG8gdXRmOCBieXRlIHNlcXVlbmNlLlxuICogLSBtb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLlxuICogICBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCwgYHRydWVgIG1lYW5zIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gZGVmbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbRGVmbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgY29tcHJlc3NlZCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdCBoYXZlXG4gKiBtb2RlIFpfRklOSVNIIChvciBgdHJ1ZWApLiBUaGF0IHdpbGwgZmx1c2ggaW50ZXJuYWwgcGVuZGluZyBidWZmZXJzIGFuZCBjYWxsXG4gKiBbW0RlZmxhdGUjb25FbmRdXS4gRm9yIGludGVyaW0gZXhwbGljaXQgZmx1c2hlcyAod2l0aG91dCBlbmRpbmcgdGhlIHN0cmVhbSkgeW91XG4gKiBjYW4gdXNlIG1vZGUgWl9TWU5DX0ZMVVNILCBrZWVwaW5nIHRoZSBjb21wcmVzc2lvbiBjb250ZXh0LlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0RlZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiBXZSBzdHJvbmdseSByZWNvbW1lbmQgdG8gdXNlIGBVaW50OEFycmF5YCBvbiBpbnB1dCBmb3IgYmVzdCBzcGVlZCAob3V0cHV0XG4gKiBhcnJheSBmb3JtYXQgaXMgZGV0ZWN0ZWQgYXV0b21hdGljYWxseSkuIEFsc28sIGRvbid0IHNraXAgbGFzdCBwYXJhbSBhbmQgYWx3YXlzXG4gKiB1c2UgdGhlIHNhbWUgdHlwZSBpbiB5b3VyIGNvZGUgKGJvb2xlYW4gb3IgbnVtYmVyKS4gVGhhdCB3aWxsIGltcHJvdmUgSlMgc3BlZWQuXG4gKlxuICogRm9yIHJlZ3VsYXIgYEFycmF5YC1zIG1ha2Ugc3VyZSBhbGwgZWxlbWVudHMgYXJlIFswLi4yNTVdLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgbW9kZSkge1xuICB2YXIgc3RybSA9IHRoaXMuc3RybTtcbiAgdmFyIGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIHZhciBzdGF0dXMsIF9tb2RlO1xuXG4gIGlmICh0aGlzLmVuZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIF9tb2RlID0gKG1vZGUgPT09IH5+bW9kZSkgPyBtb2RlIDogKChtb2RlID09PSB0cnVlKSA/IFpfRklOSVNIIDogWl9OT19GTFVTSCk7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZG8ge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGUoc3RybSwgX21vZGUpOyAgICAvKiBubyBiYWQgcmV0dXJuIHZhbHVlICovXG5cbiAgICBpZiAoc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IChzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gWl9GSU5JU0ggfHwgX21vZGUgPT09IFpfU1lOQ19GTFVTSCkpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLm9uRGF0YShzdHJpbmdzLmJ1ZjJiaW5zdHJpbmcodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbkRhdGEodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICB9XG4gICAgfVxuICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gWl9TVFJFQU1fRU5EKTtcblxuICAvLyBGaW5hbGl6ZSBvbiB0aGUgbGFzdCBjaHVuay5cbiAgaWYgKF9tb2RlID09PSBaX0ZJTklTSCkge1xuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0dXMgPT09IFpfT0s7XG4gIH1cblxuICAvLyBjYWxsYmFjayBpbnRlcmltIHJlc3VsdHMgaWYgWl9TWU5DX0ZMVVNILlxuICBpZiAoX21vZGUgPT09IFpfU1lOQ19GTFVTSCkge1xuICAgIHRoaXMub25FbmQoWl9PSyk7XG4gICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogb3V0cHV0IGRhdGEuIFR5cGUgb2YgYXJyYXkgZGVwZW5kc1xuICogICBvbiBqcyBlbmdpbmUgc3VwcG9ydC4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCwgZWFjaCBjaHVua1xuICogICB3aWxsIGJlIHN0cmluZy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRW5kKHN0YXR1cykgLT4gVm9pZFxuICogLSBzdGF0dXMgKE51bWJlcik6IGRlZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLFxuICogICBvdGhlciBpZiBub3QuXG4gKlxuICogQ2FsbGVkIG9uY2UgYWZ0ZXIgeW91IHRlbGwgZGVmbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkgb3Igc2hvdWxkIGJlIGZsdXNoZWQgKFpfU1lOQ19GTFVTSClcbiAqIG9yIGlmIGFuIGVycm9yIGhhcHBlbmVkLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBaX09LKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gICAgfVxuICB9XG4gIHRoaXMuY2h1bmtzID0gW107XG4gIHRoaXMuZXJyID0gc3RhdHVzO1xuICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG59O1xuXG5cbi8qKlxuICogZGVmbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ29tcHJlc3MgYGRhdGFgIHdpdGggZGVmbGF0ZSBhbGdvcml0aG0gYW5kIGBvcHRpb25zYC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSBsZXZlbFxuICogLSB3aW5kb3dCaXRzXG4gKiAtIG1lbUxldmVsXG4gKiAtIHN0cmF0ZWd5XG4gKiAtIGRpY3Rpb25hcnlcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBcImJpbmFyeSBzdHJpbmdcIlxuICogICAgKGVhY2ggY2hhciBjb2RlIFswLi4yNTVdKVxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBkYXRhID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhwYWtvLmRlZmxhdGUoZGF0YSkpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBkZWZsYXRvciA9IG5ldyBEZWZsYXRlKG9wdGlvbnMpO1xuXG4gIGRlZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChkZWZsYXRvci5lcnIpIHsgdGhyb3cgZGVmbGF0b3IubXNnIHx8IG1zZ1tkZWZsYXRvci5lcnJdOyB9XG5cbiAgcmV0dXJuIGRlZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGRlZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbZGVmbGF0ZV1dLCBidXQgY3JlYXRlcyByYXcgZGF0YSwgd2l0aG91dCB3cmFwcGVyXG4gKiAoaGVhZGVyIGFuZCBhZGxlcjMyIGNyYykuXG4gKiovXG5mdW5jdGlvbiBkZWZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnJhdyA9IHRydWU7XG4gIHJldHVybiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIGd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbZGVmbGF0ZV1dLCBidXQgY3JlYXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkIG9mXG4gKiBkZWZsYXRlIG9uZS5cbiAqKi9cbmZ1bmN0aW9uIGd6aXAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuZ3ppcCA9IHRydWU7XG4gIHJldHVybiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG5leHBvcnRzLkRlZmxhdGUgPSBEZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZVJhdyA9IGRlZmxhdGVSYXc7XG5leHBvcnRzLmd6aXAgPSBnemlwO1xuIiwiLy8gVG9wIGxldmVsIGZpbGUgaXMganVzdCBhIG1peGluIG9mIHN1Ym1vZHVsZXMgJiBjb25zdGFudHNcbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiAgICA9IHJlcXVpcmUoJy4vbGliL3V0aWxzL2NvbW1vbicpLmFzc2lnbjtcblxudmFyIGRlZmxhdGUgICA9IHJlcXVpcmUoJy4vbGliL2RlZmxhdGUnKTtcbnZhciBpbmZsYXRlICAgPSByZXF1aXJlKCcuL2xpYi9pbmZsYXRlJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9saWIvemxpYi9jb25zdGFudHMnKTtcblxudmFyIHBha28gPSB7fTtcblxuYXNzaWduKHBha28sIGRlZmxhdGUsIGluZmxhdGUsIGNvbnN0YW50cyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFrbztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBVU0VfVFlQRURBUlJBWSA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmICh0eXBlb2YgVWludDE2QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJiAodHlwZW9mIFVpbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyk7XG5cbnZhciBwYWtvID0gcmVxdWlyZShcInBha29cIik7XG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZShcIi4vc3RyZWFtL0dlbmVyaWNXb3JrZXJcIik7XG5cbnZhciBBUlJBWV9UWVBFID0gVVNFX1RZUEVEQVJSQVkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIjtcblxuZXhwb3J0cy5tYWdpYyA9IFwiXFx4MDhcXHgwMFwiO1xuXG4vKipcbiAqIENyZWF0ZSBhIHdvcmtlciB0aGF0IHVzZXMgcGFrbyB0byBpbmZsYXRlL2RlZmxhdGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb24gdGhlIG5hbWUgb2YgdGhlIHBha28gZnVuY3Rpb24gdG8gY2FsbCA6IGVpdGhlciBcIkRlZmxhdGVcIiBvciBcIkluZmxhdGVcIi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZSB3aGVuIChkZSljb21wcmVzc2luZy5cbiAqL1xuZnVuY3Rpb24gRmxhdGVXb3JrZXIoYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiRmxhdGVXb3JrZXIvXCIgKyBhY3Rpb24pO1xuXG4gICAgdGhpcy5fcGFrbyA9IG51bGw7XG4gICAgdGhpcy5fcGFrb0FjdGlvbiA9IGFjdGlvbjtcbiAgICB0aGlzLl9wYWtvT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgLy8gdGhlIGBtZXRhYCBvYmplY3QgZnJvbSB0aGUgbGFzdCBjaHVuayByZWNlaXZlZFxuICAgIC8vIHRoaXMgYWxsb3cgdGhpcyB3b3JrZXIgdG8gcGFzcyBhcm91bmQgbWV0YWRhdGFcbiAgICB0aGlzLm1ldGEgPSB7fTtcbn1cblxudXRpbHMuaW5oZXJpdHMoRmxhdGVXb3JrZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuRmxhdGVXb3JrZXIucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHRoaXMubWV0YSA9IGNodW5rLm1ldGE7XG4gICAgaWYgKHRoaXMuX3Bha28gPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlUGFrbygpO1xuICAgIH1cbiAgICB0aGlzLl9wYWtvLnB1c2godXRpbHMudHJhbnNmb3JtVG8oQVJSQVlfVFlQRSwgY2h1bmsuZGF0YSksIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmZsdXNoXG4gKi9cbkZsYXRlV29ya2VyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5mbHVzaC5jYWxsKHRoaXMpO1xuICAgIGlmICh0aGlzLl9wYWtvID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVBha28oKTtcbiAgICB9XG4gICAgdGhpcy5fcGFrby5wdXNoKFtdLCB0cnVlKTtcbn07XG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5jbGVhblVwXG4gKi9cbkZsYXRlV29ya2VyLnByb3RvdHlwZS5jbGVhblVwID0gZnVuY3Rpb24gKCkge1xuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLmNsZWFuVXAuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9wYWtvID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBfcGFrbyBvYmplY3QuXG4gKiBUT0RPOiBsYXp5LWxvYWRpbmcgdGhpcyBvYmplY3QgaXNuJ3QgdGhlIGJlc3Qgc29sdXRpb24gYnV0IGl0J3MgdGhlXG4gKiBxdWlja2VzdC4gVGhlIGJlc3Qgc29sdXRpb24gaXMgdG8gbGF6eS1sb2FkIHRoZSB3b3JrZXIgbGlzdC4gU2VlIGFsc28gdGhlXG4gKiBpc3N1ZSAjNDQ2LlxuICovXG5GbGF0ZVdvcmtlci5wcm90b3R5cGUuX2NyZWF0ZVBha28gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcGFrbyA9IG5ldyBwYWtvW3RoaXMuX3Bha29BY3Rpb25dKHtcbiAgICAgICAgcmF3OiB0cnVlLFxuICAgICAgICBsZXZlbDogdGhpcy5fcGFrb09wdGlvbnMubGV2ZWwgfHwgLTEgLy8gZGVmYXVsdCBjb21wcmVzc2lvblxuICAgIH0pO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl9wYWtvLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgc2VsZi5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiBkYXRhLFxuICAgICAgICAgICAgbWV0YSA6IHNlbGYubWV0YVxuICAgICAgICB9KTtcbiAgICB9O1xufTtcblxuZXhwb3J0cy5jb21wcmVzc1dvcmtlciA9IGZ1bmN0aW9uIChjb21wcmVzc2lvbk9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEZsYXRlV29ya2VyKFwiRGVmbGF0ZVwiLCBjb21wcmVzc2lvbk9wdGlvbnMpO1xufTtcbmV4cG9ydHMudW5jb21wcmVzc1dvcmtlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IEZsYXRlV29ya2VyKFwiSW5mbGF0ZVwiLCB7fSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29tcHJlc3Npb25zID0gcmVxdWlyZSgnLi4vY29tcHJlc3Npb25zJyk7XG52YXIgWmlwRmlsZVdvcmtlciA9IHJlcXVpcmUoJy4vWmlwRmlsZVdvcmtlcicpO1xuXG4vKipcbiAqIEZpbmQgdGhlIGNvbXByZXNzaW9uIHRvIHVzZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlQ29tcHJlc3Npb24gdGhlIGNvbXByZXNzaW9uIGRlZmluZWQgYXQgdGhlIGZpbGUgbGV2ZWwsIGlmIGFueS5cbiAqIEBwYXJhbSB7U3RyaW5nfSB6aXBDb21wcmVzc2lvbiB0aGUgY29tcHJlc3Npb24gZGVmaW5lZCBhdCB0aGUgbG9hZCgpIGxldmVsLlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgY29tcHJlc3Npb24gb2JqZWN0IHRvIHVzZS5cbiAqL1xudmFyIGdldENvbXByZXNzaW9uID0gZnVuY3Rpb24gKGZpbGVDb21wcmVzc2lvbiwgemlwQ29tcHJlc3Npb24pIHtcblxuICAgIHZhciBjb21wcmVzc2lvbk5hbWUgPSBmaWxlQ29tcHJlc3Npb24gfHwgemlwQ29tcHJlc3Npb247XG4gICAgdmFyIGNvbXByZXNzaW9uID0gY29tcHJlc3Npb25zW2NvbXByZXNzaW9uTmFtZV07XG4gICAgaWYgKCFjb21wcmVzc2lvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY29tcHJlc3Npb25OYW1lICsgXCIgaXMgbm90IGEgdmFsaWQgY29tcHJlc3Npb24gbWV0aG9kICFcIik7XG4gICAgfVxuICAgIHJldHVybiBjb21wcmVzc2lvbjtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgd29ya2VyIHRvIGdlbmVyYXRlIGEgemlwIGZpbGUuXG4gKiBAcGFyYW0ge0pTWmlwfSB6aXAgdGhlIEpTWmlwIGluc3RhbmNlIGF0IHRoZSByaWdodCByb290IGxldmVsLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdG8gZ2VuZXJhdGUgdGhlIHppcCBmaWxlLlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbW1lbnQgdGhlIGNvbW1lbnQgdG8gdXNlLlxuICovXG5leHBvcnRzLmdlbmVyYXRlV29ya2VyID0gZnVuY3Rpb24gKHppcCwgb3B0aW9ucywgY29tbWVudCkge1xuXG4gICAgdmFyIHppcEZpbGVXb3JrZXIgPSBuZXcgWmlwRmlsZVdvcmtlcihvcHRpb25zLnN0cmVhbUZpbGVzLCBjb21tZW50LCBvcHRpb25zLnBsYXRmb3JtLCBvcHRpb25zLmVuY29kZUZpbGVOYW1lKTtcbiAgICB2YXIgZW50cmllc0NvdW50ID0gMDtcbiAgICB0cnkge1xuXG4gICAgICAgIHppcC5mb3JFYWNoKGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIGZpbGUpIHtcbiAgICAgICAgICAgIGVudHJpZXNDb3VudCsrO1xuICAgICAgICAgICAgdmFyIGNvbXByZXNzaW9uID0gZ2V0Q29tcHJlc3Npb24oZmlsZS5vcHRpb25zLmNvbXByZXNzaW9uLCBvcHRpb25zLmNvbXByZXNzaW9uKTtcbiAgICAgICAgICAgIHZhciBjb21wcmVzc2lvbk9wdGlvbnMgPSBmaWxlLm9wdGlvbnMuY29tcHJlc3Npb25PcHRpb25zIHx8IG9wdGlvbnMuY29tcHJlc3Npb25PcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGRpciA9IGZpbGUuZGlyLCBkYXRlID0gZmlsZS5kYXRlO1xuXG4gICAgICAgICAgICBmaWxlLl9jb21wcmVzc1dvcmtlcihjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKVxuICAgICAgICAgICAgLndpdGhTdHJlYW1JbmZvKFwiZmlsZVwiLCB7XG4gICAgICAgICAgICAgICAgbmFtZSA6IHJlbGF0aXZlUGF0aCxcbiAgICAgICAgICAgICAgICBkaXIgOiBkaXIsXG4gICAgICAgICAgICAgICAgZGF0ZSA6IGRhdGUsXG4gICAgICAgICAgICAgICAgY29tbWVudCA6IGZpbGUuY29tbWVudCB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIHVuaXhQZXJtaXNzaW9ucyA6IGZpbGUudW5peFBlcm1pc3Npb25zLFxuICAgICAgICAgICAgICAgIGRvc1Blcm1pc3Npb25zIDogZmlsZS5kb3NQZXJtaXNzaW9uc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5waXBlKHppcEZpbGVXb3JrZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgemlwRmlsZVdvcmtlci5lbnRyaWVzQ291bnQgPSBlbnRyaWVzQ291bnQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB6aXBGaWxlV29ya2VyLmVycm9yKGUpO1xuICAgIH1cblxuICAgIHJldHVybiB6aXBGaWxlV29ya2VyO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFN0cmVhbUhlbHBlciA9IHJlcXVpcmUoJy4vc3RyZWFtL1N0cmVhbUhlbHBlcicpO1xudmFyIERhdGFXb3JrZXIgPSByZXF1aXJlKCcuL3N0cmVhbS9EYXRhV29ya2VyJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIENvbXByZXNzZWRPYmplY3QgPSByZXF1aXJlKCcuL2NvbXByZXNzZWRPYmplY3QnKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi9zdHJlYW0vR2VuZXJpY1dvcmtlcicpO1xuXG4vKipcbiAqIEEgc2ltcGxlIG9iamVjdCByZXByZXNlbnRpbmcgYSBmaWxlIGluIHRoZSB6aXAgZmlsZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGVcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhIHRoZSBkYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyBvZiB0aGUgZmlsZVxuICovXG52YXIgWmlwT2JqZWN0ID0gZnVuY3Rpb24obmFtZSwgZGF0YSwgb3B0aW9ucykge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5kaXIgPSBvcHRpb25zLmRpcjtcbiAgICB0aGlzLmRhdGUgPSBvcHRpb25zLmRhdGU7XG4gICAgdGhpcy5jb21tZW50ID0gb3B0aW9ucy5jb21tZW50O1xuICAgIHRoaXMudW5peFBlcm1pc3Npb25zID0gb3B0aW9ucy51bml4UGVybWlzc2lvbnM7XG4gICAgdGhpcy5kb3NQZXJtaXNzaW9ucyA9IG9wdGlvbnMuZG9zUGVybWlzc2lvbnM7XG5cbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB0aGlzLl9kYXRhQmluYXJ5ID0gb3B0aW9ucy5iaW5hcnk7XG4gICAgLy8ga2VlcCBvbmx5IHRoZSBjb21wcmVzc2lvblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgY29tcHJlc3Npb24gOiBvcHRpb25zLmNvbXByZXNzaW9uLFxuICAgICAgICBjb21wcmVzc2lvbk9wdGlvbnMgOiBvcHRpb25zLmNvbXByZXNzaW9uT3B0aW9uc1xuICAgIH07XG59O1xuXG5aaXBPYmplY3QucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpbnRlcm5hbCBzdHJlYW0gZm9yIHRoZSBjb250ZW50IG9mIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIGVhY2ggY2h1bmsuXG4gICAgICogQHJldHVybiBTdHJlYW1IZWxwZXIgdGhlIHN0cmVhbS5cbiAgICAgKi9cbiAgICBpbnRlcm5hbFN0cmVhbTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGwsIG91dHB1dFR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gb3V0cHV0IHR5cGUgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dFR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgYXNrVW5pY29kZVN0cmluZyA9IG91dHB1dFR5cGUgPT09IFwic3RyaW5nXCIgfHwgb3V0cHV0VHlwZSA9PT0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICBpZiAob3V0cHV0VHlwZSA9PT0gXCJiaW5hcnlzdHJpbmdcIiB8fCBvdXRwdXRUeXBlID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgICAgIG91dHB1dFR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZGVjb21wcmVzc1dvcmtlcigpO1xuXG4gICAgICAgICAgICB2YXIgaXNVbmljb2RlU3RyaW5nID0gIXRoaXMuX2RhdGFCaW5hcnk7XG5cbiAgICAgICAgICAgIGlmIChpc1VuaWNvZGVTdHJpbmcgJiYgIWFza1VuaWNvZGVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGlwZShuZXcgdXRmOC5VdGY4RW5jb2RlV29ya2VyKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1VuaWNvZGVTdHJpbmcgJiYgYXNrVW5pY29kZVN0cmluZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKG5ldyB1dGY4LlV0ZjhEZWNvZGVXb3JrZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBHZW5lcmljV29ya2VyKFwiZXJyb3JcIik7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3IoZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUhlbHBlcihyZXN1bHQsIG91dHB1dFR5cGUsIFwiXCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHRoZSBjb250ZW50IGluIHRoZSBhc2tlZCB0eXBlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25VcGRhdGUgYSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggaW50ZXJuYWwgdXBkYXRlLlxuICAgICAqIEByZXR1cm4gUHJvbWlzZSB0aGUgcHJvbWlzZSBvZiB0aGUgcmVzdWx0LlxuICAgICAqL1xuICAgIGFzeW5jOiBmdW5jdGlvbiAodHlwZSwgb25VcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdHJlYW0odHlwZSkuYWNjdW11bGF0ZShvblVwZGF0ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdGhlIGNvbnRlbnQgYXMgYSBub2RlanMgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIGVhY2ggY2h1bmsuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25VcGRhdGUgYSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggaW50ZXJuYWwgdXBkYXRlLlxuICAgICAqIEByZXR1cm4gU3RyZWFtIHRoZSBzdHJlYW0uXG4gICAgICovXG4gICAgbm9kZVN0cmVhbTogZnVuY3Rpb24gKHR5cGUsIG9uVXBkYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsU3RyZWFtKHR5cGUgfHwgXCJub2RlYnVmZmVyXCIpLnRvTm9kZWpzU3RyZWFtKG9uVXBkYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgd29ya2VyIGZvciB0aGUgY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uIHRoZSBjb21wcmVzc2lvbiBvYmplY3QgdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb21wcmVzc2lvbk9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gY29tcHJlc3NpbmcuXG4gICAgICogQHJldHVybiBXb3JrZXIgdGhlIHdvcmtlci5cbiAgICAgKi9cbiAgICBfY29tcHJlc3NXb3JrZXI6IGZ1bmN0aW9uIChjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgaW5zdGFuY2VvZiBDb21wcmVzc2VkT2JqZWN0ICYmXG4gICAgICAgICAgICB0aGlzLl9kYXRhLmNvbXByZXNzaW9uLm1hZ2ljID09PSBjb21wcmVzc2lvbi5tYWdpY1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdldENvbXByZXNzZWRXb3JrZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9kZWNvbXByZXNzV29ya2VyKCk7XG4gICAgICAgICAgICBpZighdGhpcy5fZGF0YUJpbmFyeSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKG5ldyB1dGY4LlV0ZjhFbmNvZGVXb3JrZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ29tcHJlc3NlZE9iamVjdC5jcmVhdGVXb3JrZXJGcm9tKHJlc3VsdCwgY29tcHJlc3Npb24sIGNvbXByZXNzaW9uT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHdvcmtlciBmb3IgdGhlIGRlY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiBXb3JrZXIgdGhlIHdvcmtlci5cbiAgICAgKi9cbiAgICBfZGVjb21wcmVzc1dvcmtlciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RhdGEgaW5zdGFuY2VvZiBDb21wcmVzc2VkT2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5nZXRDb250ZW50V29ya2VyKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YSBpbnN0YW5jZW9mIEdlbmVyaWNXb3JrZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRhV29ya2VyKHRoaXMuX2RhdGEpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIHJlbW92ZWRNZXRob2RzID0gW1wiYXNUZXh0XCIsIFwiYXNCaW5hcnlcIiwgXCJhc05vZGVCdWZmZXJcIiwgXCJhc1VpbnQ4QXJyYXlcIiwgXCJhc0FycmF5QnVmZmVyXCJdO1xudmFyIHJlbW92ZWRGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG1ldGhvZCBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKTtcbn07XG5cbmZvcih2YXIgaSA9IDA7IGkgPCByZW1vdmVkTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgIFppcE9iamVjdC5wcm90b3R5cGVbcmVtb3ZlZE1ldGhvZHNbaV1dID0gcmVtb3ZlZEZuO1xufVxubW9kdWxlLmV4cG9ydHMgPSBaaXBPYmplY3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlJlYWRhYmxlO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudXRpbHMuaW5oZXJpdHMoTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlciwgUmVhZGFibGUpO1xuXG4vKipcbiogQSBub2RlanMgc3RyZWFtIHVzaW5nIGEgd29ya2VyIGFzIHNvdXJjZS5cbiogQHNlZSB0aGUgU291cmNlV3JhcHBlciBpbiBodHRwOi8vbm9kZWpzLm9yZy9hcGkvc3RyZWFtLmh0bWxcbiogQGNvbnN0cnVjdG9yXG4qIEBwYXJhbSB7U3RyZWFtSGVscGVyfSBoZWxwZXIgdGhlIGhlbHBlciB3cmFwcGluZyB0aGUgd29ya2VyXG4qIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBub2RlanMgc3RyZWFtIG9wdGlvbnNcbiogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlQ2IgdGhlIHVwZGF0ZSBjYWxsYmFjay5cbiovXG5mdW5jdGlvbiBOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyKGhlbHBlciwgb3B0aW9ucywgdXBkYXRlQ2IpIHtcbiAgICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIHRoaXMuX2hlbHBlciA9IGhlbHBlcjtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBoZWxwZXIub24oXCJkYXRhXCIsIGZ1bmN0aW9uIChkYXRhLCBtZXRhKSB7XG4gICAgICAgIGlmICghc2VsZi5wdXNoKGRhdGEpKSB7XG4gICAgICAgICAgICBzZWxmLl9oZWxwZXIucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZih1cGRhdGVDYikge1xuICAgICAgICAgICAgdXBkYXRlQ2IobWV0YSk7XG4gICAgICAgIH1cbiAgICB9KVxuICAgIC5vbihcImVycm9yXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0pXG4gICAgLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5wdXNoKG51bGwpO1xuICAgIH0pO1xufVxuXG5cbk5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5faGVscGVyLnJlc3VtZSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vR2VuZXJpY1dvcmtlcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBBIHdvcmtlciB3aGljaCBjb252ZXJ0IGNodW5rcyB0byBhIHNwZWNpZmllZCB0eXBlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVzdFR5cGUgdGhlIGRlc3RpbmF0aW9uIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIENvbnZlcnRXb3JrZXIoZGVzdFR5cGUpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJDb252ZXJ0V29ya2VyIHRvIFwiICsgZGVzdFR5cGUpO1xuICAgIHRoaXMuZGVzdFR5cGUgPSBkZXN0VHlwZTtcbn1cbnV0aWxzLmluaGVyaXRzKENvbnZlcnRXb3JrZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuQ29udmVydFdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IHV0aWxzLnRyYW5zZm9ybVRvKHRoaXMuZGVzdFR5cGUsIGNodW5rLmRhdGEpLFxuICAgICAgICBtZXRhIDogY2h1bmsubWV0YVxuICAgIH0pO1xufTtcbm1vZHVsZS5leHBvcnRzID0gQ29udmVydFdvcmtlcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBNdXRhdGlvbiA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuXG52YXIgc2NoZWR1bGVEcmFpbjtcblxue1xuICBpZiAoTXV0YXRpb24pIHtcbiAgICB2YXIgY2FsbGVkID0gMDtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb24obmV4dFRpY2spO1xuICAgIHZhciBlbGVtZW50ID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIHtcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICBzY2hlZHVsZURyYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgZWxlbWVudC5kYXRhID0gKGNhbGxlZCA9ICsrY2FsbGVkICUgMik7XG4gICAgfTtcbiAgfSBlbHNlIGlmICghZ2xvYmFsLnNldEltbWVkaWF0ZSAmJiB0eXBlb2YgZ2xvYmFsLk1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBjaGFubmVsID0gbmV3IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCgpO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbmV4dFRpY2s7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICgnZG9jdW1lbnQnIGluIGdsb2JhbCAmJiAnb25yZWFkeXN0YXRlY2hhbmdlJyBpbiBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpIHtcbiAgICBzY2hlZHVsZURyYWluID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICB2YXIgc2NyaXB0RWwgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICBzY3JpcHRFbC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG5leHRUaWNrKCk7XG5cbiAgICAgICAgc2NyaXB0RWwub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgc2NyaXB0RWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHRFbCk7XG4gICAgICAgIHNjcmlwdEVsID0gbnVsbDtcbiAgICAgIH07XG4gICAgICBnbG9iYWwuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHNjcmlwdEVsKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHNjaGVkdWxlRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRUaW1lb3V0KG5leHRUaWNrLCAwKTtcbiAgICB9O1xuICB9XG59XG5cbnZhciBkcmFpbmluZztcbnZhciBxdWV1ZSA9IFtdO1xuLy9uYW1lZCBuZXh0VGljayBmb3IgbGVzcyBjb25mdXNpbmcgc3RhY2sgdHJhY2VzXG5mdW5jdGlvbiBuZXh0VGljaygpIHtcbiAgZHJhaW5pbmcgPSB0cnVlO1xuICB2YXIgaSwgb2xkUXVldWU7XG4gIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChsZW4pIHtcbiAgICBvbGRRdWV1ZSA9IHF1ZXVlO1xuICAgIHF1ZXVlID0gW107XG4gICAgaSA9IC0xO1xuICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgIG9sZFF1ZXVlW2ldKCk7XG4gICAgfVxuICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgfVxuICBkcmFpbmluZyA9IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGltbWVkaWF0ZTtcbmZ1bmN0aW9uIGltbWVkaWF0ZSh0YXNrKSB7XG4gIGlmIChxdWV1ZS5wdXNoKHRhc2spID09PSAxICYmICFkcmFpbmluZykge1xuICAgIHNjaGVkdWxlRHJhaW4oKTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGltbWVkaWF0ZSA9IHJlcXVpcmUoJ2ltbWVkaWF0ZScpO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gSU5URVJOQUwoKSB7fVxuXG52YXIgaGFuZGxlcnMgPSB7fTtcblxudmFyIFJFSkVDVEVEID0gWydSRUpFQ1RFRCddO1xudmFyIEZVTEZJTExFRCA9IFsnRlVMRklMTEVEJ107XG52YXIgUEVORElORyA9IFsnUEVORElORyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5cbmZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiByZXNvbHZlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Jlc29sdmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHRoaXMuc3RhdGUgPSBQRU5ESU5HO1xuICB0aGlzLnF1ZXVlID0gW107XG4gIHRoaXMub3V0Y29tZSA9IHZvaWQgMDtcbiAgaWYgKHJlc29sdmVyICE9PSBJTlRFUk5BTCkge1xuICAgIHNhZmVseVJlc29sdmVUaGVuYWJsZSh0aGlzLCByZXNvbHZlcik7XG4gIH1cbn1cblxuUHJvbWlzZS5wcm90b3R5cGVbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG59O1xuUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICBpZiAodHlwZW9mIG9uRnVsZmlsbGVkICE9PSAnZnVuY3Rpb24nICYmIHRoaXMuc3RhdGUgPT09IEZVTEZJTExFRCB8fFxuICAgIHR5cGVvZiBvblJlamVjdGVkICE9PSAnZnVuY3Rpb24nICYmIHRoaXMuc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihJTlRFUk5BTCk7XG4gIGlmICh0aGlzLnN0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgdmFyIHJlc29sdmVyID0gdGhpcy5zdGF0ZSA9PT0gRlVMRklMTEVEID8gb25GdWxmaWxsZWQgOiBvblJlamVjdGVkO1xuICAgIHVud3JhcChwcm9taXNlLCByZXNvbHZlciwgdGhpcy5vdXRjb21lKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnF1ZXVlLnB1c2gobmV3IFF1ZXVlSXRlbShwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuZnVuY3Rpb24gUXVldWVJdGVtKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gIGlmICh0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLm9uRnVsZmlsbGVkID0gb25GdWxmaWxsZWQ7XG4gICAgdGhpcy5jYWxsRnVsZmlsbGVkID0gdGhpcy5vdGhlckNhbGxGdWxmaWxsZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5vblJlamVjdGVkID0gb25SZWplY3RlZDtcbiAgICB0aGlzLmNhbGxSZWplY3RlZCA9IHRoaXMub3RoZXJDYWxsUmVqZWN0ZWQ7XG4gIH1cbn1cblF1ZXVlSXRlbS5wcm90b3R5cGUuY2FsbEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBoYW5kbGVycy5yZXNvbHZlKHRoaXMucHJvbWlzZSwgdmFsdWUpO1xufTtcblF1ZXVlSXRlbS5wcm90b3R5cGUub3RoZXJDYWxsRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHVud3JhcCh0aGlzLnByb21pc2UsIHRoaXMub25GdWxmaWxsZWQsIHZhbHVlKTtcbn07XG5RdWV1ZUl0ZW0ucHJvdG90eXBlLmNhbGxSZWplY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBoYW5kbGVycy5yZWplY3QodGhpcy5wcm9taXNlLCB2YWx1ZSk7XG59O1xuUXVldWVJdGVtLnByb3RvdHlwZS5vdGhlckNhbGxSZWplY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB1bndyYXAodGhpcy5wcm9taXNlLCB0aGlzLm9uUmVqZWN0ZWQsIHZhbHVlKTtcbn07XG5cbmZ1bmN0aW9uIHVud3JhcChwcm9taXNlLCBmdW5jLCB2YWx1ZSkge1xuICBpbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXR1cm5WYWx1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuVmFsdWUgPSBmdW5jKHZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIGUpO1xuICAgIH1cbiAgICBpZiAocmV0dXJuVmFsdWUgPT09IHByb21pc2UpIHtcbiAgICAgIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCBuZXcgVHlwZUVycm9yKCdDYW5ub3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggaXRzZWxmJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVycy5yZXNvbHZlKHByb21pc2UsIHJldHVyblZhbHVlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5oYW5kbGVycy5yZXNvbHZlID0gZnVuY3Rpb24gKHNlbGYsIHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0cnlDYXRjaChnZXRUaGVuLCB2YWx1ZSk7XG4gIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgcmV0dXJuIGhhbmRsZXJzLnJlamVjdChzZWxmLCByZXN1bHQudmFsdWUpO1xuICB9XG4gIHZhciB0aGVuYWJsZSA9IHJlc3VsdC52YWx1ZTtcblxuICBpZiAodGhlbmFibGUpIHtcbiAgICBzYWZlbHlSZXNvbHZlVGhlbmFibGUoc2VsZiwgdGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIHNlbGYuc3RhdGUgPSBGVUxGSUxMRUQ7XG4gICAgc2VsZi5vdXRjb21lID0gdmFsdWU7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgbGVuID0gc2VsZi5xdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgc2VsZi5xdWV1ZVtpXS5jYWxsRnVsZmlsbGVkKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59O1xuaGFuZGxlcnMucmVqZWN0ID0gZnVuY3Rpb24gKHNlbGYsIGVycm9yKSB7XG4gIHNlbGYuc3RhdGUgPSBSRUpFQ1RFRDtcbiAgc2VsZi5vdXRjb21lID0gZXJyb3I7XG4gIHZhciBpID0gLTE7XG4gIHZhciBsZW4gPSBzZWxmLnF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHNlbGYucXVldWVbaV0uY2FsbFJlamVjdGVkKGVycm9yKTtcbiAgfVxuICByZXR1cm4gc2VsZjtcbn07XG5cbmZ1bmN0aW9uIGdldFRoZW4ob2JqKSB7XG4gIC8vIE1ha2Ugc3VyZSB3ZSBvbmx5IGFjY2VzcyB0aGUgYWNjZXNzb3Igb25jZSBhcyByZXF1aXJlZCBieSB0aGUgc3BlY1xuICB2YXIgdGhlbiA9IG9iaiAmJiBvYmoudGhlbjtcbiAgaWYgKG9iaiAmJiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykgJiYgdHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYXBweVRoZW4oKSB7XG4gICAgICB0aGVuLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseVJlc29sdmVUaGVuYWJsZShzZWxmLCB0aGVuYWJsZSkge1xuICAvLyBFaXRoZXIgZnVsZmlsbCwgcmVqZWN0IG9yIHJlamVjdCB3aXRoIGVycm9yXG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25FcnJvcih2YWx1ZSkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBoYW5kbGVycy5yZWplY3Qoc2VsZiwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25TdWNjZXNzKHZhbHVlKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGhhbmRsZXJzLnJlc29sdmUoc2VsZiwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJ5VG9VbndyYXAoKSB7XG4gICAgdGhlbmFibGUob25TdWNjZXNzLCBvbkVycm9yKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0cnlUb1Vud3JhcCk7XG4gIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgb25FcnJvcihyZXN1bHQudmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeUNhdGNoKGZ1bmMsIHZhbHVlKSB7XG4gIHZhciBvdXQgPSB7fTtcbiAgdHJ5IHtcbiAgICBvdXQudmFsdWUgPSBmdW5jKHZhbHVlKTtcbiAgICBvdXQuc3RhdHVzID0gJ3N1Y2Nlc3MnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgb3V0LnN0YXR1cyA9ICdlcnJvcic7XG4gICAgb3V0LnZhbHVlID0gZTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG5Qcm9taXNlLnJlc29sdmUgPSByZXNvbHZlO1xuZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiB0aGlzKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBoYW5kbGVycy5yZXNvbHZlKG5ldyB0aGlzKElOVEVSTkFMKSwgdmFsdWUpO1xufVxuXG5Qcm9taXNlLnJlamVjdCA9IHJlamVjdDtcbmZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcyhJTlRFUk5BTCk7XG4gIHJldHVybiBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbn1cblxuUHJvbWlzZS5hbGwgPSBhbGw7XG5mdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXJhYmxlKSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHJldHVybiB0aGlzLnJlamVjdChuZXcgVHlwZUVycm9yKCdtdXN0IGJlIGFuIGFycmF5JykpO1xuICB9XG5cbiAgdmFyIGxlbiA9IGl0ZXJhYmxlLmxlbmd0aDtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICBpZiAoIWxlbikge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmUoW10pO1xuICB9XG5cbiAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheShsZW4pO1xuICB2YXIgcmVzb2x2ZWQgPSAwO1xuICB2YXIgaSA9IC0xO1xuICB2YXIgcHJvbWlzZSA9IG5ldyB0aGlzKElOVEVSTkFMKTtcblxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgYWxsUmVzb2x2ZXIoaXRlcmFibGVbaV0sIGkpO1xuICB9XG4gIHJldHVybiBwcm9taXNlO1xuICBmdW5jdGlvbiBhbGxSZXNvbHZlcih2YWx1ZSwgaSkge1xuICAgIHNlbGYucmVzb2x2ZSh2YWx1ZSkudGhlbihyZXNvbHZlRnJvbUFsbCwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHJlc29sdmVGcm9tQWxsKG91dFZhbHVlKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvdXRWYWx1ZTtcbiAgICAgIGlmICgrK3Jlc29sdmVkID09PSBsZW4gJiYgIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZXNvbHZlKHByb21pc2UsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblByb21pc2UucmFjZSA9IHJhY2U7XG5mdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyYWJsZSkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICByZXR1cm4gdGhpcy5yZWplY3QobmV3IFR5cGVFcnJvcignbXVzdCBiZSBhbiBhcnJheScpKTtcbiAgfVxuXG4gIHZhciBsZW4gPSBpdGVyYWJsZS5sZW5ndGg7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgaWYgKCFsZW4pIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlKFtdKTtcbiAgfVxuXG4gIHZhciBpID0gLTE7XG4gIHZhciBwcm9taXNlID0gbmV3IHRoaXMoSU5URVJOQUwpO1xuXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICByZXNvbHZlcihpdGVyYWJsZVtpXSk7XG4gIH1cbiAgcmV0dXJuIHByb21pc2U7XG4gIGZ1bmN0aW9uIHJlc29sdmVyKHZhbHVlKSB7XG4gICAgc2VsZi5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVzb2x2ZShwcm9taXNlLCByZXNwb25zZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50OyIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgYXJncywgdGhhdCl7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTsiLCJ2YXIgY3R4ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBpbnZva2UgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pbnZva2UnKVxuICAsIGh0bWwgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2h0bWwnKVxuICAsIGNlbCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKVxuICAsIGdsb2JhbCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBzZXRUYXNrICAgICAgICAgICAgPSBnbG9iYWwuc2V0SW1tZWRpYXRlXG4gICwgY2xlYXJUYXNrICAgICAgICAgID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlXG4gICwgTWVzc2FnZUNoYW5uZWwgICAgID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsXG4gICwgY291bnRlciAgICAgICAgICAgID0gMFxuICAsIHF1ZXVlICAgICAgICAgICAgICA9IHt9XG4gICwgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSdcbiAgLCBkZWZlciwgY2hhbm5lbCwgcG9ydDtcbnZhciBydW4gPSBmdW5jdGlvbigpe1xuICB2YXIgaWQgPSArdGhpcztcbiAgaWYocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKXtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQpe1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZighc2V0VGFzayB8fCAhY2xlYXJUYXNrKXtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbil7XG4gICAgdmFyIGFyZ3MgPSBbXSwgaSA9IDE7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24oKXtcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCl7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmKHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYoTWVzc2FnZUNoYW5uZWwpe1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWw7XG4gICAgcG9ydCAgICA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZihnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiAgIHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59OyIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIFMpe1xuICBpZighaXNPYmplY3QoaXQpKXJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZighUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcclxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XHJcbn0pOyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59OyIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07IiwidmFyIGRQICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZih0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59OyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGN0eCAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgc291cmNlKXtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcbiAgICAsIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0LkdcbiAgICAsIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlNcbiAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcbiAgICAsIElTX0JJTkQgICA9IHR5cGUgJiAkZXhwb3J0LkJcbiAgICAsIElTX1dSQVAgICA9IHR5cGUgJiAkZXhwb3J0LldcbiAgICAsIGV4cG9ydHMgICA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pXG4gICAgLCBleHBQcm90byAgPSBleHBvcnRzW1BST1RPVFlQRV1cbiAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV1cbiAgICAsIGtleSwgb3duLCBvdXQ7XG4gIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICBpZihvd24gJiYga2V5IGluIGV4cG9ydHMpY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbihDKXtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICAgIGlmKHRoaXMgaW5zdGFuY2VvZiBDKXtcbiAgICAgICAgICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQztcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDKGEpO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7XG4gICAgICAgICAgfSByZXR1cm4gbmV3IEMoYSwgYiwgYyk7XG4gICAgICAgIH0gcmV0dXJuIEMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG4gICAgICByZXR1cm4gRjtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLm1ldGhvZHMuJU5BTUUlXG4gICAgaWYoSVNfUFJPVE8pe1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0paGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWAgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICR0YXNrICAgPSByZXF1aXJlKCcuL190YXNrJyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiwge1xuICBzZXRJbW1lZGlhdGU6ICAgJHRhc2suc2V0LFxuICBjbGVhckltbWVkaWF0ZTogJHRhc2suY2xlYXJcbn0pOyIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmltbWVkaWF0ZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuc2V0SW1tZWRpYXRlOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlBhc3NUaHJvdWdoXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5UcmFuc2Zvcm1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIiwidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgc3JjLmNvcHkodGFyZ2V0LCBvZmZzZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG5cbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2godikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAtLXRoaXMubGVuZ3RoO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihzKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgICB9cmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQobikge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAocCkge1xuICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICBwID0gcC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpO1xuXG5pZiAodXRpbCAmJiB1dGlsLmluc3BlY3QgJiYgdXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICBtb2R1bGUuZXhwb3J0cy5wcm90b3R5cGVbdXRpbC5pbnNwZWN0LmN1c3RvbV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHV0aWwuaW5zcGVjdCh7IGxlbmd0aDogdGhpcy5sZW5ndGggfSk7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZSArICcgJyArIG9iajtcbiAgfTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHV0ZjggPSByZXF1aXJlKCcuL3V0ZjgnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi9zdHJlYW0vR2VuZXJpY1dvcmtlcicpO1xudmFyIFN0cmVhbUhlbHBlciA9IHJlcXVpcmUoJy4vc3RyZWFtL1N0cmVhbUhlbHBlcicpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xudmFyIENvbXByZXNzZWRPYmplY3QgPSByZXF1aXJlKCcuL2NvbXByZXNzZWRPYmplY3QnKTtcbnZhciBaaXBPYmplY3QgPSByZXF1aXJlKCcuL3ppcE9iamVjdCcpO1xudmFyIGdlbmVyYXRlID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVcIik7XG52YXIgbm9kZWpzVXRpbHMgPSByZXF1aXJlKFwiLi9ub2RlanNVdGlsc1wiKTtcbnZhciBOb2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIgPSByZXF1aXJlKFwiLi9ub2RlanMvTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyXCIpO1xuXG5cbi8qKlxuICogQWRkIGEgZmlsZSBpbiB0aGUgY3VycmVudCBmb2xkZXIuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGVcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhIHRoZSBkYXRhIG9mIHRoZSBmaWxlXG4gKiBAcGFyYW0ge09iamVjdH0gb3JpZ2luYWxPcHRpb25zIHRoZSBvcHRpb25zIG9mIHRoZSBmaWxlXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBuZXcgZmlsZS5cbiAqL1xudmFyIGZpbGVBZGQgPSBmdW5jdGlvbihuYW1lLCBkYXRhLCBvcmlnaW5hbE9wdGlvbnMpIHtcbiAgICAvLyBiZSBzdXJlIHN1YiBmb2xkZXJzIGV4aXN0XG4gICAgdmFyIGRhdGFUeXBlID0gdXRpbHMuZ2V0VHlwZU9mKGRhdGEpLFxuICAgICAgICBwYXJlbnQ7XG5cblxuICAgIC8qXG4gICAgICogQ29ycmVjdCBvcHRpb25zLlxuICAgICAqL1xuXG4gICAgdmFyIG8gPSB1dGlscy5leHRlbmQob3JpZ2luYWxPcHRpb25zIHx8IHt9LCBkZWZhdWx0cyk7XG4gICAgby5kYXRlID0gby5kYXRlIHx8IG5ldyBEYXRlKCk7XG4gICAgaWYgKG8uY29tcHJlc3Npb24gIT09IG51bGwpIHtcbiAgICAgICAgby5jb21wcmVzc2lvbiA9IG8uY29tcHJlc3Npb24udG9VcHBlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG8udW5peFBlcm1pc3Npb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG8udW5peFBlcm1pc3Npb25zID0gcGFyc2VJbnQoby51bml4UGVybWlzc2lvbnMsIDgpO1xuICAgIH1cblxuICAgIC8vIFVOWF9JRkRJUiAgMDA0MDAwMCBzZWUgemlwaW5mby5jXG4gICAgaWYgKG8udW5peFBlcm1pc3Npb25zICYmIChvLnVuaXhQZXJtaXNzaW9ucyAmIDB4NDAwMCkpIHtcbiAgICAgICAgby5kaXIgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBCaXQgNCAgICBEaXJlY3RvcnlcbiAgICBpZiAoby5kb3NQZXJtaXNzaW9ucyAmJiAoby5kb3NQZXJtaXNzaW9ucyAmIDB4MDAxMCkpIHtcbiAgICAgICAgby5kaXIgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvLmRpcikge1xuICAgICAgICBuYW1lID0gZm9yY2VUcmFpbGluZ1NsYXNoKG5hbWUpO1xuICAgIH1cbiAgICBpZiAoby5jcmVhdGVGb2xkZXJzICYmIChwYXJlbnQgPSBwYXJlbnRGb2xkZXIobmFtZSkpKSB7XG4gICAgICAgIGZvbGRlckFkZC5jYWxsKHRoaXMsIHBhcmVudCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdmFyIGlzVW5pY29kZVN0cmluZyA9IGRhdGFUeXBlID09PSBcInN0cmluZ1wiICYmIG8uYmluYXJ5ID09PSBmYWxzZSAmJiBvLmJhc2U2NCA9PT0gZmFsc2U7XG4gICAgaWYgKCFvcmlnaW5hbE9wdGlvbnMgfHwgdHlwZW9mIG9yaWdpbmFsT3B0aW9ucy5iaW5hcnkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgby5iaW5hcnkgPSAhaXNVbmljb2RlU3RyaW5nO1xuICAgIH1cblxuXG4gICAgdmFyIGlzQ29tcHJlc3NlZEVtcHR5ID0gKGRhdGEgaW5zdGFuY2VvZiBDb21wcmVzc2VkT2JqZWN0KSAmJiBkYXRhLnVuY29tcHJlc3NlZFNpemUgPT09IDA7XG5cbiAgICBpZiAoaXNDb21wcmVzc2VkRW1wdHkgfHwgby5kaXIgfHwgIWRhdGEgfHwgZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgby5iYXNlNjQgPSBmYWxzZTtcbiAgICAgICAgby5iaW5hcnkgPSB0cnVlO1xuICAgICAgICBkYXRhID0gXCJcIjtcbiAgICAgICAgby5jb21wcmVzc2lvbiA9IFwiU1RPUkVcIjtcbiAgICAgICAgZGF0YVR5cGUgPSBcInN0cmluZ1wiO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29udmVydCBjb250ZW50IHRvIGZpdC5cbiAgICAgKi9cblxuICAgIHZhciB6aXBPYmplY3RDb250ZW50ID0gbnVsbDtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIENvbXByZXNzZWRPYmplY3QgfHwgZGF0YSBpbnN0YW5jZW9mIEdlbmVyaWNXb3JrZXIpIHtcbiAgICAgICAgemlwT2JqZWN0Q29udGVudCA9IGRhdGE7XG4gICAgfSBlbHNlIGlmIChub2RlanNVdGlscy5pc05vZGUgJiYgbm9kZWpzVXRpbHMuaXNTdHJlYW0oZGF0YSkpIHtcbiAgICAgICAgemlwT2JqZWN0Q29udGVudCA9IG5ldyBOb2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIobmFtZSwgZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgemlwT2JqZWN0Q29udGVudCA9IHV0aWxzLnByZXBhcmVDb250ZW50KG5hbWUsIGRhdGEsIG8uYmluYXJ5LCBvLm9wdGltaXplZEJpbmFyeVN0cmluZywgby5iYXNlNjQpO1xuICAgIH1cblxuICAgIHZhciBvYmplY3QgPSBuZXcgWmlwT2JqZWN0KG5hbWUsIHppcE9iamVjdENvbnRlbnQsIG8pO1xuICAgIHRoaXMuZmlsZXNbbmFtZV0gPSBvYmplY3Q7XG4gICAgLypcbiAgICBUT0RPOiB3ZSBjYW4ndCB0aHJvdyBhbiBleGNlcHRpb24gYmVjYXVzZSB3ZSBoYXZlIGFzeW5jIHByb21pc2VzXG4gICAgKHdlIGNhbiBoYXZlIGEgcHJvbWlzZSBvZiBhIERhdGUoKSBmb3IgZXhhbXBsZSkgYnV0IHJldHVybmluZyBhXG4gICAgcHJvbWlzZSBpcyB1c2VsZXNzIGJlY2F1c2UgZmlsZShuYW1lLCBkYXRhKSByZXR1cm5zIHRoZSBKU1ppcFxuICAgIG9iamVjdCBmb3IgY2hhaW5pbmcuIFNob3VsZCB3ZSBicmVhayB0aGF0IHRvIGFsbG93IHRoZSB1c2VyXG4gICAgdG8gY2F0Y2ggdGhlIGVycm9yID9cblxuICAgIHJldHVybiBleHRlcm5hbC5Qcm9taXNlLnJlc29sdmUoemlwT2JqZWN0Q29udGVudClcbiAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSk7XG4gICAgKi9cbn07XG5cbi8qKlxuICogRmluZCB0aGUgcGFyZW50IGZvbGRlciBvZiB0aGUgcGF0aC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCB0aGUgcGF0aCB0byB1c2VcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHBhcmVudCBmb2xkZXIsIG9yIFwiXCJcbiAqL1xudmFyIHBhcmVudEZvbGRlciA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgaWYgKHBhdGguc2xpY2UoLTEpID09PSAnLycpIHtcbiAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDAsIHBhdGgubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIHZhciBsYXN0U2xhc2ggPSBwYXRoLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgcmV0dXJuIChsYXN0U2xhc2ggPiAwKSA/IHBhdGguc3Vic3RyaW5nKDAsIGxhc3RTbGFzaCkgOiBcIlwiO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXRoIHdpdGggYSBzbGFzaCBhdCB0aGUgZW5kLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgcGF0aCB3aXRoIGEgdHJhaWxpbmcgc2xhc2guXG4gKi9cbnZhciBmb3JjZVRyYWlsaW5nU2xhc2ggPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgLy8gQ2hlY2sgdGhlIG5hbWUgZW5kcyB3aXRoIGEgL1xuICAgIGlmIChwYXRoLnNsaWNlKC0xKSAhPT0gXCIvXCIpIHtcbiAgICAgICAgcGF0aCArPSBcIi9cIjsgLy8gSUUgZG9lc24ndCBsaWtlIHN1YnN0cigtMSlcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59O1xuXG4vKipcbiAqIEFkZCBhIChzdWIpIGZvbGRlciBpbiB0aGUgY3VycmVudCBmb2xkZXIuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIGZvbGRlcidzIG5hbWVcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IFtjcmVhdGVGb2xkZXJzXSBJZiB0cnVlLCBhdXRvbWF0aWNhbGx5IGNyZWF0ZSBzdWJcbiAqICBmb2xkZXJzLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIG5ldyBmb2xkZXIuXG4gKi9cbnZhciBmb2xkZXJBZGQgPSBmdW5jdGlvbihuYW1lLCBjcmVhdGVGb2xkZXJzKSB7XG4gICAgY3JlYXRlRm9sZGVycyA9ICh0eXBlb2YgY3JlYXRlRm9sZGVycyAhPT0gJ3VuZGVmaW5lZCcpID8gY3JlYXRlRm9sZGVycyA6IGRlZmF1bHRzLmNyZWF0ZUZvbGRlcnM7XG5cbiAgICBuYW1lID0gZm9yY2VUcmFpbGluZ1NsYXNoKG5hbWUpO1xuXG4gICAgLy8gRG9lcyB0aGlzIGZvbGRlciBhbHJlYWR5IGV4aXN0P1xuICAgIGlmICghdGhpcy5maWxlc1tuYW1lXSkge1xuICAgICAgICBmaWxlQWRkLmNhbGwodGhpcywgbmFtZSwgbnVsbCwge1xuICAgICAgICAgICAgZGlyOiB0cnVlLFxuICAgICAgICAgICAgY3JlYXRlRm9sZGVyczogY3JlYXRlRm9sZGVyc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmlsZXNbbmFtZV07XG59O1xuXG4vKipcbiogQ3Jvc3Mtd2luZG93LCBjcm9zcy1Ob2RlLWNvbnRleHQgcmVndWxhciBleHByZXNzaW9uIGRldGVjdGlvblxuKiBAcGFyYW0gIHtPYmplY3R9ICBvYmplY3QgQW55dGhpbmdcbiogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIHRydWUgaWYgdGhlIG9iamVjdCBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbixcbiogZmFsc2Ugb3RoZXJ3aXNlXG4qL1xuZnVuY3Rpb24gaXNSZWdFeHAob2JqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSBcIltvYmplY3QgUmVnRXhwXVwiO1xufVxuXG4vLyByZXR1cm4gdGhlIGFjdHVhbCBwcm90b3R5cGUgb2YgSlNaaXBcbnZhciBvdXQgPSB7XG4gICAgLyoqXG4gICAgICogQHNlZSBsb2FkQXN5bmNcbiAgICAgKi9cbiAgICBsb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBtZXRob2QgaGFzIGJlZW4gcmVtb3ZlZCBpbiBKU1ppcCAzLjAsIHBsZWFzZSBjaGVjayB0aGUgdXBncmFkZSBndWlkZS5cIik7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQ2FsbCBhIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBlYWNoIGVudHJ5IGF0IHRoaXMgZm9sZGVyIGxldmVsLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIHRoZSBjYWxsYmFjayBmdW5jdGlvbjpcbiAgICAgKiBmdW5jdGlvbiAocmVsYXRpdmVQYXRoLCBmaWxlKSB7Li4ufVxuICAgICAqIEl0IHRha2VzIDIgYXJndW1lbnRzIDogdGhlIHJlbGF0aXZlIHBhdGggYW5kIHRoZSBmaWxlLlxuICAgICAqL1xuICAgIGZvckVhY2g6IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgIHZhciBmaWxlbmFtZSwgcmVsYXRpdmVQYXRoLCBmaWxlO1xuICAgICAgICBmb3IgKGZpbGVuYW1lIGluIHRoaXMuZmlsZXMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5maWxlcy5oYXNPd25Qcm9wZXJ0eShmaWxlbmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbGUgPSB0aGlzLmZpbGVzW2ZpbGVuYW1lXTtcbiAgICAgICAgICAgIHJlbGF0aXZlUGF0aCA9IGZpbGVuYW1lLnNsaWNlKHRoaXMucm9vdC5sZW5ndGgsIGZpbGVuYW1lLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAocmVsYXRpdmVQYXRoICYmIGZpbGVuYW1lLnNsaWNlKDAsIHRoaXMucm9vdC5sZW5ndGgpID09PSB0aGlzLnJvb3QpIHsgLy8gdGhlIGZpbGUgaXMgaW4gdGhlIGN1cnJlbnQgcm9vdFxuICAgICAgICAgICAgICAgIGNiKHJlbGF0aXZlUGF0aCwgZmlsZSk7IC8vIFRPRE8gcmV2ZXJzZSB0aGUgcGFyYW1ldGVycyA/IG5lZWQgdG8gYmUgY2xlYW4gQU5EIGNvbnNpc3RlbnQgd2l0aCB0aGUgZmlsdGVyIHNlYXJjaCBmbi4uLlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciBuZXN0ZWQgZmlsZXMvZm9sZGVycyB3aXRoIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2VhcmNoIHRoZSBwcmVkaWNhdGUgdG8gdXNlIDpcbiAgICAgKiBmdW5jdGlvbiAocmVsYXRpdmVQYXRoLCBmaWxlKSB7Li4ufVxuICAgICAqIEl0IHRha2VzIDIgYXJndW1lbnRzIDogdGhlIHJlbGF0aXZlIHBhdGggYW5kIHRoZSBmaWxlLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBtYXRjaGluZyBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmaWx0ZXI6IGZ1bmN0aW9uKHNlYXJjaCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAocmVsYXRpdmVQYXRoLCBlbnRyeSkge1xuICAgICAgICAgICAgaWYgKHNlYXJjaChyZWxhdGl2ZVBhdGgsIGVudHJ5KSkgeyAvLyB0aGUgZmlsZSBtYXRjaGVzIHRoZSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgZmlsZSB0byB0aGUgemlwIGZpbGUsIG9yIHNlYXJjaCBhIGZpbGUuXG4gICAgICogQHBhcmFtICAge3N0cmluZ3xSZWdFeHB9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gYWRkIChpZiBkYXRhIGlzIGRlZmluZWQpLFxuICAgICAqIHRoZSBuYW1lIG9mIHRoZSBmaWxlIHRvIGZpbmQgKGlmIG5vIGRhdGEpIG9yIGEgcmVnZXggdG8gbWF0Y2ggZmlsZXMuXG4gICAgICogQHBhcmFtICAge1N0cmluZ3xBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gZGF0YSAgVGhlIGZpbGUgZGF0YSwgZWl0aGVyIHJhdyBvciBiYXNlNjQgZW5jb2RlZFxuICAgICAqIEBwYXJhbSAgIHtPYmplY3R9IG8gICAgIEZpbGUgb3B0aW9uc1xuICAgICAqIEByZXR1cm4gIHtKU1ppcHxPYmplY3R8QXJyYXl9IHRoaXMgSlNaaXAgb2JqZWN0ICh3aGVuIGFkZGluZyBhIGZpbGUpLFxuICAgICAqIGEgZmlsZSAod2hlbiBzZWFyY2hpbmcgYnkgc3RyaW5nKSBvciBhbiBhcnJheSBvZiBmaWxlcyAod2hlbiBzZWFyY2hpbmcgYnkgcmVnZXgpLlxuICAgICAqL1xuICAgIGZpbGU6IGZ1bmN0aW9uKG5hbWUsIGRhdGEsIG8pIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChpc1JlZ0V4cChuYW1lKSkge1xuICAgICAgICAgICAgICAgIHZhciByZWdleHAgPSBuYW1lO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbihyZWxhdGl2ZVBhdGgsIGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFmaWxlLmRpciAmJiByZWdleHAudGVzdChyZWxhdGl2ZVBhdGgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIHRleHRcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5maWxlc1t0aGlzLnJvb3QgKyBuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAob2JqICYmICFvYmouZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBtb3JlIHRoYW4gb25lIGFyZ3VtZW50IDogd2UgaGF2ZSBkYXRhICFcbiAgICAgICAgICAgIG5hbWUgPSB0aGlzLnJvb3QgKyBuYW1lO1xuICAgICAgICAgICAgZmlsZUFkZC5jYWxsKHRoaXMsIG5hbWUsIGRhdGEsIG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBkaXJlY3RvcnkgdG8gdGhlIHppcCBmaWxlLCBvciBzZWFyY2guXG4gICAgICogQHBhcmFtICAge1N0cmluZ3xSZWdFeHB9IGFyZyBUaGUgbmFtZSBvZiB0aGUgZGlyZWN0b3J5IHRvIGFkZCwgb3IgYSByZWdleCB0byBzZWFyY2ggZm9sZGVycy5cbiAgICAgKiBAcmV0dXJuICB7SlNaaXB9IGFuIG9iamVjdCB3aXRoIHRoZSBuZXcgZGlyZWN0b3J5IGFzIHRoZSByb290LCBvciBhbiBhcnJheSBjb250YWluaW5nIG1hdGNoaW5nIGZvbGRlcnMuXG4gICAgICovXG4gICAgZm9sZGVyOiBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgaWYgKCFhcmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUmVnRXhwKGFyZykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbihyZWxhdGl2ZVBhdGgsIGZpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZS5kaXIgJiYgYXJnLnRlc3QocmVsYXRpdmVQYXRoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZWxzZSwgbmFtZSBpcyBhIG5ldyBmb2xkZXJcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnJvb3QgKyBhcmc7XG4gICAgICAgIHZhciBuZXdGb2xkZXIgPSBmb2xkZXJBZGQuY2FsbCh0aGlzLCBuYW1lKTtcblxuICAgICAgICAvLyBBbGxvdyBjaGFpbmluZyBieSByZXR1cm5pbmcgYSBuZXcgb2JqZWN0IHdpdGggdGhpcyBmb2xkZXIgYXMgdGhlIHJvb3RcbiAgICAgICAgdmFyIHJldCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmV0LnJvb3QgPSBuZXdGb2xkZXIubmFtZTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgZmlsZSwgb3IgYSBkaXJlY3RvcnkgYW5kIGFsbCBzdWItZmlsZXMsIGZyb20gdGhlIHppcFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBmaWxlIHRvIGRlbGV0ZVxuICAgICAqIEByZXR1cm4ge0pTWmlwfSB0aGlzIEpTWmlwIG9iamVjdFxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBuYW1lID0gdGhpcy5yb290ICsgbmFtZTtcbiAgICAgICAgdmFyIGZpbGUgPSB0aGlzLmZpbGVzW25hbWVdO1xuICAgICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgICAgIC8vIExvb2sgZm9yIGFueSBmb2xkZXJzXG4gICAgICAgICAgICBpZiAobmFtZS5zbGljZSgtMSkgIT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgbmFtZSArPSBcIi9cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbGUgPSB0aGlzLmZpbGVzW25hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpbGUgJiYgIWZpbGUuZGlyKSB7XG4gICAgICAgICAgICAvLyBmaWxlXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5maWxlc1tuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG1heWJlIGEgZm9sZGVyLCBkZWxldGUgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgIHZhciBraWRzID0gdGhpcy5maWx0ZXIoZnVuY3Rpb24ocmVsYXRpdmVQYXRoLCBmaWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGUubmFtZS5zbGljZSgwLCBuYW1lLmxlbmd0aCkgPT09IG5hbWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2lkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZpbGVzW2tpZHNbaV0ubmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIGNvbXBsZXRlIHppcCBmaWxlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gZ2VuZXJhdGUgdGhlIHppcCBmaWxlIDpcbiAgICAgKiAtIGNvbXByZXNzaW9uLCBcIlNUT1JFXCIgYnkgZGVmYXVsdC5cbiAgICAgKiAtIHR5cGUsIFwiYmFzZTY0XCIgYnkgZGVmYXVsdC4gVmFsdWVzIGFyZSA6IHN0cmluZywgYmFzZTY0LCB1aW50OGFycmF5LCBhcnJheWJ1ZmZlciwgYmxvYi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd8VWludDhBcnJheXxBcnJheUJ1ZmZlcnxCdWZmZXJ8QmxvYn0gdGhlIHppcCBmaWxlXG4gICAgICovXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBtZXRob2QgaGFzIGJlZW4gcmVtb3ZlZCBpbiBKU1ppcCAzLjAsIHBsZWFzZSBjaGVjayB0aGUgdXBncmFkZSBndWlkZS5cIik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSBjb21wbGV0ZSB6aXAgZmlsZSBhcyBhbiBpbnRlcm5hbCBzdHJlYW0uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gZ2VuZXJhdGUgdGhlIHppcCBmaWxlIDpcbiAgICAgKiAtIGNvbXByZXNzaW9uLCBcIlNUT1JFXCIgYnkgZGVmYXVsdC5cbiAgICAgKiAtIHR5cGUsIFwiYmFzZTY0XCIgYnkgZGVmYXVsdC4gVmFsdWVzIGFyZSA6IHN0cmluZywgYmFzZTY0LCB1aW50OGFycmF5LCBhcnJheWJ1ZmZlciwgYmxvYi5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW1IZWxwZXJ9IHRoZSBzdHJlYW1lZCB6aXAgZmlsZS5cbiAgICAgKi9cbiAgICBnZW5lcmF0ZUludGVybmFsU3RyZWFtOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgd29ya2VyLCBvcHRzID0ge307XG4gICAgICB0cnkge1xuICAgICAgICAgIG9wdHMgPSB1dGlscy5leHRlbmQob3B0aW9ucyB8fCB7fSwge1xuICAgICAgICAgICAgICBzdHJlYW1GaWxlczogZmFsc2UsXG4gICAgICAgICAgICAgIGNvbXByZXNzaW9uOiBcIlNUT1JFXCIsXG4gICAgICAgICAgICAgIGNvbXByZXNzaW9uT3B0aW9ucyA6IG51bGwsXG4gICAgICAgICAgICAgIHR5cGU6IFwiXCIsXG4gICAgICAgICAgICAgIHBsYXRmb3JtOiBcIkRPU1wiLFxuICAgICAgICAgICAgICBjb21tZW50OiBudWxsLFxuICAgICAgICAgICAgICBtaW1lVHlwZTogJ2FwcGxpY2F0aW9uL3ppcCcsXG4gICAgICAgICAgICAgIGVuY29kZUZpbGVOYW1lOiB1dGY4LnV0ZjhlbmNvZGVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG9wdHMudHlwZSA9IG9wdHMudHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIG9wdHMuY29tcHJlc3Npb24gPSBvcHRzLmNvbXByZXNzaW9uLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICAvLyBcImJpbmFyeXN0cmluZ1wiIGlzIHByZWZlcmVkIGJ1dCB0aGUgaW50ZXJuYWxzIHVzZSBcInN0cmluZ1wiLlxuICAgICAgICAgIGlmKG9wdHMudHlwZSA9PT0gXCJiaW5hcnlzdHJpbmdcIikge1xuICAgICAgICAgICAgb3B0cy50eXBlID0gXCJzdHJpbmdcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIW9wdHMudHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gb3V0cHV0IHR5cGUgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1dGlscy5jaGVja1N1cHBvcnQob3B0cy50eXBlKTtcblxuICAgICAgICAgIC8vIGFjY2VwdCBub2RlanMgYHByb2Nlc3MucGxhdGZvcm1gXG4gICAgICAgICAgaWYoXG4gICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPT09ICdkYXJ3aW4nIHx8XG4gICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPT09ICdmcmVlYnNkJyB8fFxuICAgICAgICAgICAgICBvcHRzLnBsYXRmb3JtID09PSAnbGludXgnIHx8XG4gICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPT09ICdzdW5vcydcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9IFwiVU5JWFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0cy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgICAgICAgICAgICBvcHRzLnBsYXRmb3JtID0gXCJET1NcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY29tbWVudCA9IG9wdHMuY29tbWVudCB8fCB0aGlzLmNvbW1lbnQgfHwgXCJcIjtcbiAgICAgICAgICB3b3JrZXIgPSBnZW5lcmF0ZS5nZW5lcmF0ZVdvcmtlcih0aGlzLCBvcHRzLCBjb21tZW50KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgd29ya2VyID0gbmV3IEdlbmVyaWNXb3JrZXIoXCJlcnJvclwiKTtcbiAgICAgICAgd29ya2VyLmVycm9yKGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBTdHJlYW1IZWxwZXIod29ya2VyLCBvcHRzLnR5cGUgfHwgXCJzdHJpbmdcIiwgb3B0cy5taW1lVHlwZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgY29tcGxldGUgemlwIGZpbGUgYXN5bmNocm9ub3VzbHkuXG4gICAgICogQHNlZSBnZW5lcmF0ZUludGVybmFsU3RyZWFtXG4gICAgICovXG4gICAgZ2VuZXJhdGVBc3luYzogZnVuY3Rpb24ob3B0aW9ucywgb25VcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbShvcHRpb25zKS5hY2N1bXVsYXRlKG9uVXBkYXRlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSBjb21wbGV0ZSB6aXAgZmlsZSBhc3luY2hyb25vdXNseS5cbiAgICAgKiBAc2VlIGdlbmVyYXRlSW50ZXJuYWxTdHJlYW1cbiAgICAgKi9cbiAgICBnZW5lcmF0ZU5vZGVTdHJlYW06IGZ1bmN0aW9uKG9wdGlvbnMsIG9uVXBkYXRlKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBpZiAoIW9wdGlvbnMudHlwZSkge1xuICAgICAgICAgICAgb3B0aW9ucy50eXBlID0gXCJub2RlYnVmZmVyXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbShvcHRpb25zKS50b05vZGVqc1N0cmVhbShvblVwZGF0ZSk7XG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gb3V0O1xuIiwiLy8gVGhlIGNvbnRyb2xsZXIgb2JqZWN0IGl0c2VsZlxuaW1wb3J0IFwiLi9jb250cm9sbGVyLmpzXCI7XG5cbi8vIFRoZSBwcmVsb2FkZXJzXG5pbXBvcnQgXCIuL3ByZWxvYWQvcHJlbG9hZC5qc1wiO1xuaW1wb3J0IFwiLi9wcmVsb2FkL3ByZWxvYWRaaXAuanNcIjsgICAgICAgLy8gIFVzZXMgSlNaaXBcblxuLy8gVGhpcyBkZWZpbmVzIHRoZSBJbnN0cnVjdGlvbiBjbGFzc1xuLy8gSXQgc2hvdWxkIGFsd2F5cyBiZSBpbXBvcnRlZFxuaW1wb3J0IFwiLi9pbnN0cnVjdGlvbnMvaW5zdHJ1Y3Rpb24uanNcIjtcbi8vIExpc3Qgb2Ygc3BlY2lmaWMgaW5zdHJ1Y3Rpb25zIHRvIGltcG9ydFxuaW1wb3J0IFwiLi9pbnN0cnVjdGlvbnMvYXVkaW8uanNcIjtcbmltcG9ydCBcIi4vaW5zdHJ1Y3Rpb25zL2NhbnZhcy5qc1wiO1xuaW1wb3J0IFwiLi9pbnN0cnVjdGlvbnMvY2xlYXIuanNcIjtcbmltcG9ydCBcIi4vaW5zdHJ1Y3Rpb25zL2NvbXBsZXguanNcIjtcbmltcG9ydCBcIi4vaW5zdHJ1Y3Rpb25zL2VuZC5qc1wiO1xuaW1wb3J0IFwiLi9pbnN0cnVjdGlvbnMvZnVuY3Rpb24uanNcIjtcbmltcG9ydCBcIi4vaW5zdHJ1Y3Rpb25zL2lmLmpzXCI7XG5pbXBvcnQgXCIuL2luc3RydWN0aW9ucy9pbWFnZS5qc1wiO1xuaW1wb3J0IFwiLi9pbnN0cnVjdGlvbnMva2V5LmpzXCI7XG5pbXBvcnQgXCIuL2luc3RydWN0aW9ucy9yYWRpby5qc1wiO1xuaW1wb3J0IFwiLi9pbnN0cnVjdGlvbnMvc2F2ZS5qc1wiO1xuLy9pbXBvcnQgXCIuL2luc3RydWN0aW9ucy9zY3JlZW4uanNcIjsgICAgLy8gVEJJXG5pbXBvcnQgXCIuL2luc3RydWN0aW9ucy9zZWxlY3Rvci5qc1wiO1xuaW1wb3J0IFwiLi9pbnN0cnVjdGlvbnMvdGV4dC5qc1wiO1xuaW1wb3J0IFwiLi9pbnN0cnVjdGlvbnMvdGltZXIuanNcIjtcbi8vaW1wb3J0IFwiLi9pbnN0cnVjdGlvbnMvdG9vbHRpcC5qc1wiOyAgIC8vIFRCSVxuaW1wb3J0IFwiLi9pbnN0cnVjdGlvbnMvdm9pY2UuanNcIjsgICAgICAgLy8gVXNlcyBKU1ppcFxuaW1wb3J0IFwiLi9pbnN0cnVjdGlvbnMveW91dHViZS5qc1wiOyAgICAgLy8gVXNlcyBjb2RlIGZyb20gR29vZ2xlXG5cblxuLy8gVGFibGUgZmVlZGluZ1xuaW1wb3J0IFwiLi9mZWVkVGFibGUuanNcIjsgICAgICAvLyBVc2VzIGpRdWVyeS1DU1YgZXh0ZW5zaW9uXG5cblxuLy8gSUJFWCBjb250cm9sbGVyXG5pbXBvcnQgXCIuL2RlZmluZV9pYmV4X2NvbnRyb2xsZXJcIjtcblxuLy8gRXhwb3J0IFBlbm5Db250cm9sbGVyIGFzIGEgZ2xvYmFsIG9iamVjdFxud2luZG93LlBlbm5Db250cm9sbGVyID0gUGVubkNvbnRyb2xsZXI7Il0sInNvdXJjZVJvb3QiOiIifQ==

/* This software is licensed under a BSD license; see the LICENSE file for details. */

//
// TODO: Replace this controller with something that's not such a horrible mess!
// 

(function () {

var __Question_callback__ = null;
var __Questions_answers__ = null;

define_ibex_controller({
name: "Question",

jqueryWidget: {
    _init: function () {
        this.cssPrefix = this.options._cssPrefix;
        this.utils = this.options._utils;
        this.finishedCallback = this.options._finishedCallback;

        var questionField = "Question (NULL if none).";
        var answerField = "Answer";
        var correctField = "Whether or not answer was correct (NULL if N/A)";
        var timeField = "Time taken to answer.";

        this.question = dget(this.options, "q");
        this.answers = this.options.as;

        this.hasCorrect = dget(this.options, "hasCorrect", false);
        // hasCorrect is either false, indicating that there is no correct answer,
        // true, indicating that the first answer is correct, or an integer giving
        // the index of the correct answer, OR a string giving the correct answer.
        // Now we change it to either false or an index.
        if (this.hasCorrect === true)
            this.hasCorrect = 0;
        if (typeof(this.hasCorrect) == "string") {
            var foundIt = false;
            for (var i = 0; i < this.answers.length; ++i) {
                if (this.answers[i].toLowerCase() == this.hasCorrect.toLowerCase()) {
                    this.hasCorrect = i;
                    foundIt = true;
                    break;
                }
            }
            assert(foundIt, "Value of 'hasCorrect' option not recognized in Question");
        }
        this.showNumbers = dget(this.options, "showNumbers", true);
        this.presentAsScale = dget(this.options, "presentAsScale", false);
        this.randomOrder = dget(this.options, "randomOrder", ! (this.hasCorrect === false || this.presentAsScale));
        this.timeout = dget(this.options, "timeout", null);
        this.instructions = dget(this.options, "instructions");
        this.leftComment = dget(this.options, "leftComment");
        this.rightComment = dget(this.options, "rightComment");
        this.autoFirstChar = dget(this.options, "autoFirstChar", false);
        this.presentHorizontally = dget(this.options, "presentHorizontally", false);

        if (! (this.hasCorrect === false))
            assert(typeof(this.hasCorrect) == "number" && this.hasCorrect < this.answers.length,
                   "Bad index for correct answer in Question");

        if (this.randomOrder) {
            assert(typeof(this.answers[0]) != "object",
                  "Cannot set 'randomOrder' option to a list of keys when keys are included with the 'as' option.");
            assert(typeof(this.answers[0]) != "object" || this.answers.length == this.randomOrder.length,
                   "Length of 'randomOrder' doesn't match length of 'as'.");

            this.orderedAnswers = new Array(this.answers.length);
            for (var i = 0; i < this.answers.length; ++i)
                this.orderedAnswers[i] = this.answers[i];
            fisherYates(this.orderedAnswers);
        }
        else {
            this.orderedAnswers = this.answers;
        }

        this.setFlag = function(correct) {
            if (! correct) {
                this.utils.setValueForNextElement("failed", true);
            }
        }

        if (this.question) {
            this.qp = $(document.createElement("p"))
            .addClass(this.cssPrefix + "question-text")
            .css('text-align', conf_centerItems ? 'center' : 'left')
            .append(this.question);
        }
        this.xl = $(document.createElement(((!this.presentAsScale && !this.presentHorizontally) && this.showNumbers) ? "ol" : "ul"))
            .css('margin-left', "2em").css('padding-left', 0);
        __Question_answers__ = new Array(this.answers.length);

        if ((this.presentAsScale || this.presentHorizontally) && this.leftComment) {
            var lcd = $(document.createElement("li"))
                      .addClass(this.cssPrefix + "scale-comment-box")
                      .append(this.leftComment);
            this.xl.append(lcd);
        }
        for (var i = 0; i < this.orderedAnswers.length; ++i) {
            var li;
            li = $(document.createElement("li"));
            if (this.presentAsScale || this.presentHorizontally) {
                li.addClass(this.cssPrefix + "scale-box");
                var t = this;
                 // IE doesn't support :hover for anything other than links, so we
                 // have to use JS.
                 (function (li) {
                     li.mouseover(function () {
                         li.css('border-color', "black")
                           .css('cursor', 'pointer');
                     });
                     li.mouseout(function () {
                         li.css('border-color', "#9ea4b1")
                           .css('cursor', "default");
                     });
                 })(li);
            }
            else {
                li.addClass(this.cssPrefix + "normal-answer");
            }
            (function(i) {
                li.click(function () { __Question_callback__(i); });
            })(i);
            var ans = typeof(this.orderedAnswers[i]) == "string" ? this.orderedAnswers[i] : this.orderedAnswers[i][1];
            var t = this; // 'this' doesn't behave as a lexically scoped variable so can't be
                          // captured in the closure defined below.
            var a = $(document.createElement("span")).addClass(this.cssPrefix + "fake-link");
            __Question_answers__[i] = ans;
            __Question_callback__ = function (i) {
                var answerTime = new Date().getTime();
                var ans = __Question_answers__[i];
                var correct = "NULL";
                if (! (t.hasCorrect === false)) {
                    var correct_ans = typeof(t.answers[t.hasCorrect]) == "string" ? t.answers[t.hasCorrect] : t.answers[t.hasCorrect][1];
                    correct = (ans == correct_ans ? 1 : 0);
                    t.setFlag(correct);
                }
                t.finishedCallback([[[questionField, t.question ? csv_url_encode(t.question) : "NULL"],
                                     [answerField, csv_url_encode(ans)],
                                     [correctField, correct],
                                     [timeField, answerTime - t.creationTime]]]);
            };
            this.xl.append(li.append(a.append(ans)));
        }
        if ((this.presentAsScale || this.presentHorizontally) && this.rightComment) {
            this.xl.append($(document.createElement("li"))
                           .addClass(this.cssPrefix + 'scale-comment-box')
                           .append(this.rightComment));
        }

        if (! (this.qp === undefined))
            this.element.append(this.qp);

        // Again, using tables to center because IE sucks.
        var table = $("<table" + (conf_centerItems ? " align='center'" : "") + ">");
        var tr = $(document.createElement("tr"));
        var td = $("<td" + (conf_centerItems ? " align='center'" : "") + ">")
        if (conf_centerItems)
            td.attr('align', 'center');
        this.element.append(table.append(tr.append(td.append(this.xl))));

        if (this.instructions) {
            this.element.append($(document.createElement("p"))
                                .addClass(this.cssPrefix + "instructions-text")
                                .css('text-align', conf_centerItems ? 'center' : 'left')
                                .text(this.instructions));
        }

        if (this.timeout) {
            var t = this;
            this.utils.setTimeout(function () {
                var answerTime = new Date().getTime();
                t.setFlag(false);
                t.finishedCallback([[[questionField, t.question ? csv_url_encode(t.question) : "NULL"],
                                     [answerField, "NULL"], [correctField, "NULL"],
                                     [timeField, answerTime - t.creationTime]]]);
            }, this.timeout);
        }

        // TODO: A bit of code duplication in this function.
        var t = this;
        this.safeBind($(document), 'keydown', function(e) {
            var code = e.keyCode;
            var time = new Date().getTime();

            var answerTime = new Date().getTime();
            if ((! t.presentAsScale && !t.presentHorizontally) && t.showNumbers &&
                ((code >= 48 && code <= 57) || (code >= 96 && code <= 105))) {
                // Convert numeric keypad codes to ordinary keypad codes.
                var n = code >= 96 ? code - 96 : code - 48;
                if (n > 0 && n <= t.orderedAnswers.length) {
                    var ans = typeof(t.orderedAnswers[n-1]) == "string" ? t.orderedAnswers[n-1] : t.orderedAnswers[n-1][1];
                    var correct = "NULL";
                    if (! (t.hasCorrect === false)) {
                        var correct_ans = typeof(t.answers[t.hasCorrect]) == "string" ? t.answers[t.hasCorrect] : t.answers[t.hasCorrect][1];
                        correct = (correct_ans == ans ? 1 : 0);
                        t.setFlag(correct);
                    }
                    t.finishedCallback([[[questionField, t.question ? csv_url_encode(t.question) : "NULL"],
                                         [answerField, csv_url_encode(ans)],
                                         [correctField, correct],
                                         [timeField, answerTime - t.creationTime]]]);

                    return false;
                }
                else {
                    return true;
                }
            }
            // Letters (and numbers in the case of scales).
            else if ((code >= 65 && code <= 90) || (t.presentAsScale && ((code >= 48 && code <= 57) || (code >= 96 && code <= 105)))) {
                // Convert numeric keypad codes to ordinary keypad codes.
                code = (code >= 96 && code <= 105) ? code - 48 : code;
                var ans = null;

                if (typeof(t.randomOrder) != "object") {
                    for (var i = 0; i < t.answers.length; ++i) {
                        if (t.autoFirstChar && typeof(t.answers[i]) == "string" && code == t.answers[i].toUpperCase().charCodeAt(0)) {
                            ans = t.answers[i];
                            break;
                        }
                        else if ($.isArray(t.answers[i]) && code == t.answers[i][0].toUpperCase().charCodeAt(0)) {
                            ans = t.answers[i][1];
                            break;
                        }
                    }
                }
                else {
                    for (var i = 0; i < t.randomOrder.length; ++i) {
                        if (code == t.randomOrder[i].toUpperCase().charCodeAt(0)) {
                            ans = t.orderedAnswers[i];
                            break;
                        }
                    }
                }

                if (ans) {
                    var correct = "NULL";
                    if (! (t.hasCorrect === false)) {
                        var correct_ans = typeof(t.answers[t.hasCorrect]) == "string" ? t.answers[t.hasCorrect] : t.answers[t.hasCorrect][1];
                        correct = (correct_ans == ans ? 1 : 0);
                        t.setFlag(correct);
                    }
                    t.finishedCallback([[[questionField, t.question ? csv_url_encode(t.question) : "NULL"],
                                         [answerField, csv_url_encode(ans)],
                                         [correctField, correct],
                                         [timeField, answerTime - t.creationTime]]]);
                    
                    return false;
                }
            }

            return true;
        });

        // Store the time when this was first displayed.
        this.creationTime = new Date().getTime();
    }
},

properties: {
    obligatory: ["as"],
    htmlDescription: function(opts) {
        return $(document.createElement("div")).text(opts.q || "");
    }
}
});

})();




(function () {

function norm256(x) {
    if (x < 0)
        return 0;
    else if (x > 255)
        return 255;
    return x;
}

function rgbToS(col) {
    function pad0(s) {
        if (s.length == 1)
            s = '0' + s;
        return s;
    }

    var cols = '#';
    cols += pad0(col[0].toString(16));
    cols += pad0(col[1].toString(16));
    cols += pad0(col[2].toString(16));

    return cols;
}

function parseColor(col) {
    var m;
    if ($.isArray(col)) {
        return col;
    }
    else if (typeof(col) == 'string') {
        if (col.length > 0 && col[0] == '#') {
            var r,g,b;
            if (col.length == 7) {
                r = parseInt(col.substr(1,2), 16);
                g = parseInt(col.substr(3,2), 16);
                b = parseInt(col.substr(5,2), 16);
                if (isNaN(r) || isNaN(g) || isNaN(b))
                    assert(false, "Could not parse color '" + col + "'");
                return [r,g,b];
            }
            else if (col.length == 4) {
                r = parseInt(col.substr(1,1), 16);
                g = parseInt(col.substr(1,1), 16);
                b = parseInt(col.substr(1,1), 16)
                if (isNaN(r) || isNaN(g) || isNaN(b))
                    assert(false, "Could not parse color '" + col + "'");
                return [r,g,b];
            }
            else {
                assert(false, "Could not parse color '" + col + "'");
            }
        }
        else if (m = col.match(/\s*rgb\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\)\s*/)) {
            var r = parseFloat(m[1]);
            var g = parseFloat(m[2]);
            var b = parseFloat(m[3]);
            if (isNaN(r) || isNaN(g) || isNaN(b))
                assert(false, "Could not parse color '" + col + "'");
            r = parseInt(Math.round(r * 256.0));
            g = parseInt(Math.round(g * 256.0));
            b = parseInt(Math.round(b * 256.0));
            r = norm256(r);
            g = norm256(g);
            b = norm256(b);
            return [r,g,b];
        }
        else {
            // Support standard HTML color names.
            var map = {
                red: [255,0,0],
                green: [0,255,0],
                blue: [0,0,255],
                aqua: [0,255,255],
                black: [0,0,0],
                fuchsia: [255,0,255],
                gray: [128,128,128],
                lime: [0,255,0],
                maroon: [128,0,0],
                navy: [0,0,128],
                olive: [128,128,0],
                orange: [256,165,0],
                purple: [128,0,128],
                silver: [192,192,192],
                teal: [0, 128,128],
                white: [255,255,255],
                yellow: [255,255,0]
            };
            var u = col.toLowerCase();
            if (map[u])
                return map[u];
            assert(false, "Could not parse color '" + col + "'");
        }
    }
    else {
        assert(false, "Could not parse color '" + col + "'");
    }
}

define_ibex_controller({
name: "Scale",

jqueryWidget: {
    _init: function () {
        var self = this;

        this.utils = this.options._utils;

        this.cssPrefix = this.options._cssPrefix;
        this.finishedCallback = this.options._finishedCallback;

        this.html = this.options.html;
        this.decimalPlaces = (this.options.decimalPlaces == null ? 2 : this.options.decimalPlaces);
        this.startColor = this.options.startColor ? parseColor(this.options.startColor) : parseColor("#5947FD");
        this.endColor = this.options.endColor ? parseColor(this.options.endColor) : parseColor("#59BAFD");

        this.startValue = this.options.startValue;
        assert(typeof(this.startValue) == "number", "'startValue' option must be a number");
        this.endValue = this.options.endValue;
        assert(typeof(this.endValue) == "number", "'endValue' option must be a number");
        this.buttonMessage = this.options.buttonMessage || "Continue";

        this.$html = htmlCodeToDOM(this.html);
        this.element.append($("<div>").addClass(this.cssPrefix + 'html').append(this.$html));

        this.currentMousePos = { x: 0, y: 0};

        var $bar = $("<div>").addClass(this.cssPrefix + 'bar');
        var $handle = $("<div>").addClass(this.cssPrefix + 'handle');
        var $handleLabel = $("<div>").addClass(this.cssPrefix + 'handle-label');
        var $leftLabel = $("<div>").addClass(this.cssPrefix + 'scale-label');
        var $rightLabel = $("<div>").addClass(this.cssPrefix + 'scale-label');
        this.$bar = $bar;
        this.$handle = $handle;
        this.$handleLabel = $handleLabel;
        this.$leftLabel = $leftLabel;
        this.$rightLabel = $rightLabel;

        this.scaleWidth = this.options.scaleWidth || 300;
        this.scaleHeight = this.options.scaleHeight || 20;
        this.handleWidth = this.options.handleWidth || 30;
        this.handleHeight = this.options.handleHeight || 30;
        this.scaleWidth = parseInt(this.scaleWidth);
        this.scaleHeight = parseInt(this.scaleHeight);
        this.handleWidth = parseInt(this.handleWidth);
        this.handleHeight = parseInt(this.handleHeight);
        $bar.css('width', this.scaleWidth + 'px');
        $bar.css('height', this.scaleHeight + 'px');
        $handle.css({ width: this.handleWidth + 'px',
                      height: this.handleHeight + 'px' });

        $bar.append($handle);
        if (this.options.scaleLabels) {
            $bar.append($handleLabel);
            $bar.append($leftLabel);
            $bar.append($rightLabel);

            this.$leftLabel.text(this.startValue.toFixed(this.decimalPlaces));
            this.$rightLabel.text(this.endValue.toFixed(this.decimalPlaces));
        }
        this.element.append($bar);

        this.handleLeft = parseInt(this.scaleWidth / 2);
        this.fraction = 0.5;
        t();
        function t() {
            self.setHandlePos();
            self.utils.setTimeout(t, 100);
        }
        $handle.css('background', rgbToS(this.getHandleColor()));

        this.setLinearGradient($bar, this.startColor, this.endColor);

        this.setupDragHandler();
        self.safeBind($bar, 'click', function (e) {
            e.preventDefault();
            e.stopPropagation();
            self.handleBarClick(e);
        });

        this.$button = $("<div>").addClass(this.cssPrefix + 'button');
        this.$button.text(this.buttonMessage);
        this.element.append(this.$button);
        self.safeBind(this.$button, 'click', function (e) {
            e.preventDefault();
            e.stopPropagation();
            self.handleButtonClick(e);
        });

        this.safeBind($(window), 'resize', function (e) {
            self.setHandlePos();
        });
    },

    handleButtonClick: function () {
        var val = (this.fraction * (this.endValue - this.startValue)) + this.startValue;
        //console.log("VAL", val);
        this.finishedCallback([[
            ["html", csv_url_encode(this.$html.innerHTML)],
            ["startValue", this.startValue.toFixed(this.decimalPlaces)],
            ["endValue", this.endValue.toFixed(this.decimalPlaces)],
            ["value", val.toFixed(this.decimalPlaces)]
        ]]);
    },

    handleBarClick: function (e) {
        var self = this;

        // Calculate handle screen position.
        var o = self.$handle.offset();
        var x = o.left;
        var y = o.top;
        x += $(window).scrollLeft();
        y += $(window).scrollTop();

        var clickedBar = false;
        if (e.pageX > x - 4 && e.pageX < x + self.handleWidth + 4) {
            if (e.pageY > y - 4 && e.pageY < y + self.handleHeight + 4)
                clickedBar = true;
        }

        if (! clickedBar) {
            // Move the handle to the position on the bar where user clicked.
            var barLeft = self.$bar.offset().left + $(window).scrollLeft();
            self.handleLeft = e.pageX - barLeft;
            if (self.handleLeft < 0)
                self.handleLeft = 0;
            else if (self.handleLeft > self.scaleWidth)
                self.handleLeft = self.scaleWidth;
            self.setFraction(self.handleLeft);
            self.setHandlePos();
        }
    },

    getBarO: function () {
        var barO = this.$bar.offset();
        var barLeft = barO.left;
        var barTop = barO.top;
        //barLeft += $(window).scrollLeft();
        //barTop += $(window).scrollTop();
        return { top: barTop, left: barLeft };
    },

    setFraction: function (x) {
        this.fraction = (x / this.scaleWidth);
    },

    setHandlePos: function () {
        var x = this.fraction * this.scaleWidth;

        var barO = this.getBarO();
        var barLeft = barO.left;
        var barTop = barO.top;
        //barLeft += $(window).scrollLeft();
        //barTop += $(window).scrollTop();
        var hleft = (barLeft + parseInt(x) - parseInt(Math.round(this.handleWidth/2)));
        var htop = (barTop - parseInt(Math.round((this.handleHeight - this.scaleHeight)/2.0)));
        this.$handle.css('left', hleft + 'px');
        this.$handle.css('top', htop + 'px');
        this.$handleLabel.text(this.fraction.toFixed(this.decimalPlaces));
        this.$handleLabel.css('left', parseInt(hleft + this.handleWidth/2 - this.$handleLabel.width()/2) + 'px');
        this.$handleLabel.css('top', parseInt(htop - this.handleHeight) + 'px');
        // Set color for handle.
        var col = this.getHandleColor();
        this.$handle.css('background', rgbToS(col));

        if (this.options.scaleLabels) {
            this.$leftLabel.css('left', parseInt(barLeft - this.$leftLabel.width()/2) + 'px');
            this.$leftLabel.css('top', (barTop + this.handleHeight) + 'px');
            this.$rightLabel.css('left', parseInt(barLeft + this.scaleWidth - this.$rightLabel.width()/2) + 'px');
            this.$rightLabel.css('top', (barTop + this.handleHeight) + 'px');
        }
    },

    getHandleColor: function () {
        var self = this;
        var frac = self.handleLeft / self.scaleWidth;
        var rd = parseInt(Math.round(frac * (self.endColor[0] - self.startColor[0])));
        var gd = parseInt(Math.round(frac * (self.endColor[1] - self.startColor[1])));
        var bd = parseInt(Math.round(frac * (self.endColor[2] - self.startColor[2])));
        var r = self.startColor[0] + rd;
        var g = self.startColor[1] + gd;
        var b = self.startColor[2] + bd;
        r = norm256(r);
        g = norm256(g);
        b = norm256(b);
        return [r,g,b];
    },

    setupDragHandler: function () {
        var self = this;

        var mouseIsDown = false;
        self.currentMousePos = { x: 0, y: 0 };
        var refMousePos = { x: 0, y: 0};
        var alreadyMoved = 0;
        self.safeBind($(document), 'mousemove', function (e) {
            self.currentMousePos.x = e.pageX;
            self.currentMousePos.y = e.pageY;

            if (mouseIsDown) {
                var offset = self.currentMousePos.x - refMousePos.x;
                self.handleLeft += offset - alreadyMoved;
                alreadyMoved = offset;
                if (self.handleLeft < 0)
                    self.handleLeft = 0;
                else if (self.handleLeft >= self.scaleWidth)
                    self.handleLeft = self.scaleWidth;
                self.setFraction(self.handleLeft);
                self.setHandlePos();
            }
        });

        self.safeBind(self.$handle, 'mousedown', function (e) {
            e.preventDefault();
            e.stopPropagation();

            if (! mouseIsDown) {
                mouseIsDown = true;
                refMousePos.x = self.currentMousePos.x;
                refMousePos.y = self.currentMousePos.y;
                alreadyMoved = 0;
            }
        });
        self.safeBind($(document), 'mouseup', function () {
            mouseIsDown = false;
        });
    },

    setLinearGradient: function ($elem, startColor, endColor) {
        var scol = rgbToS(startColor);
        var ecol = rgbToS(endColor);

        $elem.css('filter', "progid:DXImageTransform.Microsoft.Gradient(startColorstr='" + scol + "', endColorstr='" + ecol + "', GradientType=1)");
        $elem.css('background-image', '-ms-linear-gradient(left,' + scol + ' 0%, ' + ecol + ' 100%)');
        $elem.css('background-image', '-webkit-gradient(linear, left rop, right top, color-stop(0, ' + scol + '), color-stop(1,' + ecol + '))');
        $elem.css('background-image', '-webkit-linear-gradient(left, ' + scol + ' 0%,' + ecol + ' 100%)');
        $elem.css('background-image', '-o-linear-gradient(left, ' + scol + ',' + ecol + ')');
        $elem.css('background-image', '-moz-linear-gradient(left, ' + scol + ',' + ecol + ')');
        $elem.css('background-image', 'linear-gradient(to right' + scol + ',' + ecol + ')');
    }
},

properties: {
    obligatory: ["html", "startValue", "endValue"],
    htmlDescription: function(opts) {
        return $(document.createElement("div")).text(opts.s || "");
    }
}
});

})();


/* This software is licensed under a BSD license; see the LICENSE file for details. */

define_ibex_controller({
name: "Separator",

jqueryWidget: {
    _init: function () {
        this.cssPrefix = this.options._cssPrefix;
        this.utils = this.options._utils;
        this.finishedCallback = this.options._finishedCallback;

        this.ignoreFailure = dget(this.options, "ignoreFailure", false);
        this.style = this.ignoreFailure ? "normal" : (this.utils.getValueFromPreviousElement("failed") ? "error" : "normal");
        var x = this.utils.getValueFromPreviousElement("style");
        if (x) this.style = x;
        assert(this.style == "normal" || this.style == "error", "'style' property of Separator must either be 'normal' or 'error'");

        this.transfer = dget(this.options, "transfer", "keypress");
        assert(this.transfer == "keypress" || typeof(this.transfer) == "number",
               "Value of 'transfer' option of Separator must either be the string 'keypress' or a number");

        var normal_message = dget(this.options, "normalMessage", "Press any key to continue.");
        var x = this.utils.getValueFromPreviousElement("normalMessage");
        if (x) normal_message = x;

        var error_message = dget(this.options, "errorMessage", "Wrong. Press any key to continue.");
        var x = this.utils.getValueFromPreviousElement("errorMessage");
        if (x) error_message = x;

        var p = $(document.createElement("p"));
        this.element.append(p);
        if (this.style == "error") {
            this.element.addClass(this.cssPrefix + "next-item-failure-message");
            p.text(error_message);
        }
        else {
            this.element.addClass(this.cssPrefix + "next-item-message");
            p.text(normal_message);
        }

        if (this.transfer == "keypress") {
	    var t = this;
	    this.safeBind($(document), 'keydown', function () {
		t.finishedCallback(null);
		return false;
	    });
        }
        else {
            var t = this;
            this.utils.setTimeout(function () {
                t.finishedCallback(null);
            }, this.transfer);
        }
    }
},

properties: {
    countsForProgressBar: false,
    htmlDescription: function (opts) {
        return $(document.createElement("div")).text(opts.normalMessage)[0];
    }
}
});

/* This software is licensed under a BSD license; see the LICENSE file for details. */

define_ibex_controller({
name: "VBox",

jqueryWidget: {
    _init: function () {
        this._finishedCalledAlready = false;

        this.cssPrefix = this.options.options._cssPrefix;
        this.utils = this.options.options._utils;
        this.finishedCallback = this.options.options._finishedCallback;
        this.controllerDefaults = this.options.options._controllerDefaults;
        this.utilsClass = this.options.options._utilsClass;
        this.callbackWhenChildFinishes = this.options.options._vboxCallbackWhenChildFinishes;

        this.children = this.options.children;
        this.triggers = this.options.triggers;
        this.padding = dget(this.options, "padding", "2em");

        assert_is_arraylike(this.children, "The 'children' option of VBox must be an array");
        assert(this.children.length % 2 == 0, "The 'children' array for VBox must contain an even number of elements");

        assert_is_arraylike(this.triggers, "The 'triggers' option of VBox must be an array");
        assert(this.triggers.length > 0, "The 'triggers' array for VBox must be an array of length > 0");

        var t = this;
        $.each(this.triggers, function (_, tr) {
            assert(typeof(tr) == "number", "The 'triggers' array for VBox must be an array of integers");
            assert(tr >= 0 && tr < t.children.length / 2,
                   "Numbers in the 'triggers' array must be indices into the 'children' array starting from 0");
        });

        this.indicesAndResultsOfThingsThatHaveFinished = [];
//        this.childInstances = [];
        this.childUtils = [];

        this.childElements = new Array(this.children.length / 2);
        for (var i = 0; i < this.children.length; i += 2) {
            var controllerClass = this.children[i];
            var addImmediately = true;
            var removePrevious = false;
            if (controllerClass.charAt(0) == "*" || controllerClass.charAt(0) == "!") {
                addImmediately = false;
                if (controllerClass.charAt(0) == "!")
                    removePrevious = true;
                controllerClass = controllerClass.substr(1);
            }
            var childOptions = this.children[i + 1];
            childOptions = merge_dicts(this.controllerDefaults[controllerClass], childOptions);

            var u = new this.utilsClass(this.utils.getValuesFromPreviousElement());
            this.childUtils.push(u);
            (function(i) {
                u.setResults = function(results) {
                    t.indicesAndResultsOfThingsThatHaveFinished.push([i, results]);
                };
            })(i);

            function makeDiv() {
                var d = $(document.createElement("p")).css('clear', 'both');

                // Call a manipulator if one was supplied.
                if (! (t.options.manipulators === undefined)) {
                    for (var j = 0; j < t.options.manipulators.length; ++j) {
                        if (t.options.manipulators[j][0] == (i / 2))
                            d = t.options.manipulators[j][1](d);
                    }
                }

                // Add padding if requested.
                var dd = null;
                if (t.padding && i > 0) {
                    dd = $(document.createElement("div"))
                        .css('margin-top', t.padding)
                        .css('margin-bottom', 0)
                        .append(d);
                }

                // Wrap in a table if we're centering things.
                var ddd = null;
                if (conf_centerItems) {
                    ddd = $("<table align='center'>");
                    var tr = $(document.createElement("tr"));
                    var td = $(document.createElement("td"));
                    ddd.append(tr.append(td.append(dd ? dd : d)));
                }
                
                // Add the actual child.
                var ac = ddd ? ddd : (dd ? dd : d);

                var l = t.childUtils.length - 1;
                // Get around JavaScript's silly closure capture behavior (deriving
                // from weird variable scoping rules).
                // See http://calculist.blogspot.com/2005/12/gotcha-gotcha.html
                (function(l) {
                    childOptions._finishedCallback = function (r) { t.myFinishedCallback(l, r); };
                    childOptions._cssPrefix = ibex_controller_name_to_css_prefix(controllerClass);
                    childOptions._utils = u;
                    addSafeBindMethodPair(controllerClass);
                    d[controllerClass](childOptions);
                })(l);

                return ac;
            }

            if (addImmediately) {
                var ac = makeDiv()
                this.childElements[i/2] = { child: ac, addImmediately: true, removePrevious: false };
                this.element.append(ac);
            }
            else {
                this.childElements[i/2] = { makeDiv: makeDiv, addImmediately: false, removePrevious: removePrevious };
            }
        }
    },

    myFinishedCallback: function(index, results) {
        if (this._finishedCalledAlready)
            return;

        this.childUtils[index].gc();
        this.indicesAndResultsOfThingsThatHaveFinished.push([index, results]);

        var satisfied = true;
        for (var i = 0; i < this.triggers.length; ++i) {
            var foundIt = false;
            for (var j = 0; j < this.indicesAndResultsOfThingsThatHaveFinished.length; ++j) {
                if (this.indicesAndResultsOfThingsThatHaveFinished[j][0] == this.triggers[i]) {
                    foundIt = true;
                    break;
                }
            }
            if (! foundIt) {
                satisfied = false;
                break;
            }
        }

        if (satisfied) {
            // Merge values for next element.
            var merged = merge_list_of_dicts($.map(this.childUtils,
                                             function (x) { return x.valuesForNextElement; }));
            this.utils.valuesForNextElement = merged;

            this._finishedCalledAlready = true;
            this.finishedCallback(this.concatResults(this.indicesAndResultsOfThingsThatHaveFinished));
        }

        if (this.callbackWhenChildFinishes)
            this.callbackWhenChildFinishes(index, this.childElements[index].child, results);

        // Add next child if it wasn't added at the beginning.
        if (index + 1 < this.childElements.length) {
            var ce = this.childElements[index+1];
            if (! ce.addImmediately) {
                var ac = ce.makeDiv();
                ce.child = ac;
                ce.child.insertAfter(this.childElements[index].child);
                if (ce.removePrevious)
                    this.childElements[index].child.remove();
            }
        }
    },

    concatResults: function(iar) {
        iar = iar.sort(function(x, y) { return x[0] - y[0]; });
        var res = [];
        for (var i = 0; i < iar.length; ++i) {
            if (iar[i][1]) {
                for (var j = 0; j < iar[i][1].length; ++j) {
                    var line = [];
                    for (var k = 0; k < iar[i][1][j].length; ++k)
                        line.push(iar[i][1][j][k]);
                    res.push(line);
                }
            }
        }
        return res;
    }
},

properties: { obligatory: ["children", "triggers"] }

});


/*!

JSZipUtils - A collection of cross-browser utilities to go along with JSZip.
<http://stuk.github.io/jszip-utils>

(c) 2014 Stuart Knightley, David Duponchel
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip-utils/master/LICENSE.markdown.

*/
!function(e){"object"==typeof exports?module.exports=e():"function"==typeof define&&define.amd?define(e):"undefined"!=typeof window?window.JSZipUtils=e():"undefined"!=typeof global?global.JSZipUtils=e():"undefined"!=typeof self&&(self.JSZipUtils=e())}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var JSZipUtils = {};
// just use the responseText with xhr1, response with xhr2.
// The transformation doesn't throw away high-order byte (with responseText)
// because JSZip handles that case. If not used with JSZip, you may need to
// do it, see https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data
JSZipUtils._getBinaryFromXHR = function (xhr) {
    // for xhr.responseText, the 0xFF mask is applied by JSZip
    return xhr.response || xhr.responseText;
};

// taken from jQuery
function createStandardXHR() {
    try {
        return new window.XMLHttpRequest();
    } catch( e ) {}
}

function createActiveXHR() {
    try {
        return new window.ActiveXObject("Microsoft.XMLHTTP");
    } catch( e ) {}
}

// Create the request object
var createXHR = window.ActiveXObject ?
    /* Microsoft failed to properly
     * implement the XMLHttpRequest in IE7 (can't request local files),
     * so we use the ActiveXObject when it is available
     * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
     * we need a fallback.
     */
    function() {
    return createStandardXHR() || createActiveXHR();
} :
    // For all other browsers, use the standard XMLHttpRequest object
    createStandardXHR;



JSZipUtils.getBinaryContent = function(path, callback) {
    /*
     * Here is the tricky part : getting the data.
     * In firefox/chrome/opera/... setting the mimeType to 'text/plain; charset=x-user-defined'
     * is enough, the result is in the standard xhr.responseText.
     * cf https://developer.mozilla.org/En/XMLHttpRequest/Using_XMLHttpRequest#Receiving_binary_data_in_older_browsers
     * In IE <= 9, we must use (the IE only) attribute responseBody
     * (for binary data, its content is different from responseText).
     * In IE 10, the 'charset=x-user-defined' trick doesn't work, only the
     * responseType will work :
     * http://msdn.microsoft.com/en-us/library/ie/hh673569%28v=vs.85%29.aspx#Binary_Object_upload_and_download
     *
     * I'd like to use jQuery to avoid this XHR madness, but it doesn't support
     * the responseType attribute : http://bugs.jquery.com/ticket/11461
     */
    try {

        var xhr = createXHR();

        xhr.open('GET', path, true);

        // recent browsers
        if ("responseType" in xhr) {
            xhr.responseType = "arraybuffer";
        }

        // older browser
        if(xhr.overrideMimeType) {
            xhr.overrideMimeType("text/plain; charset=x-user-defined");
        }

        xhr.onreadystatechange = function(evt) {
            var file, err;
            // use `xhr` and not `this`... thanks IE
            if (xhr.readyState === 4) {
                if (xhr.status === 200 || xhr.status === 0) {
                    file = null;
                    err = null;
                    try {
                        file = JSZipUtils._getBinaryFromXHR(xhr);
                    } catch(e) {
                        err = new Error(e);
                    }
                    callback(err, file);
                } else {
                    callback(new Error("Ajax error for " + path + " : " + this.status + " " + this.statusText), null);
                }
            }
        };

        xhr.send();

    } catch (e) {
        callback(new Error(e), null);
    }
};

// export
module.exports = JSZipUtils;

// enforcing Stuk's coding style
// vim: set shiftwidth=4 softtabstop=4:

},{}]},{},[1])
(1)
});
;

/*!

JSZip v3.1.5 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.JSZip = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';
var utils = require('./utils');
var support = require('./support');
// private property
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";


// public method for encoding
exports.encode = function(input) {
    var output = [];
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0, len = input.length, remainingBytes = len;

    var isArray = utils.getTypeOf(input) !== "string";
    while (i < input.length) {
        remainingBytes = len - i;

        if (!isArray) {
            chr1 = input.charCodeAt(i++);
            chr2 = i < len ? input.charCodeAt(i++) : 0;
            chr3 = i < len ? input.charCodeAt(i++) : 0;
        } else {
            chr1 = input[i++];
            chr2 = i < len ? input[i++] : 0;
            chr3 = i < len ? input[i++] : 0;
        }

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = remainingBytes > 1 ? (((chr2 & 15) << 2) | (chr3 >> 6)) : 64;
        enc4 = remainingBytes > 2 ? (chr3 & 63) : 64;

        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));

    }

    return output.join("");
};

// public method for decoding
exports.decode = function(input) {
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0, resultIndex = 0;

    var dataUrlPrefix = "data:";

    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
        // This is a common error: people give a data url
        // (data:image/png;base64,iVBOR...) with a {base64: true} and
        // wonders why things don't work.
        // We can detect that the string input looks like a data url but we
        // *can't* be sure it is one: removing everything up to the comma would
        // be too dangerous.
        throw new Error("Invalid base64 input, it looks like a data url.");
    }

    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

    var totalLength = input.length * 3 / 4;
    if(input.charAt(input.length - 1) === _keyStr.charAt(64)) {
        totalLength--;
    }
    if(input.charAt(input.length - 2) === _keyStr.charAt(64)) {
        totalLength--;
    }
    if (totalLength % 1 !== 0) {
        // totalLength is not an integer, the length does not match a valid
        // base64 content. That can happen if:
        // - the input is not a base64 content
        // - the input is *almost* a base64 content, with a extra chars at the
        //   beginning or at the end
        // - the input uses a base64 variant (base64url for example)
        throw new Error("Invalid base64 input, bad content length.");
    }
    var output;
    if (support.uint8array) {
        output = new Uint8Array(totalLength|0);
    } else {
        output = new Array(totalLength|0);
    }

    while (i < input.length) {

        enc1 = _keyStr.indexOf(input.charAt(i++));
        enc2 = _keyStr.indexOf(input.charAt(i++));
        enc3 = _keyStr.indexOf(input.charAt(i++));
        enc4 = _keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        output[resultIndex++] = chr1;

        if (enc3 !== 64) {
            output[resultIndex++] = chr2;
        }
        if (enc4 !== 64) {
            output[resultIndex++] = chr3;
        }

    }

    return output;
};

},{"./support":30,"./utils":32}],2:[function(require,module,exports){
'use strict';

var external = require("./external");
var DataWorker = require('./stream/DataWorker');
var DataLengthProbe = require('./stream/DataLengthProbe');
var Crc32Probe = require('./stream/Crc32Probe');
var DataLengthProbe = require('./stream/DataLengthProbe');

/**
 * Represent a compressed object, with everything needed to decompress it.
 * @constructor
 * @param {number} compressedSize the size of the data compressed.
 * @param {number} uncompressedSize the size of the data after decompression.
 * @param {number} crc32 the crc32 of the decompressed file.
 * @param {object} compression the type of compression, see lib/compressions.js.
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the compressed data.
 */
function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
    this.compressedSize = compressedSize;
    this.uncompressedSize = uncompressedSize;
    this.crc32 = crc32;
    this.compression = compression;
    this.compressedContent = data;
}

CompressedObject.prototype = {
    /**
     * Create a worker to get the uncompressed content.
     * @return {GenericWorker} the worker.
     */
    getContentWorker : function () {
        var worker = new DataWorker(external.Promise.resolve(this.compressedContent))
        .pipe(this.compression.uncompressWorker())
        .pipe(new DataLengthProbe("data_length"));

        var that = this;
        worker.on("end", function () {
            if(this.streamInfo['data_length'] !== that.uncompressedSize) {
                throw new Error("Bug : uncompressed data size mismatch");
            }
        });
        return worker;
    },
    /**
     * Create a worker to get the compressed content.
     * @return {GenericWorker} the worker.
     */
    getCompressedWorker : function () {
        return new DataWorker(external.Promise.resolve(this.compressedContent))
        .withStreamInfo("compressedSize", this.compressedSize)
        .withStreamInfo("uncompressedSize", this.uncompressedSize)
        .withStreamInfo("crc32", this.crc32)
        .withStreamInfo("compression", this.compression)
        ;
    }
};

/**
 * Chain the given worker with other workers to compress the content with the
 * given compresion.
 * @param {GenericWorker} uncompressedWorker the worker to pipe.
 * @param {Object} compression the compression object.
 * @param {Object} compressionOptions the options to use when compressing.
 * @return {GenericWorker} the new worker compressing the content.
 */
CompressedObject.createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {
    return uncompressedWorker
    .pipe(new Crc32Probe())
    .pipe(new DataLengthProbe("uncompressedSize"))
    .pipe(compression.compressWorker(compressionOptions))
    .pipe(new DataLengthProbe("compressedSize"))
    .withStreamInfo("compression", compression);
};

module.exports = CompressedObject;

},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(require,module,exports){
'use strict';

var GenericWorker = require("./stream/GenericWorker");

exports.STORE = {
    magic: "\x00\x00",
    compressWorker : function (compressionOptions) {
        return new GenericWorker("STORE compression");
    },
    uncompressWorker : function () {
        return new GenericWorker("STORE decompression");
    }
};
exports.DEFLATE = require('./flate');

},{"./flate":7,"./stream/GenericWorker":28}],4:[function(require,module,exports){
'use strict';

var utils = require('./utils');

/**
 * The following functions come from pako, from pako/lib/zlib/crc32.js
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */

// Use ordinary array, since untyped makes no boost here
function makeTable() {
    var c, table = [];

    for(var n =0; n < 256; n++){
        c = n;
        for(var k =0; k < 8; k++){
            c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        table[n] = c;
    }

    return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
    var t = crcTable, end = pos + len;

    crc = crc ^ (-1);

    for (var i = pos; i < end; i++ ) {
        crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
    }

    return (crc ^ (-1)); // >>> 0;
}

// That's all for the pako functions.

/**
 * Compute the crc32 of a string.
 * This is almost the same as the function crc32, but for strings. Using the
 * same function for the two use cases leads to horrible performances.
 * @param {Number} crc the starting value of the crc.
 * @param {String} str the string to use.
 * @param {Number} len the length of the string.
 * @param {Number} pos the starting position for the crc32 computation.
 * @return {Number} the computed crc32.
 */
function crc32str(crc, str, len, pos) {
    var t = crcTable, end = pos + len;

    crc = crc ^ (-1);

    for (var i = pos; i < end; i++ ) {
        crc = (crc >>> 8) ^ t[(crc ^ str.charCodeAt(i)) & 0xFF];
    }

    return (crc ^ (-1)); // >>> 0;
}

module.exports = function crc32wrapper(input, crc) {
    if (typeof input === "undefined" || !input.length) {
        return 0;
    }

    var isArray = utils.getTypeOf(input) !== "string";

    if(isArray) {
        return crc32(crc|0, input, input.length, 0);
    } else {
        return crc32str(crc|0, input, input.length, 0);
    }
};

},{"./utils":32}],5:[function(require,module,exports){
'use strict';
exports.base64 = false;
exports.binary = false;
exports.dir = false;
exports.createFolders = true;
exports.date = null;
exports.compression = null;
exports.compressionOptions = null;
exports.comment = null;
exports.unixPermissions = null;
exports.dosPermissions = null;

},{}],6:[function(require,module,exports){
/* global Promise */
'use strict';

// load the global object first:
// - it should be better integrated in the system (unhandledRejection in node)
// - the environment may have a custom Promise implementation (see zone.js)
var ES6Promise = null;
if (typeof Promise !== "undefined") {
    ES6Promise = Promise;
} else {
    ES6Promise = require("lie");
}

/**
 * Let the user use/change some implementations.
 */
module.exports = {
    Promise: ES6Promise
};

},{"lie":58}],7:[function(require,module,exports){
'use strict';
var USE_TYPEDARRAY = (typeof Uint8Array !== 'undefined') && (typeof Uint16Array !== 'undefined') && (typeof Uint32Array !== 'undefined');

var pako = require("pako");
var utils = require("./utils");
var GenericWorker = require("./stream/GenericWorker");

var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";

exports.magic = "\x08\x00";

/**
 * Create a worker that uses pako to inflate/deflate.
 * @constructor
 * @param {String} action the name of the pako function to call : either "Deflate" or "Inflate".
 * @param {Object} options the options to use when (de)compressing.
 */
function FlateWorker(action, options) {
    GenericWorker.call(this, "FlateWorker/" + action);

    this._pako = null;
    this._pakoAction = action;
    this._pakoOptions = options;
    // the `meta` object from the last chunk received
    // this allow this worker to pass around metadata
    this.meta = {};
}

utils.inherits(FlateWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
FlateWorker.prototype.processChunk = function (chunk) {
    this.meta = chunk.meta;
    if (this._pako === null) {
        this._createPako();
    }
    this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
};

/**
 * @see GenericWorker.flush
 */
FlateWorker.prototype.flush = function () {
    GenericWorker.prototype.flush.call(this);
    if (this._pako === null) {
        this._createPako();
    }
    this._pako.push([], true);
};
/**
 * @see GenericWorker.cleanUp
 */
FlateWorker.prototype.cleanUp = function () {
    GenericWorker.prototype.cleanUp.call(this);
    this._pako = null;
};

/**
 * Create the _pako object.
 * TODO: lazy-loading this object isn't the best solution but it's the
 * quickest. The best solution is to lazy-load the worker list. See also the
 * issue #446.
 */
FlateWorker.prototype._createPako = function () {
    this._pako = new pako[this._pakoAction]({
        raw: true,
        level: this._pakoOptions.level || -1 // default compression
    });
    var self = this;
    this._pako.onData = function(data) {
        self.push({
            data : data,
            meta : self.meta
        });
    };
};

exports.compressWorker = function (compressionOptions) {
    return new FlateWorker("Deflate", compressionOptions);
};
exports.uncompressWorker = function () {
    return new FlateWorker("Inflate", {});
};

},{"./stream/GenericWorker":28,"./utils":32,"pako":59}],8:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('../stream/GenericWorker');
var utf8 = require('../utf8');
var crc32 = require('../crc32');
var signature = require('../signature');

/**
 * Transform an integer into a string in hexadecimal.
 * @private
 * @param {number} dec the number to convert.
 * @param {number} bytes the number of bytes to generate.
 * @returns {string} the result.
 */
var decToHex = function(dec, bytes) {
    var hex = "", i;
    for (i = 0; i < bytes; i++) {
        hex += String.fromCharCode(dec & 0xff);
        dec = dec >>> 8;
    }
    return hex;
};

/**
 * Generate the UNIX part of the external file attributes.
 * @param {Object} unixPermissions the unix permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :
 *
 * TTTTsstrwxrwxrwx0000000000ADVSHR
 * ^^^^____________________________ file type, see zipinfo.c (UNX_*)
 *     ^^^_________________________ setuid, setgid, sticky
 *        ^^^^^^^^^________________ permissions
 *                 ^^^^^^^^^^______ not used ?
 *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only
 */
var generateUnixExternalFileAttr = function (unixPermissions, isDir) {

    var result = unixPermissions;
    if (!unixPermissions) {
        // I can't use octal values in strict mode, hence the hexa.
        //  040775 => 0x41fd
        // 0100664 => 0x81b4
        result = isDir ? 0x41fd : 0x81b4;
    }
    return (result & 0xFFFF) << 16;
};

/**
 * Generate the DOS part of the external file attributes.
 * @param {Object} dosPermissions the dos permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * Bit 0     Read-Only
 * Bit 1     Hidden
 * Bit 2     System
 * Bit 3     Volume Label
 * Bit 4     Directory
 * Bit 5     Archive
 */
var generateDosExternalFileAttr = function (dosPermissions, isDir) {

    // the dir flag is already set for compatibility
    return (dosPermissions || 0)  & 0x3F;
};

/**
 * Generate the various parts used in the construction of the final zip file.
 * @param {Object} streamInfo the hash with informations about the compressed file.
 * @param {Boolean} streamedContent is the content streamed ?
 * @param {Boolean} streamingEnded is the stream finished ?
 * @param {number} offset the current offset from the start of the zip file.
 * @param {String} platform let's pretend we are this platform (change platform dependents fields)
 * @param {Function} encodeFileName the function to encode the file name / comment.
 * @return {Object} the zip parts.
 */
var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
    var file = streamInfo['file'],
    compression = streamInfo['compression'],
    useCustomEncoding = encodeFileName !== utf8.utf8encode,
    encodedFileName = utils.transformTo("string", encodeFileName(file.name)),
    utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)),
    comment = file.comment,
    encodedComment = utils.transformTo("string", encodeFileName(comment)),
    utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)),
    useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,
    useUTF8ForComment = utfEncodedComment.length !== comment.length,
    dosTime,
    dosDate,
    extraFields = "",
    unicodePathExtraField = "",
    unicodeCommentExtraField = "",
    dir = file.dir,
    date = file.date;


    var dataInfo = {
        crc32 : 0,
        compressedSize : 0,
        uncompressedSize : 0
    };

    // if the content is streamed, the sizes/crc32 are only available AFTER
    // the end of the stream.
    if (!streamedContent || streamingEnded) {
        dataInfo.crc32 = streamInfo['crc32'];
        dataInfo.compressedSize = streamInfo['compressedSize'];
        dataInfo.uncompressedSize = streamInfo['uncompressedSize'];
    }

    var bitflag = 0;
    if (streamedContent) {
        // Bit 3: the sizes/crc32 are set to zero in the local header.
        // The correct values are put in the data descriptor immediately
        // following the compressed data.
        bitflag |= 0x0008;
    }
    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
        // Bit 11: Language encoding flag (EFS).
        bitflag |= 0x0800;
    }


    var extFileAttr = 0;
    var versionMadeBy = 0;
    if (dir) {
        // dos or unix, we set the dos dir flag
        extFileAttr |= 0x00010;
    }
    if(platform === "UNIX") {
        versionMadeBy = 0x031E; // UNIX, version 3.0
        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
    } else { // DOS or other, fallback to DOS
        versionMadeBy = 0x0014; // DOS, version 2.0
        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
    }

    // date
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html

    dosTime = date.getUTCHours();
    dosTime = dosTime << 6;
    dosTime = dosTime | date.getUTCMinutes();
    dosTime = dosTime << 5;
    dosTime = dosTime | date.getUTCSeconds() / 2;

    dosDate = date.getUTCFullYear() - 1980;
    dosDate = dosDate << 4;
    dosDate = dosDate | (date.getUTCMonth() + 1);
    dosDate = dosDate << 5;
    dosDate = dosDate | date.getUTCDate();

    if (useUTF8ForFileName) {
        // set the unicode path extra field. unzip needs at least one extra
        // field to correctly handle unicode path, so using the path is as good
        // as any other information. This could improve the situation with
        // other archive managers too.
        // This field is usually used without the utf8 flag, with a non
        // unicode path in the header (winrar, winzip). This helps (a bit)
        // with the messy Windows' default compressed folders feature but
        // breaks on p7zip which doesn't seek the unicode path extra field.
        // So for now, UTF-8 everywhere !
        unicodePathExtraField =
            // Version
            decToHex(1, 1) +
            // NameCRC32
            decToHex(crc32(encodedFileName), 4) +
            // UnicodeName
            utfEncodedFileName;

        extraFields +=
            // Info-ZIP Unicode Path Extra Field
            "\x75\x70" +
            // size
            decToHex(unicodePathExtraField.length, 2) +
            // content
            unicodePathExtraField;
    }

    if(useUTF8ForComment) {

        unicodeCommentExtraField =
            // Version
            decToHex(1, 1) +
            // CommentCRC32
            decToHex(crc32(encodedComment), 4) +
            // UnicodeName
            utfEncodedComment;

        extraFields +=
            // Info-ZIP Unicode Path Extra Field
            "\x75\x63" +
            // size
            decToHex(unicodeCommentExtraField.length, 2) +
            // content
            unicodeCommentExtraField;
    }

    var header = "";

    // version needed to extract
    header += "\x0A\x00";
    // general purpose bit flag
    header += decToHex(bitflag, 2);
    // compression method
    header += compression.magic;
    // last mod file time
    header += decToHex(dosTime, 2);
    // last mod file date
    header += decToHex(dosDate, 2);
    // crc-32
    header += decToHex(dataInfo.crc32, 4);
    // compressed size
    header += decToHex(dataInfo.compressedSize, 4);
    // uncompressed size
    header += decToHex(dataInfo.uncompressedSize, 4);
    // file name length
    header += decToHex(encodedFileName.length, 2);
    // extra field length
    header += decToHex(extraFields.length, 2);


    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;

    var dirRecord = signature.CENTRAL_FILE_HEADER +
        // version made by (00: DOS)
        decToHex(versionMadeBy, 2) +
        // file header (common to file and central directory)
        header +
        // file comment length
        decToHex(encodedComment.length, 2) +
        // disk number start
        "\x00\x00" +
        // internal file attributes TODO
        "\x00\x00" +
        // external file attributes
        decToHex(extFileAttr, 4) +
        // relative offset of local header
        decToHex(offset, 4) +
        // file name
        encodedFileName +
        // extra field
        extraFields +
        // file comment
        encodedComment;

    return {
        fileRecord: fileRecord,
        dirRecord: dirRecord
    };
};

/**
 * Generate the EOCD record.
 * @param {Number} entriesCount the number of entries in the zip file.
 * @param {Number} centralDirLength the length (in bytes) of the central dir.
 * @param {Number} localDirLength the length (in bytes) of the local dir.
 * @param {String} comment the zip file comment as a binary string.
 * @param {Function} encodeFileName the function to encode the comment.
 * @return {String} the EOCD record.
 */
var generateCentralDirectoryEnd = function (entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
    var dirEnd = "";
    var encodedComment = utils.transformTo("string", encodeFileName(comment));

    // end of central dir signature
    dirEnd = signature.CENTRAL_DIRECTORY_END +
        // number of this disk
        "\x00\x00" +
        // number of the disk with the start of the central directory
        "\x00\x00" +
        // total number of entries in the central directory on this disk
        decToHex(entriesCount, 2) +
        // total number of entries in the central directory
        decToHex(entriesCount, 2) +
        // size of the central directory   4 bytes
        decToHex(centralDirLength, 4) +
        // offset of start of central directory with respect to the starting disk number
        decToHex(localDirLength, 4) +
        // .ZIP file comment length
        decToHex(encodedComment.length, 2) +
        // .ZIP file comment
        encodedComment;

    return dirEnd;
};

/**
 * Generate data descriptors for a file entry.
 * @param {Object} streamInfo the hash generated by a worker, containing informations
 * on the file entry.
 * @return {String} the data descriptors.
 */
var generateDataDescriptors = function (streamInfo) {
    var descriptor = "";
    descriptor = signature.DATA_DESCRIPTOR +
        // crc-32                          4 bytes
        decToHex(streamInfo['crc32'], 4) +
        // compressed size                 4 bytes
        decToHex(streamInfo['compressedSize'], 4) +
        // uncompressed size               4 bytes
        decToHex(streamInfo['uncompressedSize'], 4);

    return descriptor;
};


/**
 * A worker to concatenate other workers to create a zip file.
 * @param {Boolean} streamFiles `true` to stream the content of the files,
 * `false` to accumulate it.
 * @param {String} comment the comment to use.
 * @param {String} platform the platform to use, "UNIX" or "DOS".
 * @param {Function} encodeFileName the function to encode file names and comments.
 */
function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
    GenericWorker.call(this, "ZipFileWorker");
    // The number of bytes written so far. This doesn't count accumulated chunks.
    this.bytesWritten = 0;
    // The comment of the zip file
    this.zipComment = comment;
    // The platform "generating" the zip file.
    this.zipPlatform = platform;
    // the function to encode file names and comments.
    this.encodeFileName = encodeFileName;
    // Should we stream the content of the files ?
    this.streamFiles = streamFiles;
    // If `streamFiles` is false, we will need to accumulate the content of the
    // files to calculate sizes / crc32 (and write them *before* the content).
    // This boolean indicates if we are accumulating chunks (it will change a lot
    // during the lifetime of this worker).
    this.accumulate = false;
    // The buffer receiving chunks when accumulating content.
    this.contentBuffer = [];
    // The list of generated directory records.
    this.dirRecords = [];
    // The offset (in bytes) from the beginning of the zip file for the current source.
    this.currentSourceOffset = 0;
    // The total number of entries in this zip file.
    this.entriesCount = 0;
    // the name of the file currently being added, null when handling the end of the zip file.
    // Used for the emited metadata.
    this.currentFile = null;



    this._sources = [];
}
utils.inherits(ZipFileWorker, GenericWorker);

/**
 * @see GenericWorker.push
 */
ZipFileWorker.prototype.push = function (chunk) {

    var currentFilePercent = chunk.meta.percent || 0;
    var entriesCount = this.entriesCount;
    var remainingFiles = this._sources.length;

    if(this.accumulate) {
        this.contentBuffer.push(chunk);
    } else {
        this.bytesWritten += chunk.data.length;

        GenericWorker.prototype.push.call(this, {
            data : chunk.data,
            meta : {
                currentFile : this.currentFile,
                percent : entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
            }
        });
    }
};

/**
 * The worker started a new source (an other worker).
 * @param {Object} streamInfo the streamInfo object from the new source.
 */
ZipFileWorker.prototype.openedSource = function (streamInfo) {
    this.currentSourceOffset = this.bytesWritten;
    this.currentFile = streamInfo['file'].name;

    var streamedContent = this.streamFiles && !streamInfo['file'].dir;

    // don't stream folders (because they don't have any content)
    if(streamedContent) {
        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        this.push({
            data : record.fileRecord,
            meta : {percent:0}
        });
    } else {
        // we need to wait for the whole file before pushing anything
        this.accumulate = true;
    }
};

/**
 * The worker finished a source (an other worker).
 * @param {Object} streamInfo the streamInfo object from the finished source.
 */
ZipFileWorker.prototype.closedSource = function (streamInfo) {
    this.accumulate = false;
    var streamedContent = this.streamFiles && !streamInfo['file'].dir;
    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);

    this.dirRecords.push(record.dirRecord);
    if(streamedContent) {
        // after the streamed file, we put data descriptors
        this.push({
            data : generateDataDescriptors(streamInfo),
            meta : {percent:100}
        });
    } else {
        // the content wasn't streamed, we need to push everything now
        // first the file record, then the content
        this.push({
            data : record.fileRecord,
            meta : {percent:0}
        });
        while(this.contentBuffer.length) {
            this.push(this.contentBuffer.shift());
        }
    }
    this.currentFile = null;
};

/**
 * @see GenericWorker.flush
 */
ZipFileWorker.prototype.flush = function () {

    var localDirLength = this.bytesWritten;
    for(var i = 0; i < this.dirRecords.length; i++) {
        this.push({
            data : this.dirRecords[i],
            meta : {percent:100}
        });
    }
    var centralDirLength = this.bytesWritten - localDirLength;

    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);

    this.push({
        data : dirEnd,
        meta : {percent:100}
    });
};

/**
 * Prepare the next source to be read.
 */
ZipFileWorker.prototype.prepareNextSource = function () {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
        this.previous.pause();
    } else {
        this.previous.resume();
    }
};

/**
 * @see GenericWorker.registerPrevious
 */
ZipFileWorker.prototype.registerPrevious = function (previous) {
    this._sources.push(previous);
    var self = this;

    previous.on('data', function (chunk) {
        self.processChunk(chunk);
    });
    previous.on('end', function () {
        self.closedSource(self.previous.streamInfo);
        if(self._sources.length) {
            self.prepareNextSource();
        } else {
            self.end();
        }
    });
    previous.on('error', function (e) {
        self.error(e);
    });
    return this;
};

/**
 * @see GenericWorker.resume
 */
ZipFileWorker.prototype.resume = function () {
    if(!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (!this.previous && this._sources.length) {
        this.prepareNextSource();
        return true;
    }
    if (!this.previous && !this._sources.length && !this.generatedError) {
        this.end();
        return true;
    }
};

/**
 * @see GenericWorker.error
 */
ZipFileWorker.prototype.error = function (e) {
    var sources = this._sources;
    if(!GenericWorker.prototype.error.call(this, e)) {
        return false;
    }
    for(var i = 0; i < sources.length; i++) {
        try {
            sources[i].error(e);
        } catch(e) {
            // the `error` exploded, nothing to do
        }
    }
    return true;
};

/**
 * @see GenericWorker.lock
 */
ZipFileWorker.prototype.lock = function () {
    GenericWorker.prototype.lock.call(this);
    var sources = this._sources;
    for(var i = 0; i < sources.length; i++) {
        sources[i].lock();
    }
};

module.exports = ZipFileWorker;

},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(require,module,exports){
'use strict';

var compressions = require('../compressions');
var ZipFileWorker = require('./ZipFileWorker');

/**
 * Find the compression to use.
 * @param {String} fileCompression the compression defined at the file level, if any.
 * @param {String} zipCompression the compression defined at the load() level.
 * @return {Object} the compression object to use.
 */
var getCompression = function (fileCompression, zipCompression) {

    var compressionName = fileCompression || zipCompression;
    var compression = compressions[compressionName];
    if (!compression) {
        throw new Error(compressionName + " is not a valid compression method !");
    }
    return compression;
};

/**
 * Create a worker to generate a zip file.
 * @param {JSZip} zip the JSZip instance at the right root level.
 * @param {Object} options to generate the zip file.
 * @param {String} comment the comment to use.
 */
exports.generateWorker = function (zip, options, comment) {

    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
    var entriesCount = 0;
    try {

        zip.forEach(function (relativePath, file) {
            entriesCount++;
            var compression = getCompression(file.options.compression, options.compression);
            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
            var dir = file.dir, date = file.date;

            file._compressWorker(compression, compressionOptions)
            .withStreamInfo("file", {
                name : relativePath,
                dir : dir,
                date : date,
                comment : file.comment || "",
                unixPermissions : file.unixPermissions,
                dosPermissions : file.dosPermissions
            })
            .pipe(zipFileWorker);
        });
        zipFileWorker.entriesCount = entriesCount;
    } catch (e) {
        zipFileWorker.error(e);
    }

    return zipFileWorker;
};

},{"../compressions":3,"./ZipFileWorker":8}],10:[function(require,module,exports){
'use strict';

/**
 * Representation a of zip file in js
 * @constructor
 */
function JSZip() {
    // if this constructor isused without`new`, itadds `new` beforeitself:
    if(!(this instanceof JSZip)) {
        return new JSZip();
    }

    if(arguments.length) {
        throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
    }

    // object containing the files :
    // {
    //   "folder/" : {...},
    //   "folder/data.txt" : {...}
    // }
    this.files = {};

    this.comment = null;

    // Where we are in the hierarchy
    this.root = "";
    this.clone = function() {
        var newObj = new JSZip();
        for (var i in this) {
            if (typeof this[i] !== "function") {
                newObj[i] = this[i];
            }
        }
        return newObj;
    };
}
JSZip.prototype = require('./object');
JSZip.prototype.loadAsync = require('./load');
JSZip.support = require('./support');
JSZip.defaults = require('./defaults');

// TODO find a better way to handle this version,
// a require('package.json').version doesn't work with webpack, see #327
JSZip.version = "3.1.5";

JSZip.loadAsync = function (content, options) {
    return new JSZip().loadAsync(content, options);
};

JSZip.external = require("./external");
module.exports = JSZip;

},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(require,module,exports){
'use strict';
var utils = require('./utils');
var external = require("./external");
var utf8 = require('./utf8');
var utils = require('./utils');
var ZipEntries = require('./zipEntries');
var Crc32Probe = require('./stream/Crc32Probe');
var nodejsUtils = require("./nodejsUtils");

/**
 * Check the CRC32 of an entry.
 * @param {ZipEntry} zipEntry the zip entry to check.
 * @return {Promise} the result.
 */
function checkEntryCRC32(zipEntry) {
    return new external.Promise(function (resolve, reject) {
        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
        worker.on("error", function (e) {
            reject(e);
        })
        .on("end", function () {
            if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
                reject(new Error("Corrupted zip : CRC32 mismatch"));
            } else {
                resolve();
            }
        })
        .resume();
    });
}

module.exports = function(data, options) {
    var zip = this;
    options = utils.extend(options || {}, {
        base64: false,
        checkCRC32: false,
        optimizedBinaryString: false,
        createFolders: false,
        decodeFileName: utf8.utf8decode
    });

    if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
    }

    return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64)
    .then(function(data) {
        var zipEntries = new ZipEntries(options);
        zipEntries.load(data);
        return zipEntries;
    }).then(function checkCRC32(zipEntries) {
        var promises = [external.Promise.resolve(zipEntries)];
        var files = zipEntries.files;
        if (options.checkCRC32) {
            for (var i = 0; i < files.length; i++) {
                promises.push(checkEntryCRC32(files[i]));
            }
        }
        return external.Promise.all(promises);
    }).then(function addFiles(results) {
        var zipEntries = results.shift();
        var files = zipEntries.files;
        for (var i = 0; i < files.length; i++) {
            var input = files[i];
            zip.file(input.fileNameStr, input.decompressed, {
                binary: true,
                optimizedBinaryString: true,
                date: input.date,
                dir: input.dir,
                comment : input.fileCommentStr.length ? input.fileCommentStr : null,
                unixPermissions : input.unixPermissions,
                dosPermissions : input.dosPermissions,
                createFolders: options.createFolders
            });
        }
        if (zipEntries.zipComment.length) {
            zip.comment = zipEntries.zipComment;
        }

        return zip;
    });
};

},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(require,module,exports){
"use strict";

var utils = require('../utils');
var GenericWorker = require('../stream/GenericWorker');

/**
 * A worker that use a nodejs stream as source.
 * @constructor
 * @param {String} filename the name of the file entry for this stream.
 * @param {Readable} stream the nodejs stream.
 */
function NodejsStreamInputAdapter(filename, stream) {
    GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
    this._upstreamEnded = false;
    this._bindStream(stream);
}

utils.inherits(NodejsStreamInputAdapter, GenericWorker);

/**
 * Prepare the stream and bind the callbacks on it.
 * Do this ASAP on node 0.10 ! A lazy binding doesn't always work.
 * @param {Stream} stream the nodejs stream to use.
 */
NodejsStreamInputAdapter.prototype._bindStream = function (stream) {
    var self = this;
    this._stream = stream;
    stream.pause();
    stream
    .on("data", function (chunk) {
        self.push({
            data: chunk,
            meta : {
                percent : 0
            }
        });
    })
    .on("error", function (e) {
        if(self.isPaused) {
            this.generatedError = e;
        } else {
            self.error(e);
        }
    })
    .on("end", function () {
        if(self.isPaused) {
            self._upstreamEnded = true;
        } else {
            self.end();
        }
    });
};
NodejsStreamInputAdapter.prototype.pause = function () {
    if(!GenericWorker.prototype.pause.call(this)) {
        return false;
    }
    this._stream.pause();
    return true;
};
NodejsStreamInputAdapter.prototype.resume = function () {
    if(!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if(this._upstreamEnded) {
        this.end();
    } else {
        this._stream.resume();
    }

    return true;
};

module.exports = NodejsStreamInputAdapter;

},{"../stream/GenericWorker":28,"../utils":32}],13:[function(require,module,exports){
'use strict';

var Readable = require('readable-stream').Readable;

var utils = require('../utils');
utils.inherits(NodejsStreamOutputAdapter, Readable);

/**
* A nodejs stream using a worker as source.
* @see the SourceWrapper in http://nodejs.org/api/stream.html
* @constructor
* @param {StreamHelper} helper the helper wrapping the worker
* @param {Object} options the nodejs stream options
* @param {Function} updateCb the update callback.
*/
function NodejsStreamOutputAdapter(helper, options, updateCb) {
    Readable.call(this, options);
    this._helper = helper;

    var self = this;
    helper.on("data", function (data, meta) {
        if (!self.push(data)) {
            self._helper.pause();
        }
        if(updateCb) {
            updateCb(meta);
        }
    })
    .on("error", function(e) {
        self.emit('error', e);
    })
    .on("end", function () {
        self.push(null);
    });
}


NodejsStreamOutputAdapter.prototype._read = function() {
    this._helper.resume();
};

module.exports = NodejsStreamOutputAdapter;

},{"../utils":32,"readable-stream":16}],14:[function(require,module,exports){
'use strict';

module.exports = {
    /**
     * True if this is running in Nodejs, will be undefined in a browser.
     * In a browser, browserify won't include this file and the whole module
     * will be resolved an empty object.
     */
    isNode : typeof Buffer !== "undefined",
    /**
     * Create a new nodejs Buffer from an existing content.
     * @param {Object} data the data to pass to the constructor.
     * @param {String} encoding the encoding to use.
     * @return {Buffer} a new Buffer.
     */
    newBufferFrom: function(data, encoding) {
        // XXX We can't use `Buffer.from` which comes from `Uint8Array.from`
        // in nodejs v4 (< v.4.5). It's not the expected implementation (and
        // has a different signature).
        // see https://github.com/nodejs/node/issues/8053
        // A condition on nodejs' version won't solve the issue as we don't
        // control the Buffer polyfills that may or may not be used.
        return new Buffer(data, encoding);
    },
    /**
     * Create a new nodejs Buffer with the specified size.
     * @param {Integer} size the size of the buffer.
     * @return {Buffer} a new Buffer.
     */
    allocBuffer: function (size) {
        if (Buffer.alloc) {
            return Buffer.alloc(size);
        } else {
            return new Buffer(size);
        }
    },
    /**
     * Find out if an object is a Buffer.
     * @param {Object} b the object to test.
     * @return {Boolean} true if the object is a Buffer, false otherwise.
     */
    isBuffer : function(b){
        return Buffer.isBuffer(b);
    },

    isStream : function (obj) {
        return obj &&
            typeof obj.on === "function" &&
            typeof obj.pause === "function" &&
            typeof obj.resume === "function";
    }
};

},{}],15:[function(require,module,exports){
'use strict';
var utf8 = require('./utf8');
var utils = require('./utils');
var GenericWorker = require('./stream/GenericWorker');
var StreamHelper = require('./stream/StreamHelper');
var defaults = require('./defaults');
var CompressedObject = require('./compressedObject');
var ZipObject = require('./zipObject');
var generate = require("./generate");
var nodejsUtils = require("./nodejsUtils");
var NodejsStreamInputAdapter = require("./nodejs/NodejsStreamInputAdapter");


/**
 * Add a file in the current folder.
 * @private
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file
 * @param {Object} originalOptions the options of the file
 * @return {Object} the new file.
 */
var fileAdd = function(name, data, originalOptions) {
    // be sure sub folders exist
    var dataType = utils.getTypeOf(data),
        parent;


    /*
     * Correct options.
     */

    var o = utils.extend(originalOptions || {}, defaults);
    o.date = o.date || new Date();
    if (o.compression !== null) {
        o.compression = o.compression.toUpperCase();
    }

    if (typeof o.unixPermissions === "string") {
        o.unixPermissions = parseInt(o.unixPermissions, 8);
    }

    // UNX_IFDIR  0040000 see zipinfo.c
    if (o.unixPermissions && (o.unixPermissions & 0x4000)) {
        o.dir = true;
    }
    // Bit 4    Directory
    if (o.dosPermissions && (o.dosPermissions & 0x0010)) {
        o.dir = true;
    }

    if (o.dir) {
        name = forceTrailingSlash(name);
    }
    if (o.createFolders && (parent = parentFolder(name))) {
        folderAdd.call(this, parent, true);
    }

    var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
    if (!originalOptions || typeof originalOptions.binary === "undefined") {
        o.binary = !isUnicodeString;
    }


    var isCompressedEmpty = (data instanceof CompressedObject) && data.uncompressedSize === 0;

    if (isCompressedEmpty || o.dir || !data || data.length === 0) {
        o.base64 = false;
        o.binary = true;
        data = "";
        o.compression = "STORE";
        dataType = "string";
    }

    /*
     * Convert content to fit.
     */

    var zipObjectContent = null;
    if (data instanceof CompressedObject || data instanceof GenericWorker) {
        zipObjectContent = data;
    } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        zipObjectContent = new NodejsStreamInputAdapter(name, data);
    } else {
        zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
    }

    var object = new ZipObject(name, zipObjectContent, o);
    this.files[name] = object;
    /*
    TODO: we can't throw an exception because we have async promises
    (we can have a promise of a Date() for example) but returning a
    promise is useless because file(name, data) returns the JSZip
    object for chaining. Should we break that to allow the user
    to catch the error ?

    return external.Promise.resolve(zipObjectContent)
    .then(function () {
        return object;
    });
    */
};

/**
 * Find the parent folder of the path.
 * @private
 * @param {string} path the path to use
 * @return {string} the parent folder, or ""
 */
var parentFolder = function (path) {
    if (path.slice(-1) === '/') {
        path = path.substring(0, path.length - 1);
    }
    var lastSlash = path.lastIndexOf('/');
    return (lastSlash > 0) ? path.substring(0, lastSlash) : "";
};

/**
 * Returns the path with a slash at the end.
 * @private
 * @param {String} path the path to check.
 * @return {String} the path with a trailing slash.
 */
var forceTrailingSlash = function(path) {
    // Check the name ends with a /
    if (path.slice(-1) !== "/") {
        path += "/"; // IE doesn't like substr(-1)
    }
    return path;
};

/**
 * Add a (sub) folder in the current folder.
 * @private
 * @param {string} name the folder's name
 * @param {boolean=} [createFolders] If true, automatically create sub
 *  folders. Defaults to false.
 * @return {Object} the new folder.
 */
var folderAdd = function(name, createFolders) {
    createFolders = (typeof createFolders !== 'undefined') ? createFolders : defaults.createFolders;

    name = forceTrailingSlash(name);

    // Does this folder already exist?
    if (!this.files[name]) {
        fileAdd.call(this, name, null, {
            dir: true,
            createFolders: createFolders
        });
    }
    return this.files[name];
};

/**
* Cross-window, cross-Node-context regular expression detection
* @param  {Object}  object Anything
* @return {Boolean}        true if the object is a regular expression,
* false otherwise
*/
function isRegExp(object) {
    return Object.prototype.toString.call(object) === "[object RegExp]";
}

// return the actual prototype of JSZip
var out = {
    /**
     * @see loadAsync
     */
    load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },


    /**
     * Call a callback function for each entry at this folder level.
     * @param {Function} cb the callback function:
     * function (relativePath, file) {...}
     * It takes 2 arguments : the relative path and the file.
     */
    forEach: function(cb) {
        var filename, relativePath, file;
        for (filename in this.files) {
            if (!this.files.hasOwnProperty(filename)) {
                continue;
            }
            file = this.files[filename];
            relativePath = filename.slice(this.root.length, filename.length);
            if (relativePath && filename.slice(0, this.root.length) === this.root) { // the file is in the current root
                cb(relativePath, file); // TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...
            }
        }
    },

    /**
     * Filter nested files/folders with the specified function.
     * @param {Function} search the predicate to use :
     * function (relativePath, file) {...}
     * It takes 2 arguments : the relative path and the file.
     * @return {Array} An array of matching elements.
     */
    filter: function(search) {
        var result = [];
        this.forEach(function (relativePath, entry) {
            if (search(relativePath, entry)) { // the file matches the function
                result.push(entry);
            }

        });
        return result;
    },

    /**
     * Add a file to the zip file, or search a file.
     * @param   {string|RegExp} name The name of the file to add (if data is defined),
     * the name of the file to find (if no data) or a regex to match files.
     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
     * @param   {Object} o     File options
     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
     * a file (when searching by string) or an array of files (when searching by regex).
     */
    file: function(name, data, o) {
        if (arguments.length === 1) {
            if (isRegExp(name)) {
                var regexp = name;
                return this.filter(function(relativePath, file) {
                    return !file.dir && regexp.test(relativePath);
                });
            }
            else { // text
                var obj = this.files[this.root + name];
                if (obj && !obj.dir) {
                    return obj;
                } else {
                    return null;
                }
            }
        }
        else { // more than one argument : we have data !
            name = this.root + name;
            fileAdd.call(this, name, data, o);
        }
        return this;
    },

    /**
     * Add a directory to the zip file, or search.
     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
     */
    folder: function(arg) {
        if (!arg) {
            return this;
        }

        if (isRegExp(arg)) {
            return this.filter(function(relativePath, file) {
                return file.dir && arg.test(relativePath);
            });
        }

        // else, name is a new folder
        var name = this.root + arg;
        var newFolder = folderAdd.call(this, name);

        // Allow chaining by returning a new object with this folder as the root
        var ret = this.clone();
        ret.root = newFolder.name;
        return ret;
    },

    /**
     * Delete a file, or a directory and all sub-files, from the zip
     * @param {string} name the name of the file to delete
     * @return {JSZip} this JSZip object
     */
    remove: function(name) {
        name = this.root + name;
        var file = this.files[name];
        if (!file) {
            // Look for any folders
            if (name.slice(-1) !== "/") {
                name += "/";
            }
            file = this.files[name];
        }

        if (file && !file.dir) {
            // file
            delete this.files[name];
        } else {
            // maybe a folder, delete recursively
            var kids = this.filter(function(relativePath, file) {
                return file.name.slice(0, name.length) === name;
            });
            for (var i = 0; i < kids.length; i++) {
                delete this.files[kids[i].name];
            }
        }

        return this;
    },

    /**
     * Generate the complete zip file
     * @param {Object} options the options to generate the zip file :
     * - compression, "STORE" by default.
     * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
     * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file
     */
    generate: function(options) {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },

    /**
     * Generate the complete zip file as an internal stream.
     * @param {Object} options the options to generate the zip file :
     * - compression, "STORE" by default.
     * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
     * @return {StreamHelper} the streamed zip file.
     */
    generateInternalStream: function(options) {
      var worker, opts = {};
      try {
          opts = utils.extend(options || {}, {
              streamFiles: false,
              compression: "STORE",
              compressionOptions : null,
              type: "",
              platform: "DOS",
              comment: null,
              mimeType: 'application/zip',
              encodeFileName: utf8.utf8encode
          });

          opts.type = opts.type.toLowerCase();
          opts.compression = opts.compression.toUpperCase();

          // "binarystring" is prefered but the internals use "string".
          if(opts.type === "binarystring") {
            opts.type = "string";
          }

          if (!opts.type) {
            throw new Error("No output type specified.");
          }

          utils.checkSupport(opts.type);

          // accept nodejs `process.platform`
          if(
              opts.platform === 'darwin' ||
              opts.platform === 'freebsd' ||
              opts.platform === 'linux' ||
              opts.platform === 'sunos'
          ) {
              opts.platform = "UNIX";
          }
          if (opts.platform === 'win32') {
              opts.platform = "DOS";
          }

          var comment = opts.comment || this.comment || "";
          worker = generate.generateWorker(this, opts, comment);
      } catch (e) {
        worker = new GenericWorker("error");
        worker.error(e);
      }
      return new StreamHelper(worker, opts.type || "string", opts.mimeType);
    },
    /**
     * Generate the complete zip file asynchronously.
     * @see generateInternalStream
     */
    generateAsync: function(options, onUpdate) {
        return this.generateInternalStream(options).accumulate(onUpdate);
    },
    /**
     * Generate the complete zip file asynchronously.
     * @see generateInternalStream
     */
    generateNodeStream: function(options, onUpdate) {
        options = options || {};
        if (!options.type) {
            options.type = "nodebuffer";
        }
        return this.generateInternalStream(options).toNodejsStream(onUpdate);
    }
};
module.exports = out;

},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(require,module,exports){
/*
 * This file is used by module bundlers (browserify/webpack/etc) when
 * including a stream implementation. We use "readable-stream" to get a
 * consistent behavior between nodejs versions but bundlers often have a shim
 * for "stream". Using this shim greatly improve the compatibility and greatly
 * reduce the final size of the bundle (only one stream implementation, not
 * two).
 */
module.exports = require("stream");

},{"stream":undefined}],17:[function(require,module,exports){
'use strict';
var DataReader = require('./DataReader');
var utils = require('../utils');

function ArrayReader(data) {
    DataReader.call(this, data);
	for(var i = 0; i < this.data.length; i++) {
		data[i] = data[i] & 0xFF;
	}
}
utils.inherits(ArrayReader, DataReader);
/**
 * @see DataReader.byteAt
 */
ArrayReader.prototype.byteAt = function(i) {
    return this.data[this.zero + i];
};
/**
 * @see DataReader.lastIndexOfSignature
 */
ArrayReader.prototype.lastIndexOfSignature = function(sig) {
    var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3);
    for (var i = this.length - 4; i >= 0; --i) {
        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
            return i - this.zero;
        }
    }

    return -1;
};
/**
 * @see DataReader.readAndCheckSignature
 */
ArrayReader.prototype.readAndCheckSignature = function (sig) {
    var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3),
        data = this.readData(4);
    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
};
/**
 * @see DataReader.readData
 */
ArrayReader.prototype.readData = function(size) {
    this.checkOffset(size);
    if(size === 0) {
        return [];
    }
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = ArrayReader;

},{"../utils":32,"./DataReader":18}],18:[function(require,module,exports){
'use strict';
var utils = require('../utils');

function DataReader(data) {
    this.data = data; // type : see implementation
    this.length = data.length;
    this.index = 0;
    this.zero = 0;
}
DataReader.prototype = {
    /**
     * Check that the offset will not go too far.
     * @param {string} offset the additional offset to check.
     * @throws {Error} an Error if the offset is out of bounds.
     */
    checkOffset: function(offset) {
        this.checkIndex(this.index + offset);
    },
    /**
     * Check that the specified index will not be too far.
     * @param {string} newIndex the index to check.
     * @throws {Error} an Error if the index is out of bounds.
     */
    checkIndex: function(newIndex) {
        if (this.length < this.zero + newIndex || newIndex < 0) {
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + (newIndex) + "). Corrupted zip ?");
        }
    },
    /**
     * Change the index.
     * @param {number} newIndex The new index.
     * @throws {Error} if the new index is out of the data.
     */
    setIndex: function(newIndex) {
        this.checkIndex(newIndex);
        this.index = newIndex;
    },
    /**
     * Skip the next n bytes.
     * @param {number} n the number of bytes to skip.
     * @throws {Error} if the new index is out of the data.
     */
    skip: function(n) {
        this.setIndex(this.index + n);
    },
    /**
     * Get the byte at the specified index.
     * @param {number} i the index to use.
     * @return {number} a byte.
     */
    byteAt: function(i) {
        // see implementations
    },
    /**
     * Get the next number with a given byte size.
     * @param {number} size the number of bytes to read.
     * @return {number} the corresponding number.
     */
    readInt: function(size) {
        var result = 0,
            i;
        this.checkOffset(size);
        for (i = this.index + size - 1; i >= this.index; i--) {
            result = (result << 8) + this.byteAt(i);
        }
        this.index += size;
        return result;
    },
    /**
     * Get the next string with a given byte size.
     * @param {number} size the number of bytes to read.
     * @return {string} the corresponding string.
     */
    readString: function(size) {
        return utils.transformTo("string", this.readData(size));
    },
    /**
     * Get raw data without conversion, <size> bytes.
     * @param {number} size the number of bytes to read.
     * @return {Object} the raw data, implementation specific.
     */
    readData: function(size) {
        // see implementations
    },
    /**
     * Find the last occurence of a zip signature (4 bytes).
     * @param {string} sig the signature to find.
     * @return {number} the index of the last occurence, -1 if not found.
     */
    lastIndexOfSignature: function(sig) {
        // see implementations
    },
    /**
     * Read the signature (4 bytes) at the current position and compare it with sig.
     * @param {string} sig the expected signature
     * @return {boolean} true if the signature matches, false otherwise.
     */
    readAndCheckSignature: function(sig) {
        // see implementations
    },
    /**
     * Get the next date.
     * @return {Date} the date.
     */
    readDate: function() {
        var dostime = this.readInt(4);
        return new Date(Date.UTC(
        ((dostime >> 25) & 0x7f) + 1980, // year
        ((dostime >> 21) & 0x0f) - 1, // month
        (dostime >> 16) & 0x1f, // day
        (dostime >> 11) & 0x1f, // hour
        (dostime >> 5) & 0x3f, // minute
        (dostime & 0x1f) << 1)); // second
    }
};
module.exports = DataReader;

},{"../utils":32}],19:[function(require,module,exports){
'use strict';
var Uint8ArrayReader = require('./Uint8ArrayReader');
var utils = require('../utils');

function NodeBufferReader(data) {
    Uint8ArrayReader.call(this, data);
}
utils.inherits(NodeBufferReader, Uint8ArrayReader);

/**
 * @see DataReader.readData
 */
NodeBufferReader.prototype.readData = function(size) {
    this.checkOffset(size);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = NodeBufferReader;

},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(require,module,exports){
'use strict';
var DataReader = require('./DataReader');
var utils = require('../utils');

function StringReader(data) {
    DataReader.call(this, data);
}
utils.inherits(StringReader, DataReader);
/**
 * @see DataReader.byteAt
 */
StringReader.prototype.byteAt = function(i) {
    return this.data.charCodeAt(this.zero + i);
};
/**
 * @see DataReader.lastIndexOfSignature
 */
StringReader.prototype.lastIndexOfSignature = function(sig) {
    return this.data.lastIndexOf(sig) - this.zero;
};
/**
 * @see DataReader.readAndCheckSignature
 */
StringReader.prototype.readAndCheckSignature = function (sig) {
    var data = this.readData(4);
    return sig === data;
};
/**
 * @see DataReader.readData
 */
StringReader.prototype.readData = function(size) {
    this.checkOffset(size);
    // this will work because the constructor applied the "& 0xff" mask.
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = StringReader;

},{"../utils":32,"./DataReader":18}],21:[function(require,module,exports){
'use strict';
var ArrayReader = require('./ArrayReader');
var utils = require('../utils');

function Uint8ArrayReader(data) {
    ArrayReader.call(this, data);
}
utils.inherits(Uint8ArrayReader, ArrayReader);
/**
 * @see DataReader.readData
 */
Uint8ArrayReader.prototype.readData = function(size) {
    this.checkOffset(size);
    if(size === 0) {
        // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].
        return new Uint8Array(0);
    }
    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = Uint8ArrayReader;

},{"../utils":32,"./ArrayReader":17}],22:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var support = require('../support');
var ArrayReader = require('./ArrayReader');
var StringReader = require('./StringReader');
var NodeBufferReader = require('./NodeBufferReader');
var Uint8ArrayReader = require('./Uint8ArrayReader');

/**
 * Create a reader adapted to the data.
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data to read.
 * @return {DataReader} the data reader.
 */
module.exports = function (data) {
    var type = utils.getTypeOf(data);
    utils.checkSupport(type);
    if (type === "string" && !support.uint8array) {
        return new StringReader(data);
    }
    if (type === "nodebuffer") {
        return new NodeBufferReader(data);
    }
    if (support.uint8array) {
        return new Uint8ArrayReader(utils.transformTo("uint8array", data));
    }
    return new ArrayReader(utils.transformTo("array", data));
};

},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(require,module,exports){
'use strict';
exports.LOCAL_FILE_HEADER = "PK\x03\x04";
exports.CENTRAL_FILE_HEADER = "PK\x01\x02";
exports.CENTRAL_DIRECTORY_END = "PK\x05\x06";
exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x06\x07";
exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\x06\x06";
exports.DATA_DESCRIPTOR = "PK\x07\x08";

},{}],24:[function(require,module,exports){
'use strict';

var GenericWorker = require('./GenericWorker');
var utils = require('../utils');

/**
 * A worker which convert chunks to a specified type.
 * @constructor
 * @param {String} destType the destination type.
 */
function ConvertWorker(destType) {
    GenericWorker.call(this, "ConvertWorker to " + destType);
    this.destType = destType;
}
utils.inherits(ConvertWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
ConvertWorker.prototype.processChunk = function (chunk) {
    this.push({
        data : utils.transformTo(this.destType, chunk.data),
        meta : chunk.meta
    });
};
module.exports = ConvertWorker;

},{"../utils":32,"./GenericWorker":28}],25:[function(require,module,exports){
'use strict';

var GenericWorker = require('./GenericWorker');
var crc32 = require('../crc32');
var utils = require('../utils');

/**
 * A worker which calculate the crc32 of the data flowing through.
 * @constructor
 */
function Crc32Probe() {
    GenericWorker.call(this, "Crc32Probe");
    this.withStreamInfo("crc32", 0);
}
utils.inherits(Crc32Probe, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Crc32Probe.prototype.processChunk = function (chunk) {
    this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
    this.push(chunk);
};
module.exports = Crc32Probe;

},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('./GenericWorker');

/**
 * A worker which calculate the total length of the data flowing through.
 * @constructor
 * @param {String} propName the name used to expose the length
 */
function DataLengthProbe(propName) {
    GenericWorker.call(this, "DataLengthProbe for " + propName);
    this.propName = propName;
    this.withStreamInfo(propName, 0);
}
utils.inherits(DataLengthProbe, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
DataLengthProbe.prototype.processChunk = function (chunk) {
    if(chunk) {
        var length = this.streamInfo[this.propName] || 0;
        this.streamInfo[this.propName] = length + chunk.data.length;
    }
    GenericWorker.prototype.processChunk.call(this, chunk);
};
module.exports = DataLengthProbe;


},{"../utils":32,"./GenericWorker":28}],27:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('./GenericWorker');

// the size of the generated chunks
// TODO expose this as a public variable
var DEFAULT_BLOCK_SIZE = 16 * 1024;

/**
 * A worker that reads a content and emits chunks.
 * @constructor
 * @param {Promise} dataP the promise of the data to split
 */
function DataWorker(dataP) {
    GenericWorker.call(this, "DataWorker");
    var self = this;
    this.dataIsReady = false;
    this.index = 0;
    this.max = 0;
    this.data = null;
    this.type = "";

    this._tickScheduled = false;

    dataP.then(function (data) {
        self.dataIsReady = true;
        self.data = data;
        self.max = data && data.length || 0;
        self.type = utils.getTypeOf(data);
        if(!self.isPaused) {
            self._tickAndRepeat();
        }
    }, function (e) {
        self.error(e);
    });
}

utils.inherits(DataWorker, GenericWorker);

/**
 * @see GenericWorker.cleanUp
 */
DataWorker.prototype.cleanUp = function () {
    GenericWorker.prototype.cleanUp.call(this);
    this.data = null;
};

/**
 * @see GenericWorker.resume
 */
DataWorker.prototype.resume = function () {
    if(!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (!this._tickScheduled && this.dataIsReady) {
        this._tickScheduled = true;
        utils.delay(this._tickAndRepeat, [], this);
    }
    return true;
};

/**
 * Trigger a tick a schedule an other call to this function.
 */
DataWorker.prototype._tickAndRepeat = function() {
    this._tickScheduled = false;
    if(this.isPaused || this.isFinished) {
        return;
    }
    this._tick();
    if(!this.isFinished) {
        utils.delay(this._tickAndRepeat, [], this);
        this._tickScheduled = true;
    }
};

/**
 * Read and push a chunk.
 */
DataWorker.prototype._tick = function() {

    if(this.isPaused || this.isFinished) {
        return false;
    }

    var size = DEFAULT_BLOCK_SIZE;
    var data = null, nextIndex = Math.min(this.max, this.index + size);
    if (this.index >= this.max) {
        // EOF
        return this.end();
    } else {
        switch(this.type) {
            case "string":
                data = this.data.substring(this.index, nextIndex);
            break;
            case "uint8array":
                data = this.data.subarray(this.index, nextIndex);
            break;
            case "array":
            case "nodebuffer":
                data = this.data.slice(this.index, nextIndex);
            break;
        }
        this.index = nextIndex;
        return this.push({
            data : data,
            meta : {
                percent : this.max ? this.index / this.max * 100 : 0
            }
        });
    }
};

module.exports = DataWorker;

},{"../utils":32,"./GenericWorker":28}],28:[function(require,module,exports){
'use strict';

/**
 * A worker that does nothing but passing chunks to the next one. This is like
 * a nodejs stream but with some differences. On the good side :
 * - it works on IE 6-9 without any issue / polyfill
 * - it weights less than the full dependencies bundled with browserify
 * - it forwards errors (no need to declare an error handler EVERYWHERE)
 *
 * A chunk is an object with 2 attributes : `meta` and `data`. The former is an
 * object containing anything (`percent` for example), see each worker for more
 * details. The latter is the real data (String, Uint8Array, etc).
 *
 * @constructor
 * @param {String} name the name of the stream (mainly used for debugging purposes)
 */
function GenericWorker(name) {
    // the name of the worker
    this.name = name || "default";
    // an object containing metadata about the workers chain
    this.streamInfo = {};
    // an error which happened when the worker was paused
    this.generatedError = null;
    // an object containing metadata to be merged by this worker into the general metadata
    this.extraStreamInfo = {};
    // true if the stream is paused (and should not do anything), false otherwise
    this.isPaused = true;
    // true if the stream is finished (and should not do anything), false otherwise
    this.isFinished = false;
    // true if the stream is locked to prevent further structure updates (pipe), false otherwise
    this.isLocked = false;
    // the event listeners
    this._listeners = {
        'data':[],
        'end':[],
        'error':[]
    };
    // the previous worker, if any
    this.previous = null;
}

GenericWorker.prototype = {
    /**
     * Push a chunk to the next workers.
     * @param {Object} chunk the chunk to push
     */
    push : function (chunk) {
        this.emit("data", chunk);
    },
    /**
     * End the stream.
     * @return {Boolean} true if this call ended the worker, false otherwise.
     */
    end : function () {
        if (this.isFinished) {
            return false;
        }

        this.flush();
        try {
            this.emit("end");
            this.cleanUp();
            this.isFinished = true;
        } catch (e) {
            this.emit("error", e);
        }
        return true;
    },
    /**
     * End the stream with an error.
     * @param {Error} e the error which caused the premature end.
     * @return {Boolean} true if this call ended the worker with an error, false otherwise.
     */
    error : function (e) {
        if (this.isFinished) {
            return false;
        }

        if(this.isPaused) {
            this.generatedError = e;
        } else {
            this.isFinished = true;

            this.emit("error", e);

            // in the workers chain exploded in the middle of the chain,
            // the error event will go downward but we also need to notify
            // workers upward that there has been an error.
            if(this.previous) {
                this.previous.error(e);
            }

            this.cleanUp();
        }
        return true;
    },
    /**
     * Add a callback on an event.
     * @param {String} name the name of the event (data, end, error)
     * @param {Function} listener the function to call when the event is triggered
     * @return {GenericWorker} the current object for chainability
     */
    on : function (name, listener) {
        this._listeners[name].push(listener);
        return this;
    },
    /**
     * Clean any references when a worker is ending.
     */
    cleanUp : function () {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null;
        this._listeners = [];
    },
    /**
     * Trigger an event. This will call registered callback with the provided arg.
     * @param {String} name the name of the event (data, end, error)
     * @param {Object} arg the argument to call the callback with.
     */
    emit : function (name, arg) {
        if (this._listeners[name]) {
            for(var i = 0; i < this._listeners[name].length; i++) {
                this._listeners[name][i].call(this, arg);
            }
        }
    },
    /**
     * Chain a worker with an other.
     * @param {Worker} next the worker receiving events from the current one.
     * @return {worker} the next worker for chainability
     */
    pipe : function (next) {
        return next.registerPrevious(this);
    },
    /**
     * Same as `pipe` in the other direction.
     * Using an API with `pipe(next)` is very easy.
     * Implementing the API with the point of view of the next one registering
     * a source is easier, see the ZipFileWorker.
     * @param {Worker} previous the previous worker, sending events to this one
     * @return {Worker} the current worker for chainability
     */
    registerPrevious : function (previous) {
        if (this.isLocked) {
            throw new Error("The stream '" + this + "' has already been used.");
        }

        // sharing the streamInfo...
        this.streamInfo = previous.streamInfo;
        // ... and adding our own bits
        this.mergeStreamInfo();
        this.previous =  previous;
        var self = this;
        previous.on('data', function (chunk) {
            self.processChunk(chunk);
        });
        previous.on('end', function () {
            self.end();
        });
        previous.on('error', function (e) {
            self.error(e);
        });
        return this;
    },
    /**
     * Pause the stream so it doesn't send events anymore.
     * @return {Boolean} true if this call paused the worker, false otherwise.
     */
    pause : function () {
        if(this.isPaused || this.isFinished) {
            return false;
        }
        this.isPaused = true;

        if(this.previous) {
            this.previous.pause();
        }
        return true;
    },
    /**
     * Resume a paused stream.
     * @return {Boolean} true if this call resumed the worker, false otherwise.
     */
    resume : function () {
        if(!this.isPaused || this.isFinished) {
            return false;
        }
        this.isPaused = false;

        // if true, the worker tried to resume but failed
        var withError = false;
        if(this.generatedError) {
            this.error(this.generatedError);
            withError = true;
        }
        if(this.previous) {
            this.previous.resume();
        }

        return !withError;
    },
    /**
     * Flush any remaining bytes as the stream is ending.
     */
    flush : function () {},
    /**
     * Process a chunk. This is usually the method overridden.
     * @param {Object} chunk the chunk to process.
     */
    processChunk : function(chunk) {
        this.push(chunk);
    },
    /**
     * Add a key/value to be added in the workers chain streamInfo once activated.
     * @param {String} key the key to use
     * @param {Object} value the associated value
     * @return {Worker} the current worker for chainability
     */
    withStreamInfo : function (key, value) {
        this.extraStreamInfo[key] = value;
        this.mergeStreamInfo();
        return this;
    },
    /**
     * Merge this worker's streamInfo into the chain's streamInfo.
     */
    mergeStreamInfo : function () {
        for(var key in this.extraStreamInfo) {
            if (!this.extraStreamInfo.hasOwnProperty(key)) {
                continue;
            }
            this.streamInfo[key] = this.extraStreamInfo[key];
        }
    },

    /**
     * Lock the stream to prevent further updates on the workers chain.
     * After calling this method, all calls to pipe will fail.
     */
    lock: function () {
        if (this.isLocked) {
            throw new Error("The stream '" + this + "' has already been used.");
        }
        this.isLocked = true;
        if (this.previous) {
            this.previous.lock();
        }
    },

    /**
     *
     * Pretty print the workers chain.
     */
    toString : function () {
        var me = "Worker " + this.name;
        if (this.previous) {
            return this.previous + " -> " + me;
        } else {
            return me;
        }
    }
};

module.exports = GenericWorker;

},{}],29:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var ConvertWorker = require('./ConvertWorker');
var GenericWorker = require('./GenericWorker');
var base64 = require('../base64');
var support = require("../support");
var external = require("../external");

var NodejsStreamOutputAdapter = null;
if (support.nodestream) {
    try {
        NodejsStreamOutputAdapter = require('../nodejs/NodejsStreamOutputAdapter');
    } catch(e) {}
}

/**
 * Apply the final transformation of the data. If the user wants a Blob for
 * example, it's easier to work with an U8intArray and finally do the
 * ArrayBuffer/Blob conversion.
 * @param {String} type the name of the final type
 * @param {String|Uint8Array|Buffer} content the content to transform
 * @param {String} mimeType the mime type of the content, if applicable.
 * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.
 */
function transformZipOutput(type, content, mimeType) {
    switch(type) {
        case "blob" :
            return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);
        case "base64" :
            return base64.encode(content);
        default :
            return utils.transformTo(type, content);
    }
}

/**
 * Concatenate an array of data of the given type.
 * @param {String} type the type of the data in the given array.
 * @param {Array} dataArray the array containing the data chunks to concatenate
 * @return {String|Uint8Array|Buffer} the concatenated data
 * @throws Error if the asked type is unsupported
 */
function concat (type, dataArray) {
    var i, index = 0, res = null, totalLength = 0;
    for(i = 0; i < dataArray.length; i++) {
        totalLength += dataArray[i].length;
    }
    switch(type) {
        case "string":
            return dataArray.join("");
          case "array":
            return Array.prototype.concat.apply([], dataArray);
        case "uint8array":
            res = new Uint8Array(totalLength);
            for(i = 0; i < dataArray.length; i++) {
                res.set(dataArray[i], index);
                index += dataArray[i].length;
            }
            return res;
        case "nodebuffer":
            return Buffer.concat(dataArray);
        default:
            throw new Error("concat : unsupported type '"  + type + "'");
    }
}

/**
 * Listen a StreamHelper, accumulate its content and concatenate it into a
 * complete block.
 * @param {StreamHelper} helper the helper to use.
 * @param {Function} updateCallback a callback called on each update. Called
 * with one arg :
 * - the metadata linked to the update received.
 * @return Promise the promise for the accumulation.
 */
function accumulate(helper, updateCallback) {
    return new external.Promise(function (resolve, reject){
        var dataArray = [];
        var chunkType = helper._internalType,
            resultType = helper._outputType,
            mimeType = helper._mimeType;
        helper
        .on('data', function (data, meta) {
            dataArray.push(data);
            if(updateCallback) {
                updateCallback(meta);
            }
        })
        .on('error', function(err) {
            dataArray = [];
            reject(err);
        })
        .on('end', function (){
            try {
                var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
                resolve(result);
            } catch (e) {
                reject(e);
            }
            dataArray = [];
        })
        .resume();
    });
}

/**
 * An helper to easily use workers outside of JSZip.
 * @constructor
 * @param {Worker} worker the worker to wrap
 * @param {String} outputType the type of data expected by the use
 * @param {String} mimeType the mime type of the content, if applicable.
 */
function StreamHelper(worker, outputType, mimeType) {
    var internalType = outputType;
    switch(outputType) {
        case "blob":
        case "arraybuffer":
            internalType = "uint8array";
        break;
        case "base64":
            internalType = "string";
        break;
    }

    try {
        // the type used internally
        this._internalType = internalType;
        // the type used to output results
        this._outputType = outputType;
        // the mime type
        this._mimeType = mimeType;
        utils.checkSupport(internalType);
        this._worker = worker.pipe(new ConvertWorker(internalType));
        // the last workers can be rewired without issues but we need to
        // prevent any updates on previous workers.
        worker.lock();
    } catch(e) {
        this._worker = new GenericWorker("error");
        this._worker.error(e);
    }
}

StreamHelper.prototype = {
    /**
     * Listen a StreamHelper, accumulate its content and concatenate it into a
     * complete block.
     * @param {Function} updateCb the update callback.
     * @return Promise the promise for the accumulation.
     */
    accumulate : function (updateCb) {
        return accumulate(this, updateCb);
    },
    /**
     * Add a listener on an event triggered on a stream.
     * @param {String} evt the name of the event
     * @param {Function} fn the listener
     * @return {StreamHelper} the current helper.
     */
    on : function (evt, fn) {
        var self = this;

        if(evt === "data") {
            this._worker.on(evt, function (chunk) {
                fn.call(self, chunk.data, chunk.meta);
            });
        } else {
            this._worker.on(evt, function () {
                utils.delay(fn, arguments, self);
            });
        }
        return this;
    },
    /**
     * Resume the flow of chunks.
     * @return {StreamHelper} the current helper.
     */
    resume : function () {
        utils.delay(this._worker.resume, [], this._worker);
        return this;
    },
    /**
     * Pause the flow of chunks.
     * @return {StreamHelper} the current helper.
     */
    pause : function () {
        this._worker.pause();
        return this;
    },
    /**
     * Return a nodejs stream for this helper.
     * @param {Function} updateCb the update callback.
     * @return {NodejsStreamOutputAdapter} the nodejs stream.
     */
    toNodejsStream : function (updateCb) {
        utils.checkSupport("nodestream");
        if (this._outputType !== "nodebuffer") {
            // an object stream containing blob/arraybuffer/uint8array/string
            // is strange and I don't know if it would be useful.
            // I you find this comment and have a good usecase, please open a
            // bug report !
            throw new Error(this._outputType + " is not supported by this method");
        }

        return new NodejsStreamOutputAdapter(this, {
            objectMode : this._outputType !== "nodebuffer"
        }, updateCb);
    }
};


module.exports = StreamHelper;

},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(require,module,exports){
'use strict';

exports.base64 = true;
exports.array = true;
exports.string = true;
exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
exports.nodebuffer = typeof Buffer !== "undefined";
// contains true if JSZip can read/generate Uint8Array, false otherwise.
exports.uint8array = typeof Uint8Array !== "undefined";

if (typeof ArrayBuffer === "undefined") {
    exports.blob = false;
}
else {
    var buffer = new ArrayBuffer(0);
    try {
        exports.blob = new Blob([buffer], {
            type: "application/zip"
        }).size === 0;
    }
    catch (e) {
        try {
            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
            var builder = new Builder();
            builder.append(buffer);
            exports.blob = builder.getBlob('application/zip').size === 0;
        }
        catch (e) {
            exports.blob = false;
        }
    }
}

try {
    exports.nodestream = !!require('readable-stream').Readable;
} catch(e) {
    exports.nodestream = false;
}

},{"readable-stream":16}],31:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var support = require('./support');
var nodejsUtils = require('./nodejsUtils');
var GenericWorker = require('./stream/GenericWorker');

/**
 * The following functions come from pako, from pako/lib/utils/strings
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */

// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new Array(256);
for (var i=0; i<256; i++) {
  _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);
}
_utf8len[254]=_utf8len[254]=1; // Invalid sequence start

// convert string to array (typed, when possible)
var string2buf = function (str) {
    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

    // count binary size
    for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {
            c2 = str.charCodeAt(m_pos+1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
    }

    // allocate buffer
    if (support.uint8array) {
        buf = new Uint8Array(buf_len);
    } else {
        buf = new Array(buf_len);
    }

    // convert
    for (i=0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {
            c2 = str.charCodeAt(m_pos+1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        if (c < 0x80) {
            /* one byte */
            buf[i++] = c;
        } else if (c < 0x800) {
            /* two bytes */
            buf[i++] = 0xC0 | (c >>> 6);
            buf[i++] = 0x80 | (c & 0x3f);
        } else if (c < 0x10000) {
            /* three bytes */
            buf[i++] = 0xE0 | (c >>> 12);
            buf[i++] = 0x80 | (c >>> 6 & 0x3f);
            buf[i++] = 0x80 | (c & 0x3f);
        } else {
            /* four bytes */
            buf[i++] = 0xf0 | (c >>> 18);
            buf[i++] = 0x80 | (c >>> 12 & 0x3f);
            buf[i++] = 0x80 | (c >>> 6 & 0x3f);
            buf[i++] = 0x80 | (c & 0x3f);
        }
    }

    return buf;
};

// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = function(buf, max) {
    var pos;

    max = max || buf.length;
    if (max > buf.length) { max = buf.length; }

    // go back from last position, until start of sequence found
    pos = max-1;
    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

    // Fuckup - very small and broken sequence,
    // return max, because we should return something anyway.
    if (pos < 0) { return max; }

    // If we came to start of buffer - that means vuffer is too small,
    // return max too.
    if (pos === 0) { return max; }

    return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

// convert array to string
var buf2string = function (buf) {
    var str, i, out, c, c_len;
    var len = buf.length;

    // Reserve max possible length (2 words per char)
    // NB: by unknown reasons, Array is significantly faster for
    //     String.fromCharCode.apply than Uint16Array.
    var utf16buf = new Array(len*2);

    for (out=0, i=0; i<len;) {
        c = buf[i++];
        // quick process ascii
        if (c < 0x80) { utf16buf[out++] = c; continue; }

        c_len = _utf8len[c];
        // skip 5 & 6 byte codes
        if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }

        // apply mask on first byte
        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
        // join the rest
        while (c_len > 1 && i < len) {
            c = (c << 6) | (buf[i++] & 0x3f);
            c_len--;
        }

        // terminated by end of string?
        if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

        if (c < 0x10000) {
            utf16buf[out++] = c;
        } else {
            c -= 0x10000;
            utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
            utf16buf[out++] = 0xdc00 | (c & 0x3ff);
        }
    }

    // shrinkBuf(utf16buf, out)
    if (utf16buf.length !== out) {
        if(utf16buf.subarray) {
            utf16buf = utf16buf.subarray(0, out);
        } else {
            utf16buf.length = out;
        }
    }

    // return String.fromCharCode.apply(null, utf16buf);
    return utils.applyFromCharCode(utf16buf);
};


// That's all for the pako functions.


/**
 * Transform a javascript string into an array (typed if possible) of bytes,
 * UTF-8 encoded.
 * @param {String} str the string to encode
 * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.
 */
exports.utf8encode = function utf8encode(str) {
    if (support.nodebuffer) {
        return nodejsUtils.newBufferFrom(str, "utf-8");
    }

    return string2buf(str);
};


/**
 * Transform a bytes array (or a representation) representing an UTF-8 encoded
 * string into a javascript string.
 * @param {Array|Uint8Array|Buffer} buf the data de decode
 * @return {String} the decoded string.
 */
exports.utf8decode = function utf8decode(buf) {
    if (support.nodebuffer) {
        return utils.transformTo("nodebuffer", buf).toString("utf-8");
    }

    buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);

    return buf2string(buf);
};

/**
 * A worker to decode utf8 encoded binary chunks into string chunks.
 * @constructor
 */
function Utf8DecodeWorker() {
    GenericWorker.call(this, "utf-8 decode");
    // the last bytes if a chunk didn't end with a complete codepoint.
    this.leftOver = null;
}
utils.inherits(Utf8DecodeWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Utf8DecodeWorker.prototype.processChunk = function (chunk) {

    var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);

    // 1st step, re-use what's left of the previous chunk
    if (this.leftOver && this.leftOver.length) {
        if(support.uint8array) {
            var previousData = data;
            data = new Uint8Array(previousData.length + this.leftOver.length);
            data.set(this.leftOver, 0);
            data.set(previousData, this.leftOver.length);
        } else {
            data = this.leftOver.concat(data);
        }
        this.leftOver = null;
    }

    var nextBoundary = utf8border(data);
    var usableData = data;
    if (nextBoundary !== data.length) {
        if (support.uint8array) {
            usableData = data.subarray(0, nextBoundary);
            this.leftOver = data.subarray(nextBoundary, data.length);
        } else {
            usableData = data.slice(0, nextBoundary);
            this.leftOver = data.slice(nextBoundary, data.length);
        }
    }

    this.push({
        data : exports.utf8decode(usableData),
        meta : chunk.meta
    });
};

/**
 * @see GenericWorker.flush
 */
Utf8DecodeWorker.prototype.flush = function () {
    if(this.leftOver && this.leftOver.length) {
        this.push({
            data : exports.utf8decode(this.leftOver),
            meta : {}
        });
        this.leftOver = null;
    }
};
exports.Utf8DecodeWorker = Utf8DecodeWorker;

/**
 * A worker to endcode string chunks into utf8 encoded binary chunks.
 * @constructor
 */
function Utf8EncodeWorker() {
    GenericWorker.call(this, "utf-8 encode");
}
utils.inherits(Utf8EncodeWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Utf8EncodeWorker.prototype.processChunk = function (chunk) {
    this.push({
        data : exports.utf8encode(chunk.data),
        meta : chunk.meta
    });
};
exports.Utf8EncodeWorker = Utf8EncodeWorker;

},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(require,module,exports){
'use strict';

var support = require('./support');
var base64 = require('./base64');
var nodejsUtils = require('./nodejsUtils');
var setImmediate = require('core-js/library/fn/set-immediate');
var external = require("./external");


/**
 * Convert a string that pass as a "binary string": it should represent a byte
 * array but may have > 255 char codes. Be sure to take only the first byte
 * and returns the byte array.
 * @param {String} str the string to transform.
 * @return {Array|Uint8Array} the string in a binary format.
 */
function string2binary(str) {
    var result = null;
    if (support.uint8array) {
      result = new Uint8Array(str.length);
    } else {
      result = new Array(str.length);
    }
    return stringToArrayLike(str, result);
}

/**
 * Create a new blob with the given content and the given type.
 * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use
 * an Uint8Array because the stock browser of android 4 won't accept it (it
 * will be silently converted to a string, "[object Uint8Array]").
 *
 * Use only ONE part to build the blob to avoid a memory leak in IE11 / Edge:
 * when a large amount of Array is used to create the Blob, the amount of
 * memory consumed is nearly 100 times the original data amount.
 *
 * @param {String} type the mime type of the blob.
 * @return {Blob} the created blob.
 */
exports.newBlob = function(part, type) {
    exports.checkSupport("blob");

    try {
        // Blob constructor
        return new Blob([part], {
            type: type
        });
    }
    catch (e) {

        try {
            // deprecated, browser only, old way
            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
            var builder = new Builder();
            builder.append(part);
            return builder.getBlob(type);
        }
        catch (e) {

            // well, fuck ?!
            throw new Error("Bug : can't construct the Blob.");
        }
    }


};
/**
 * The identity function.
 * @param {Object} input the input.
 * @return {Object} the same input.
 */
function identity(input) {
    return input;
}

/**
 * Fill in an array with a string.
 * @param {String} str the string to use.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.
 */
function stringToArrayLike(str, array) {
    for (var i = 0; i < str.length; ++i) {
        array[i] = str.charCodeAt(i) & 0xFF;
    }
    return array;
}

/**
 * An helper for the function arrayLikeToString.
 * This contains static informations and functions that
 * can be optimized by the browser JIT compiler.
 */
var arrayToStringHelper = {
    /**
     * Transform an array of int into a string, chunk by chunk.
     * See the performances notes on arrayLikeToString.
     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
     * @param {String} type the type of the array.
     * @param {Integer} chunk the chunk size.
     * @return {String} the resulting string.
     * @throws Error if the chunk is too big for the stack.
     */
    stringifyByChunk: function(array, type, chunk) {
        var result = [], k = 0, len = array.length;
        // shortcut
        if (len <= chunk) {
            return String.fromCharCode.apply(null, array);
        }
        while (k < len) {
            if (type === "array" || type === "nodebuffer") {
                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
            }
            else {
                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
            }
            k += chunk;
        }
        return result.join("");
    },
    /**
     * Call String.fromCharCode on every item in the array.
     * This is the naive implementation, which generate A LOT of intermediate string.
     * This should be used when everything else fail.
     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
     * @return {String} the result.
     */
    stringifyByChar: function(array){
        var resultStr = "";
        for(var i = 0; i < array.length; i++) {
            resultStr += String.fromCharCode(array[i]);
        }
        return resultStr;
    },
    applyCanBeUsed : {
        /**
         * true if the browser accepts to use String.fromCharCode on Uint8Array
         */
        uint8array : (function () {
            try {
                return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
            } catch (e) {
                return false;
            }
        })(),
        /**
         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
         */
        nodebuffer : (function () {
            try {
                return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
            } catch (e) {
                return false;
            }
        })()
    }
};

/**
 * Transform an array-like object to a string.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
 * @return {String} the result.
 */
function arrayLikeToString(array) {
    // Performances notes :
    // --------------------
    // String.fromCharCode.apply(null, array) is the fastest, see
    // see http://jsperf.com/converting-a-uint8array-to-a-string/2
    // but the stack is limited (and we can get huge arrays !).
    //
    // result += String.fromCharCode(array[i]); generate too many strings !
    //
    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2
    // TODO : we now have workers that split the work. Do we still need that ?
    var chunk = 65536,
        type = exports.getTypeOf(array),
        canUseApply = true;
    if (type === "uint8array") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
    } else if (type === "nodebuffer") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
    }

    if (canUseApply) {
        while (chunk > 1) {
            try {
                return arrayToStringHelper.stringifyByChunk(array, type, chunk);
            } catch (e) {
                chunk = Math.floor(chunk / 2);
            }
        }
    }

    // no apply or chunk error : slow and painful algorithm
    // default browser on android 4.*
    return arrayToStringHelper.stringifyByChar(array);
}

exports.applyFromCharCode = arrayLikeToString;


/**
 * Copy the data from an array-like to an other array-like.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.
 */
function arrayLikeToArrayLike(arrayFrom, arrayTo) {
    for (var i = 0; i < arrayFrom.length; i++) {
        arrayTo[i] = arrayFrom[i];
    }
    return arrayTo;
}

// a matrix containing functions to transform everything into everything.
var transform = {};

// string to ?
transform["string"] = {
    "string": identity,
    "array": function(input) {
        return stringToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
        return transform["string"]["uint8array"](input).buffer;
    },
    "uint8array": function(input) {
        return stringToArrayLike(input, new Uint8Array(input.length));
    },
    "nodebuffer": function(input) {
        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
    }
};

// array to ?
transform["array"] = {
    "string": arrayLikeToString,
    "array": identity,
    "arraybuffer": function(input) {
        return (new Uint8Array(input)).buffer;
    },
    "uint8array": function(input) {
        return new Uint8Array(input);
    },
    "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(input);
    }
};

// arraybuffer to ?
transform["arraybuffer"] = {
    "string": function(input) {
        return arrayLikeToString(new Uint8Array(input));
    },
    "array": function(input) {
        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
    },
    "arraybuffer": identity,
    "uint8array": function(input) {
        return new Uint8Array(input);
    },
    "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(new Uint8Array(input));
    }
};

// uint8array to ?
transform["uint8array"] = {
    "string": arrayLikeToString,
    "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
        return input.buffer;
    },
    "uint8array": identity,
    "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(input);
    }
};

// nodebuffer to ?
transform["nodebuffer"] = {
    "string": arrayLikeToString,
    "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
        return transform["nodebuffer"]["uint8array"](input).buffer;
    },
    "uint8array": function(input) {
        return arrayLikeToArrayLike(input, new Uint8Array(input.length));
    },
    "nodebuffer": identity
};

/**
 * Transform an input into any type.
 * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.
 * If no output type is specified, the unmodified input will be returned.
 * @param {String} outputType the output type.
 * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.
 * @throws {Error} an Error if the browser doesn't support the requested output type.
 */
exports.transformTo = function(outputType, input) {
    if (!input) {
        // undefined, null, etc
        // an empty string won't harm.
        input = "";
    }
    if (!outputType) {
        return input;
    }
    exports.checkSupport(outputType);
    var inputType = exports.getTypeOf(input);
    var result = transform[inputType][outputType](input);
    return result;
};

/**
 * Return the type of the input.
 * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.
 * @param {Object} input the input to identify.
 * @return {String} the (lowercase) type of the input.
 */
exports.getTypeOf = function(input) {
    if (typeof input === "string") {
        return "string";
    }
    if (Object.prototype.toString.call(input) === "[object Array]") {
        return "array";
    }
    if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
        return "nodebuffer";
    }
    if (support.uint8array && input instanceof Uint8Array) {
        return "uint8array";
    }
    if (support.arraybuffer && input instanceof ArrayBuffer) {
        return "arraybuffer";
    }
};

/**
 * Throw an exception if the type is not supported.
 * @param {String} type the type to check.
 * @throws {Error} an Error if the browser doesn't support the requested type.
 */
exports.checkSupport = function(type) {
    var supported = support[type.toLowerCase()];
    if (!supported) {
        throw new Error(type + " is not supported by this platform");
    }
};

exports.MAX_VALUE_16BITS = 65535;
exports.MAX_VALUE_32BITS = -1; // well, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" is parsed as -1

/**
 * Prettify a string read as binary.
 * @param {string} str the string to prettify.
 * @return {string} a pretty string.
 */
exports.pretty = function(str) {
    var res = '',
        code, i;
    for (i = 0; i < (str || "").length; i++) {
        code = str.charCodeAt(i);
        res += '\\x' + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
    }
    return res;
};

/**
 * Defer the call of a function.
 * @param {Function} callback the function to call asynchronously.
 * @param {Array} args the arguments to give to the callback.
 */
exports.delay = function(callback, args, self) {
    setImmediate(function () {
        callback.apply(self || null, args || []);
    });
};

/**
 * Extends a prototype with an other, without calling a constructor with
 * side effects. Inspired by nodejs' `utils.inherits`
 * @param {Function} ctor the constructor to augment
 * @param {Function} superCtor the parent constructor to use
 */
exports.inherits = function (ctor, superCtor) {
    var Obj = function() {};
    Obj.prototype = superCtor.prototype;
    ctor.prototype = new Obj();
};

/**
 * Merge the objects passed as parameters into a new one.
 * @private
 * @param {...Object} var_args All objects to merge.
 * @return {Object} a new object with the data of the others.
 */
exports.extend = function() {
    var result = {}, i, attr;
    for (i = 0; i < arguments.length; i++) { // arguments is not enumerable in some browsers
        for (attr in arguments[i]) {
            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
                result[attr] = arguments[i][attr];
            }
        }
    }
    return result;
};

/**
 * Transform arbitrary content into a Promise.
 * @param {String} name a name for the content being processed.
 * @param {Object} inputData the content to process.
 * @param {Boolean} isBinary true if the content is not an unicode string
 * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.
 * @param {Boolean} isBase64 true if the string content is encoded with base64.
 * @return {Promise} a promise in a format usable by JSZip.
 */
exports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {

    // if inputData is already a promise, this flatten it.
    var promise = external.Promise.resolve(inputData).then(function(data) {
        
        
        var isBlob = support.blob && (data instanceof Blob || ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString.call(data)) !== -1);

        if (isBlob && typeof FileReader !== "undefined") {
            return new external.Promise(function (resolve, reject) {
                var reader = new FileReader();

                reader.onload = function(e) {
                    resolve(e.target.result);
                };
                reader.onerror = function(e) {
                    reject(e.target.error);
                };
                reader.readAsArrayBuffer(data);
            });
        } else {
            return data;
        }
    });

    return promise.then(function(data) {
        var dataType = exports.getTypeOf(data);

        if (!dataType) {
            return external.Promise.reject(
                new Error("Can't read the data of '" + name + "'. Is it " +
                          "in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")
            );
        }
        // special case : it's way easier to work with Uint8Array than with ArrayBuffer
        if (dataType === "arraybuffer") {
            data = exports.transformTo("uint8array", data);
        } else if (dataType === "string") {
            if (isBase64) {
                data = base64.decode(data);
            }
            else if (isBinary) {
                // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask
                if (isOptimizedBinaryString !== true) {
                    // this is a string, not in a base64 format.
                    // Be sure that this is a correct "binary string"
                    data = string2binary(data);
                }
            }
        }
        return data;
    });
};

},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,"core-js/library/fn/set-immediate":36}],33:[function(require,module,exports){
'use strict';
var readerFor = require('./reader/readerFor');
var utils = require('./utils');
var sig = require('./signature');
var ZipEntry = require('./zipEntry');
var utf8 = require('./utf8');
var support = require('./support');
//  class ZipEntries {{{
/**
 * All the entries in the zip file.
 * @constructor
 * @param {Object} loadOptions Options for loading the stream.
 */
function ZipEntries(loadOptions) {
    this.files = [];
    this.loadOptions = loadOptions;
}
ZipEntries.prototype = {
    /**
     * Check that the reader is on the specified signature.
     * @param {string} expectedSignature the expected signature.
     * @throws {Error} if it is an other signature.
     */
    checkSignature: function(expectedSignature) {
        if (!this.reader.readAndCheckSignature(expectedSignature)) {
            this.reader.index -= 4;
            var signature = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
        }
    },
    /**
     * Check if the given signature is at the given index.
     * @param {number} askedIndex the index to check.
     * @param {string} expectedSignature the signature to expect.
     * @return {boolean} true if the signature is here, false otherwise.
     */
    isSignature: function(askedIndex, expectedSignature) {
        var currentIndex = this.reader.index;
        this.reader.setIndex(askedIndex);
        var signature = this.reader.readString(4);
        var result = signature === expectedSignature;
        this.reader.setIndex(currentIndex);
        return result;
    },
    /**
     * Read the end of the central directory.
     */
    readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2);
        this.diskWithCentralDirStart = this.reader.readInt(2);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
        this.centralDirRecords = this.reader.readInt(2);
        this.centralDirSize = this.reader.readInt(4);
        this.centralDirOffset = this.reader.readInt(4);

        this.zipCommentLength = this.reader.readInt(2);
        // warning : the encoding depends of the system locale
        // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.
        // On a windows machine, this field is encoded with the localized windows code page.
        var zipComment = this.reader.readData(this.zipCommentLength);
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        // To get consistent behavior with the generation part, we will assume that
        // this is utf8 encoded unless specified otherwise.
        var decodeContent = utils.transformTo(decodeParamType, zipComment);
        this.zipComment = this.loadOptions.decodeFileName(decodeContent);
    },
    /**
     * Read the end of the Zip 64 central directory.
     * Not merged with the method readEndOfCentral :
     * The end of central can coexist with its Zip64 brother,
     * I don't want to read the wrong number of bytes !
     */
    readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8);
        this.reader.skip(4);
        // this.versionMadeBy = this.reader.readString(2);
        // this.versionNeeded = this.reader.readInt(2);
        this.diskNumber = this.reader.readInt(4);
        this.diskWithCentralDirStart = this.reader.readInt(4);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
        this.centralDirRecords = this.reader.readInt(8);
        this.centralDirSize = this.reader.readInt(8);
        this.centralDirOffset = this.reader.readInt(8);

        this.zip64ExtensibleData = {};
        var extraDataSize = this.zip64EndOfCentralSize - 44,
            index = 0,
            extraFieldId,
            extraFieldLength,
            extraFieldValue;
        while (index < extraDataSize) {
            extraFieldId = this.reader.readInt(2);
            extraFieldLength = this.reader.readInt(4);
            extraFieldValue = this.reader.readData(extraFieldLength);
            this.zip64ExtensibleData[extraFieldId] = {
                id: extraFieldId,
                length: extraFieldLength,
                value: extraFieldValue
            };
        }
    },
    /**
     * Read the end of the Zip 64 central directory locator.
     */
    readBlockZip64EndOfCentralLocator: function() {
        this.diskWithZip64CentralDirStart = this.reader.readInt(4);
        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
        this.disksCount = this.reader.readInt(4);
        if (this.disksCount > 1) {
            throw new Error("Multi-volumes zip are not supported");
        }
    },
    /**
     * Read the local files, based on the offset read in the central part.
     */
    readLocalFiles: function() {
        var i, file;
        for (i = 0; i < this.files.length; i++) {
            file = this.files[i];
            this.reader.setIndex(file.localHeaderOffset);
            this.checkSignature(sig.LOCAL_FILE_HEADER);
            file.readLocalPart(this.reader);
            file.handleUTF8();
            file.processAttributes();
        }
    },
    /**
     * Read the central directory.
     */
    readCentralDir: function() {
        var file;

        this.reader.setIndex(this.centralDirOffset);
        while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
            file = new ZipEntry({
                zip64: this.zip64
            }, this.loadOptions);
            file.readCentralPart(this.reader);
            this.files.push(file);
        }

        if (this.centralDirRecords !== this.files.length) {
            if (this.centralDirRecords !== 0 && this.files.length === 0) {
                // We expected some records but couldn't find ANY.
                // This is really suspicious, as if something went wrong.
                throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
            } else {
                // We found some records but not all.
                // Something is wrong but we got something for the user: no error here.
                // console.warn("expected", this.centralDirRecords, "records in central dir, got", this.files.length);
            }
        }
    },
    /**
     * Read the end of central directory.
     */
    readEndOfCentral: function() {
        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
        if (offset < 0) {
            // Check if the content is a truncated zip or complete garbage.
            // A "LOCAL_FILE_HEADER" is not required at the beginning (auto
            // extractible zip for example) but it can give a good hint.
            // If an ajax request was used without responseType, we will also
            // get unreadable data.
            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);

            if (isGarbage) {
                throw new Error("Can't find end of central directory : is this a zip file ? " +
                                "If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
            } else {
                throw new Error("Corrupted zip: can't find end of central directory");
            }

        }
        this.reader.setIndex(offset);
        var endOfCentralDirOffset = offset;
        this.checkSignature(sig.CENTRAL_DIRECTORY_END);
        this.readBlockEndOfCentral();


        /* extract from the zip spec :
            4)  If one of the fields in the end of central directory
                record is too small to hold required data, the field
                should be set to -1 (0xFFFF or 0xFFFFFFFF) and the
                ZIP64 format record should be created.
            5)  The end of central directory record and the
                Zip64 end of central directory locator record must
                reside on the same disk when splitting or spanning
                an archive.
         */
        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
            this.zip64 = true;

            /*
            Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from
            the zip file can fit into a 32bits integer. This cannot be solved : JavaScript represents
            all numbers as 64-bit double precision IEEE 754 floating point numbers.
            So, we have 53bits for integers and bitwise operations treat everything as 32bits.
            see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators
            and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5
            */

            // should look for a zip64 EOCD locator
            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            if (offset < 0) {
                throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            }
            this.reader.setIndex(offset);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            this.readBlockZip64EndOfCentralLocator();

            // now the zip64 EOCD record
            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
                // console.warn("ZIP64 end of central directory not where expected.");
                this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
                if (this.relativeOffsetEndOfZip64CentralDir < 0) {
                    throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                }
            }
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            this.readBlockZip64EndOfCentral();
        }

        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
        if (this.zip64) {
            expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator
            expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */ + this.zip64EndOfCentralSize;
        }

        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;

        if (extraBytes > 0) {
            // console.warn(extraBytes, "extra bytes at beginning or within zipfile");
            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
                // The offsets seem wrong, but we have something at the specified offset.
                // So we keep it.
            } else {
                // the offset is wrong, update the "zero" of the reader
                // this happens if data has been prepended (crx files for example)
                this.reader.zero = extraBytes;
            }
        } else if (extraBytes < 0) {
            throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
        }
    },
    prepareReader: function(data) {
        this.reader = readerFor(data);
    },
    /**
     * Read a zip file and create ZipEntries.
     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
     */
    load: function(data) {
        this.prepareReader(data);
        this.readEndOfCentral();
        this.readCentralDir();
        this.readLocalFiles();
    }
};
// }}} end of ZipEntries
module.exports = ZipEntries;

},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utf8":31,"./utils":32,"./zipEntry":34}],34:[function(require,module,exports){
'use strict';
var readerFor = require('./reader/readerFor');
var utils = require('./utils');
var CompressedObject = require('./compressedObject');
var crc32fn = require('./crc32');
var utf8 = require('./utf8');
var compressions = require('./compressions');
var support = require('./support');

var MADE_BY_DOS = 0x00;
var MADE_BY_UNIX = 0x03;

/**
 * Find a compression registered in JSZip.
 * @param {string} compressionMethod the method magic to find.
 * @return {Object|null} the JSZip compression object, null if none found.
 */
var findCompression = function(compressionMethod) {
    for (var method in compressions) {
        if (!compressions.hasOwnProperty(method)) {
            continue;
        }
        if (compressions[method].magic === compressionMethod) {
            return compressions[method];
        }
    }
    return null;
};

// class ZipEntry {{{
/**
 * An entry in the zip file.
 * @constructor
 * @param {Object} options Options of the current file.
 * @param {Object} loadOptions Options for loading the stream.
 */
function ZipEntry(options, loadOptions) {
    this.options = options;
    this.loadOptions = loadOptions;
}
ZipEntry.prototype = {
    /**
     * say if the file is encrypted.
     * @return {boolean} true if the file is encrypted, false otherwise.
     */
    isEncrypted: function() {
        // bit 1 is set
        return (this.bitFlag & 0x0001) === 0x0001;
    },
    /**
     * say if the file has utf-8 filename/comment.
     * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
     */
    useUTF8: function() {
        // bit 11 is set
        return (this.bitFlag & 0x0800) === 0x0800;
    },
    /**
     * Read the local part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readLocalPart: function(reader) {
        var compression, localExtraFieldsLength;

        // we already know everything from the central dir !
        // If the central dir data are false, we are doomed.
        // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.
        // The less data we get here, the more reliable this should be.
        // Let's skip the whole header and dash to the data !
        reader.skip(22);
        // in some zip created on windows, the filename stored in the central dir contains \ instead of /.
        // Strangely, the filename here is OK.
        // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes
        // or APPNOTE#4.4.17.1, "All slashes MUST be forward slashes '/'") but there are a lot of bad zip generators...
        // Search "unzip mismatching "local" filename continuing with "central" filename version" on
        // the internet.
        //
        // I think I see the logic here : the central directory is used to display
        // content and the local directory is used to extract the files. Mixing / and \
        // may be used to display \ to windows users and use / when extracting the files.
        // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394
        this.fileNameLength = reader.readInt(2);
        localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir
        // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.
        this.fileName = reader.readData(this.fileNameLength);
        reader.skip(localExtraFieldsLength);

        if (this.compressedSize === -1 || this.uncompressedSize === -1) {
            throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " + "(compressedSize === -1 || uncompressedSize === -1)");
        }

        compression = findCompression(this.compressionMethod);
        if (compression === null) { // no compression found
            throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
        }
        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
    },

    /**
     * Read the central part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readCentralPart: function(reader) {
        this.versionMadeBy = reader.readInt(2);
        reader.skip(2);
        // this.versionNeeded = reader.readInt(2);
        this.bitFlag = reader.readInt(2);
        this.compressionMethod = reader.readString(2);
        this.date = reader.readDate();
        this.crc32 = reader.readInt(4);
        this.compressedSize = reader.readInt(4);
        this.uncompressedSize = reader.readInt(4);
        var fileNameLength = reader.readInt(2);
        this.extraFieldsLength = reader.readInt(2);
        this.fileCommentLength = reader.readInt(2);
        this.diskNumberStart = reader.readInt(2);
        this.internalFileAttributes = reader.readInt(2);
        this.externalFileAttributes = reader.readInt(4);
        this.localHeaderOffset = reader.readInt(4);

        if (this.isEncrypted()) {
            throw new Error("Encrypted zip are not supported");
        }

        // will be read in the local part, see the comments there
        reader.skip(fileNameLength);
        this.readExtraFields(reader);
        this.parseZIP64ExtraField(reader);
        this.fileComment = reader.readData(this.fileCommentLength);
    },

    /**
     * Parse the external file attributes and get the unix/dos permissions.
     */
    processAttributes: function () {
        this.unixPermissions = null;
        this.dosPermissions = null;
        var madeBy = this.versionMadeBy >> 8;

        // Check if we have the DOS directory flag set.
        // We look for it in the DOS and UNIX permissions
        // but some unknown platform could set it as a compatibility flag.
        this.dir = this.externalFileAttributes & 0x0010 ? true : false;

        if(madeBy === MADE_BY_DOS) {
            // first 6 bits (0 to 5)
            this.dosPermissions = this.externalFileAttributes & 0x3F;
        }

        if(madeBy === MADE_BY_UNIX) {
            this.unixPermissions = (this.externalFileAttributes >> 16) & 0xFFFF;
            // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);
        }

        // fail safe : if the name ends with a / it probably means a folder
        if (!this.dir && this.fileNameStr.slice(-1) === '/') {
            this.dir = true;
        }
    },

    /**
     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
     * @param {DataReader} reader the reader to use.
     */
    parseZIP64ExtraField: function(reader) {

        if (!this.extraFields[0x0001]) {
            return;
        }

        // should be something, preparing the extra reader
        var extraReader = readerFor(this.extraFields[0x0001].value);

        // I really hope that these 64bits integer can fit in 32 bits integer, because js
        // won't let us have more.
        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
            this.uncompressedSize = extraReader.readInt(8);
        }
        if (this.compressedSize === utils.MAX_VALUE_32BITS) {
            this.compressedSize = extraReader.readInt(8);
        }
        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
            this.localHeaderOffset = extraReader.readInt(8);
        }
        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
            this.diskNumberStart = extraReader.readInt(4);
        }
    },
    /**
     * Read the central part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readExtraFields: function(reader) {
        var end = reader.index + this.extraFieldsLength,
            extraFieldId,
            extraFieldLength,
            extraFieldValue;

        if (!this.extraFields) {
            this.extraFields = {};
        }

        while (reader.index < end) {
            extraFieldId = reader.readInt(2);
            extraFieldLength = reader.readInt(2);
            extraFieldValue = reader.readData(extraFieldLength);

            this.extraFields[extraFieldId] = {
                id: extraFieldId,
                length: extraFieldLength,
                value: extraFieldValue
            };
        }
    },
    /**
     * Apply an UTF8 transformation if needed.
     */
    handleUTF8: function() {
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) {
            this.fileNameStr = utf8.utf8decode(this.fileName);
            this.fileCommentStr = utf8.utf8decode(this.fileComment);
        } else {
            var upath = this.findExtraFieldUnicodePath();
            if (upath !== null) {
                this.fileNameStr = upath;
            } else {
                // ASCII text or unsupported code page
                var fileNameByteArray =  utils.transformTo(decodeParamType, this.fileName);
                this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
            }

            var ucomment = this.findExtraFieldUnicodeComment();
            if (ucomment !== null) {
                this.fileCommentStr = ucomment;
            } else {
                // ASCII text or unsupported code page
                var commentByteArray =  utils.transformTo(decodeParamType, this.fileComment);
                this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
            }
        }
    },

    /**
     * Find the unicode path declared in the extra field, if any.
     * @return {String} the unicode path, null otherwise.
     */
    findExtraFieldUnicodePath: function() {
        var upathField = this.extraFields[0x7075];
        if (upathField) {
            var extraReader = readerFor(upathField.value);

            // wrong version
            if (extraReader.readInt(1) !== 1) {
                return null;
            }

            // the crc of the filename changed, this field is out of date.
            if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
                return null;
            }

            return utf8.utf8decode(extraReader.readData(upathField.length - 5));
        }
        return null;
    },

    /**
     * Find the unicode comment declared in the extra field, if any.
     * @return {String} the unicode comment, null otherwise.
     */
    findExtraFieldUnicodeComment: function() {
        var ucommentField = this.extraFields[0x6375];
        if (ucommentField) {
            var extraReader = readerFor(ucommentField.value);

            // wrong version
            if (extraReader.readInt(1) !== 1) {
                return null;
            }

            // the crc of the comment changed, this field is out of date.
            if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
                return null;
            }

            return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
        }
        return null;
    }
};
module.exports = ZipEntry;

},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(require,module,exports){
'use strict';

var StreamHelper = require('./stream/StreamHelper');
var DataWorker = require('./stream/DataWorker');
var utf8 = require('./utf8');
var CompressedObject = require('./compressedObject');
var GenericWorker = require('./stream/GenericWorker');

/**
 * A simple object representing a file in the zip file.
 * @constructor
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data
 * @param {Object} options the options of the file
 */
var ZipObject = function(name, data, options) {
    this.name = name;
    this.dir = options.dir;
    this.date = options.date;
    this.comment = options.comment;
    this.unixPermissions = options.unixPermissions;
    this.dosPermissions = options.dosPermissions;

    this._data = data;
    this._dataBinary = options.binary;
    // keep only the compression
    this.options = {
        compression : options.compression,
        compressionOptions : options.compressionOptions
    };
};

ZipObject.prototype = {
    /**
     * Create an internal stream for the content of this object.
     * @param {String} type the type of each chunk.
     * @return StreamHelper the stream.
     */
    internalStream: function (type) {
        var result = null, outputType = "string";
        try {
            if (!type) {
                throw new Error("No output type specified.");
            }
            outputType = type.toLowerCase();
            var askUnicodeString = outputType === "string" || outputType === "text";
            if (outputType === "binarystring" || outputType === "text") {
                outputType = "string";
            }
            result = this._decompressWorker();

            var isUnicodeString = !this._dataBinary;

            if (isUnicodeString && !askUnicodeString) {
                result = result.pipe(new utf8.Utf8EncodeWorker());
            }
            if (!isUnicodeString && askUnicodeString) {
                result = result.pipe(new utf8.Utf8DecodeWorker());
            }
        } catch (e) {
            result = new GenericWorker("error");
            result.error(e);
        }

        return new StreamHelper(result, outputType, "");
    },

    /**
     * Prepare the content in the asked type.
     * @param {String} type the type of the result.
     * @param {Function} onUpdate a function to call on each internal update.
     * @return Promise the promise of the result.
     */
    async: function (type, onUpdate) {
        return this.internalStream(type).accumulate(onUpdate);
    },

    /**
     * Prepare the content as a nodejs stream.
     * @param {String} type the type of each chunk.
     * @param {Function} onUpdate a function to call on each internal update.
     * @return Stream the stream.
     */
    nodeStream: function (type, onUpdate) {
        return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
    },

    /**
     * Return a worker for the compressed content.
     * @private
     * @param {Object} compression the compression object to use.
     * @param {Object} compressionOptions the options to use when compressing.
     * @return Worker the worker.
     */
    _compressWorker: function (compression, compressionOptions) {
        if (
            this._data instanceof CompressedObject &&
            this._data.compression.magic === compression.magic
        ) {
            return this._data.getCompressedWorker();
        } else {
            var result = this._decompressWorker();
            if(!this._dataBinary) {
                result = result.pipe(new utf8.Utf8EncodeWorker());
            }
            return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
        }
    },
    /**
     * Return a worker for the decompressed content.
     * @private
     * @return Worker the worker.
     */
    _decompressWorker : function () {
        if (this._data instanceof CompressedObject) {
            return this._data.getContentWorker();
        } else if (this._data instanceof GenericWorker) {
            return this._data;
        } else {
            return new DataWorker(this._data);
        }
    }
};

var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
var removedFn = function () {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
};

for(var i = 0; i < removedMethods.length; i++) {
    ZipObject.prototype[removedMethods[i]] = removedFn;
}
module.exports = ZipObject;

},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(require,module,exports){
require('../modules/web.immediate');
module.exports = require('../modules/_core').setImmediate;
},{"../modules/_core":40,"../modules/web.immediate":56}],37:[function(require,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],38:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./_is-object":51}],39:[function(require,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],40:[function(require,module,exports){
var core = module.exports = {version: '2.3.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],41:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./_a-function":37}],42:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_fails":45}],43:[function(require,module,exports){
var isObject = require('./_is-object')
  , document = require('./_global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./_global":46,"./_is-object":51}],44:[function(require,module,exports){
var global    = require('./_global')
  , core      = require('./_core')
  , ctx       = require('./_ctx')
  , hide      = require('./_hide')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , IS_WRAP   = type & $export.W
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE]
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(a, b, c){
        if(this instanceof C){
          switch(arguments.length){
            case 0: return new C;
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if(IS_PROTO){
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;
},{"./_core":40,"./_ctx":41,"./_global":46,"./_hide":47}],45:[function(require,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],46:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],47:[function(require,module,exports){
var dP         = require('./_object-dp')
  , createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./_descriptors":42,"./_object-dp":52,"./_property-desc":53}],48:[function(require,module,exports){
module.exports = require('./_global').document && document.documentElement;
},{"./_global":46}],49:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function(){
  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_descriptors":42,"./_dom-create":43,"./_fails":45}],50:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return              fn.apply(that, args);
};
},{}],51:[function(require,module,exports){
module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};
},{}],52:[function(require,module,exports){
var anObject       = require('./_an-object')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , toPrimitive    = require('./_to-primitive')
  , dP             = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};
},{"./_an-object":38,"./_descriptors":42,"./_ie8-dom-define":49,"./_to-primitive":55}],53:[function(require,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],54:[function(require,module,exports){
var ctx                = require('./_ctx')
  , invoke             = require('./_invoke')
  , html               = require('./_html')
  , cel                = require('./_dom-create')
  , global             = require('./_global')
  , process            = global.process
  , setTask            = global.setImmediate
  , clearTask          = global.clearImmediate
  , MessageChannel     = global.MessageChannel
  , counter            = 0
  , queue              = {}
  , ONREADYSTATECHANGE = 'onreadystatechange'
  , defer, channel, port;
var run = function(){
  var id = +this;
  if(queue.hasOwnProperty(id)){
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function(event){
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!setTask || !clearTask){
  setTask = function setImmediate(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id){
    delete queue[id];
  };
  // Node.js 0.8-
  if(require('./_cof')(process) == 'process'){
    defer = function(id){
      process.nextTick(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if(MessageChannel){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
    defer = function(id){
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if(ONREADYSTATECHANGE in cel('script')){
    defer = function(id){
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set:   setTask,
  clear: clearTask
};
},{"./_cof":39,"./_ctx":41,"./_dom-create":43,"./_global":46,"./_html":48,"./_invoke":50}],55:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};
},{"./_is-object":51}],56:[function(require,module,exports){
var $export = require('./_export')
  , $task   = require('./_task');
$export($export.G + $export.B, {
  setImmediate:   $task.set,
  clearImmediate: $task.clear
});
},{"./_export":44,"./_task":54}],57:[function(require,module,exports){
(function (global){
'use strict';
var Mutation = global.MutationObserver || global.WebKitMutationObserver;

var scheduleDrain;

{
  if (Mutation) {
    var called = 0;
    var observer = new Mutation(nextTick);
    var element = global.document.createTextNode('');
    observer.observe(element, {
      characterData: true
    });
    scheduleDrain = function () {
      element.data = (called = ++called % 2);
    };
  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = nextTick;
    scheduleDrain = function () {
      channel.port2.postMessage(0);
    };
  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
    scheduleDrain = function () {

      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var scriptEl = global.document.createElement('script');
      scriptEl.onreadystatechange = function () {
        nextTick();

        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };
      global.document.documentElement.appendChild(scriptEl);
    };
  } else {
    scheduleDrain = function () {
      setTimeout(nextTick, 0);
    };
  }
}

var draining;
var queue = [];
//named nextTick for less confusing stack traces
function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;
  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;
    while (++i < len) {
      oldQueue[i]();
    }
    len = queue.length;
  }
  draining = false;
}

module.exports = immediate;
function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],58:[function(require,module,exports){
'use strict';
var immediate = require('immediate');

/* istanbul ignore next */
function INTERNAL() {}

var handlers = {};

var REJECTED = ['REJECTED'];
var FULFILLED = ['FULFILLED'];
var PENDING = ['PENDING'];

module.exports = Promise;

function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('resolver must be a function');
  }
  this.state = PENDING;
  this.queue = [];
  this.outcome = void 0;
  if (resolver !== INTERNAL) {
    safelyResolveThenable(this, resolver);
  }
}

Promise.prototype["catch"] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
    typeof onRejected !== 'function' && this.state === REJECTED) {
    return this;
  }
  var promise = new this.constructor(INTERNAL);
  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }
  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}
QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};
QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};
QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};
QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }
    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}

handlers.resolve = function (self, value) {
  var result = tryCatch(getThen, value);
  if (result.status === 'error') {
    return handlers.reject(self, result.value);
  }
  var thenable = result.value;

  if (thenable) {
    safelyResolveThenable(self, thenable);
  } else {
    self.state = FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;
    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }
  return self;
};
handlers.reject = function (self, error) {
  self.state = REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;
  while (++i < len) {
    self.queue[i].callRejected(error);
  }
  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;
  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}

function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;
  function onError(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }

  var result = tryCatch(tryToUnwrap);
  if (result.status === 'error') {
    onError(result.value);
  }
}

function tryCatch(func, value) {
  var out = {};
  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }
  return out;
}

Promise.resolve = resolve;
function resolve(value) {
  if (value instanceof this) {
    return value;
  }
  return handlers.resolve(new this(INTERNAL), value);
}

Promise.reject = reject;
function reject(reason) {
  var promise = new this(INTERNAL);
  return handlers.reject(promise, reason);
}

Promise.all = all;
function all(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    allResolver(iterable[i], i);
  }
  return promise;
  function allResolver(value, i) {
    self.resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
    function resolveFromAll(outValue) {
      values[i] = outValue;
      if (++resolved === len && !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}

Promise.race = race;
function race(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    resolver(iterable[i]);
  }
  return promise;
  function resolver(value) {
    self.resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}

},{"immediate":57}],59:[function(require,module,exports){
// Top level file is just a mixin of submodules & constants
'use strict';

var assign    = require('./lib/utils/common').assign;

var deflate   = require('./lib/deflate');
var inflate   = require('./lib/inflate');
var constants = require('./lib/zlib/constants');

var pako = {};

assign(pako, deflate, inflate, constants);

module.exports = pako;

},{"./lib/deflate":60,"./lib/inflate":61,"./lib/utils/common":62,"./lib/zlib/constants":65}],60:[function(require,module,exports){
'use strict';


var zlib_deflate = require('./zlib/deflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH      = 0;
var Z_FINISH        = 4;

var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_SYNC_FLUSH    = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY    = 0;

var Z_DEFLATED  = 8;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overriden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) { return false; }

  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;

},{"./utils/common":62,"./utils/strings":63,"./zlib/deflate":67,"./zlib/messages":72,"./zlib/zstream":74}],61:[function(require,module,exports){
'use strict';


var zlib_inflate = require('./zlib/inflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var c            = require('./zlib/constants');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');
var GZheader     = require('./zlib/gzheader');

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overriden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var dict;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      // Convert data if needed
      if (typeof dictionary === 'string') {
        dict = strings.string2buf(dictionary);
      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(dictionary);
      } else {
        dict = dictionary;
      }

      status = zlib_inflate.inflateSetDictionary(this.strm, dict);

    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 alligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip  = inflate;

},{"./utils/common":62,"./utils/strings":63,"./zlib/constants":65,"./zlib/gzheader":68,"./zlib/inflate":70,"./zlib/messages":72,"./zlib/zstream":74}],62:[function(require,module,exports){
'use strict';


var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');


exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (source.hasOwnProperty(p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],63:[function(require,module,exports){
// String encode/decode helpers
'use strict';


var utils = require('./common');


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safary
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // use fallback for big arrays to avoid stack overflow
  if (len < 65537) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Fuckup - very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means vuffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

},{"./common":62}],64:[function(require,module,exports){
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It doesn't worth to make additional optimizationa as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;

},{}],65:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

},{}],66:[function(require,module,exports){
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;

},{}],67:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils   = require('../utils/common');
var trees   = require('./trees');
var adler32 = require('./adler32');
var crc32   = require('./crc32');
var msg     = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
                );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":62,"./adler32":64,"./crc32":66,"./messages":72,"./trees":73}],68:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;

},{}],69:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

},{}],70:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils         = require('../utils/common');
var adler32       = require('./adler32');
var crc32         = require('./crc32');
var inflate_fast  = require('./inffast');
var inflate_table = require('./inftrees');

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
    case HEAD:
      if (state.wrap === 0) {
        state.mode = TYPEDO;
        break;
      }
      //=== NEEDBITS(16);
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//

        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = FLAGS;
        break;
      }
      state.flags = 0;           /* expect zlib header */
      if (state.head) {
        state.head.done = false;
      }
      if (!(state.wrap & 1) ||   /* check if zlib header allowed */
        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
        strm.msg = 'incorrect header check';
        state.mode = BAD;
        break;
      }
      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
      len = (hold & 0x0f)/*BITS(4)*/ + 8;
      if (state.wbits === 0) {
        state.wbits = len;
      }
      else if (len > state.wbits) {
        strm.msg = 'invalid window size';
        state.mode = BAD;
        break;
      }
      state.dmax = 1 << len;
      //Tracev((stderr, "inflate:   zlib header ok\n"));
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = hold & 0x200 ? DICTID : TYPE;
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      break;
    case FLAGS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.flags = hold;
      if ((state.flags & 0xff) !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      if (state.flags & 0xe000) {
        strm.msg = 'unknown header flags set';
        state.mode = BAD;
        break;
      }
      if (state.head) {
        state.head.text = ((hold >> 8) & 1);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = TIME;
      /* falls through */
    case TIME:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.time = hold;
      }
      if (state.flags & 0x0200) {
        //=== CRC4(state.check, hold)
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        hbuf[2] = (hold >>> 16) & 0xff;
        hbuf[3] = (hold >>> 24) & 0xff;
        state.check = crc32(state.check, hbuf, 4, 0);
        //===
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = OS;
      /* falls through */
    case OS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.xflags = (hold & 0xff);
        state.head.os = (hold >> 8);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = EXLEN;
      /* falls through */
    case EXLEN:
      if (state.flags & 0x0400) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length = hold;
        if (state.head) {
          state.head.extra_len = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      else if (state.head) {
        state.head.extra = null/*Z_NULL*/;
      }
      state.mode = EXTRA;
      /* falls through */
    case EXTRA:
      if (state.flags & 0x0400) {
        copy = state.length;
        if (copy > have) { copy = have; }
        if (copy) {
          if (state.head) {
            len = state.head.extra_len - state.length;
            if (!state.head.extra) {
              // Use untyped array for more conveniend processing later
              state.head.extra = new Array(state.head.extra_len);
            }
            utils.arraySet(
              state.head.extra,
              input,
              next,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len
            );
            //zmemcpy(state.head.extra + len, next,
            //        len + copy > state.head.extra_max ?
            //        state.head.extra_max - len : copy);
          }
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          state.length -= copy;
        }
        if (state.length) { break inf_leave; }
      }
      state.length = 0;
      state.mode = NAME;
      /* falls through */
    case NAME:
      if (state.flags & 0x0800) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          // TODO: 2 or 1 bytes?
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.name_max*/)) {
            state.head.name += String.fromCharCode(len);
          }
        } while (len && copy < have);

        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.name = null;
      }
      state.length = 0;
      state.mode = COMMENT;
      /* falls through */
    case COMMENT:
      if (state.flags & 0x1000) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.comm_max*/)) {
            state.head.comment += String.fromCharCode(len);
          }
        } while (len && copy < have);
        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.comment = null;
      }
      state.mode = HCRC;
      /* falls through */
    case HCRC:
      if (state.flags & 0x0200) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.check & 0xffff)) {
          strm.msg = 'header crc mismatch';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      if (state.head) {
        state.head.hcrc = ((state.flags >> 9) & 1);
        state.head.done = true;
      }
      strm.adler = state.check = 0;
      state.mode = TYPE;
      break;
    case DICTID:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      strm.adler = state.check = zswap32(hold);
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = DICT;
      /* falls through */
    case DICT:
      if (state.havedict === 0) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        return Z_NEED_DICT;
      }
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = TYPE;
      /* falls through */
    case TYPE:
      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case TYPEDO:
      if (state.last) {
        //--- BYTEBITS() ---//
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        state.mode = CHECK;
        break;
      }
      //=== NEEDBITS(3); */
      while (bits < 3) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.last = (hold & 0x01)/*BITS(1)*/;
      //--- DROPBITS(1) ---//
      hold >>>= 1;
      bits -= 1;
      //---//

      switch ((hold & 0x03)/*BITS(2)*/) {
      case 0:                             /* stored block */
        //Tracev((stderr, "inflate:     stored block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = STORED;
        break;
      case 1:                             /* fixed block */
        fixedtables(state);
        //Tracev((stderr, "inflate:     fixed codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = LEN_;             /* decode codes */
        if (flush === Z_TREES) {
          //--- DROPBITS(2) ---//
          hold >>>= 2;
          bits -= 2;
          //---//
          break inf_leave;
        }
        break;
      case 2:                             /* dynamic block */
        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = TABLE;
        break;
      case 3:
        strm.msg = 'invalid block type';
        state.mode = BAD;
      }
      //--- DROPBITS(2) ---//
      hold >>>= 2;
      bits -= 2;
      //---//
      break;
    case STORED:
      //--- BYTEBITS() ---// /* go to byte boundary */
      hold >>>= bits & 7;
      bits -= bits & 7;
      //---//
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
        strm.msg = 'invalid stored block lengths';
        state.mode = BAD;
        break;
      }
      state.length = hold & 0xffff;
      //Tracev((stderr, "inflate:       stored length %u\n",
      //        state.length));
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = COPY_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case COPY_:
      state.mode = COPY;
      /* falls through */
    case COPY:
      copy = state.length;
      if (copy) {
        if (copy > have) { copy = have; }
        if (copy > left) { copy = left; }
        if (copy === 0) { break inf_leave; }
        //--- zmemcpy(put, next, copy); ---
        utils.arraySet(output, input, next, copy, put);
        //---//
        have -= copy;
        next += copy;
        left -= copy;
        put += copy;
        state.length -= copy;
        break;
      }
      //Tracev((stderr, "inflate:       stored end\n"));
      state.mode = TYPE;
      break;
    case TABLE:
      //=== NEEDBITS(14); */
      while (bits < 14) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
//#ifndef PKZIP_BUG_WORKAROUND
      if (state.nlen > 286 || state.ndist > 30) {
        strm.msg = 'too many length or distance symbols';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracev((stderr, "inflate:       table sizes ok\n"));
      state.have = 0;
      state.mode = LENLENS;
      /* falls through */
    case LENLENS:
      while (state.have < state.ncode) {
        //=== NEEDBITS(3);
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
        //--- DROPBITS(3) ---//
        hold >>>= 3;
        bits -= 3;
        //---//
      }
      while (state.have < 19) {
        state.lens[order[state.have++]] = 0;
      }
      // We have separate tables & no pointers. 2 commented lines below not needed.
      //state.next = state.codes;
      //state.lencode = state.next;
      // Switch to use dynamic table
      state.lencode = state.lendyn;
      state.lenbits = 7;

      opts = { bits: state.lenbits };
      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
      state.lenbits = opts.bits;

      if (ret) {
        strm.msg = 'invalid code lengths set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, "inflate:       code lengths ok\n"));
      state.have = 0;
      state.mode = CODELENS;
      /* falls through */
    case CODELENS:
      while (state.have < state.nlen + state.ndist) {
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_val < 16) {
          //--- DROPBITS(here.bits) ---//
          hold >>>= here_bits;
          bits -= here_bits;
          //---//
          state.lens[state.have++] = here_val;
        }
        else {
          if (here_val === 16) {
            //=== NEEDBITS(here.bits + 2);
            n = here_bits + 2;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            if (state.have === 0) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            len = state.lens[state.have - 1];
            copy = 3 + (hold & 0x03);//BITS(2);
            //--- DROPBITS(2) ---//
            hold >>>= 2;
            bits -= 2;
            //---//
          }
          else if (here_val === 17) {
            //=== NEEDBITS(here.bits + 3);
            n = here_bits + 3;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 3 + (hold & 0x07);//BITS(3);
            //--- DROPBITS(3) ---//
            hold >>>= 3;
            bits -= 3;
            //---//
          }
          else {
            //=== NEEDBITS(here.bits + 7);
            n = here_bits + 7;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 11 + (hold & 0x7f);//BITS(7);
            //--- DROPBITS(7) ---//
            hold >>>= 7;
            bits -= 7;
            //---//
          }
          if (state.have + copy > state.nlen + state.ndist) {
            strm.msg = 'invalid bit length repeat';
            state.mode = BAD;
            break;
          }
          while (copy--) {
            state.lens[state.have++] = len;
          }
        }
      }

      /* handle error breaks in while */
      if (state.mode === BAD) { break; }

      /* check for end-of-block code (better have one) */
      if (state.lens[256] === 0) {
        strm.msg = 'invalid code -- missing end-of-block';
        state.mode = BAD;
        break;
      }

      /* build code tables -- note: do not change the lenbits or distbits
         values here (9 and 6) without reading the comments in inftrees.h
         concerning the ENOUGH constants, which depend on those values */
      state.lenbits = 9;

      opts = { bits: state.lenbits };
      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.lenbits = opts.bits;
      // state.lencode = state.next;

      if (ret) {
        strm.msg = 'invalid literal/lengths set';
        state.mode = BAD;
        break;
      }

      state.distbits = 6;
      //state.distcode.copy(state.codes);
      // Switch to use dynamic table
      state.distcode = state.distdyn;
      opts = { bits: state.distbits };
      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.distbits = opts.bits;
      // state.distcode = state.next;

      if (ret) {
        strm.msg = 'invalid distances set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, 'inflate:       codes ok\n'));
      state.mode = LEN_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case LEN_:
      state.mode = LEN;
      /* falls through */
    case LEN:
      if (have >= 6 && left >= 258) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        inflate_fast(strm, _out);
        //--- LOAD() ---
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        //---

        if (state.mode === TYPE) {
          state.back = -1;
        }
        break;
      }
      state.back = 0;
      for (;;) {
        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if (here_bits <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if (here_op && (here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.lencode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      state.length = here_val;
      if (here_op === 0) {
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        state.mode = LIT;
        break;
      }
      if (here_op & 32) {
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.back = -1;
        state.mode = TYPE;
        break;
      }
      if (here_op & 64) {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break;
      }
      state.extra = here_op & 15;
      state.mode = LENEXT;
      /* falls through */
    case LENEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
      //Tracevv((stderr, "inflate:         length %u\n", state.length));
      state.was = state.length;
      state.mode = DIST;
      /* falls through */
    case DIST:
      for (;;) {
        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if ((here_bits) <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if ((here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.distcode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      if (here_op & 64) {
        strm.msg = 'invalid distance code';
        state.mode = BAD;
        break;
      }
      state.offset = here_val;
      state.extra = (here_op) & 15;
      state.mode = DISTEXT;
      /* falls through */
    case DISTEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
//#ifdef INFLATE_STRICT
      if (state.offset > state.dmax) {
        strm.msg = 'invalid distance too far back';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
      state.mode = MATCH;
      /* falls through */
    case MATCH:
      if (left === 0) { break inf_leave; }
      copy = _out - left;
      if (state.offset > copy) {         /* copy from window */
        copy = state.offset - copy;
        if (copy > state.whave) {
          if (state.sane) {
            strm.msg = 'invalid distance too far back';
            state.mode = BAD;
            break;
          }
// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
        }
        if (copy > state.wnext) {
          copy -= state.wnext;
          from = state.wsize - copy;
        }
        else {
          from = state.wnext - copy;
        }
        if (copy > state.length) { copy = state.length; }
        from_source = state.window;
      }
      else {                              /* copy from output */
        from_source = output;
        from = put - state.offset;
        copy = state.length;
      }
      if (copy > left) { copy = left; }
      left -= copy;
      state.length -= copy;
      do {
        output[put++] = from_source[from++];
      } while (--copy);
      if (state.length === 0) { state.mode = LEN; }
      break;
    case LIT:
      if (left === 0) { break inf_leave; }
      output[put++] = state.length;
      left--;
      state.mode = LEN;
      break;
    case CHECK:
      if (state.wrap) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          // Use '|' insdead of '+' to make sure that result is signed
          hold |= input[next++] << bits;
          bits += 8;
        }
        //===//
        _out -= left;
        strm.total_out += _out;
        state.total += _out;
        if (_out) {
          strm.adler = state.check =
              /*UPDATE(state.check, put - _out, _out);*/
              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

        }
        _out = left;
        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
        if ((state.flags ? hold : zswap32(hold)) !== state.check) {
          strm.msg = 'incorrect data check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   check matches trailer\n"));
      }
      state.mode = LENGTH;
      /* falls through */
    case LENGTH:
      if (state.wrap && state.flags) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.total & 0xffffffff)) {
          strm.msg = 'incorrect length check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   length matches trailer\n"));
      }
      state.mode = DONE;
      /* falls through */
    case DONE:
      ret = Z_STREAM_END;
      break inf_leave;
    case BAD:
      ret = Z_DATA_ERROR;
      break inf_leave;
    case MEM:
      return Z_MEM_ERROR;
    case SYNC:
      /* falls through */
    default:
      return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

},{"../utils/common":62,"./adler32":64,"./crc32":66,"./inffast":69,"./inftrees":71}],71:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

},{"../utils/common":62}],72:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],73:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');

/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH    = 3;
var MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS      = 256;
/* number of literal bytes 0..255 */

var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES       = 30;
/* number of distance codes */

var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


var static_l_desc;
var static_d_desc;
var static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    var len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init  = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block  = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

},{"../utils/common":62}],74:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}]},{},[10])(10)
});

